<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <head>
    <link href="/styles/main.css" rel="stylesheet" type="text/css"/>

    <meta charset="UTF-8">
    
    <title>第一章 数据结构及算法概念 - ZestJourney</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/bootstrap/4.6.1/css/bootstrap.min.css">
    <script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/bootstrap/4.6.1/js/bootstrap.min.js"></script>

<script src="https://npm.elemecdn.com/@waline/client@v2/dist/waline.js"></script>
<link
  rel="stylesheet"
  href="https://npm.elemecdn.com/@waline/client@v2/dist/waline.css"
/>
<meta name="generator" content="Hexo 5.4.2"></head>

</head>

<body>
    


        <div>
            <div class="container-fluid position-relative">
                <nav class="navbar navbar-expand-lg navbar-dark  text-white bg-transparent">
                    <div class="container">
                        
                        <a class="navbar-brand" href="/">💖我们的秘密基地💖</a>
                        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarText"
                            aria-controls="navbarText" aria-expanded="false" aria-label="Toggle navigation">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                        <div class="collapse navbar-collapse" id="navbarText">
                            <ul class="navbar-nav mr-auto">
                            </ul>
                            <span class="navbar-text">
                                💕愿你三冬暖，愿你春不寒🍂
                            </span>
                        </div>
                    </div>
                </nav>
                <section class="lover-background"
                    style="background-image: url(/img/banner.jpg)">
                </section>
                <section
                    class="container lover-container d-flex flex-column align-content-center justify-content-center">
                    <div class="row align-items-center pb-5 lover">
                        <div class="col">
                            <div class="d-flex flex-column">
                                <img class="mx-auto avatar-img rounded-circle"
                                    src="/img/zestaken.jpg" alt="">
                                <h4 class="mx-auto text-white pt-2">  
                                    zestaken
                                </h4>
                            </div>
                        </div>
                        <div class="col">
                            <div class="d-flex justify-content-center">
                                <div class="heart"></div>
                            </div>
                        </div>
                        <div class="col">
                            <div class="d-flex flex-column">
                                <img class="mx-auto avatar-img rounded-circle"
                                    src="/img/zinny.jpg" alt="">
                                <h4 class="mx-auto text-white pt-2">
                                    zinny
                                </h4>
                            </div>
                        </div>
                    </div>
                </section>
                <section class="main-hero-waves-area waves-area">
                    <svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
                        viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
                        <defs>
                            <path id="gentle-wave"
                                d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z">
                            </path>
                        </defs>
                        <g class="parallax">
                            <use xlink:href="#gentle-wave" x="48" y="0"></use>
                            <use xlink:href="#gentle-wave" x="48" y="3"></use>
                            <use xlink:href="#gentle-wave" x="48" y="5"></use>
                            <use xlink:href="#gentle-wave" x="48" y="7"></use>
                        </g>
                    </svg>
                </section>
            </div>

            <div id="Pjax">

  <div class="list-content mx-auto mt-5">
      <div id="article" class="list-top">
          <h5 class="list-text"> 第一章 数据结构及算法概念
          </h5>
          <article>
              <article>
                <h1 id="第一章-绪论"><a class="markdownIt-Anchor" href="#第一章-绪论"></a> 第一章 绪论</h1>
<h2 id="1数据结构的基本概念"><a class="markdownIt-Anchor" href="#1数据结构的基本概念"></a> 1.数据结构的基本概念</h2>
<h3 id="数据的基本概念"><a class="markdownIt-Anchor" href="#数据的基本概念"></a> 数据的基本概念</h3>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200630163623.jpg" alt="" /><br />
默认情况下，程序中处理的数据都是数据对象。</p>
<h3 id="数据结构定义"><a class="markdownIt-Anchor" href="#数据结构定义"></a> 数据结构定义</h3>
<p>数据结构 = 数据对象 + 结构<br />
结构:数据元素之间的关系</p>
<h3 id="数据结构的组成"><a class="markdownIt-Anchor" href="#数据结构的组成"></a> 数据结构的组成</h3>
<ol>
<li>逻辑结构：数据元素间的逻辑关系
<ul>
<li>逻辑结构的表示
<ul>
<li>表</li>
<li>二元组</li>
<li>图形</li>
</ul>
</li>
<li>逻辑结构的分类
<ul>
<li>线性结构</li>
<li>树形结构</li>
<li>集合类结构</li>
<li>图结构</li>
</ul>
</li>
</ul>
</li>
<li>存储结构：数据在计算机存储器中的存储方式就是存储结构。
<ol>
<li>顺序存储结构
<ol>
<li>数组</li>
</ol>
</li>
<li>链式存储结构
<ol>
<li>链表</li>
</ol>
</li>
</ol>
</li>
<li>数据运算：数据运算是对数据的操作。分为两个阶段：运算描述和运算实现。</li>
</ol>
<p><strong>注：</strong></p>
<ul>
<li>同一逻辑结构可以对应多种存储结构。</li>
<li>同样的运算，在不同的存储结构中，其实现过程是不同的。</li>
<li>不同的实现过程的效率是不一样的。</li>
</ul>
<h2 id="2算法及其描述"><a class="markdownIt-Anchor" href="#2算法及其描述"></a> 2.算法及其描述</h2>
<h3 id="算法的定义及特性"><a class="markdownIt-Anchor" href="#算法的定义及特性"></a> 算法的定义及特性</h3>
<ul>
<li>算法的定义：数据元素之间的关系有逻辑关系和物理关系，对应的运算有基于<strong>逻辑结构的运算描述</strong>和基于<strong>存储结构的运算实现</strong>。通常把基于存储结构的运算实现的步骤或过程称为算法。</li>
<li>算法的五个特性：
<ol>
<li>有穷性：在有穷步之后结束，算法能够停机。</li>
<li>确定性：无二义性。</li>
<li>可行性：可通过基本运算有限次执行来实现，也就是算法中每一个动作能够被机械地执行。</li>
<li>有输入</li>
<li>有输出（即存在数据处理过程）</li>
</ol>
</li>
<li>算法的描述：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200718094944.jpg" alt="" /></li>
</ul>
<h3 id="算法的分析"><a class="markdownIt-Anchor" href="#算法的分析"></a> 算法的分析</h3>
<h4 id="算法的时间复杂度分析"><a class="markdownIt-Anchor" href="#算法的时间复杂度分析"></a> 算法的时间复杂度分析</h4>
<ul>
<li>一个算法是由<strong>控制结构</strong>（顺序、分支和循环三种）和<strong>原操作</strong>（指固有数据类型的操作，如+、-、*、/、++和–等）构成的。算法执行时间取决于两者的综合效果。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200718100057.jpg" alt="" /></li>
<li>算法时间复杂度分析流程：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200718100413.jpg" alt="" />
<ul>
<li>算法时间复杂度：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200718100713.jpg" alt="" /></li>
<li>简化分析：在算法分析时，计算T(n)时仅仅考虑基本操作的运算次数。</li>
</ul>
</li>
<li>示例：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200718100857.jpg" alt="" />
<ul>
<li>用修正常量得出循环次数 <img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200718101719.jpg" alt="" /></li>
</ul>
</li>
<li>分析技巧：
<ul>
<li>无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)。</li>
<li>如果有循环，就计算循环的执行次数。（嵌套循环则是内层循环数等于每层循环次数相乘。计算最内层循环则可得出O(n)。）</li>
</ul>
</li>
<li>常见算法时间复杂度
<ul>
<li>无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1),也称作常数阶。</li>
<li>一个只有一重循环的算法的执行时间与问题规模n的增长呈线性增大关系，记作O(n)，也称线性阶。</li>
<li>其余常用的算法时间复杂度还有平方阶O(n2)、立方阶O(n3)、对数阶O(log2n)、指数阶O(2n)等。</li>
</ul>
</li>
<li>各种时间复杂度比较：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200718102212.jpg" alt="" /></li>
<li>最好、最坏和平均时间复杂度分析
<ul>
<li><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200720180009.jpg" alt="" /></li>
<li><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200720180044.jpg" alt="" /></li>
<li>时间复杂度存在变数的原因在于，循环的控制语句中存在随条件变化而变化的变量。</li>
</ul>
</li>
</ul>
<h4 id="算法的空间复杂度"><a class="markdownIt-Anchor" href="#算法的空间复杂度"></a> 算法的空间复杂度</h4>
<ul>
<li>空间复杂度：用于量度一个算法在运行过程中<strong>临时占用</strong>的存储空间大小。（即只考虑算法执行过程中分配的空间）</li>
<li>一般也作为问题规模n的函数，采用数量级形式描述，记作：S(n)=O(g(n))</li>
<li>特殊：若一个算法的空间复杂度为O(1)，则称此算法为原地工作或就地工作算法。</li>
</ul>
<h4 id="递归算法的时空复杂度"><a class="markdownIt-Anchor" href="#递归算法的时空复杂度"></a> 递归算法的时空复杂度</h4>
<ul>
<li>
<p>递归算法中，时空复杂度不仅仅是与问题规模有关的函数，它还与控制递归的递归条件有关。（类似一元函数的讨论变为了多元函数）</p>
</li>
<li>
<p>例题：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200720182551.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200720182751.PNG" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200720182718.PNG" alt="" /></p>
</li>
<li>
<p>求解递归算法的时空复杂度的关键在于<strong>根据递归条件写出递归方程组</strong>。</p>
</li>
</ul>
<h2 id="第二章-线性表"><a class="markdownIt-Anchor" href="#第二章-线性表"></a> 第二章 线性表</h2>
<h3 id="线性表的定义"><a class="markdownIt-Anchor" href="#线性表的定义"></a> 线性表的定义</h3>
<ul>
<li>线性表是一个具有<strong>相同特性</strong>的数据元素的有限序列。</li>
<li>特性：
<ul>
<li>相同特性：所有元素属于同一数据类型。</li>
<li>有限：数据元素个数是有限的。</li>
<li>序列：数据元素由逻辑序号唯一确定。一个线性表中可以有<strong>相同值</strong>的元素。</li>
<li>结构：除第一个元素无前驱、最后一个元素无后继外，其余每个元素都有<strong>唯一前驱和唯一后继元素</strong>。</li>
</ul>
</li>
<li>线性表中所含元素的个数叫做线性表的长度。</li>
<li>线性表的逻辑表示：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721183419.jpg" alt="" /></li>
</ul>
<h3 id="线性表的顺序存储结构"><a class="markdownIt-Anchor" href="#线性表的顺序存储结构"></a> 线性表的顺序存储结构</h3>
<h4 id="线性表的顺序存储结构定义"><a class="markdownIt-Anchor" href="#线性表的顺序存储结构定义"></a> 线性表的顺序存储结构定义</h4>
<ul>
<li>把线性表中元素按照顺序存储的方法存储（即存储位置为一篇连续的空间，如数组）</li>
<li>静态存储顺序表
<ul>
<li>定义：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721183915.jpg" alt="" />（意味着last是从0开始的）</li>
<li>特性：
<ul>
<li>随机存取</li>
</ul>
</li>
</ul>
</li>
<li>动态存储顺序表：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721223730.jpg" alt="" />
<ul>
<li>创建动态存储的顺序表：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721223923.jpg" alt="" />
<ul>
<li>关键在于数组的长度是根据具体情况来分配的<code>L-&gt;elem  = (ElemType *)malloc(maxSize*sizeof(ElemType))</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="线性表在静态顺序存储结构上的基本运算"><a class="markdownIt-Anchor" href="#线性表在静态顺序存储结构上的基本运算"></a> 线性表在静态顺序存储结构上的基本运算</h4>
<ul>
<li>
<ol>
<li>求某个元素在顺序表中的序号<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721184701.jpg" alt="" /></li>
</ol>
<ul>
<li>因为数组中计数是从0开始，而实际生活中数数是从1开始，所以需要<code>i + 1</code></li>
<li>控制条件为找到数组的最后一个元素<code>i &lt;= L.last</code></li>
</ul>
</li>
<li>
<ol start="2">
<li>求序号为i的数据元素值</li>
</ol>
<ul>
<li>
<p>法一：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721185107.jpg" alt="" /></p>
<ul>
<li>注意控制条件，i过大或者过小都会超出数组边界，故需<code>i &lt; 1 || i &gt; L-&gt;last +1</code></li>
</ul>
</li>
<li>
<p>法二：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721185732.jpg" alt="" /></p>
</li>
<li>
<p>二者的区别在于直接返回元素的值还是通过指针传递元素的值。</p>
</li>
</ul>
</li>
<li>
<ol start="3">
<li>在顺序表的第i个位置<strong>插入</strong>数据元素 (1 &lt;= i &lt;= last + 2)<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721215615.jpg" alt="" /></li>
</ol>
<ul>
<li>控制条件：此时插入位置i的范围要比数组原来的范围增加一，因为数组整体要先增加一个位置，所以有<code>i &lt; 1 || i &gt; L-&gt;last + 2</code>.</li>
<li>关键的元素后移操作：先在数组末尾增加上一个位置，然后从后往前逐次将第i位起的元素后移，<code>for(k = L-&gt;last; k &gt;= i - 1 ; k--) L-&gt;elem[k+1] = L-&gt;elem[k];</code></li>
<li>末尾别忘了<code>last</code>的更改。</li>
<li>算法的时间复杂度：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721220637.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721220653.jpg" alt="" /></li>
</ul>
</li>
<li>
<ol start="4">
<li>顺序表<strong>删除</strong>第i个位置的元素（1 &lt; i &lt; last + 1)<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721221040.jpg" alt="" /></li>
</ol>
<ul>
<li>先将特殊的情况考虑，再做常规处理：i超出数组的范围和顺序表为空的两种情况。<code>i &lt; 1 || i &gt; L-&gt;last + 1</code>和<code>L-&gt;last &lt; 0</code>.(i = 0 不行是因为此处的i代表的是实际生活中的计数，而不是数组从零开始的计数)</li>
<li>关键的元素前移操作：从第i个元素之后的一个元素开始逐渐前移 <code>for(k = i; k &lt;= L-&gt;last; k++) L-&gt;elem[k-1] = L-&gt;elem[k];</code>，控制条件为<code>k &lt;= L -&gt;last</code>的原因是，此时的k作为数组的下标而不是实际生活中的计数，与last的意义相同了，所以不需要再做元素个数与数组下标之间+1 的转换。</li>
<li>算法的时间复杂度：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721222832.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721222948.jpg" alt="" /></li>
</ul>
</li>
</ul>
<h4 id="线性表动态顺序存储结构的算法"><a class="markdownIt-Anchor" href="#线性表动态顺序存储结构的算法"></a> 线性表动态顺序存储结构的算法</h4>
<ul>
<li>二路归并算法
<ul>
<li>将两个非递减顺序表合并为一个有序表，称为二路归并。</li>
<li>基本原理：同时遍历两个顺序表，遍历过程中比较元素的大小并存入有序表中，并根据比较结果调整两个顺序表遍历的速度。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721225112.jpg" alt="" /></li>
<li>注意：两表的同时遍历进行结束之后，还要检查是否有哪个表没有遍历完。</li>
</ul>
</li>
</ul>
<h3 id="线性表的链式存储结构"><a class="markdownIt-Anchor" href="#线性表的链式存储结构"></a> 线性表的链式存储结构</h3>
<h4 id="线性表的链式存储结构的定义"><a class="markdownIt-Anchor" href="#线性表的链式存储结构的定义"></a> 线性表的链式存储结构的定义</h4>
<ul>
<li>链式存储结构即使用链表存储。使用链表时，每个逻辑结点单独存储，为了表示逻辑关系，每个结点里增加一个指针域。</li>
<li>链表的分类：
<ul>
<li>单链表：每个物理结点里增加一个指向<strong>后继结点</strong>的指针域。
<ul>
<li>当访问过一个结点后，只能接着访问它的后继结点，而无法访问它的前驱结点。</li>
</ul>
</li>
<li>循环单链表：将表中尾结点的指针域改为指向表头结点，整个链表形成一个环。
<ul>
<li>从表中任一结点出发均可找到链表中其他结点。</li>
<li>链表中没有空指针域（最后一个结点的空指针域现在指向头结点）</li>
</ul>
</li>
<li>双向链表:  每个物理结点增加一个指向<strong>后继结点</strong>和一个指向<strong>前驱结点</strong>的指针。
<ul>
<li>从任一结点出啊发可以快速找到其前驱结点和后继结点。</li>
<li>从任一结点出发可以访问其他任一结点。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="单链表"><a class="markdownIt-Anchor" href="#单链表"></a> 单链表</h4>
<h5 id="结点类型定义"><a class="markdownIt-Anchor" href="#结点类型定义"></a> 结点类型定义</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200722110417.jpg" alt="" /></p>
<ul>
<li>单独创建一个 LinkList类型的目的是区分普通数据结点和头结点。</li>
</ul>
<h5 id="建表"><a class="markdownIt-Anchor" href="#建表"></a> 建表</h5>
<ul>
<li>
<p>头插法建表</p>
<ul>
<li>基本原理：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200722110741.jpg" alt="" />
<ul>
<li>读取是从前往后，但最终形成的链表顺序是原来数据排列方式的从后往前。</li>
<li>最终的表头是一个不含数据的空结点。</li>
</ul>
</li>
<li>算法：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200722111848.jpg" alt="" />
<ul>
<li>每一个结点（包括头结点）都是现场分配的内存。</li>
<li>头结点的指针域始终指向刚插入的结点（开始为NULL除外）。</li>
<li>每次插入操作需将头结点指针域赋给新结点的指针域，然后头结点指针域指向新结点。这样达到断开头结点与旧结点之间的旧链,而形成头结点与新结点之间新链的效果。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>尾插法建表：</p>
<ul>
<li>基本原理：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200722112653.jpg" alt="" />
<ul>
<li>增加一个移动的尾指针，使其一直指向链表的尾结点（开始时指向头结点）</li>
</ul>
</li>
<li>算法：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200722113210.jpg" alt="" />
<ul>
<li>先使用尾指针，使旧尾结点的指针域指向新结点，然后将尾指针指向新结点。</li>
<li>注意：最后要将尾结点的指针域设置为NULL。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="求线性表中第i个位置的数据元素"><a class="markdownIt-Anchor" href="#求线性表中第i个位置的数据元素"></a> 求线性表中第i个位置的数据元素</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723094813.jpg" alt="" /></p>
<ul>
<li>设置一个移动的指针（最开始指向头结点），在计数（从0开始）的同时，移动指针。</li>
<li>在找到第i个元素之前，用循环移动指针。（注意控制条件：计数变量比i小，且不能超出链表元素数目）</li>
</ul>
<h5 id="按元素值查找"><a class="markdownIt-Anchor" href="#按元素值查找"></a> 按元素值查找</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723095356.jpg" alt="" /></p>
<ul>
<li>设置一个移动的指针，从第一个有值域的结点开始查找，每一个元素和所找元素比较，若不相等，则指针向后移。</li>
</ul>
<h5 id="求带头单链表的长度"><a class="markdownIt-Anchor" href="#求带头单链表的长度"></a> 求带头单链表的长度</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723095728.jpg" alt="" /></p>
<ul>
<li>设置一个移动的指针（开始指向头结点），设置一个计数变量(开始设为0表示头结点的序号为0，不算在数据结点的个数中），每移动一次指针，计数变量加一。</li>
<li>结束的控制条件：最后一个结点的指针域为NULL。</li>
</ul>
<h5 id="在链表的第i个位置插入数据元素"><a class="markdownIt-Anchor" href="#在链表的第i个位置插入数据元素"></a> 在链表的第i个位置插入数据元素</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723100430.jpg" alt="" /></p>
<ul>
<li><a href="#%E6%B1%82%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B8%AD%E7%AC%ACi%E4%B8%AA%E4%BD%8D%E7%BD%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0">查找算法</a>和<a href="#%E5%BB%BA%E8%A1%A8">头插法创建链表算法</a>的结合。</li>
</ul>
<h5 id="删除链表的第i个位置的数据元素"><a class="markdownIt-Anchor" href="#删除链表的第i个位置的数据元素"></a> 删除链表的第i个位置的数据元素</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723101022.jpg" alt="" /></p>
<ul>
<li>查找到第i-1个结点，利用它的指向后继结点的指针域（所以结束查找的条件是找到第i-1个元素或者当前结点的指针域为NULL），来删除第i个结点。</li>
<li>使用<code>free()</code>来删除一个结点。</li>
</ul>
<h5 id="合并两个有序链表为一个有序链表"><a class="markdownIt-Anchor" href="#合并两个有序链表为一个有序链表"></a> 合并两个有序链表为一个有序链表</h5>
<ul>
<li>
<p>占用其中一个链表来合并<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723102129.jpg" alt="" /></p>
<ul>
<li>基本原理类似<a href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E7%AE%97%E6%B3%95">二路归并算法</a></li>
<li>设置两个可移动指针，指向原来两个链表的数据元素。</li>
<li>新链表头指针指向原来某个链表的头结点，以此来占用该链表的空间。</li>
</ul>
</li>
<li>
<p>合并为一个全新的链表<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723103937.jpg" alt="" /></p>
<ul>
<li>所不同的是每一次插入都需要重新分配空间，故采用<a href="#%E5%BB%BA%E8%A1%A8">尾插法</a>重新建立一个链表。</li>
<li>最后没有遍历完的结点，需要使用循环来插入新链表中。</li>
<li>注意最后新链表尾结点的指针域要置为NULL。</li>
</ul>
</li>
</ul>
<h4 id="循环单链表"><a class="markdownIt-Anchor" href="#循环单链表"></a> 循环单链表</h4>
<ul>
<li>找到尾结点的条件变为：<code>p-&gt;next = L</code>。</li>
<li>结点类型：同单链表</li>
</ul>
<h5 id="初始化循环单链表"><a class="markdownIt-Anchor" href="#初始化循环单链表"></a> 初始化循环单链表</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723222629.jpg" alt="" /></p>
<ul>
<li>形参为指向头结点指针的指针。</li>
<li>最开始时，头结点即为尾结点，故头结点的指针域指向自己。</li>
</ul>
<h5 id="创建循环单链表"><a class="markdownIt-Anchor" href="#创建循环单链表"></a> 创建循环单链表</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723223045.jpg" alt="" /></p>
<ul>
<li>使用尾插法创建循环链表</li>
<li>最后要将尾结点的指针域设为头结点。</li>
</ul>
<h5 id="循环单链表的合并"><a class="markdownIt-Anchor" href="#循环单链表的合并"></a> 循环单链表的合并</h5>
<ul>
<li>
<p>传入两个循环单链表的头指针<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723223617.jpg" alt="" /></p>
<ul>
<li>找尾结点的循环：<code>while(p-&gt;next != LA) p = p-&gt;next;</code></li>
<li>第一个链表的尾结点的指针域设为第二个链表的第一个数据结点（不是头结点），第二个链表的尾结点的指针域设为第一个链表的头结点。</li>
</ul>
</li>
<li>
<p>传入两个循环单链表的尾指针<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723224057.jpg" alt="" /></p>
<ul>
<li>先找到两个链表的头结点，在修改各自尾结点的指针域。</li>
</ul>
</li>
</ul>
<h4 id="双向链表"><a class="markdownIt-Anchor" href="#双向链表"></a> 双向链表</h4>
<ul>
<li>结点类型定义<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723224256.jpg" alt="" /></li>
</ul>
<h5 id="建立双向链表"><a class="markdownIt-Anchor" href="#建立双向链表"></a> 建立双向链表</h5>
<ul>
<li>
<p>头插法建表<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200725220437.jpg" alt="" /></p>
<ul>
<li>头结点刚创立时前后驱指针域都设为空<code>(*L)-&gt;prior = (*L)-&gt;next = NULL;</code></li>
<li>新插入结点的前驱指针域设为头结点，后驱指针域设为原来头结点后原第一个数据结点。<code>s-&gt;next = (*L)-&gt;next; s-&gt;prior = *L</code></li>
<li>原第一个数据结点的前驱指针需修改为新插入结点<code>(*L)-&gt;next-&gt;prior = s;</code>,头结点的后驱指针域设为新插入结点<code>(*L)-&gt;next = s;</code></li>
<li>头插法的共性是建成的线性表是逆序的；</li>
<li>注意：传入函数的是指向头结点指针的指针，又有-&gt;的优先级高于*，所以需使用（*L）。</li>
</ul>
</li>
<li>
<p>尾插法建表<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200725221517.jpg" alt="" /></p>
<ul>
<li>设立一个可移动的尾指针，始终指向当前的尾结点；</li>
<li>最后注意将尾结点的后驱指针域设为NULL</li>
<li>相较头插法，只需修改两个结点的三个指针域，修改较少。</li>
</ul>
</li>
<li>
<p>建表的变式：逆置双向链表<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200725222226.jpg" alt="" /></p>
<ul>
<li>本质是头插法的运用;</li>
<li>需要新设两个可移动指针来扫描原来的链表。</li>
</ul>
</li>
</ul>
<h5 id="在第i个位置插入数据元素"><a class="markdownIt-Anchor" href="#在第i个位置插入数据元素"></a> 在第i个位置插入数据元素</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200725222900.jpg" alt="" /></p>
<ul>
<li>本质是头插法</li>
<li>查找第i-1个结点即为尾插法</li>
</ul>
<h5 id="删除第i个结点"><a class="markdownIt-Anchor" href="#删除第i个结点"></a> 删除第i个结点</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200725223227.jpg" alt="" /></p>
<ul>
<li>可以找到第i个结点，也可以找第i-1结点；</li>
<li>只需修改两个指针；</li>
</ul>
<h4 id="循环双向链表"><a class="markdownIt-Anchor" href="#循环双向链表"></a> 循环双向链表</h4>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727110328.jpg" alt="" /></p>
<ul>
<li>找到尾结点的条件变为了：<code>L-&gt;next = L</code></li>
<li>判断循环链表是否对称相等的算法<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727110858.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727111123.jpg" alt="" />
<ul>
<li>设置两个可移动指针分别从链表头尾扫描向中间</li>
<li>数据结点数目不同，扫描完是两个扫描指针的相对位置不同。为奇数时，最后两个结点指向同一个数据结点<code>p == q</code>;为偶数时，最后两个扫描指针相邻<code>p-&gt;next == q</code>或者<code>p == q-&gt;prior</code></li>
</ul>
</li>
</ul>
<h3 id="线性表的应用"><a class="markdownIt-Anchor" href="#线性表的应用"></a> 线性表的应用</h3>
<h4 id="一元多项式的运算"><a class="markdownIt-Anchor" href="#一元多项式的运算"></a> 一元多项式的运算</h4>
<ul>
<li>基本原理（一元稀疏多项式的线性表表示）<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727112250.jpg" alt="" /></li>
<li>单链表储存一元多项式的结点定义<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727112636.jpg" alt="" /></li>
<li>创建一元多项式单链表存储的算法<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727153633.jpg" alt="" />
<ul>
<li>尾插法创建</li>
<li>需要申请一个空的头结点</li>
</ul>
</li>
<li>两个一元多项式相加的算法<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727154010.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727154225.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727154452.jpg" alt="" />
<ul>
<li>默认即将要相加的两个一元多项式是按照次数从小到大排好序的。</li>
<li>从头开始遍历，将指数较小的存入新表，两个的指数相等时系数相加后存入新表。</li>
<li>采用头插法创建相加后的新表</li>
</ul>
</li>
</ul>
<h3 id="线性表经典题目"><a class="markdownIt-Anchor" href="#线性表经典题目"></a> 线性表经典题目</h3>
<h4 id="1删除顺序表中值为x的元素"><a class="markdownIt-Anchor" href="#1删除顺序表中值为x的元素"></a> 1.删除顺序表中值为x的元素</h4>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727155451.jpg" alt="" /></p>
<ul>
<li>先找到第一个值为x的元素</li>
<li>之后将其后面值不为x的元素逐个前移</li>
<li>最后修改last的值。因为在移动最后一个元素后，i还加了1，所以<code>L-&gt;last = i-1</code></li>
</ul>
<h4 id="2带头结点单链表就地逆置"><a class="markdownIt-Anchor" href="#2带头结点单链表就地逆置"></a> 2.带头结点单链表就地逆置</h4>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200730101814.jpg" alt="" /></p>
<ul>
<li>将原来链表的头结点分离出来。</li>
<li>遍历原来链表的数据结点，然后用头插法插入分离出来的头结点中，从而实现就地逆置。</li>
</ul>
<h4 id="3以第一个元素为标准将数据元素分为两边"><a class="markdownIt-Anchor" href="#3以第一个元素为标准将数据元素分为两边"></a> 3.以第一个元素为标准将数据元素分为两边</h4>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200730103614.jpg" alt="" /></p>
<ul>
<li>p1为固定指针，始终指向第一个结点，方便其它结点与第一个结点比较大小。</li>
<li>pre、p、q为一套移动指针，其中p指向当前扫描到的与第一个结点比较大小的结点,q指向当前结点的下一个结点，pre指向当前结点的前一个结点。</li>
<li>pre的作用是当需要把当前结点移走时，能够使其它两个结点能够连起来。<code>pre-&gt;next = p-&gt;next</code>。</li>
<li>q的作用一方面是使p能够持续进行扫描，另一方面使在中间结点被移走的情况下协同pre建立边上两个结点的联系。</li>
</ul>
<h4 id="4存放一个二进制数的链表"><a class="markdownIt-Anchor" href="#4存放一个二进制数的链表"></a> 4.存放一个二进制数的链表</h4>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731094419.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731095000.jpg" alt="" /></p>
<ul>
<li>二进制的加法关键在于找到第一个值为0的位，然后进行01的互换（怪不得计算机要用二进制，确实好操作）</li>
<li>链表实现加法有两种情况，第一种是，不需增加位数，直接01互换即可；第二种是位数需进一位，此时需要增加一个新结点。</li>
<li>q指针的作用是扫描链表;r指针的作用是指向为最后一个值域为1的结点，若没有则指向头结点；temp指针的作用是在需要新增一个结点时，指向原来的第一个数据结点，以便与新增结点建立连接。</li>
</ul>
<h2 id="第三章-限定性线性表-栈与队列"><a class="markdownIt-Anchor" href="#第三章-限定性线性表-栈与队列"></a> 第三章 限定性线性表-栈与队列</h2>
<h3 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h3>
<h4 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h4>
<ul>
<li>栈与队列都是特殊的线性表，是操作受限的线性表，称为限定性线性表。</li>
<li>特点：先进后出（FILO:first in last out）或后进先出（LIFO:last in first out）<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731163004.jpg" alt="" />
<ul>
<li>线性表可以在任意位置插入、删除，而栈只允许在栈顶进行插入或者删除操作，故称为操作受限。</li>
</ul>
</li>
<li>典例：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731163554.jpg" alt="" /></li>
</ul>
<h2 id="第九章-内排序"><a class="markdownIt-Anchor" href="#第九章-内排序"></a> 第九章 内排序</h2>
<h3 id="91-排序的概念"><a class="markdownIt-Anchor" href="#91-排序的概念"></a> 9.1 排序的概念</h3>
<h4 id="排序的定义"><a class="markdownIt-Anchor" href="#排序的定义"></a> 排序的定义</h4>
<p>所谓排序，是整理表中的记录，使之按关键字递增（或递减）有序排列。</p>
<h4 id="内排序与外排序"><a class="markdownIt-Anchor" href="#内排序与外排序"></a> 内排序与外排序</h4>
<p>在排序过程中，若整个表都是放在内存中处理，排序时不涉及数据的内、外存交换，则称之为<strong>内排序</strong>；反之，若排序过程中要进行数据的内、外存交换，则称之为<strong>外排序</strong>。</p>
<h4 id="内排序"><a class="markdownIt-Anchor" href="#内排序"></a> 内排序</h4>
<h5 id="内排序的分类"><a class="markdownIt-Anchor" href="#内排序的分类"></a> 内排序的分类</h5>
<ol>
<li>基于比较的排序算法
<ol>
<li>插入排序</li>
<li>交换排序</li>
<li>选择排序</li>
<li>归并排序</li>
</ol>
</li>
<li>不基于比较的排序算法
<ol>
<li>基数排序</li>
</ol>
</li>
</ol>
<h5 id="-基于比较的内排序的时间复杂度"><a class="markdownIt-Anchor" href="#-基于比较的内排序的时间复杂度"></a> ?-&gt;基于比较的内排序的时间复杂度</h5>
<ul>
<li>最好的平均时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li>
<li>最好情况是排序序列正序，此时时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h5 id="内排序算法的稳定性"><a class="markdownIt-Anchor" href="#内排序算法的稳定性"></a> 内排序算法的稳定性</h5>
<ul>
<li>如果待排序的表中，存在有多个关键字相同的记录，经过排序后这些具有相同关键字的记录之间的相对次序保持不变，则称这种排序方法是<strong>稳定</strong>的。</li>
<li>反之，若具有相同关键字的记录之间的相对次序发生变化，则称这种排序方法是<strong>不稳定</strong>的。</li>
</ul>
<h5 id="正序与反序"><a class="markdownIt-Anchor" href="#正序与反序"></a> 正序与反序</h5>
<ul>
<li>若待排序的表中元素已按关键字排好序，称此表中元素为正序；</li>
<li>反之，若待排序的表中元素的关键字顺序正好和排好序的顺序相反，称此表中元素为反序。</li>
<li>有一些排序算法与初始序列的正序或反序有关，另一些排序算法与初始序列的情况无关。</li>
</ul>
<h5 id="内排序数据的组织"><a class="markdownIt-Anchor" href="#内排序数据的组织"></a> 内排序数据的组织</h5>
<p>待排序顺序表的数据元素类型定义：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct
&#123;
    KeyType key; &#x2F;&#x2F;关键字项
    InfoType data; &#x2F;&#x2F;其它数据项
&#125;RecType; &#x2F;&#x2F; 排序的记录类型定义</code></pre>
<h3 id="92-插入排序"><a class="markdownIt-Anchor" href="#92-插入排序"></a> 9.2 插入排序</h3>
<h4 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h4>
<ul>
<li>基本原理：将无序区的元素逐个插入有序区（局部有序）</li>
<li>分类：
<ol>
<li>直接插入排序</li>
<li>折半插入排序</li>
<li>希尔排序</li>
</ol>
</li>
</ul>
<h4 id="1直接插入排序"><a class="markdownIt-Anchor" href="#1直接插入排序"></a> 1.直接插入排序</h4>
<ul>
<li>
<p>基本原理：插入排序通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入 ，如此重复，直至完成序列排序。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200630103424.jpg" alt="" /></p>
</li>
<li>
<p>算法分析：</p>
<ol>
<li>从序列第一个元素开始，该元素可以认为已经被排序（即有序区第一个元素）</li>
<li>取出下一个元素，设为待插入元素（即放入临时区：因为需要在有序区中插入一个元素，所以有序区得扩充一格，而临时区既能放置未找到位置的新入元素，又能为之后有序区元素的后移提供操作空间），在已经排序的元素序列中从后向前扫描，如果该元素（已排序）大于待插入元素，将该元素移到下一位置。</li>
<li>重复步骤2，直到找到已排序的元素小于或者等于待排序元素的位置，插入元素。</li>
<li>重复2，3步骤，完成排序。（得有两个循环嵌套）</li>
</ol>
</li>
<li>
<p>实例演示：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200630103537.png" alt="" /></p>
<ol>
<li>默认序列的第一个元素12已经被排序</li>
<li>取下一元素 15，从后往前与已排序序列一次比较，15插入12 之后，已排序序列为[12，15]。</li>
<li>取下一元素9，重复2步骤，将9插12 之前，已排序序列为[9，12，15]。</li>
<li>循环上述操作，直至最后一个元素24，插入合适位置，完成排序。</li>
</ol>
</li>
<li>
<p>直接插入排序代码（c)</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">void InsertSort(RecType R[],int n)
&#123;
   int i,j;
   RecType temp；

   for(i &#x3D; 1; i &lt; n; i++)&#123;
      temp &#x3D; R[i]; &#x2F;&#x2F; 将取出的无序区元素放入临时区
      j &#x3D; i - 1;   &#x2F;&#x2F; 找到有序区最后一个元素
      while(j &gt;&#x3D; 0 &amp;&amp; R[j] &gt; temp)&#123;
         R[j + 1] &#x3D; R[j];
         j--;
      &#125; &#x2F;&#x2F;从后往前逐个扫描有序区元素，直到找到比新入元素小或者相等的元素，同时将比新入元素大的元素这个往后移一位
      R[j] &#x3D; temp; &#x2F;&#x2F;将新入元素插入扫描找到的元素之后
   &#125;
&#125;</code></pre>
</li>
<li>
<p>性能分析</p>
<ul>
<li>时间复杂度：
<ul>
<li>最好的情况（正序排列）：比较<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>次（每个元素只与自己前面的元素比一次，而第一个元素没有前面的元素），时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
<li>最坏的情况（反序排列）：比较<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n(n-1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>次（每个元素需与自己前面所有元素比一次），时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>平均时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>空间复杂度：
<ul>
<li>只有一个临时元素，故空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>算法稳定性：
<ul>
<li>直接插入排序是稳定的排序算法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2折半插入排序二分插入排序"><a class="markdownIt-Anchor" href="#2折半插入排序二分插入排序"></a> 2.折半插入排序（二分插入排序）</h4>

              </article>
          </article>
      </div>
  </div>

</div>



        </div>


        <!-- <div class="p-5 text-center ">
  <p class="h6"> <a href="https://beian.miit.gov.cn/" target="_blank">蜀ICP备2021022902号-1</a> ※ <a
          href="https://beian.mps.gov.cn/#/query/webSearch" target="_blank">川公网安备51010802032250号</a></p>
</div> -->

<!-- <div class="p-5 text-center">
  <img src="/img/beian_icon.png" alt="备案图标" class="icon" style="max-width: 48px; max-height: 48px; vertical-align: middle;">
  <p class="h6">
    <a href="https://beian.miit.gov.cn/" target="_blank">蜀ICP备2021022902号-1</a> ※
    <a href="https://beian.mps.gov.cn/#/query/webSearch" target="_blank">川公网安备51010802032250号</a>
  </p>
</div> -->

<div class="p-5 text-center ">
  <p class="h6"> zestaken ❤️ zinny </p>
</div>
</body>

</html>