<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.zestaken.top","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":true,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="区块链与比特币概念   区块链（BlockChain）起源于比特币，2008年11月1日，一位自称中本聪(Satoshi Nakamoto)的人发表了《比特币:一种点对点的电子现金系统》一文，阐述了基于P2P网络技术、加密技术、时间戳技术、区块链技术等的电子现金系统的构架理念，这标志着比特币的诞生。   在比特币系统中，区块（Block）是一个一个的存储单元，记录了一定时间内各个区块节点全部的交">
<meta property="og:type" content="article">
<meta property="og:title" content="Java实现区块链Demo">
<meta property="og:url" content="http://www.zestaken.top/post/%E9%A1%B9%E7%9B%AE/Java%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%9D%97%E9%93%BEDemo/index.html">
<meta property="og:site_name" content="ZestJourney">
<meta property="og:description" content="区块链与比特币概念   区块链（BlockChain）起源于比特币，2008年11月1日，一位自称中本聪(Satoshi Nakamoto)的人发表了《比特币:一种点对点的电子现金系统》一文，阐述了基于P2P网络技术、加密技术、时间戳技术、区块链技术等的电子现金系统的构架理念，这标志着比特币的诞生。   在比特币系统中，区块（Block）是一个一个的存储单元，记录了一定时间内各个区块节点全部的交">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/0QlkTi.jpg">
<meta property="og:image" content="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/XhKOwy.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/v2-8317abc7bb2e2058bb2e5242739aba01_r.jpg">
<meta property="og:image" content="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/y71QB4.jpg">
<meta property="og:image" content="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/SAWTcE.png">
<meta property="og:image" content="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/lVcfrW.png">
<meta property="og:image" content="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/4IZwd2.png">
<meta property="og:image" content="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/5N08eT.png">
<meta property="article:published_time" content="2021-07-26T00:02:19.000Z">
<meta property="article:modified_time" content="2022-09-17T11:29:23.869Z">
<meta property="article:author" content="Zestaken">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="区块链">
<meta property="article:tag" content="比特币">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/0QlkTi.jpg">


<link rel="canonical" href="http://www.zestaken.top/post/%E9%A1%B9%E7%9B%AE/Java%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%9D%97%E9%93%BEDemo/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://www.zestaken.top/post/%E9%A1%B9%E7%9B%AE/Java%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%9D%97%E9%93%BEDemo/index.html","path":"/post/项目/Java实现区块链Demo/index.html","title":"Java实现区块链Demo"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java实现区块链Demo | ZestJourney</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">ZestJourney</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">乐游记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E6%AF%94%E7%89%B9%E5%B8%81%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text"> 区块链与比特币概念</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E5%AE%9E%E7%8E%B0block%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text"> 1. 实现Block结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%9D%97%E9%93%BEblockchain%E7%BB%93%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text"> 2. 实现区块链（BlockChain）结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E5%87%86%E5%A4%87%E6%8C%96%E7%9F%BF"><span class="nav-number">4.</span> <span class="nav-text"> 3. 准备挖矿！！！</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E5%88%9B%E5%BB%BA%E9%92%B1%E5%8C%85"><span class="nav-number">5.</span> <span class="nav-text"> 4. 创建钱包</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E5%AE%9E%E7%8E%B0%E4%BA%A4%E6%98%93transaction"><span class="nav-number">6.</span> <span class="nav-text"> 5. 实现交易（Transaction)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E5%AE%8C%E5%96%84%E9%92%B1%E5%8C%85wallet"><span class="nav-number">7.</span> <span class="nav-text"> 6. 完善钱包（Wallet）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E5%AE%8C%E5%96%84%E5%85%B6%E5%AE%83%E7%B1%BB"><span class="nav-number">8.</span> <span class="nav-text"> 7. 完善其它类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-%E6%B5%8B%E8%AF%95"><span class="nav-number">9.</span> <span class="nav-text"> 8. 测试</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E"><span class="nav-number">10.</span> <span class="nav-text"> 9. 写在最后</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zestaken</p>
  <div class="site-description" itemprop="description">吾好梦中读书~</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">84</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">60</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E9%A1%B9%E7%9B%AE/Java%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%9D%97%E9%93%BEDemo/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java实现区块链Demo | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java实现区块链Demo
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-26 08:02:19" itemprop="dateCreated datePublished" datetime="2021-07-26T08:02:19+08:00">2021-07-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:29:23" itemprop="dateModified" datetime="2022-09-17T19:29:23+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>25k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>22 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="区块链与比特币概念"><a class="markdownIt-Anchor" href="#区块链与比特币概念"></a> 区块链与比特币概念</h1>
<ul>
<li>
<p>区块链（BlockChain）起源于比特币，2008年11月1日，一位自称中本聪(Satoshi Nakamoto)的人发表了《比特币:一种点对点的电子现金系统》一文，阐述了基于P2P网络技术、加密技术、时间戳技术、区块链技术等的电子现金系统的构架理念，这标志着比特币的诞生。</p>
</li>
<li>
<p>在比特币系统中，区块（Block）是一个一个的存储单元，记录了一定时间内各个区块节点全部的交流信息。各个区块之间通过随机散列(也称哈希算法)实现链接，后一个区块包含前一个区块的哈希值，随着信息交流的扩大，一个区块与一个区块相继接续，形成的结果就叫区块链（BlockChain）。</p>
</li>
<li>
<p>在知乎上看到一个漫画讲得很形象：</p>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/0QlkTi.jpg" alt="0QlkTi" /></p>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/XhKOwy.jpg" alt="XhKOwy" /></p>
<p><img src="https://pic2.zhimg.com/v2-8317abc7bb2e2058bb2e5242739aba01_r.jpg" alt="preview" /></p>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/y71QB4.jpg" alt="y71QB4" /></p>
</li>
<li>
<p>看着这些概念头脑中也难以形成一个具体的印象，不如实现一个区块链的demo来看一看。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://medium.com/programmers-blockchain/create-simple-blockchain-java-tutorial-from-scratch-6eeed3cb03fa">参考教程</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://github.com/zestaken/BlockChainDemo">代码地址</a></p>
</li>
</ul>
<h1 id="1-实现block结构"><a class="markdownIt-Anchor" href="#1-实现block结构"></a> 1. 实现Block结构</h1>
<ul>
<li>区块链（BlockChain）顾名思义，是将一个个区块（Block）链接起来形成。所以我们实现区块链的第一步是实现Block结构。</li>
<li>区块链的链不是传统的通过指针等技术实现，而是通过哈希值来链接。所以一个Block中需要包含自身的哈希值，前一个Block的哈希值，还有自身的数据（这个数据与交易信息有关）。而当前块的哈希值是通过前一个块的哈希值、当前块的创建的时间以及当前块的数据三者根据加密算法计算得出的。所以Block中还要包含时间戳变量表示块创建时间。</li>
<li>Block类实现如下：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Block &#123;

    public String hash;
    public String prevHash;
    private String data;
    private long timestamp;

    public ZJChain.Block(String data, String prevHash) &#123;
        this.data &#x3D; data;
        this.prevHash &#x3D; prevHash;
        this.timestamp &#x3D; new Date().getTime();
        &#x2F;&#x2F;初始化哈希值必须在其它属性都已初始化之后
        try &#123;
            this.hash &#x3D; calculateHash();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    &#x2F;**
     * 计算当前块的哈希值
     * @return
     * @throws Exception
     *&#x2F;
    public String calculateHash() throws Exception &#123;
        String calculatedHash &#x3D; StringUtil.applySha256(prevHash+data+timestamp);
        return calculatedHash;
    &#125;
&#125;</code></pre>
<ul>
<li>应用SHA256算法来计算哈希值：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 应用SHA256算法接收输入字符串计算并返回哈希字符串
 * @param input
 * @return
 * @throws Exception
 *&#x2F;
public static String applySha256(String input) throws Exception &#123;
        &#x2F;&#x2F;返回实现指定摘要算法的 MessageDigest 对象。此处是SHA-256算法
        MessageDigest digest &#x3D; MessageDigest.getInstance(&quot;SHA-256&quot;); &#x2F;&#x2F;getInstance有异常
        &#x2F;&#x2F;根据输入的bytes数组完成哈希计算。
        byte[] hash &#x3D; digest.digest(input.getBytes(&quot;UTF-8&quot;));&#x2F;&#x2F;getBytes有异常
        StringBuffer hexString &#x3D; new StringBuffer();
        for(int i &#x3D; 0; i &lt; hash.length; i++) &#123;
            &#x2F;&#x2F;将生成的哈希字节数组每一字节（8bit）转换16进制数字符串
            String hex &#x3D; Integer.toHexString(0xff &amp; hash[i]);
            if(hex.length() &#x3D;&#x3D; 1) &#123;
                &#x2F;&#x2F;当生成的16进制数只有一位时，在末尾添0，丢弃生成的16进制数（因为8位应是两位的16进制数，除非前面全为0）
                hexString.append(&quot;0&quot;);
            &#125;
            &#x2F;&#x2F;将每一个字节的转换结果连接
            hexString.append(hex);
        &#125;
        return hexString.toString();
&#125;</code></pre>
<ul>
<li>SHA256:
<ul>
<li>SHA256的中文全称叫做“安全哈希算法”。所谓的“哈希”是Hash的音译，而Hash就是进行Hash函数的意思。通常来说，Hash函数的运算有一个共同特点。就是不论原始数据有多少位，只要通过Hash运算后，得到结果的长度都是固定的。</li>
<li>Hash函数的类型有很多种，包括SHA224、SHA256、SHA384、SHA512、SHA512/224、SHA512/256等。但是比特币仅选用了SHA256。这个256代表的意思是，数据经过函数运算后得到的结果必须是一个256位的2进制数字。</li>
<li>每次Hash计算后得到的结果有三个要求：第一、输入Hash函数之前的数据和通过Hash函数处理过后得到的编号必须一一对应。第二、每一个编号的长度都是固定的。第三、我们无法通过编号倒推出数据的内容。</li>
</ul>
</li>
<li>因为哈希值的涉及到前一个块的哈希值，时间，数据等，所以哈希链表是无法在中间插入修改的。</li>
</ul>
<h1 id="2-实现区块链blockchain结构"><a class="markdownIt-Anchor" href="#2-实现区块链blockchain结构"></a> 2. 实现区块链（BlockChain）结构</h1>
<ul>
<li>前面构造了区块（Block），现在把他们连接起来存储就形成了区块链。我们采用ArrayList结构来组织这些Block。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ZJChain &#123;

    &#x2F;&#x2F;blockChain为静态属性，所有对象都是在对同一个blockchain修改
    public static ArrayList&lt;Block&gt; blockChain &#x3D; new ArrayList&lt;Block&gt;();

    &#x2F;**
     * 检查区块链的有效性
     * @return
     *&#x2F;
    public boolean isChainValid() &#123;
        Block curBlock;
        Block prevBlock;

        &#x2F;&#x2F;遍历blockchain，从1开始，保证prevblock的有效性
        for(int i &#x3D; 1; i &lt; blockChain.size(); i++) &#123;
            curBlock &#x3D; blockChain.get(i);
            prevBlock &#x3D; blockChain.get(i - 1);

            try &#123;
                &#x2F;&#x2F;检查hash值计算有效性
                if(!curBlock.hash.equals(curBlock.calculateHash())) &#123;
                    System.out.println(&quot;block的hash值计算错误&quot;);
                    return false;
                &#125;
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;

            &#x2F;&#x2F;检查hash值前后对应关系正确性
            if(!prevBlock.hash.equals(curBlock.prevHash)) &#123;
                System.out.println(&quot;当前block与前面block的hash值不对应&quot;);
                return false;
            &#125;
        &#125;
        return true;
    &#125;

    &#x2F;**
     * 向区块链中添加块
     * @param block
     *&#x2F;
    public void addBlock(Block block) &#123;
        blockChain.add(block);
    &#125;

    &#x2F;**
     * 将blockChain转换为json字符串本地存储
     * @return
     *&#x2F;
    public String toJson() &#123;
        String blockChainString &#x3D; JSON.toJSONString(blockChain);
        return blockChainString;
    &#125;
&#125;</code></pre>
<ul>
<li>因为ArrayList是内存中的数据结构，需要长期保存的话需要转换为JSON字符串写入文件中保存,通过alibaba的fastjson包实现。</li>
<li>构建区块链的测试：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
 public void test1() &#123;
     &#x2F;&#x2F;初始化区块链
     ZJChain zjChain &#x3D; new ZJChain();
     &#x2F;&#x2F;向区块链中添加10个块
     for(int i &#x3D; 0; i &lt; 10; i++) &#123;
         &#x2F;&#x2F;创建新块
         Block block;
         if(zjChain.blockChain.size() &#x3D;&#x3D; 0) &#123;
             block &#x3D; new Block(&quot;Block: &quot; + i, &quot;0&quot;);
         &#125; else &#123;
             block &#x3D; new Block(&quot;Block: &quot; + i, zjChain.blockChain.get(
                     zjChain.blockChain.size() - 1).hash);
         &#125;
         zjChain.addBlock(block);
     &#125;

     for(ZJChain.Block block : zjChain.blockChain) &#123;
         System.out.println(&quot;hash: &quot; + block.hash + &quot; prevHash: &quot; + block.prevHash);
     &#125;
 &#125;</code></pre>
<h1 id="3-准备挖矿"><a class="markdownIt-Anchor" href="#3-准备挖矿"></a> 3. 准备挖矿！！！</h1>
<ul>
<li>提起比特币、区块链，便离不开挖矿这个话题。那什么是挖矿？比特币挖矿就是找到一个随机数（Nonce）参与哈希运算Hash，使得最后得到的哈希值符合难度要求（在很多种组合中试出满足要求的组合, 有一点运气成分），用公式表示就是Hash &lt;= target。具体的说就是使生成的哈希值的开头至少有指定数目个0。实现如下：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public void mineBlock(int difficulty) &#123;
    &#x2F;&#x2F;生成目标字符串：此处是包含指定数量（difficulty）个连续的0的字符串
    String target &#x3D; new String(new char[difficulty]).replace(&#39;\0&#39;, &#39;0&#39;);
    &#x2F;&#x2F;检查当前块的hash值中从0到difficulty部分是否与target字符串相同，如果不相同，则修改nonce，重新计算hash
    while(!hash.substring(0, difficulty).equals(target)) &#123;
        nonce++;
        try &#123;
            hash &#x3D; calculateHash();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    System.out.println(&quot;nonce：&quot; + nonce);
&#125;</code></pre>
<ul>
<li>简单来看挖矿难度的高低就是生成区块头的哈希值有多少0，前面固定的0越多，满足条件的值就越少，计算得到符合标准的hash值的概率就低，宏观上说需要计算的次数就越多。difficulty每增加1，运算量都是呈几何速率增加，十分恐怖。</li>
<li>当难度为4:<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/SAWTcE.png" alt="SAWTcE" /></li>
<li>当难度为5:<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/lVcfrW.png" alt="lVcfrW" /></li>
<li>当难度为6:<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/4IZwd2.png" alt="4IZwd2" />（好家伙，直接跑了8分多钟。。。）</li>
<li>对比可以看出，难度增加1，运算量（nonce可以表示运算的次数）直接增加一个量级，怪不得作为工作量衡量的标准（proof-of-work)。</li>
<li>这里还可以看出，挖矿之所以很耗算力，并不是因为这个哈希计算本身有多么复杂，而是它是需要重复这个哈希计算很多次（我这随便提一点难度，都到千万级了。。。）直到满足要求。这也是为什么GPU挖矿效率比CPU高的原因：其实不是GPU运算速度比CPU快，而是GPU运算的数据是单一的，是经过CPU运算往后分离出来的单一数据。CPU运算的所需求的东西许多，而且不是单一的某种数据。CPU可以运行更复杂的指令。如果是做一个简单的数学计算，一个最大16核的CPU最多只能同时跑16个线程，而一个普通的GPU就可以同时跑3000多个线程，所以做简单数学，GPU就比CPU要快几个数量级，而生成区块要做的哈希计算偏偏就是一个很简单的数学题。</li>
<li>另外，在检查区块链的有效性(isChainValid)的时候，还需要增加检查hash值是否满足难度要求这一点：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">if(!curBlock.hash.substring(0, difficulty).equals(target)) &#123;
    &#x2F;&#x2F;如果不满足难度标准，也无效
    System.out.println(&quot;当前块未满足难度标准！&quot;);
    return false;
&#125;</code></pre>
<h1 id="4-创建钱包"><a class="markdownIt-Anchor" href="#4-创建钱包"></a> 4. 创建钱包</h1>
<ul>
<li>比特币是一种点对点的电子现金系统，没有实物形态，可以存储在比特币钱包里。日常生活中，钱包是用来放钱的，但比特币钱包里却没有比特币，而只是确立比特币所有权的工具：比特币被记录在比特币网络的区块中（即Block，实际记录的也不是具体的比特币而是一笔笔交易记录）中，比特币的所有权是通过数字密钥、比特币地址和数字签名（接下来要实现的）来确立的。</li>
<li>数字密钥并不存储在网络中，而是由用户生成并存储在一个文件或简单的数据库中，称为钱包。比特币钱包里存储着你的比特币信息，包括比特币地址（类似于你的银行卡账号）和数字秘钥。</li>
<li>数字秘钥是用公钥加密创建一个密钥对，用于控制比特币的获取。密钥对包括一个私钥，和由其衍生出的唯一的公钥。公钥用于接收比特币，而私钥用于生成比特币支付时的交易签名（类似于你银行卡的密码）。支付比特币时，比特币的当前所有者需要在交易中提交其公钥和签名（每次交易的签名都不同，但均从同一个私钥生成）。比特币网络中的所有人都可以通过所提交的公钥和签名进行验证，并确认该交易是否有效，即确认支付者在该时刻对所交易的比特币拥有所有权。比特币私钥就用来保护你的钱包，如果私钥丢失，你将永远失去这笔比特币。</li>
<li>Wallet实现：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Wallet &#123;
    public PublicKey publicKey;
    public PrivateKey privateKey;

    public Wallet() &#123;
        generateKeyPair();
    &#125;

    &#x2F;**
     * 生成公私钥
     *&#x2F;
    public void generateKeyPair() &#123;
        try &#123;
            &#x2F;&#x2F;指定算法ECDSA生成密钥对
            KeyPairGenerator keyGen &#x3D; KeyPairGenerator.getInstance(&quot;ECDSA&quot;, &quot;BC&quot;);
            SecureRandom random &#x3D; SecureRandom.getInstance(&quot;SHA1PRNG&quot;);
            ECGenParameterSpec ecSpec &#x3D; new ECGenParameterSpec(&quot;prime192v1&quot;);
            &#x2F;&#x2F;初始化并生成密钥对
            keyGen.initialize(ecSpec, random);
            KeyPair keyPair &#x3D; keyGen.generateKeyPair();
            &#x2F;&#x2F;获取公私钥
            privateKey &#x3D; keyPair.getPrivate();
            publicKey &#x3D; keyPair.getPublic();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>
<ul>
<li>ECDSA:椭圆曲线数字签名算法（Elliptic Curve Digital Signature Algorithm，缩写ECDSA）是一种被广泛应用于数字签名的加密算法。</li>
</ul>
<h1 id="5-实现交易transaction"><a class="markdownIt-Anchor" href="#5-实现交易transaction"></a> 5. 实现交易（Transaction)</h1>
<ul>
<li>既然是一种货币，那么最重要的功能就是用来交易，作为最早出现的加密货币，比特币采用了 UTXO 模型作为其底层存储的数据结构，其全称为 Unspent Transaction output，也就是未被使用的交易输出。</li>
<li>UTXO 模型的加密货币中，某一个账户中的余额并不是由一个数字表示的，而是由当前区块链网络中所有属于当前账户的 UTXO 组成的。每一个UTXO就跟现实世界中的一张纸钞类似，一个UTXO只能用一次，如果数额超出需要支付的价钱则发给自己新的UTXO（自己给自己找零）。</li>
<li>比特币实质上没有存储货币，它有的不过是在一个个交易中记录的数字变化，而这个数字的源头来自矿工。我们挖矿产生的Block实质上是一个账本，其中记录一笔笔交易的记录。每挖出一个Block，就会从无到有生成可以用于交易的value（交易中的数字）给矿工，这便是比特币产生的地方。</li>
<li>交易中每个人用钱包来保管自己的UTXO，以及公私钥。公钥就类似于银行卡号，别人通过指定你的公钥来转账给你。私钥类似于你的密码，但是又有不同：每次你发起转账，都需要通过你的私钥结合交易的内容来生成一个签名，通过验证签名与公钥来确认身份。签名与交易是一一对应的，即使暴露了也无妨，但是私钥是绝对不能泄漏的。</li>
<li>UTXO 其实就是交易的一部分，基于 UTXO 模型的交易由输入和输出两个部分组成:UTXO 模型中的每一笔交易都是由多个交易输入组成的，这些输入其实就是 UTXO + 签名:属于某个人的UTXO加上这个人的签名（由秘钥生成）则可以表示这个人授权使用这个UTXO。每一个交易都可能会有多个输出，每一个输出都可以指向不同的地址，其中也有当前输出包含的值 value，这个value也就是比特币的计量数。</li>
<li>交易实现：
<ul>
<li>Transaction.java</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Transaction &#123;
    &#x2F;**
     * 交易号
     *&#x2F;
    public String transactionId;
    &#x2F;**
     * 交易序号，用于记录交易数量
     *&#x2F;
    public static int sequence &#x3D; 0;
    &#x2F;**
     * 发送方的地址&#x2F;public key
     *&#x2F;
    public PublicKey sender;
    &#x2F;**
     * 接收方的地址&#x2F;public key
     *&#x2F;
    public PublicKey recipient;
    &#x2F;**
     * 交易额
     *&#x2F;
    public float value;
    &#x2F;**
     * 发送方的签名
     *&#x2F;
    public byte[] signature;

    &#x2F;**
     * 本次交易所涉及到的所有交易输入
     *&#x2F;
    public ArrayList&lt;TransactionInput&gt; inputs &#x3D; new ArrayList&lt;TransactionInput&gt;();
    &#x2F;**
     * 本次交易所涉及到的所有交易输出（第0位output是发给别人的，第1位output是发给自己的）
     *&#x2F;
    public ArrayList&lt;TransactionOutput&gt; outputs &#x3D; new ArrayList&lt;TransactionOutput&gt;();

    public Transaction(PublicKey from, PublicKey to, float value, ArrayList&lt;TransactionInput&gt; inputs) &#123;
        this.sender &#x3D; from;
        this.recipient &#x3D; to;
        this.value &#x3D; value;
        this.inputs &#x3D; inputs;
    &#125;

    &#x2F;**
     * 计算用于标识交易的transactionId
     * @return
     * @throws Exception
     *&#x2F;
    private String calculateHash() throws Exception &#123;
        sequence++;
            return StringUtil.applySha256(
                    StringUtil.getStringFromKey(sender) +
                    StringUtil.getStringFromKey(recipient) +
                    value + sequence);
    &#125;

    &#x2F;**
     * 根据私钥和其它数据生成数字签名
     * @param privateKey
     *&#x2F;
    public void generateSignature(PrivateKey privateKey) &#123;
        String data &#x3D; StringUtil.getStringFromKey(sender) + StringUtil.getStringFromKey(recipient) + value;
        signature &#x3D; StringUtil.applyECDSASig(privateKey, data);
    &#125;

    &#x2F;**
     * 检查发送方数字签名，以验证数据没有损坏或者被修改
     * @return
     *&#x2F;
    public boolean verifySignature() throws Exception &#123;
        String data &#x3D; StringUtil.getStringFromKey(sender) + StringUtil.getStringFromKey(recipient) + value;
        return StringUtil.verifyECDSASig(sender, data, signature);
    &#125;

    &#x2F;**
     * 实现一次交易
     * @return
     *&#x2F;
    public boolean processTransaction() &#123;

        &#x2F;&#x2F;验证交易的发送方的数字签名是否有效
        try &#123;
            if(!verifySignature()) &#123;
                System.out.println(&quot;交易签名验证失败&quot;);
                return false;
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;

        &#x2F;&#x2F;根据交易输出的id从整个区块链中有效的UTXO集合中获取对应的UTXO
        for(TransactionInput input : inputs) &#123;
            input.UTXO &#x3D; ZJChain.UTXOs.get(input.transactionOutputId);
        &#125;

        &#x2F;&#x2F;检测交易输入额是否符合最小标准
        if(getInputsValue() &lt; ZJChain.minimumTransaction) &#123;
            System.out.println(&quot;交易输入数额：&quot; + getInputsValue() + &quot; 小于最小交易额&quot;);
            return false;
        &#125;

        &#x2F;&#x2F;计算交易输入还有多少剩余（类似找零）
        float leftover &#x3D; getInputsValue() - value;
        if(leftover &lt; 0) &#123;
            System.out.println(&quot;金额不足，交易终止！&quot;);
            return false;
        &#125;
        &#x2F;&#x2F;计算交易id
        try &#123;
            transactionId &#x3D; calculateHash();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        &#x2F;&#x2F;建立指向收款方的交易输出
        outputs.add(new TransactionOutput(this.recipient, value, transactionId));
        &#x2F;&#x2F;如果需要找零才找零
        if(leftover &gt; 0) &#123;
            &#x2F;&#x2F;建立指向发送方的交易输出（将交易输出中没有用完的还给自己，实现找零功能）
            outputs.add(new TransactionOutput(this.sender, leftover, transactionId));
        &#125;

        &#x2F;&#x2F;将本次交易中的所有交易输出添加到整个区块链的UTXO集合中（实现向所有用户通报这笔交易）
        for(TransactionOutput output : outputs) &#123;
            ZJChain.UTXOs.put(output.id, output);
        &#125;
        &#x2F;&#x2F;移除整个区块链中本次交易中所有交易输入所对应的UTXO（每个UTXO只能用来支付一次）
        for(TransactionInput input : inputs) &#123;
            if(input.UTXO !&#x3D; null) &#123;
                ZJChain.UTXOs.remove(input.UTXO.id);
            &#125;
        &#125;

        return true;

    &#125;

    &#x2F;**
     * 获取所有交易输入中的总价值（计算拥有的钱的总数）
     * @return
     *&#x2F;
    public float getInputsValue() &#123;
        float sum &#x3D; 0;
        for(TransactionInput i : inputs) &#123;
            if(i.UTXO !&#x3D; null) &#123;
                sum +&#x3D; i.UTXO.value;
            &#125;
        &#125;
        return sum;
    &#125;

    &#x2F;**
     * 获取所有交易输出中的总价值（要支付的钱的总数）
     * @return
     *&#x2F;
    public float getOutputsValue() &#123;
        float sum &#x3D; 0;
        for(TransactionOutput output : outputs) &#123;
            sum +&#x3D; output.value;
        &#125;
        return sum;
    &#125;

&#125;</code></pre>
<ul>
<li>TransactionInput.java</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TransactionInput &#123;
    &#x2F;**
     * 这笔交易输入从该ID的交易输出来（类似你曾经收到的某张钞票的编号）
     *&#x2F;
    public String transactionOutputId;
    &#x2F;**
     * UTXO 未花费交易输出（你要使用的具体钞票）
     *&#x2F;
    public TransactionOutput UTXO;

    public TransactionInput(String transactionOutputId) &#123;
        this.transactionOutputId &#x3D; transactionOutputId;
    &#125;

&#125;</code></pre>
<ul>
<li>TransactionOutput.java</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TransactionOutput &#123;
    &#x2F;**
     * 交易输出编号id
     *&#x2F;
    public String id;
    &#x2F;**
     * 这笔交易输出的接收方公钥（类似收款方银行账号）
     *&#x2F;
    public PublicKey recipient;
    &#x2F;**
     * 交易输出额
     *&#x2F;
    public float value;
    &#x2F;**
     * 创建这个交易输出的交易id
     *&#x2F;
    public String parentTransactionId;


    public TransactionOutput(PublicKey recipient, float value, String parentTransactionId) &#123;
        this.recipient &#x3D; recipient;
        this.value &#x3D; value;
        this.parentTransactionId &#x3D; parentTransactionId;
        &#x2F;&#x2F;前面属性均赋值后再计算id
        try &#123;
            this.id &#x3D; StringUtil.applySha256(StringUtil.getStringFromKey(recipient) + this.value + this.parentTransactionId);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    &#x2F;&#x2F;检查UTXO（未消费的交易输出）是否是指定publickey的拥有者的
    public boolean isMine(PublicKey publicKey) &#123;
        return (publicKey &#x3D;&#x3D; recipient);
    &#125;
&#125;</code></pre>
<h1 id="6-完善钱包wallet"><a class="markdownIt-Anchor" href="#6-完善钱包wallet"></a> 6. 完善钱包（Wallet）</h1>
<ul>
<li>一个钱包中保存着每个账户的公私钥，并且具备统计该账户拥有的UTXO并计算余额的能力，此外钱包还有创建交易发起支出的能力。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Wallet &#123;
    &#x2F;&#x2F;公私钥
    public PublicKey publicKey;
    public PrivateKey privateKey;

    &#x2F;**
     * 钱包存储属于自己的UTXO（未消费交易输出）
     *&#x2F;
    public HashMap&lt;String, TransactionOutput&gt; UTXOs &#x3D; new HashMap&lt;&gt;();

    public Wallet() &#123;
        generateKeyPair();
    &#125;

    &#x2F;**
     * 生成公私钥
     *&#x2F;
    public void generateKeyPair() &#123;
        try &#123;
            &#x2F;&#x2F;指定算法ECDSA生成密钥对
            KeyPairGenerator keyGen &#x3D; KeyPairGenerator.getInstance(&quot;ECDSA&quot;, &quot;BC&quot;);
            SecureRandom random &#x3D; SecureRandom.getInstance(&quot;SHA1PRNG&quot;);
            ECGenParameterSpec ecSpec &#x3D; new ECGenParameterSpec(&quot;prime192v1&quot;);
            &#x2F;&#x2F;初始化并生成密钥对
            keyGen.initialize(ecSpec, random);
            KeyPair keyPair &#x3D; keyGen.generateKeyPair();
            &#x2F;&#x2F;获取公私钥
            privateKey &#x3D; keyPair.getPrivate();
            publicKey &#x3D; keyPair.getPublic();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    &#x2F;**
     * 计算钱包的总余额
     * @return
     *&#x2F;
    public float getBalance() &#123;
        float sum &#x3D; 0;
        &#x2F;&#x2F;遍历Map集合获取键值对对象
        for(Map.Entry&lt;String, TransactionOutput&gt; item : ZJChain.UTXOs.entrySet()) &#123;
            TransactionOutput UTXO &#x3D;  item.getValue();
            &#x2F;&#x2F;检查该UTXO是否属于该钱包
            if(UTXO.isMine(publicKey)) &#123;
                &#x2F;&#x2F;添加到钱包的UTXOs集合中
                UTXOs.put(UTXO.id, UTXO);
                sum +&#x3D; UTXO.value;
            &#125;
        &#125;
        return sum;
    &#125;

    &#x2F;**
     * 创建交易，支出
     * @param _recipient
     * @param value
     * @return
     *&#x2F;
    public Transaction sendFunds(PublicKey _recipient, float value) &#123;
        &#x2F;&#x2F;检查余额是否足够
        if(getBalance() &lt; value) &#123;
            System.out.println(&quot;余额不足，交易终止！&quot;);
            return null;
        &#125;
        &#x2F;&#x2F;建立动态数组用来记录作为交易输入使用的UTXO
        ArrayList&lt;TransactionInput&gt; inputs &#x3D; new ArrayList&lt;&gt;();

        &#x2F;&#x2F;查找钱包的UTXO，直到总金额达到要支付的金额
        float total &#x3D; 0;
        for(Map.Entry&lt;String, TransactionOutput&gt; item : UTXOs.entrySet()) &#123;
            TransactionOutput UTXO &#x3D; item.getValue();
            total +&#x3D; UTXO.value;
            inputs.add(new TransactionInput(UTXO.id));
            if(total &gt;&#x3D; value) &#123;
                break;
            &#125;
        &#125;

        &#x2F;&#x2F;创建交易
        Transaction newTransaction &#x3D; new Transaction(publicKey, _recipient, value, inputs);
        newTransaction.generateSignature(privateKey);

        &#x2F;&#x2F;将已经使用的UTXO从钱包中移除
        for(TransactionInput input : inputs) &#123;
            UTXOs.remove(input.transactionOutputId);
        &#125;

        return  newTransaction;
    &#125;
    
&#125;</code></pre>
<h1 id="7-完善其它类"><a class="markdownIt-Anchor" href="#7-完善其它类"></a> 7. 完善其它类</h1>
<ul>
<li>在StringUtil工具类中，增加生成和验证数字签名的功能。同时还有根据添加到区块中的交易记录生成merkleRoot的功能，merkelRoot用于标识区块及其中的唯一性。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class StringUtil &#123;

    &#x2F;**
     * 应用SHA256算法接收输入字符串计算并返回哈希字符串
     * @param input
     * @return
     * @throws Exception
     *&#x2F;
    public static String applySha256(String input) throws Exception &#123;
            &#x2F;&#x2F;返回实现指定摘要算法的 MessageDigest 对象。此处是SHA-256算法
            MessageDigest digest &#x3D; MessageDigest.getInstance(&quot;SHA-256&quot;); &#x2F;&#x2F;getInstance有异常
            &#x2F;&#x2F;根据输入的bytes数组完成哈希计算。
            byte[] hash &#x3D; digest.digest(input.getBytes(&quot;UTF-8&quot;));&#x2F;&#x2F;getBytes有异常
            StringBuffer hexString &#x3D; new StringBuffer();
            for(int i &#x3D; 0; i &lt; hash.length; i++) &#123;
                &#x2F;&#x2F;将生成的哈希字节数组每一字节（8bit）转换16进制数字符串
                String hex &#x3D; Integer.toHexString(0xff &amp; hash[i]);
                if(hex.length() &#x3D;&#x3D; 1) &#123;
                    &#x2F;&#x2F;当生成的16进制数只有一位时，在末尾添0，丢弃生成的16进制数（因为8位应是两位的16进制数，除非前面全为0）
                    hexString.append(&quot;0&quot;);
                &#125;
                &#x2F;&#x2F;将每一个字节的转换结果连接
                hexString.append(hex);
            &#125;
            return hexString.toString();
    &#125;

    &#x2F;**
     * 根据秘钥获得字符串
     * @param key
     * @return
     *&#x2F;
    public static String getStringFromKey(Key key) &#123;
        return Base64.getEncoder().encodeToString(key.getEncoded());
    &#125;

    &#x2F;**
     * 根据ECDSA算法，由privatekey生成数字签名（字节数组）
     * @param privateKey
     * @param data
     * @return
     *&#x2F;
    public static byte[] applyECDSASig(PrivateKey privateKey, String data) &#123;
        Signature dsa;
        &#x2F;&#x2F;提前声明变量，避免最后不能返回有效值
        byte[] output &#x3D; new byte[0];
        try&#123;
            dsa &#x3D; Signature.getInstance(&quot;ECDSA&quot;, &quot;BC&quot;);
            dsa.initSign(privateKey);
            byte[] strByte &#x3D; data.getBytes();
            dsa.update(strByte);
            byte[] realSig &#x3D; dsa.sign();
            output &#x3D; realSig;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;

        return output;
    &#125;

    &#x2F;**
     * 由publickey验证数字签名是否正确
     * @param publicKey
     * @param data
     * @param signature
     * @return
     *&#x2F;
    public static boolean verifyECDSASig(PublicKey publicKey, String data, byte[] signature) throws Exception &#123;
            Signature ecdsaVerify &#x3D; Signature.getInstance(&quot;ECDSA&quot;, &quot;BC&quot;);
            ecdsaVerify.initVerify(publicKey);
            ecdsaVerify.update(data.getBytes());
            return ecdsaVerify.verify(signature);
    &#125;

    &#x2F;**
     * 根据交易生成merkleRoot标志区块
     * @param transactions
     * @return
     *&#x2F;
    public static String getMerkleRoot(ArrayList&lt;Transaction&gt; transactions) &#123;
        int count &#x3D; transactions.size();
        ArrayList&lt;String&gt; previousTreeLayer &#x3D; new ArrayList&lt;&gt;();
        for(Transaction transaction : transactions) &#123;
            previousTreeLayer.add(transaction.transactionId);
        &#125;

        ArrayList&lt;String&gt; treeLayer &#x3D; previousTreeLayer;

        while(count &gt; 1) &#123;
            treeLayer &#x3D; new ArrayList&lt;&gt;();
            for(int i &#x3D; 1; i &lt; previousTreeLayer.size(); i++) &#123;
                try &#123;
                    treeLayer.add(StringUtil.applySha256(previousTreeLayer.get(i - 1) + previousTreeLayer.get(i)));
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125;
                count &#x3D; treeLayer.size();
                previousTreeLayer &#x3D; treeLayer;
            &#125;
        &#125;

        String merkleRoot &#x3D; (treeLayer.size() &#x3D;&#x3D; 1) ? treeLayer.get(0) : &quot;&quot;;

        return merkleRoot;
    &#125;
&#125;</code></pre>
<ul>
<li>Block类的设置中，用merkleRoot来做数据生成哈希值，同时新增将交易记录添加到区块中的功能。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Block &#123;

    public String hash;
    public String prevHash;
    public long timestamp;
    public int nonce; &#x2F;&#x2F;用于挖矿的变量
    public ArrayList&lt;Transaction&gt; transactions &#x3D; new ArrayList&lt;&gt;();
    &#x2F;&#x2F;merkleRoot充当data的作用（因为区块block本质就是个账本，用交易来充当数据最合理）
    public String merkleRoot;

    public Block(String prevHash) &#123;
        this.prevHash &#x3D; prevHash;
        this.timestamp &#x3D; new Date().getTime();
        &#x2F;&#x2F;初始化哈希值必须在其它属性都已初始化之后
        try &#123;
            this.hash &#x3D; calculateHash();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    &#x2F;**
     * 计算当前块的哈希值
     * @return
     * @throws Exception
     *&#x2F;
    public String calculateHash() throws Exception &#123;
        &#x2F;&#x2F;取消使用data生成hash而使用merkleRoot
        String calculatedHash &#x3D; StringUtil.applySha256(prevHash+merkleRoot+timestamp+nonce);
        return calculatedHash;
    &#125;

    &#x2F;**
     * 挖矿计算
     * @param difficulty
     *&#x2F;
    public void mineBlock(int difficulty) &#123;
        &#x2F;&#x2F;挖矿前计算merkleRoot值
        merkleRoot &#x3D; StringUtil.getMerkleRoot(transactions);
        &#x2F;&#x2F;生成目标字符串：此处是包含指定数量（difficulty）个连续的0的字符串
        String target &#x3D; new String(new char[difficulty]).replace(&#39;\0&#39;, &#39;0&#39;);
        &#x2F;&#x2F;检查当前块的hash值中从0到difficulty部分是否与target字符串相同，如果不相同，则修改nonce，重新计算hash
        while(!hash.substring(0, difficulty).equals(target)) &#123;
            nonce++;
            try &#123;
                hash &#x3D; calculateHash();
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        System.out.println(&quot;nonce：&quot; + nonce);
    &#125;

    &#x2F;**
     * 在将交易添加到块时执行交易
     * @param transaction
     * @return
     *&#x2F;
    public boolean addTransaction(Transaction transaction) &#123;
        &#x2F;&#x2F;验证交易的有效性
        if(transaction &#x3D;&#x3D; null) return false;
        if(!prevHash.equals(&quot;0&quot;)) &#123;
            if(!transaction.processTransaction()) &#123;
                System.out.println(&quot;交易处理失败！&quot;);
                return false;
            &#125;
        &#125;
        &#x2F;&#x2F;将交易记录添加到区块中
        transactions.add(transaction);
        System.out.println(&quot;交易成功添加到Block中！&quot;);
        return true;
    &#125;
&#125;</code></pre>
<ul>
<li>ZJchain类:加强验证区块链有效功能，在将一个块添加到区块前进行挖矿计算。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ZJChain &#123;                                                                                   
                                                                                                         
    &#x2F;&#x2F;blockChain为静态属性，所有对象都是在对同一个blockchain修改                                                            
    public static ArrayList&lt;Block&gt; blockChain &#x3D; new ArrayList&lt;Block&gt;();                                  
    public static int difficulty &#x3D; 5;                                                                    
    &#x2F;**                                                                                                  
     * 用于记录所有有效的UTXO，键是String类型的TransactionOutputId                                                      
     *&#x2F;                                                                                                  
    public static HashMap&lt;String, TransactionOutput&gt; UTXOs &#x3D; new HashMap&lt;&gt;();                            
    &#x2F;**                                                                                                  
     * 每次交易的最小交易额                                                                                        
     *&#x2F;                                                                                                  
    public static float minimumTransaction &#x3D; 0.1f;                                                       
    public static Wallet walletA;                                                                        
    public static Wallet walletB;                                                                        
    &#x2F;**                                                                                                  
     * 初始交易（创建区块链时初始化第一笔交易）                                                                              
     *&#x2F;                                                                                                  
    public static Transaction genesisTransaction;                                                        
                                                                                                         
    &#x2F;**                                                                                                  
     * 检查区块链的有效性                                                                                         
     * @return                                                                                           
     *&#x2F;                                                                                                  
    public boolean isChainValid() &#123;                                                                      
        Block curBlock;                                                                                  
        Block prevBlock;                                                                                 
        &#x2F;&#x2F;用于检验挖矿难度是否达标的字符串                                                                               
        String target &#x3D; new String(new char[difficulty]).replace(&#39;\0&#39;, &#39;0&#39;);                             
        HashMap&lt;String, TransactionOutput&gt; tempUTXOs &#x3D; new HashMap&lt;&gt;();                                  
        tempUTXOs.put(genesisTransaction.outputs.get(0).id, genesisTransaction.outputs.get(0));          
                                                                                                         
                                                                                                         
        &#x2F;&#x2F;遍历blockchain，从1开始，保证prevblock的有效性                                                              
        for(int i &#x3D; 1; i &lt; blockChain.size(); i++) &#123;                                                     
            curBlock &#x3D; blockChain.get(i);                                                                
            prevBlock &#x3D; blockChain.get(i - 1);                                                           
                                                                                                         
                                                                                                         
            try &#123;                                                                                        
                &#x2F;&#x2F;检查hash值计算有效性                                                                           
                if(!curBlock.hash.equals(curBlock.calculateHash())) &#123;                                    
                    System.out.println(&quot;block的hash值计算错误&quot;);                                               
                    return false;                                                                        
                &#125;                                                                                        
            &#125; catch (Exception e) &#123;                                                                      
                e.printStackTrace();                                                                     
            &#125;                                                                                            
                                                                                                         
            &#x2F;&#x2F;检查hash值前后对应关系正确性                                                                           
            if(!prevBlock.hash.equals(curBlock.prevHash)) &#123;                                              
                System.out.println(&quot;当前block与前面block的hash值不对应&quot;);                                          
                return false;                                                                            
            &#125;                                                                                            
                                                                                                         
            if(!curBlock.hash.substring(0, difficulty).equals(target)) &#123;                                 
                &#x2F;&#x2F;如果不满足难度标准，也无效                                                                          
                System.out.println(&quot;当前块未满足挖矿难度标准！&quot;);                                                     
                return false;                                                                            
            &#125;                                                                                            
                                                                                                         
            TransactionOutput tempOutput;                                                                
            for(int t &#x3D; 0; i &lt; curBlock.transactions.size(); t++) &#123;                                      
                Transaction currentTransaction &#x3D; curBlock.transactions.get(t);                           
                                                                                                         
                &#x2F;&#x2F;检查交易的签名                                                                                
                try &#123;                                                                                    
                    if(!currentTransaction.verifySignature()) &#123;                                          
                        System.out.println(&quot;第&quot; + t + &quot;个交易的签名无效！&quot;);                                       
                        return false;                                                                    
                    &#125;                                                                                    
                &#125; catch (Exception e) &#123;                                                                  
                    e.printStackTrace();                                                                 
                &#125;                                                                                        
                                                                                                         
                &#x2F;&#x2F;检查交易的交易输出额和交易输入额是否相等                                                                   
                if(!(currentTransaction.getInputsValue() &#x3D;&#x3D; currentTransaction.getOutputsValue())) &#123;     
                    System.out.println(&quot;第&quot; + t + &quot;个交易的交易输出与交易输入额不相等！&quot;);                                  
                    return false;                                                                        
                &#125;                                                                                        
                                                                                                         
                &#x2F;&#x2F;检查交易输入是否正确（交易输入要么来源于初始交易（和矿工），要么来源于其它交易输出）                                             
                for(TransactionInput input : currentTransaction.inputs) &#123;                                
                    tempOutput &#x3D; tempUTXOs.get(input.transactionOutputId);                               
                                                                                                         
                    if(tempOutput &#x3D;&#x3D; null) &#123;                                                             
                        System.out.println(&quot;第&quot; + t + &quot;个交易的交易输入不存在！&quot;);                                    
                        return false;                                                                    
                    &#125;                                                                                    
                                                                                                         
                    if(input.UTXO.value !&#x3D; tempOutput.value) &#123;                                           
                        System.out.println(&quot;第&quot; + t + &quot;个交易的交易输入的值无效！&quot;);                                   
                        return false;                                                                    
                    &#125;                                                                                    
                                                                                                         
                    tempUTXOs.remove(input.transactionOutputId);                                         
                &#125;                                                                                        
                                                                                                         
                &#x2F;&#x2F;将交易输出加入临时UTXOs                                                                         
                for(TransactionOutput output : currentTransaction.outputs) &#123;                             
                    tempUTXOs.put(output.id, output);                                                    
                &#125;                                                                                        
                                                                                                         
                if(currentTransaction.outputs.get(0).recipient !&#x3D; currentTransaction.recipient) &#123;        
                    System.out.println(&quot;第&quot; + t + &quot;个交易的交易输出目的方错误！&quot;);                                      
                    return false;                                                                        
                &#125;                                                                                        
                                                                                                         
                if(currentTransaction.outputs.get(1).recipient !&#x3D; currentTransaction.sender) &#123;           
                    System.out.println(&quot;第&quot; + t + &quot;个交易的找零的交易输出没有发给发送者！&quot;);                                 
                    return false;                                                                        
                &#125;                                                                                        
            &#125;                                                                                            
        &#125;                                                                                                
         System.out.println(&quot;区块链有效！&quot;);                                                                   
         return true;                                                                                    
    &#125;                                                                                                    
                                                                                                         
    &#x2F;**                                                                                                  
     * 向区块链中添加块                                                                                          
     * @param newBlock                                                                                   
     *&#x2F;                                                                                                  
    public void addBlock(Block newBlock) &#123;                                                               
        &#x2F;&#x2F;先完成挖矿工作才能加入区块链中                                                                                
        newBlock.mineBlock(difficulty);                                                                  
        blockChain.add(newBlock);                                                                        
    &#125;                                                                                                    
                                                                                                         
    &#x2F;**                                                                                                  
     * 将blockChain转换为json字符串本地存储                                                                         
     * @return                                                                                           
     *&#x2F;                                                                                                  
    public String toJson() &#123;                                                                             
        String blockChainString &#x3D; JSON.toJSONString(blockChain);                                         
        return blockChainString;                                                                         
    &#125;                                                                                                    
                                                                                                         
    &#x2F;**                                                                                                  
     * 设置挖矿难度                                                                                            
     * @param difficulty                                                                                 
     *&#x2F;                                                                                                  
    public void setDifficulty(int difficulty) &#123;                                                          
        this.difficulty &#x3D; difficulty;                                                                    
    &#125;                                                                                                    
                                                                                                         
&#125;                                                                                                        </code></pre>
<h1 id="8-测试"><a class="markdownIt-Anchor" href="#8-测试"></a> 8. 测试</h1>
<ul>
<li>在一个测试类中走一遍基本功能：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public void test2() &#123;
    &#x2F;&#x2F;用于支撑验证签名的功能
    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider()); 

    &#x2F;&#x2F;初始化区块链
    ZJChain zjChain &#x3D; new ZJChain();

    &#x2F;&#x2F;创建钱包
    Wallet walletA &#x3D; new Wallet();
    Wallet walletB &#x3D; new Wallet();
    &#x2F;&#x2F;初始交易的钱包
    Wallet coinBase &#x3D; new Wallet();

    &#x2F;&#x2F;创建初始交易
    &#x2F;&#x2F;最初的交易的value从coinbase凭空出现
    System.out.println(&quot;第一次交易：coinbase向walletA转账100&quot;);
    ZJChain.genesisTransaction &#x3D; new Transaction(coinBase.publicKey, walletA.publicKey, 100f, null);
    &#x2F;&#x2F;生成coinbase对此次交易的签名
    ZJChain.genesisTransaction.generateSignature(coinBase.privateKey);
    &#x2F;&#x2F;初始交易id设为0
    ZJChain.genesisTransaction.transactionId &#x3D; &quot;0&quot;;
    &#x2F;&#x2F;因为初始交易是凭空生成，与普通交易不同，所以很多参数需要手动设置
    ZJChain.genesisTransaction.outputs.add(new TransactionOutput(
            ZJChain.genesisTransaction.recipient,
            ZJChain.genesisTransaction.value,
            ZJChain.genesisTransaction.transactionId));
    &#x2F;&#x2F;将本次交易输出添加到UTXOs
    ZJChain.UTXOs.put(ZJChain.genesisTransaction.outputs.get(0).id,
            ZJChain.genesisTransaction.outputs.get(0));

    System.out.println(&quot;挖矿生成第一个区块。。。&quot;);
    &#x2F;&#x2F;前面的哈希值为手动设为0
    Block genesis &#x3D; new Block(&quot;0&quot;);
    &#x2F;&#x2F;添加交易
    genesis.addTransaction(ZJChain.genesisTransaction);
    &#x2F;&#x2F;将该块加入区块链中
    zjChain.addBlock(genesis);

    System.out.println(&quot;第二笔交易： walletA向walletB转账20&quot;);
    System.out.println(&quot;WalletA的余额：&quot; + walletA.getBalance());
    System.out.println(&quot;WalletB的余额：&quot; + walletB.getBalance());
    &#x2F;&#x2F;新生成一个区块用于记账
    System.out.println(&quot;挖矿生成第二个区块。。。&quot;);
    Block block1 &#x3D; new Block(genesis.hash);
    block1.addTransaction(walletA.sendFunds(walletB.publicKey, 20f));
    zjChain.addBlock(block1);
    System.out.println(&quot;第二笔交易结束&quot;);
    System.out.println(&quot;WalletA的余额：&quot; + walletA.getBalance());
    System.out.println(&quot;WalletB的余额：&quot; + walletB.getBalance());

    zjChain.isChainValid();
&#125;</code></pre>
<ul>
<li>结果：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/5N08eT.png" alt="5N08eT" /></li>
</ul>
<h1 id="9-写在最后"><a class="markdownIt-Anchor" href="#9-写在最后"></a> 9. 写在最后</h1>
<ul>
<li>不得不说，比特币的出现是一次思维的革命。写这个小项目的时候虽然我没有去涉及高深的密码学算法，但是其中蕴含的天才思维逻辑也依旧让我震撼不已（同时也迷糊不已，即使已经粗略写了一下，很多地方还是不能理解得很清楚。。。）。</li>
<li>再想到比特币的创始人至今不知道其真实姓名，此时看这神秘的“中本聪”仿佛有了看金庸笔下的隐世高手的感觉。这或许就是程序员的浪漫吧！</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="tag"># 区块链</a>
              <a href="/tags/%E6%AF%94%E7%89%B9%E5%B8%81/" rel="tag"># 比特币</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/Python%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/index.html" rel="prev" title="Python深度学习环境">
                  <i class="fa fa-angle-left"></i> Python深度学习环境
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/LeetCode-%E9%98%9F%E5%88%97/index.html" rel="next" title="LeetCode-队列">
                  LeetCode-队列 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Zestaken</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">678k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:17</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js" integrity="sha256-4mJNT2bMXxcc1GCJaxBmMPdmah5ji0Ldnd79DKd1hoM=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha256-AjM0J5XIbiB590BrznLEgZGLnOQWrt62s3BEq65Q/I0=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha256-9cmf7tcLdXpKsPi/2AWE93PbZpTp4M4tqzFk+lWomjU=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
