<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.zestaken.top","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":true,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="python概述  Python是一门解释性语言，无需编译和链接。 Python解释器是可以交互的，因此Python甚至可以用作桌面计算器。 Python是可扩展的，可以为Python的解释器添加内置函数和模块。 本文学习的是Python3.   解释器  trackback:程序无法成功地运行时，解释器会提供一个traceback。traceback是一条记录，指出了解释器尝试运行代码时， 在">
<meta property="og:type" content="article">
<meta property="og:title" content="Python">
<meta property="og:url" content="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/Python/index.html">
<meta property="og:site_name" content="ZestJourney">
<meta property="og:description" content="python概述  Python是一门解释性语言，无需编译和链接。 Python解释器是可以交互的，因此Python甚至可以用作桌面计算器。 Python是可扩展的，可以为Python的解释器添加内置函数和模块。 本文学习的是Python3.   解释器  trackback:程序无法成功地运行时，解释器会提供一个traceback。traceback是一条记录，指出了解释器尝试运行代码时， 在">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-09-05T12:45:19.000Z">
<meta property="article:modified_time" content="2021-09-26T13:42:19.458Z">
<meta property="article:author" content="Zestaken">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/Python/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/Python/index.html","path":"/post/技术笔记/Python/Python/index.html","title":"Python"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Python | ZestJourney</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">ZestJourney</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">乐游记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#python%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text"> python概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="nav-number">1.1.</span> <span class="nav-text"> 解释器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83"><span class="nav-number">1.2.</span> <span class="nav-text"> Python编写规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python%E7%9A%84%E6%B3%A8%E9%87%8A"><span class="nav-number">1.3.</span> <span class="nav-text"> python的注释</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text"> 变量和数据类型(结构)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">2.1.</span> <span class="nav-text"> 变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E6%95%B0%E5%AD%97"><span class="nav-number">2.2.</span> <span class="nav-text"> 一：数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.3.</span> <span class="nav-text"> 二：字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="nav-number">2.3.1.</span> <span class="nav-text"> 字符串对象方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E5%88%97%E8%A1%A8"><span class="nav-number">2.4.</span> <span class="nav-text"> 三：列表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%B4%A8"><span class="nav-number">2.4.1.</span> <span class="nav-text"> 列表的基本性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">2.4.2.</span> <span class="nav-text"> 列表中常用的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">2.4.3.</span> <span class="nav-text"> 列表的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90"><span class="nav-number">2.4.4.</span> <span class="nav-text"> 列表解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#del%E8%AF%AD%E5%8F%A5"><span class="nav-number">2.4.5.</span> <span class="nav-text"> del语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#range%E5%87%BD%E6%95%B0"><span class="nav-number">2.4.6.</span> <span class="nav-text"> range()函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E5%85%83%E7%BB%84"><span class="nav-number">2.5.</span> <span class="nav-text"> 四：元组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E9%9B%86%E5%90%88set"><span class="nav-number">2.6.</span> <span class="nav-text"> 五：集合（set）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E5%AD%97%E5%85%B8"><span class="nav-number">2.7.</span> <span class="nav-text"> 六：字典</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#python%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">3.</span> <span class="nav-text"> python的流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#if%E8%AF%AD%E5%8F%A5"><span class="nav-number">3.1.</span> <span class="nav-text"> if语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for%E8%AF%AD%E5%8F%A5"><span class="nav-number">3.2.</span> <span class="nav-text"> for语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#while%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.3.</span> <span class="nav-text"> while循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#break%E5%92%8Ccontinue%E8%AF%AD%E5%8F%A5"><span class="nav-number">3.4.</span> <span class="nav-text"> break和continue语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pass%E8%AF%AD%E5%8F%A5"><span class="nav-number">3.5.</span> <span class="nav-text"> pass语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6"><span class="nav-number">3.6.</span> <span class="nav-text"> 条件控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#in-%E5%92%8C-not-in"><span class="nav-number">3.6.1.</span> <span class="nav-text"> in 和 not in</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#is-%E5%92%8C-not-is"><span class="nav-number">3.6.2.</span> <span class="nav-text"> is 和 not is</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E4%BB%A5%E5%8F%8A%E5%88%A4%E7%AD%89"><span class="nav-number">3.6.3.</span> <span class="nav-text"> 大于等于以及判等</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">3.6.4.</span> <span class="nav-text"> 逻辑操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">3.6.5.</span> <span class="nav-text"> 序列的比较</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text"> 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="nav-number">4.1.</span> <span class="nav-text"> 函数定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">4.2.</span> <span class="nav-text"> 函数调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">4.3.</span> <span class="nav-text"> 函数的参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">4.4.</span> <span class="nav-text"> 函数的返回值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97"><span class="nav-number">4.5.</span> <span class="nav-text"> 模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">4.5.1.</span> <span class="nav-text"> 模块的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AF%BC%E5%85%A5%E4%B8%8E%E8%B0%83%E7%94%A8"><span class="nav-number">4.5.2.</span> <span class="nav-text"> 模块的导入与调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84"><span class="nav-number">4.5.3.</span> <span class="nav-text"> 模块的搜索路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E6%A8%A1%E5%9D%97"><span class="nav-number">4.5.4.</span> <span class="nav-text"> 标准模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dir%E5%87%BD%E6%95%B0"><span class="nav-number">4.5.5.</span> <span class="nav-text"> dir（）函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E6%A8%A1%E5%9D%97%E9%9B%86"><span class="nav-number">4.5.6.</span> <span class="nav-text"> 包（模块集）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="nav-number">5.</span> <span class="nav-text"> 输入和输出</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA-print"><span class="nav-number">5.1.</span> <span class="nav-text"> 格式化输出-print()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5"><span class="nav-number">5.2.</span> <span class="nav-text"> 格式化输入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5-input"><span class="nav-number">5.2.1.</span> <span class="nav-text"> 字符串输入-input()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97"><span class="nav-number">5.2.2.</span> <span class="nav-text"> 将字符串转换为数字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99"><span class="nav-number">5.3.</span> <span class="nav-text"> 文件读写</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%BC%80%E4%B8%8E%E5%85%B3%E9%97%AD"><span class="nav-number">5.3.1.</span> <span class="nav-text"> 文件的打开与关闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="nav-number">5.3.2.</span> <span class="nav-text"> 读取文件内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="nav-number">5.3.3.</span> <span class="nav-text"> 写入文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">6.</span> <span class="nav-text"> 异常</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AFsyntaxerror"><span class="nav-number">6.1.</span> <span class="nav-text"> 语法错误（SyntaxError）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">6.2.</span> <span class="nav-text"> 异常的处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8A%9B%E5%87%BA"><span class="nav-number">6.3.</span> <span class="nav-text"> 异常的抛出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="nav-number">6.4.</span> <span class="nav-text"> 自定义异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E6%B8%85%E7%90%86%E8%A1%8C%E4%B8%BA"><span class="nav-number">6.5.</span> <span class="nav-text"> 预定义清理行为、</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">7.</span> <span class="nav-text"> 类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">7.1.</span> <span class="nav-text"> 类的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#_init_-%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">7.2.</span> <span class="nav-text"> _init_()-类构造方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">7.3.</span> <span class="nav-text"> 类的实例化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC"><span class="nav-number">7.4.</span> <span class="nav-text"> 类的编码风格</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="nav-number">7.5.</span> <span class="nav-text"> 类的继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5%E7%B1%BB"><span class="nav-number">7.6.</span> <span class="nav-text"> 导入类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-number">7.7.</span> <span class="nav-text"> Python标准库</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#json%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE"><span class="nav-number">8.</span> <span class="nav-text"> JSON存储数据</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#python%E6%B5%8B%E8%AF%95"><span class="nav-number">9.</span> <span class="nav-text"> Python测试</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zestaken</p>
  <div class="site-description" itemprop="description">吾好梦中读书~</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">84</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">60</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/Python/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Python | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Python
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-05 20:45:19" itemprop="dateCreated datePublished" datetime="2020-09-05T20:45:19+08:00">2020-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-09-26 21:42:19" itemprop="dateModified" datetime="2021-09-26T21:42:19+08:00">2021-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>26k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>24 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="python概述"><a class="markdownIt-Anchor" href="#python概述"></a> python概述</h1>
<ol>
<li>Python是一门解释性语言，无需编译和链接。</li>
<li>Python解释器是可以交互的，因此Python甚至可以用作桌面计算器。</li>
<li>Python是可扩展的，可以为Python的解释器添加内置函数和模块。</li>
<li>本文学习的是Python3.</li>
</ol>
<h2 id="解释器"><a class="markdownIt-Anchor" href="#解释器"></a> 解释器</h2>
<ul>
<li>trackback:程序无法成功地运行时，解释器会提供一个traceback。traceback是一条记录，指出了解释器尝试运行代码时， 在什么地方陷入了困境。</li>
</ul>
<h2 id="python编写规范"><a class="markdownIt-Anchor" href="#python编写规范"></a> Python编写规范</h2>
<p><a target="_blank" rel="noopener" href="https://python.freelycode.com/contribution/detail/47">PEP8编写规范</a></p>
<ul>
<li><strong>python之禅</strong>：Python社区的理念都包含在TimPeters撰写的“Python之禅”中。要获悉这些有关编写优秀Python代码的指导原则，只需在解释器中执行命令<code>import this</code>。</li>
<li><strong>Python改进提案（Python Enhancement Proposal，PEP）</strong>。PEP 8是最古老的PEP之一，它向Python程序员提供了代码格式设置指南。PEP 8的篇幅很长，但大都与复杂的编码结构相关。</li>
<li><strong>缩进</strong>：每级缩进都使用四个空格;
<ul>
<li>如果你混合使用了制表符和空格，可将文件中所有的<strong>制表符转换为空格</strong></li>
</ul>
</li>
<li><strong>空格</strong>：
<ul>
<li>在诸如== 、&gt;= 和&lt;= 等<strong>比较运算符</strong>两边各添加一个空格，例如，<code>if age &lt; 4:</code> 要比<code>if age&lt;4:</code>好。</li>
</ul>
</li>
</ul>
<h2 id="python的注释"><a class="markdownIt-Anchor" href="#python的注释"></a> python的注释</h2>
<ul>
<li>Python中使用<code>#</code>做注释符，即使是在解释器的交互编程中也可以使用<code>#</code>注释符。</li>
</ul>
<h1 id="变量和数据类型结构"><a class="markdownIt-Anchor" href="#变量和数据类型结构"></a> 变量和数据类型(结构)</h1>
<h2 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h2>
<ul>
<li>变量名只能包含<strong>字母、数字和下划线</strong>。变量名可以以字母或下划线打头，但不能以数字打头，例如，可将变量命名为message_1，但不能将其命名为1_message。</li>
<li>变量名不能包含空格，但可使用下划线来分隔其中的单词。例如，变量名greeting_message可行，但变量名greeting message会引发错误。</li>
<li>不要将Python关键字和函数名用作变量名，即不要使用Python保留用于特殊用途的单词，如print。</li>
<li>变量名应既简短又具有描述性。例如，name比n好，student_name比s_n好，name_length比length_of_persons_name好。 慎用小写字母l和大写字母O，因为它们可能被人错看成数字1和0。</li>
<li>就目前而言，应使用小写的Python变量名。在变量名中使用大写字母虽然不会导致错误，但避免使用大写字母是个不错的主意。</li>
</ul>
<h2 id="一数字"><a class="markdownIt-Anchor" href="#一数字"></a> 一：数字</h2>
<ul>
<li>常用的数据类型有int、float，但是Python还有其它很多数据类型。例如复数类型（complex）,这种类型中使用j或者J代表复数部分，如<code>5+2j</code>.</li>
<li>基本运算
<ul>
<li>Python支持基本的<code>+</code>,<code>-</code>,<code>*</code>以及<code>/</code>，<code>%</code>（求模/余）的运算，但是和c语言不同的是，<code>/</code>默认的结果是浮点型。使用<code>//</code>可以做返回值为int型的除法运算（类似c语言的普通除法运算）.</li>
<li>Python还支持<strong>幂方运算</strong><code>**</code>,<code>5**2</code>表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>5</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">5^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">5</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>；</li>
<li>python仍旧使用<code>=</code>为变量赋值，同c语言一样，Python中的变量在使用前必须先进行赋值。（但是在交互式编程中，Python内置了一个变量<code>_</code>,存储最近一个表达式的运算结果，这个变量无需赋值，便可直接使用，事实上，<code>_</code>是一个只读变量，对它赋值是没有意义的。）</li>
<li>python的赋值可以进行多重赋值，例如：<code>a, b = 0, 1</code>相当于<code>a = 0, b = 1</code></li>
<li>在字符串中使用<strong>数值类型时</strong>，需要显式地指出你希望Python将这个整数用作字符串。为此，可调用函数<code>str()</code> ， 它让Python将非字符串值表示为字符串,如：<code>print(&quot;age:&quot;+str(19))</code></li>
</ul>
</li>
</ul>
<h2 id="二字符串"><a class="markdownIt-Anchor" href="#二字符串"></a> 二：字符串</h2>
<ul>
<li>字符串可以用单引号<code>''</code>或者双引号<code>&quot;&quot;</code>表示;
<ul>
<li>灵活地使用单引号和双引号来使字符串中可以<strong>嵌套引号和撇号</strong>，如：
<ul>
<li><code>'I told my friend, &quot;Python is my favorite language!&quot;'</code></li>
<li><code>&quot;The language 'Python' is named after Monty Python, not the snake.&quot;</code></li>
<li><code>&quot;One of Python's strengths is its diverse and supportive community.&quot;</code></li>
</ul>
</li>
</ul>
</li>
<li>引号可以用<code>\</code>来转义。</li>
<li>字符串可以用<code>+</code>连接，如<code>'zhang'+'jie'</code>合为<code>'zhangjie'</code>.</li>
<li>字符串可以用<code>*</code>重复输出。<code>'zj'*3</code>即为<code>'zjzjzj'</code>。</li>
<li>字符串可以被索引，进行类似c语言的取出字符串的中字母的操作。如：<code>word = 'python</code>, <code>word[0] == 'p'</code>;
<ul>
<li><strong>索引可以为负数</strong>，这会从右边开始索引。如：<code>word = 'python'</code>,<code>word[-1] = 'n'</code>(负索引是从-1开始，而不是0)。</li>
</ul>
</li>
<li>字符串可以被切片。如<code>word = 'python'</code>,则<code>word[0:2] = 'py'</code>,包含起始的字符，不包含末尾的字符。切片可以省略，省略左边，默认为从0开始，省略右边，则默认到末尾。如<code>word[:3] = 'pyt'</code>,<code>word[1:] = 'ython'</code>。</li>
<li>字符串<strong>是不可变的</strong>，不可以被修改。如果需要修改，只能创建一个新的字符串，并在创建的过程中，将修改加进去。</li>
<li>制表符<code>\t</code>:添加四个空格，如：<code>print(&quot;\tPython&quot;)</code></li>
<li>换行符<code>\n</code>:换到下一行。</li>
</ul>
<h3 id="字符串对象方法"><a class="markdownIt-Anchor" href="#字符串对象方法"></a> 字符串对象方法</h3>
<ul>
<li><code>title()</code>:以首字母大写的方式显示每个单词，即将每个单词的首字母都改为大写。其中以空格区分单词。</li>
<li><code>upper()</code>:将字符串改为全部大写</li>
<li><code>lower()</code>:将字符串改为全部小写,存储数据时，方法lower() 很有用。很多时候，你无法依靠用户来提供正确的大小写，因此需要将字符串先转换为小写，再存储它们。以后需要显示这些信息时，再将其转换为 最合适的大小写方式。</li>
<li>删除空白的方法：
<ul>
<li><code>rstrip()</code>:删除字符串末尾的空白,只是输出的结果中没有了空白，要想将字符串变量中的空白永久删除，需要将结果重新赋值给字符串变量。</li>
<li><code>lstrip()</code>:删除字符串开头的空白。</li>
<li><code>strip()</code>:同时删除字符串两端的空白。</li>
</ul>
</li>
<li></li>
</ul>
<h2 id="三列表"><a class="markdownIt-Anchor" href="#三列表"></a> 三：列表</h2>
<h3 id="列表的基本性质"><a class="markdownIt-Anchor" href="#列表的基本性质"></a> 列表的基本性质</h3>
<ul>
<li>列表由一系列按<strong>特定顺序排列的元素组成</strong>。你可以创建包含字母表中所有字母、数字0~9或所有家庭成员姓名的列表；也可以将任何东西加入列表中，其中的元素之间可以没有任何关系。鉴于列表通常包含多个元素，给列表指定一个表示复数的名称（如letters 、digits 或names ）是个不错的主意。</li>
<li>用方括号<code>[]</code>来表示列表，并用逗号来分隔其中的元素。</li>
<li>列表类似c语言的数组。但是列表中的元素不需要是同一类型。</li>
<li>列表的赋值：如<code>list1 = [1, 2, 3, 4, 5]</code>， <code>list2 = [1, 'a', 2, 'b', 3,[1, 2,&quot;zhangjie&quot;]]</code>,<code>list3 = []</code>。</li>
<li>访问列表元素：类似数组，通过<strong>索引</strong>来访问列表中的元素。如：<code>list1[0]</code>访问的元素是1。
<ul>
<li>最后一个列表元素可以通过索引-1来访问，如：<code>list1[-1]</code>访问的是5。</li>
<li>用负数索引，是从-1开始从右往左依次索引。</li>
</ul>
</li>
<li>同字符串一样，列表也可以被切片和索引。
<ul>
<li>可以<strong>通过切片来复制一个列表</strong>，如：<code>list2 = list1[:]</code>,如果直接赋值，引用还是同一个列表：<code>list2 = list1</code>，两个列表名其实是一个列表的两个不同名字。</li>
</ul>
</li>
<li>同字符串一样，列表也支持使用<code>+</code>进行连接,使用<code>*</code>进行重复。但是连接和重复的对象都必须是列表，返回的结果也是列表。</li>
<li>与字符串不同的是，列表中的元素是<strong>可以修改</strong>的。可以利用赋值操作对列表中某个元素进行修改。</li>
<li>可以使用append（）方法，在列表后面加元素。(括号中放需要加的元素。)</li>
<li>列表中可以嵌套列表。</li>
<li>使用函数<code>len()</code>，可以得到列表或者字符串的长度。如；<code>len(list1)</code>的结果为5.</li>
<li>可以使用函数<code>enumerate(序列)</code>来同时得到元素的值和索引值。</li>
</ul>
<h3 id="列表中常用的方法"><a class="markdownIt-Anchor" href="#列表中常用的方法"></a> 列表中常用的方法</h3>
<ul>
<li><code>list.append（x）</code>在列表的后面加上一个元素x。</li>
<li><code>list.extend(L)</code>将一个给定列表（L）中的元素全部都加到另一个列表里（list）.</li>
<li><code>list.insert(i, x)</code>在列表的指定元素之前插入元素。其中第一个参数是指定列表中元素的索引，第二个参数是要插入的值。如，<code>list.insert(0, 5)</code>是在整个列表前插入一个5.</li>
<li><code>list.remove(x)</code>删除列表中值为x的第一个元素，如果没有这样的元素，则会返回错误。</li>
<li><code>list.pop([i])</code>类似栈里面的弹出，会删除列表里指定元素并返回它的值。如果<strong>没有指定参数</strong>则默认对列表的最后一个元素进行操作。（另外，参数用方括号[]括起来是表示，这个参数是可以有也可以没有的）。结合<code>append</code>方法和<code>pop</code>方法可以将列表当做一个栈使用。</li>
<li><code>list.clear()</code>删除列表中的所有元素，此时打印列表只剩下一对空的方括号。</li>
<li><code>list.index(x)</code>返回列表中第一个值为x的元素的索引，如果不存在这样的元素，则返回一个错误。</li>
<li><code>list.count(x)</code>返回值x在列表中出现的次数。</li>
<li><code>list.sort()</code>会对列表中的元素进行永久性正向排序（即按字母顺序从小到大）;
<ul>
<li>传递参数<code>reverse=True</code>可以对元素进行永久性反向排序（按字母顺序从大到小），如：<code>list.sort(reverse=True)</code></li>
</ul>
</li>
<li><code>sorted(list)</code>对列表中的元素进行临时正向排序，排序规则与sort方法相同，如：<code>print(sorted(list))</code></li>
<li><code>list.reverse()</code>会对列表中的元素进行逆序排列，不是指按与字母顺序相反的顺序排列列表元素，而只是反转列表元素的排列顺序。</li>
<li><code>list.copy()</code>会返回一个列表的拷贝。</li>
</ul>
<h3 id="列表的应用"><a class="markdownIt-Anchor" href="#列表的应用"></a> 列表的应用</h3>
<ul>
<li>当作栈使用。</li>
<li>当作队列使用。需要引入collections.deque方法。</li>
</ul>
<h3 id="列表解析"><a class="markdownIt-Anchor" href="#列表解析"></a> 列表解析</h3>
<ul>
<li>列表可以由公式推出其中的元素。列表推导式由包含一个表达式的方括号组成，<strong>表达式用于存储要存入列表的结果</strong>，表达式后面跟随一个 for 子句，之后可以有零或多个 for 或 if 子句。结果是一个列表，由表达式依据其后面的 for 和 if 子句上下文计算而来的结果构成。</li>
<li>例如： <code>[(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]</code>,它的结果为<code>[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]</code>。</li>
</ul>
<h3 id="del语句"><a class="markdownIt-Anchor" href="#del语句"></a> del语句</h3>
<ul>
<li>del语句可以<strong>根据索引删除列表中的元素。del语句也可以删除列表中的切片</strong>。例如：<code>del list[1]</code>以及<code>del list[2:4]</code>,<code>del list[:]</code>。</li>
<li>del语句还可以删除整个变量，<code>del list</code>.在del删除整个变量后，再次调用该变量会报错，除非再次这个变量赋值。</li>
</ul>
<h3 id="range函数"><a class="markdownIt-Anchor" href="#range函数"></a> range()函数</h3>
<ul>
<li>range()会生成一个指定长度的链表，例如：`range(10),会生成一个<strong>从0到9</strong>的序列，即参数10是指定生成的链表的长度，默认情况下，这个等差链表是从0开始的。</li>
<li>可以指定range生成的链表的起始和结束，例如：<code>range(5, 10)</code>会生成一个从5到9的链表。</li>
<li>可以指定链表的步长（即公差，可以为负数）。例如：<code>range(0, 10, 3)中的第一个参数是起始的数，结束的数为10（永远不会包含指定的结束数），3为步长</code>,结果为0， 3， 6， 9。可以把步长设置为负数，形成从大到小的链表。例如<code>range(-10, -100, -30)</code>,结果-10，-40，-70。</li>
</ul>
<h2 id="四元组"><a class="markdownIt-Anchor" href="#四元组"></a> 四：元组</h2>
<ul>
<li>元组与列表有很多地方类似的，但是元组是用<strong>圆括号来定义</strong>的。</li>
<li>元组和字符串一样是<strong>不可变</strong>的，一般是通过索引来访问其中的元素值。
<ul>
<li>虽然不能修改元组的元素，但可以给存储元组的变量赋值。如：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">dimensions&#x3D;(1,2)
dimensions&#x3D;(3,4)</code></pre>
</li>
<li>元组中的元素可以是<strong>不同类型</strong>的，但是列表中的元素必须是<strong>同一类型</strong>的。</li>
<li>元组的定义可以省掉括号，但最好带上。</li>
<li>元组的常见形式， <code>t = 12345, 'hello'</code>，<code>t = (1, 3 ,&quot;zhangjie&quot;)</code></li>
</ul>
<h2 id="五集合set"><a class="markdownIt-Anchor" href="#五集合set"></a> 五：集合（set）</h2>
<ul>
<li>集合同数学中的定义一样，是一个无序不重复的集。集合中的元素可以是不同的类型的。如果在给集合定义或者复制时，有重复的元素，并不会报错，但是Python会自动删除集合中重复的元素，最终只留下一个元素。</li>
<li>可以使用花括号<code>&#123;&#125;</code>或者<code>set()</code>函数来创建集合。例如：<code>a = &#123;1, 'hello'&#125;</code>或者<code>a = set('abcdefg')</code>。使用set必须有单引号<code>''</code>或者双引号<code>&quot;&quot;</code>，并且set会把被引号包围的任何东西拆分，并按照随机顺序存入集合中。（定义空集合只能使用set(),而不能使用花括号｛｝）</li>
<li>集合也可类似列表使用推导式来定义其内的元素。</li>
<li>集合中可以使用<code>&amp;并，^交，-, |</code>等数学集合运算。</li>
</ul>
<h2 id="六字典"><a class="markdownIt-Anchor" href="#六字典"></a> 六：字典</h2>
<ul>
<li>字典与列表不同，它是根据事先存好的的关键字来索引具体元素的。就像真实的字典一样,在Python中，字典是一系列<strong>键—值对</strong> 。每个键都与一个值相关联,形如<code>key:value</code>，你可以使用键来访问与之相关联的值。与键相关联的值可以是数字、字符串、列表乃至字典。事实上，可将任何Python对象用作字典中的值。</li>
<li>使用<strong>花括号</strong>来创建字典。例如；<code>dict = &#123;'key1':1, 'key2': 2&#125;</code>。一对空的花括号可以创建一个空的字典。</li>
<li>可以直接给字典<strong>增加关键字和对应的值</strong>:<code>dict['key3'] = 3</code>.要<strong>修改字典中的值</strong>，可依次指定字典名、用方括号括起的键以及与该键相关联的新值。</li>
<li>键—值对是两个相关联的值。指定键时，Python将返回与之相关联的值。键和值之间用<strong>冒号</strong>分隔，而键—值对之间用<strong>逗号</strong>分隔。在字典中，你想存储多少个键—值对都可以。</li>
<li>要获取与键相关联的值，可依次指定字典名和放在方括号内的键,如：<code>print(dict['key1'])</code>。</li>
<li>注意，键—值对的<strong>排列顺序与添加顺序不同</strong>。Python不关心键—值对的添加顺序，而只关心键和值之间的关联关系。</li>
<li>对于字典中不再需要的信息，可使用<strong>del 语句将相应的键—值对彻底删除</strong>。使用del 语句时，必须指定字典名和要删除的键。如：<code>del dict['key1']</code>.</li>
<li>使用关键字<code>in</code>可以确认某个关键字是否在字典中。例如；<code>'key1' in dict</code>,如果’key1’存在的话返回True，否则返回False。（类似的还有<code>'key1' not in dict</code>的写法）、</li>
<li>可以使用方法<code>字典名.items()</code><strong>同时读出字典中的关键字和值</strong>（常用在循环中遍历字典）。</li>
<li>使用方法 <code>字典名.keys()</code>可以返回一个字典中的<strong>全部关键字</strong>。</li>
<li>可使用方法<code>values()</code>，它<strong>返回一个值列表，而不包含任何键</strong>。</li>
<li>遍历循环示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"># 遍历键值对
for key, value in dict.items():
    print(&quot;key &#x3D; &quot; + key)
    print(&quot;value &#x3D; &quot; + value)

# 只遍历键
for key in dict.keys():
    print(&quot;key &#x3D; &quot;  + key)</code></pre>
<ul>
<li>可使用函数<code>sorted()</code>来获得按特定顺序排列(特定顺序是指按字母的大小写顺序等默认的顺序)的键列表的副本,如：<code>for name in sorted(dict.keys()):</code></li>
<li>dic()函数可以从值对列表中创建字典。</li>
<li>通过对包含重复元素的列表调用<code>set()</code>方法 ，可让Python找出列表中<strong>独一无二的元素，并使用这些元素来创建一个集合</strong>。如：<code>for value in set(dict.values()):</code></li>
<li>字典推导式也是同样可以使用的。</li>
<li>我们将较大的字典放在多行中:</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">favorite_languages &#x3D; &#123;
    &#39;jen&#39;: &#39;python&#39;,
    &#39;sarah&#39;: &#39;c&#39;,
    &#39;edward&#39;: &#39;ruby&#39;,
    &#39;phil&#39;: &#39;python&#39;,
    &#125;</code></pre>
<ul>
<li>字典和列表等可以相互嵌套，如：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"># 列表中嵌套字典
alien_0 &#x3D; &#123;&#39;color&#39;: &#39;green&#39;, &#39;points&#39;: 5&#125;
alien_1 &#x3D; &#123;&#39;color&#39;: &#39;yellow&#39;, &#39;points&#39;: 10&#125;
alien_2 &#x3D; &#123;&#39;color&#39;: &#39;red&#39;, &#39;points&#39;: 15&#125;
aliens &#x3D; [alien_0, alien_1, alien_2]

# 在字典中嵌套列表
pizza &#x3D; &#123;
&#39;crust&#39;: &#39;thick&#39;,
&#39;toppings&#39;: [&#39;mushrooms&#39;, &#39;extra cheese&#39;],
&#125;

# 在字典中嵌套字典
users &#x3D; &#123;
&#39;aeinstein&#39;: &#123;
&#39;first&#39;: &#39;albert&#39;,
&#39;last&#39;: &#39;einstein&#39;,
&#39;location&#39;: &#39;princeton&#39;,
&#125;,
&#39;mcurie&#39;: &#123;
&#39;first&#39;: &#39;marie&#39;,
&#39;last&#39;: &#39;curie&#39;,
&#39;location&#39;: &#39;paris&#39;,
&#125;,
&#125;</code></pre>
<h1 id="python的流程控制"><a class="markdownIt-Anchor" href="#python的流程控制"></a> python的流程控制</h1>
<h2 id="if语句"><a class="markdownIt-Anchor" href="#if语句"></a> if语句</h2>
<ul>
<li>类似c语言中的if语句，但是python<strong>省去了条件外面的括号</strong>，而是<strong>用冒号<code>:</code>来表示</strong>（就像c语言不能忘记括号一样，python也不能忘记冒号），<strong>并将<code>else if</code>合成了一个<code>elif</code>关键字</strong>（但是还是有单独的<code>else</code>)。如：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; (int)(input()) #input读取键盘的输入，但是默认读入的类型是字符串型，需要强制转换为数字整型

if x &lt; 0:
        x &#x3D; 0
        print(x)
elif x &#x3D;&#x3D; 0:
        x &#x3D; -1
        print(x)
else:
        x &#x3D; 1
       print(x)</code></pre>
<ul>
<li>python条件语句内部的语句不是用花括号<code>&#123;&#125;</code>来括起来，而是直接<strong>用缩进来表示包含关系</strong>。所以这种带有控制语句的代码最好不直接在解释器中写。</li>
<li><strong>条件测试（布尔表达式）</strong>：每条if 语句的核心都是一个值为True 或False 的表达式，这种表达式被称为条件测试。
<ul>
<li>条件表达式(布尔表达式)的结果要么为True ，要么为False 。</li>
</ul>
</li>
<li>if语句判断列表是否为空：<code>if list:</code>,如果列表是空的，相当于条件为false，如果为非空，则相当于条件为true。</li>
</ul>
<h2 id="for语句"><a class="markdownIt-Anchor" href="#for语句"></a> for语句</h2>
<ul>
<li>与c语言的for循环不同的是，python的for循环没有控制条件，它自动停止的。例如</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">words &#x3D; [&#39;zhang&#39;, &#39;jie&#39;]

for word in words:
  print(word)</code></pre>
<ul>
<li>for循环常用来遍历列表或者字符串等序列，循环会在序列尾部自动结束。而在示例程序中的<code>word</code>变量是定义的列表序列中的单个元素。注意<code>for...in...</code>的格式。</li>
<li>for语句的末尾有一个<strong>冒号</strong>。</li>
<li>循环中的语句依靠<strong>缩进</strong>来识别。</li>
</ul>
<h2 id="while循环"><a class="markdownIt-Anchor" href="#while循环"></a> while循环</h2>
<ul>
<li>for 循环用于针对<strong>集合中的每个元素</strong>，而while 循环不断地运行，直到<strong>指定的条件不满足</strong>为止。示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">current_number &#x3D; 1
while current_number &lt;&#x3D; 5:
    print(current_number)
    current_number +&#x3D; 1</code></pre>
<h2 id="break和continue语句"><a class="markdownIt-Anchor" href="#break和continue语句"></a> break和continue语句</h2>
<ul>
<li>break 语句用于控制程序流程，可使用它来控制哪些代码行将执行，哪些代码行不执行，从而让程序按你的要求执行你要执行的代码。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; for n in range(2, 10):
...     for x in range(2, n):#第一次循环，range（2,2)是没有值的,解释器不会输出任何内容
...         if n % x &#x3D;&#x3D; 0:
...             print(n, &#39;equals&#39;, x, &#39;*&#39;, n&#x2F;&#x2F;x)
...             break
...     else:
...         # loop fell through without finding a factor
...         print(n, &#39;is a prime number&#39;)
...
2 is a prime number
3 is a prime number
4 equals 2 * 2
5 is a prime number
6 equals 2 * 3
7 is a prime number
8 equals 2 * 4
9 equals 3 * 3</code></pre>
<ul>
<li>要<strong>返回到循环开头</strong>，并根据条件测试结果决定是否继续执行循环，可使用continue 语句，它不像break 语句那样不再执行余下的代码并退出整个循环。continue语句与c语言中基本一样，它表示跳过continue语句中后面所有的当前循环的语句（到循环尾），从而直接进入下一次迭代。示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; for num in range(2, 10):
...     if num % 2 &#x3D;&#x3D; 0:
...         print(&quot;Found an even number&quot;, num)
...         continue
...     print(&quot;Found a number&quot;, num)
Found an even number 2
Found a number 3
Found an even number 4
Found a number 5
Found an even number 6
Found a number 7
Found an even number 8
Found a number 9</code></pre>
<h2 id="pass语句"><a class="markdownIt-Anchor" href="#pass语句"></a> pass语句</h2>
<ul>
<li>pass语句就像它的名字一样，读到它时，什么也不做，直接过去就行。</li>
</ul>
<h2 id="条件控制"><a class="markdownIt-Anchor" href="#条件控制"></a> 条件控制</h2>
<h3 id="in-和-not-in"><a class="markdownIt-Anchor" href="#in-和-not-in"></a> in 和 not in</h3>
<ul>
<li>in和not in用来判断某个值是否在某个区间内（如列表）。</li>
<li><strong>检查特定值是否在列表中</strong>:要判断特定的值是否已包含在列表中，可使用<strong>关键字in</strong>,如：<code>if user in users:</code>,也可以判断特定值不再列表中，如：<code>if user not in users:</code></li>
</ul>
<h3 id="is-和-not-is"><a class="markdownIt-Anchor" href="#is-和-not-is"></a> is 和 not is</h3>
<ul>
<li>is和not is用来判断两个比较对象是否相同。</li>
</ul>
<h3 id="大于等于以及判等"><a class="markdownIt-Anchor" href="#大于等于以及判等"></a> 大于等于以及判等</h3>
<ul>
<li>python中支持连续比较，即像普通比较一样可以连续的比较多个值的关系。例如：<code>a &lt; b == c</code>可以判断b是否大于a的同时等于c。</li>
</ul>
<h3 id="逻辑操作符"><a class="markdownIt-Anchor" href="#逻辑操作符"></a> 逻辑操作符</h3>
<ul>
<li>python中的逻辑操作符包括<code>and, not, or</code>。</li>
<li><strong>or</strong>的示例：<code>x or y</code>,如果x为真则返回x，否则返回y。</li>
<li><strong>and</strong>的示例：<code>x and y</code>,如果x的值为假，则不再看y的值，返回（false），如果x的值为真，则返回y的值。（and和or都是从左向右解析，and返回值的条件是遇见假的变量或或者到末尾， 而or返回的条件是遇见真或者到末尾。</li>
<li><strong>not</strong>的示例：<code>not x</code>,not只有True和False两种返回值。如果x为真，则not使其取反，结果为False，反之亦然。</li>
</ul>
<h3 id="序列的比较"><a class="markdownIt-Anchor" href="#序列的比较"></a> 序列的比较</h3>
<ul>
<li>条件比较<code>&gt;, &lt; ,==</code>可以用于比较序列（如列表，字符串，字典）。</li>
<li>比较规则：首先比较前两个元素，如果不同，就决定了比较的结果；如果相同，就比较后两个元素，依此类推，直到所有序列都完成比较。如果两个元素本身就是同样类 型的序列，就递归字典序比较。如果两个序列的所有子项都相等，就认为序列相等。如果一个序列是另一个序列的初始子序列，较短的一个序列就小于另一个。字符 串的字典序按照单字符的 ASCII 顺序。</li>
</ul>
<h1 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h1>
<ul>
<li>函数是带名字的代码块，用于完成具体的工作。</li>
<li>重构：将代码划分为一系列完成具体工作的函数。这样的过程被称为<strong>重构</strong>。重构让代码更清晰、更易于理解、更容易扩展。</li>
<li>函数编写规范：
<ul>
<li>应给函数指定描述性名称，且只在其中使用<strong>小写字母和下划线</strong>;</li>
<li>每个函数都应包含简要地阐述其功能的注释，该注释应紧跟在函数定义后面，并采用文档字符串格式；</li>
<li>给形参指定默认值时以及函数调用中的关键字实参，<strong>等号两边不要有空格</strong>；</li>
<li>如果程序或模块包含多个函数，可使用<strong>两个空行将相邻的函数分开</strong>，这样将更容易知道前一个函数在什么地方结束，下一个函数从什么地方开始。</li>
<li>所有的<strong>import 语句都应放在文件开头</strong>，唯一例外的情形是，在文件开头使用了注释来描述整个程序。</li>
<li>如果形参很多，导致函数定义的长度超过了79字符，可在函数定义中输入左括号后按回车键，并在下一行按两次Tab键，从而将形参列表和只缩进一层的函数体区分开来。如：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def function_name(
      parameter_0, parameter_1, parameter_2,
      parameter_3, parameter_4, parameter_5):
  function body...</code></pre>
</li>
</ul>
<h2 id="函数定义"><a class="markdownIt-Anchor" href="#函数定义"></a> 函数定义</h2>
<ul>
<li>使用<code>def</code>定义函数，<code>def</code>后接函数的名字，以及她的形参列表，最后就像大多数功能语句一样，以<code>:</code>开启函数体。</li>
<li>函数体的书写必须必须<strong>全部相对定义缩进</strong>。示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; def fib(n):    # write Fibonacci series up to n
...     &quot;&quot;&quot;Print a Fibonacci series up to n.&quot;&quot;&quot;
...     a, b &#x3D; 0, 1
...     while a &lt; n:
...         print(a, end&#x3D;&#39; &#39;)
...         a, b &#x3D; b, a+b
...     print()
...
&gt;&gt;&gt; # Now call the function we just defined:
... fib(2000)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597</code></pre>
<ul>
<li>函数第一行处的文本是被称为<strong>文档字符串 （docstring）<strong>的注释，描述了函数是做什么的。文档字符串用</strong>三引号</strong>括<br />
起，Python使用它们来生成有关程序中函数的文档。。</li>
</ul>
<h2 id="函数调用"><a class="markdownIt-Anchor" href="#函数调用"></a> 函数调用</h2>
<ul>
<li>直接输入函数的名字并给他传递实参即可，例如<code>fib(10)</code>,即是对前文函数的调用。</li>
<li>函数名可以直接赋值给其它变量。如</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">f &#x3D; fib

f(10)</code></pre>
<p>与直接<code>fib(10)</code>效果一样。</p>
<h2 id="函数的参数"><a class="markdownIt-Anchor" href="#函数的参数"></a> 函数的参数</h2>
<ul>
<li>鉴于函数定义中可能包含<strong>多个形参</strong>，因此函数调用中也可能包含多个实参。向函数传递实参的方式很多，可使用<strong>位置实参</strong> ，这要求实参的顺序与形参的顺序相同；也可使用<strong>关键字实参</strong> ，其中每个实参都由变量名和值组成；还可使用列表和字典。</li>
<li><strong>位置实参</strong>：要求实参的顺序与形参的顺序相同，如：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def describe_pet(animal_type, pet_name):
    &quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot;
    print(&quot;\nI have a &quot; + animal_type + &quot;.&quot;)
    print(&quot;My &quot; + animal_type + &quot;&#39;s name is &quot; + pet_name.title() + &quot;.&quot;)

describe_pet(&#39;hamster&#39;, &#39;harry&#39;)
describe_pet(&#39;dog&#39;, &#39;willie&#39;)</code></pre>
<ul>
<li><strong>关键字实参</strong>：每个实参都由变量名和值组成；还可使用列表和字典，如：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def describe_pet(animal_type, pet_name):
    &quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot;
    print(&quot;\nI have a &quot; + animal_type + &quot;.&quot;)
    print(&quot;My &quot; + animal_type + &quot;&#39;s name is &quot; + pet_name.title() + &quot;.&quot;)

describe_pet(animal_type&#x3D;&#39;hamster&#39;, pet_name&#x3D;&#39;harry&#39;)</code></pre>
<ul>
<li><strong>形参的默认值</strong>：编写函数时，可给每个形参指定默认值 。在调用函数中给形参提供了实参时，Python将使用指定的实参值；否则，将使用形参的默认值。因此，给形参指定默认值后，可在函数调用中省略相应的实参。使用默认值可简化函数调用，还可清楚地指出函数的典型用法。</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def describe_pet(pet_name, animal_type&#x3D;&#39;dog&#39;):
    &quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot;
    print(&quot;\nI have a &quot; + animal_type + &quot;.&quot;)
    print(&quot;My &quot; + animal_type + &quot;&#39;s name is &quot; + pet_name.title() + &quot;.&quot;)</code></pre>
<ul>
<li>如果传递的参数是列表等复杂类型，<strong>函数中对列表等的修改是永久生效的</strong>（类似传递给该函数的是对该列表的引用）
<ul>
<li>若想要仅仅<strong>传一个副本给函数</strong>，可使用切片的方法。如：<code>function_name(list_name[:])</code>。</li>
</ul>
</li>
<li>传递<strong>任意数量的实参</strong>：在形参的前面加上<code>*</code>可以生成一个元组，将所有接收到的元组都封装到这个元组中，使用参数时便在这个元组中去取。示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def make_pizza(*toppings):
    &quot;&quot;&quot;概述要制作的比萨&quot;&quot;&quot;
    print(&quot;\nMaking a pizza with the following toppings:&quot;)
    for topping in toppings:
      print(&quot;- &quot; + topping)

make_pizza(&#39;pepperoni&#39;)
make_pizza(&#39;mushrooms&#39;, &#39;green peppers&#39;, &#39;extra cheese&#39;)</code></pre>
<ul>
<li>结合使用<strong>位置形参和任意数量的实参</strong>：如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。Python<strong>先匹配位置实参和关键字实参</strong>，再将余下的实参都收集到最后一个形参中。</li>
<li><strong>任意数量的关键字实参</strong>：有时候，需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。在这种情况下，可将函数编写成能够接受任意数量的<strong>键—值对</strong>——调用语句提供了多少就接受多少。
<ul>
<li>使用<code>**</code>能够将接收到的关键字实参封装为一个字典。示例：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def build_profile(first, last, **user_info):
    &quot;&quot;&quot;创建一个字典，其中包含我们知道的有关用户的一切&quot;&quot;&quot;
    profile &#x3D; &#123;&#125;
    profile[&#39;first_name&#39;] &#x3D; first
    profile[&#39;last_name&#39;] &#x3D; last
    for key, value in user_info.items():
      profile[key] &#x3D; value
    return profile

user_profile &#x3D; build_profile(&#39;albert&#39;, &#39;einstein&#39;,
                              location&#x3D;&#39;princeton&#39;,
                              field&#x3D;&#39;physics&#39;)
print(user_profile) </code></pre>
<h2 id="函数的返回值"><a class="markdownIt-Anchor" href="#函数的返回值"></a> 函数的返回值</h2>
<ul>
<li>
<p>在函数中，可使用return 语句将值返回到调用函数的代码行。</p>
</li>
<li>
<p>函数可返回任何类型的值，包括列表和字典等较复杂的数据结构。</p>
</li>
<li>
<p><code>-&gt;</code>常常出现在python函数定义的函数名后面，为函数添加<code>元数据</code>,描述函数的返回类型，从而方便开发人员使用。如：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Class ListNode:
    def _init_(self, x):
        self.val &#x3D; x
        self.next &#x3D; None

Class Solution:
    def reverseList(self, head: ListNode) -&gt; ListNode:
# 表示该函数的返回值类型为ListNode</code></pre>
</li>
</ul>
<h2 id="模块"><a class="markdownIt-Anchor" href="#模块"></a> 模块</h2>
<h3 id="模块的概念"><a class="markdownIt-Anchor" href="#模块的概念"></a> 模块的概念</h3>
<ul>
<li>模块是一个在其中<strong>封装了函数的Python程序</strong>。模块可以比作一整盒拼装玩具，而函数就是其中的一块块积木。</li>
<li>模块是包含了函数的定义的Python文件。<a target="_blank" rel="noopener" href="http://xn--ciq4sf6ja323bty0ax7a40rl63althx06d.py">这个文件的名称是模块名.py</a>。</li>
<li>模块中也可以导入其它模块。</li>
</ul>
<h3 id="模块的导入与调用"><a class="markdownIt-Anchor" href="#模块的导入与调用"></a> 模块的导入与调用</h3>
<ul>
<li><code>import 模块名</code>导入模块名。这种方法导入的模块名，使用名模块内的函数时，必须再加上模块名。即类似<code>模块名.函数名</code>的调用方法。示例：<br />
模块(<a target="_blank" rel="noopener" href="http://fibo.py">fibo.py</a>)内容：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def fib(n):    # write Fibonacci series up to n
    a, b &#x3D; 0, 1
    while b &lt; n:
        print(b, end&#x3D;&#39; &#39;)
        a, b &#x3D; b, a+b
    print()

def fib2(n): # return Fibonacci series up to n
    result &#x3D; []
    a, b &#x3D; 0, 1
    while b &lt; n:
        result.append(b)
        a, b &#x3D; b, a+b
    return result</code></pre>
<p>模块调用：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; import fibo
&gt;&gt;&gt; fibo.fib(1000)
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
&gt;&gt;&gt; fibo.fib2(100)
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
&gt;&gt;&gt; fib &#x3D; fibo.fib #还可以将调用的函数赋给本地定义的变量，以方便频繁调用。
&gt;&gt;&gt; fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377</code></pre>
<ul>
<li><code>from 模块名 import 函数名</code>导入函数,这样不会导入模块名，但是导入的函数可以不依赖模块而直接调用。
<ul>
<li>通过用逗号分隔函数名，可根据需要从模块中导入任意数量的函数：<code>from module_name import function_0, function_1, function_2</code></li>
</ul>
</li>
<li>还可以使用<code>from 模块名 import *</code>来导入模块中所有除了以下划线<code>_</code>开头的定义。示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; from fibo import fib, fib2 #导入
&gt;&gt;&gt; fib(500) #直接调用函数
1 1 2 3 5 8 13 21 34 55 89 144 233 377
&gt;&gt;&gt; from fibo import * #导入模块中所有的定义
&gt;&gt;&gt; fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377</code></pre>
<ul>
<li>使用<code>as</code><strong>给导入的函数指定别名</strong>：如果要导入的函数的名称可能与程序中现有的名称冲突，或者函数的名称太长，可指定简短而独一无二的别名 ——函数的另一个名称，类似于外号。如：<code>from module_name import function_name as fn</code>.</li>
<li>使用<code>as</code>给<strong>模块指定别名</strong>：通过给模块指定简短的别名（如给模块pizza 指定别名p ），让你能够更轻松地调用模块中的函数。如：<code>import module_name as mn</code></li>
<li>最佳的做法是，要么只导入你需要使用的函数，要么导入整个模块并使用句点表示法。这能让代码更清晰，更容易阅读和理解。</li>
</ul>
<h3 id="模块的搜索路径"><a class="markdownIt-Anchor" href="#模块的搜索路径"></a> 模块的搜索路径</h3>
<ul>
<li>在导入一个模块时，解释器会从<strong>当前目录</strong>， <strong>环境变量PYTHONPATH</strong>指定的目录列表以及<strong>Python的默认安装路径中</strong>搜索模块。</li>
<li>解释器的实际搜索路径是由变量<code>sys.path</code>指定的。</li>
</ul>
<h3 id="标准模块"><a class="markdownIt-Anchor" href="#标准模块"></a> 标准模块</h3>
<ul>
<li>Python默认内置了很多标准模块，可以直接调用和配置。</li>
</ul>
<h3 id="dir函数"><a class="markdownIt-Anchor" href="#dir函数"></a> dir（）函数</h3>
<ul>
<li>dir（）函数用来按模块名搜索模块的定义。</li>
</ul>
<h3 id="包模块集"><a class="markdownIt-Anchor" href="#包模块集"></a> 包（模块集）</h3>
<ul>
<li>包是模块的上层，调用包中的模块与调用模块中的函数大体是相同的。可以直接<code>import 包名.模块名.函数名</code>,也可以用<code>from 包名 import 模块名/函数、变量名</code>或者<code>from 包名.模块名 import 子模块名/函数、变量名</code>。当然，类似模块的导入，包也同样有<code>from 包名 import *</code>的导入方式。</li>
<li>同样的，包内也可以引用其他包。</li>
<li>包文件的创建；包文件中必须包含<code>_init_.py</code>文件，这个文件可以让Python把该文件识别为包。它可以为空，也可以包含初始化的一些配置。示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">sound&#x2F;                          Top-level package
      __init__.py               Initialize the sound package
      formats&#x2F;                  Subpackage for file format conversions
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects&#x2F;                  Subpackage for sound effects
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters&#x2F;                  Subpackage for filters
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...</code></pre>
<h1 id="输入和输出"><a class="markdownIt-Anchor" href="#输入和输出"></a> 输入和输出</h1>
<h2 id="格式化输出-print"><a class="markdownIt-Anchor" href="#格式化输出-print"></a> 格式化输出-print()</h2>
<ul>
<li>使用<code>print()</code>函数。print()中有类似c语言的用%以及相应参数限制输出格式的方法。
<ul>
<li>Python 3中的print 是一个函数，因此<strong>括号必不可少</strong>。</li>
<li>每一个<code>print()</code>语句结束后，对内容会自动进行换行。</li>
<li>下面示例演示了如何将较长的print 语句分成多行。单词print 比大多数字典名都短，因此让输出的第一部分紧跟在左括号后面是合理的（见❶）。请选择在合适的地方拆分要打印的内容，并在第一行末尾（见❷）加上一个拼接运算符（+ ）。按回车键进入print 语句的后续各行，并使用Tab键将它们对齐并缩进一级。指定要打印的所有内容后，在print 语句的最后一行末尾加上右括号（见❸）。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">❶ print(&quot;Sarah&#39;s favorite language is &quot; +
❷     favorite_languages[&#39;sarah&#39;].title() +
❸     &quot;.&quot;)</code></pre>
<ul>
<li>使用标准string模块，对字符串进行格式操作；例如<code>字符串.format()</code>方法。</li>
<li>使用Template方法；</li>
<li>使用str（）和repr（）函数。str（）将值转化为适合人阅读的形式，repr将值转化为适合解释器读取的形式。示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; s &#x3D; &#39;Hello, world.&#39;
&gt;&gt;&gt; str(s)
&#39;Hello, world.&#39;
&gt;&gt;&gt; repr(s)
&quot;&#39;Hello, world.&#39;&quot;</code></pre>
<h2 id="格式化输入"><a class="markdownIt-Anchor" href="#格式化输入"></a> 格式化输入</h2>
<h3 id="字符串输入-input"><a class="markdownIt-Anchor" href="#字符串输入-input"></a> 字符串输入-input()</h3>
<ul>
<li>函数input() 让程序暂停运行，等待用户输入一些文本。获取用户输入后，Python将其存储在一个变量中，以方便你使用。</li>
<li>函数input() 接受一个参数：即要向用户显示的提示 或说明，让用户知道该如何做。示例：</li>
<li>使用函数input() 时，Python将用户输入解读为<strong>字符串</strong>。</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">name &#x3D; input(&quot;Please enter your name: &quot;)
print(&quot;Hello, &quot; + name + &quot;!&quot;)</code></pre>
<h3 id="将字符串转换为数字"><a class="markdownIt-Anchor" href="#将字符串转换为数字"></a> 将字符串转换为数字</h3>
<ul>
<li>因为input()函数只能读取进来字符串，所以在需要读取数值的时候，需要对字符串类型进行转换。</li>
<li><code>int()</code>函数可以将符合整数的规定的<strong>字符串转换成int型的</strong></li>
<li><code>float(str)</code>函数将符合浮点型的规定的<strong>字符串转换成float型的</strong></li>
<li><code>str(num)</code>将<strong>整数、浮点型转换成字符串型的</strong></li>
</ul>
<h2 id="文件读写"><a class="markdownIt-Anchor" href="#文件读写"></a> 文件读写</h2>
<h3 id="文件的打开与关闭"><a class="markdownIt-Anchor" href="#文件的打开与关闭"></a> 文件的打开与关闭</h3>
<ul>
<li>要以任何方式使用文件——哪怕仅仅是打印其内容，都得先<strong>打开文件</strong>，这样才能访问它。
<ul>
<li>**函数<code>open()</code>**接受一个参数：要打开的文件的名称。Python在当前执行的文件所在的目录中查找指定的文件。</li>
<li>使用函数<code>open()</code>会<strong>返回文件对象</strong>。open常用的模式是<code>open('filename', 'mode')</code>.
<ul>
<li>第一个参数是一个含有要打开的文件的文件名（或文件路径）的字符串。
<ul>
<li><strong>文件路径</strong>：你将类似pi_digits.txt这样的简单文件名传递给函数open() 时，Python将在<strong>当前执行的文件（即.py程序文件）所在的目录</strong>中查找文件,但仅向open()传递位于当前目录下的文件夹下的文件的名称也不可行。要让Python打开不与程序文件位于同一个目录中的文件，需要提供<strong>文件路径</strong> ，它让Python到系统的特定位置去查找。</li>
<li><strong>相对路径</strong>：如：Linux/OS:<code>with open('text_files/filename.txt') as file_object:</code>,在Windows系统中，在文件路径中使用<strong>反斜杠（<code>\</code>）而不是斜杠（<code>/</code>）</strong>：</li>
<li><strong>绝对路径</strong>：绝对路径通常比相对路径更长，因此将其存储在一个变量中，再将该变量传递给open() 会有所帮助。</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"># Linux&#x2F;OS
file_path &#x3D; &#39;&#x2F;home&#x2F;ehmatthes&#x2F;other_files&#x2F;text_files&#x2F;filename.txt&#39; 
with open(file_path) as file_object:

# Windows
file_path &#x3D; &#39;C:\Users\ehmatthes\other_files\text_files\filename.txt&#39; 
with open(file_path) as file_object:</code></pre>
</li>
<li>第二个参数也是一个字符串，含有描述如何使用该文件的几个字符。
<ul>
<li>mode 为 ‘r’ 时表示只是读取文件；‘w’ 表示只是写入文件（已经存在的同名文件将被删掉）；‘a’ 表示打开文件进行追加，写入到文件中的任何数据将自动添加到末尾。 ‘r+’ 表示打开文件进行读取和写入。</li>
<li>mode 参数是可选的，默认为 ‘r’。示例：<code>f = open('workfile', 'w')</code>。</li>
<li>只用写入的模式(w,a)，如果输入的文件不存在，会在当前目录下<strong>创建该文件</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>文件打开之后需要正常的<strong>关闭</strong>：
<ul>
<li>未妥善地关闭文件可能会导致数据丢失或受损；</li>
<li>可以<code>close()</code>语句来关闭文件。</li>
<li>也可以是用关键字<code>with</code>来关闭文件：关键字with 在不再需要访问文件后将其关闭。如：<code>with open('pi_digits.txt') as file_object:</code></li>
</ul>
</li>
</ul>
<h3 id="读取文件内容"><a class="markdownIt-Anchor" href="#读取文件内容"></a> 读取文件内容</h3>
<ul>
<li><code>文件对象.read(size)</code>方法：该方法读取若干数量的数据并以字符串形式返回其内容，size 是可选的数值，指定字符串长度。如果没有指定 size 或者指定为负数，就会<strong>读取并返回整个文件</strong>。如果到了文件末尾，f.read() 会返回一个空字符串（’’）</li>
<li><strong>逐行读取文件</strong>：要以每次一行的方式检查文件，可对文件对象使用<strong>for 循环</strong>(注意：每行的末尾都有一个看不见的换行符,可以使用<code>rstrip()</code>方法去掉)：<pre class="line-numbers language-python" data-language="python"><code class="language-python">filename &#x3D; &#39;pi_digits.txt&#39; 
with open(filename) as file_object:  
  # 每一次在循环中只读取文件中的一行
  for line in file_object: 
    print(line.rstrip())</code></pre>
</li>
<li><code>文件对象.readline()</code>从文件中读取单独一行，字符串结尾会自动加上一个换行符（ \n ）。如果 f.readline() 返回一个空字符串，那就表示到达了文件末尾。</li>
</ul>
<h3 id="写入文件"><a class="markdownIt-Anchor" href="#写入文件"></a> 写入文件</h3>
<ul>
<li>要将文本写入文件，你在调用open() 时需要提供<strong>另一个实参</strong>（因为默认是r模式），告诉Python你要写入打开的文件。</li>
<li>使用文件对象的方法<code>write()</code><strong>将一个字符串写入文件</strong>;
<ul>
<li>函数write() <strong>不会在你写入的文本末尾添加换行符</strong>，因此如果你写入多行时没有指定换行符，文件看起来可能不是你希望的那样：</li>
<li>要让每个字符串都单独占一行，需要在write() 语句中<strong>包含换行符</strong>,如：<code>file_object.write(&quot;I love programming.\n&quot;)</code></li>
<li>像显示到终端的输出一样，还可以<strong>使用空格、制表符和空行来设置这些输出的格式</strong>。</li>
</ul>
</li>
<li>Python<strong>只能将字符串写入文本文件</strong>。要将数值数据存储到文本文件中，必须先使用函数<code>str()</code> 将其转换为字符串格式。</li>
</ul>
<h1 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h1>
<ul>
<li>Python使用<strong>被称为异常的特殊对象来管理程序执行期间发生的错误</strong>。
<ul>
<li>语法正确的情况下发生的错误为异常错误。</li>
<li>错误信息的最后一行指出发生了什么异常类型。异常也有不同的类型，异常类型做为错误信息的一部分显示出来：如零除错误（ ZeroDivisionError ） ，命名错误（ NameError） 和 类型错误（ TypeError ）等。</li>
</ul>
</li>
<li>每当发生让Python不知所措的错误时，它都会创建一个异常对象。如果你编写了处理该异常的代码，程序将继 续运行；如果你未对异常进行处理，程序将停止，并显示一个traceback(在异常没有被处理的情况下才会有traceback)，其中包含有关异常的报告。</li>
<li>异常是使用<strong>try-except 代码块处理</strong>的。try-except 代码块让Python执行指定的操作，同时告诉Python发生异常时怎么办。使用了try-except 代码块时，<strong>即便出现异常， 程序也将继续运行：显示你编写的友好的错误消息，而不是令用户迷惑的traceback并让程序终止</strong>。</li>
</ul>
<h2 id="语法错误syntaxerror"><a class="markdownIt-Anchor" href="#语法错误syntaxerror"></a> 语法错误（SyntaxError）</h2>
<ul>
<li>语法分析器指出错误行，并且在检测到错误的位置前面显示一个小“箭头”。 错误是由箭头 前面 的标记引起的（或者至少是这么检测的）。</li>
<li>错误会输出文件名和行号，所以如果是从脚本输入的你就知道去哪里检查错误了。</li>
</ul>
<h2 id="异常的处理"><a class="markdownIt-Anchor" href="#异常的处理"></a> 异常的处理</h2>
<ul>
<li>使用<code>try...except</code>语句来处理异常。
<ul>
<li>如果try 代码块中的代码运行起来没有问题，Python将跳过except 代码块；如果try 代码块中的代码导致了 错误，Python将查找这样的except 代码块，并运行其中的代码，即其中指定的错误与引发的错误相同。 可以在except代码块中放入<strong>pass语句，告诉程序捕获到异常后什么都不需要做</strong>。</li>
<li>在出现异常的情况下，如果<strong>try-except 代码块后面还有其他代码，程序将接着运行</strong>，因为已经告诉了Python如何处理这种错误。</li>
<li>如：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">try:
  print(5&#x2F;0) 
except ZeroDivisionError: 
  print(&quot;You can&#39;t divide by zero!&quot;)</code></pre>
<ul>
<li><code>try...except...else</code>代码块：依赖于try 代码块成功执行的代码都应放到else 代码块中：
<ul>
<li>try-except-else 代码块的工作原理大致如下：Python尝试执行try 代码块中的代码；只有可能引发异常的代码才需要放在try 语句中。有时候，<strong>有一些仅在try 代码块成功 执行时才需要运行的代码；这些代码应放在else 代码块中</strong>。except 代码块告诉Python，如果它尝试运行try 代码块中的代码时引发了指定的异常，该怎么办。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">try:
  answer &#x3D; int(first_number) &#x2F; int(second_number) 
except ZeroDivisionError: 
  print(&quot;You can&#39;t divide by 0!&quot;) 
else:
  print(answer)</code></pre>
</li>
<li>（<code>try...finall</code>）可以用来定义清理行为。</li>
</ul>
<h2 id="异常的抛出"><a class="markdownIt-Anchor" href="#异常的抛出"></a> 异常的抛出</h2>
<ul>
<li>使用<code>raise</code>语句可以抛出异常。</li>
</ul>
<h2 id="自定义异常"><a class="markdownIt-Anchor" href="#自定义异常"></a> 自定义异常</h2>
<ul>
<li>用户可以自定义异常类型来创建自己的异常名。</li>
</ul>
<h2 id="预定义清理行为"><a class="markdownIt-Anchor" href="#预定义清理行为"></a> 预定义清理行为、</h2>
<ul>
<li><code>with</code>语句打开文件，使用完毕之后会自动关闭文件。这可以称作一种预定义的清理行为。示例；</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">with open(&quot;myfile.txt&quot;) as f:
    for line in f:
        print(line)</code></pre>
<h1 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h1>
<h2 id="类的定义"><a class="markdownIt-Anchor" href="#类的定义"></a> 类的定义</h2>
<ul>
<li>类与函数一样，在使用前需要先定义。类的定义示例如下：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">class ClassName():
    &lt;statement-1&gt;
    .
    .
    .
    &lt;statement-N&gt;</code></pre>
<ul>
<li><strong>方法</strong>：类中的函数叫做方法。</li>
<li><strong>属性</strong>：可通过实例访问的变量称为属性 。</li>
<li>可将类视为有关如何创建实例的说明。</li>
</ul>
<h2 id="_init_-类构造方法"><a class="markdownIt-Anchor" href="#_init_-类构造方法"></a> <code>_init_()</code>-类构造方法</h2>
<ul>
<li><code>__init__()</code>是一个特殊的方法，每当你根据类创建新实例时，<strong>Python都会自动运行它</strong>。在这个方法的名称中，<strong>开头和末尾各有两个下划线</strong>，这是一种约定，旨在避免Python默认方法与普通方法发生名称冲突。</li>
<li>在<code>_init_()</code>这个方法的定义中，<strong>形参self 必不可少，还必须位于其他形参的前面</strong>。
<ul>
<li>Python调用这个<code>__init__()</code>方法来创建实例时，将<strong>自动传入实参self</strong> 。每个**与类相关联的方法调用都自动传递实参self ，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。**每当我们根据类创建实例时，都只需给除开self的形参提供值。</li>
<li>以self 为前缀的变量都可供类中的所有方法使用，我们还可以通过类的任何实例来访问这些变量。如：<code>self.name = name</code> 获取存储在形参name 中的值，并将其存储到变量name 中，然后<strong>该变量被关联到当前创建的实例</strong>。</li>
</ul>
</li>
<li>类的属性不用单独定义，**在<code>_init()</code>中通过self定义并初始化。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">class Dog():
    &quot;&quot;&quot;一次模拟小狗的简单尝试&quot;&quot;&quot;

    def __init__(self, name, age):
      &quot;&quot;&quot;初始化属性name和age&quot;&quot;&quot;
      self.name &#x3D; name
      self.age &#x3D; age

    def sit(self):
      &quot;&quot;&quot;模拟小狗被命令时蹲下&quot;&quot;&quot;
     print(self.name.title() + &quot; is now sitting.&quot;)

    def roll_over(self):
      &quot;&quot;&quot;模拟小狗被命令时打滚&quot;&quot;&quot;
      print(self.name.title() + &quot; rolled over!&quot;)</code></pre>
<h2 id="类的实例化"><a class="markdownIt-Anchor" href="#类的实例化"></a> 类的实例化</h2>
<ul>
<li>类的实例化就就是<strong>将类看做一个函数进行调用</strong>。例如：<code>x = Myclass()</code>。</li>
<li>我们通常可以认为首字母大写的名称（如Dog）指的是类，而小写的名称（如my_dog ）指的是根据类创建的实例。</li>
<li>属性与方法的调用：使用句点表示法获取实例的属性和调用其方法。如：<code>my_dog.name</code>,<code>my_dog.roll_over()</code>
<ul>
<li><code>__doc__</code> 也是一个有效的属性，返回类的文档字符串</li>
</ul>
</li>
</ul>
<h2 id="类的编码风格"><a class="markdownIt-Anchor" href="#类的编码风格"></a> 类的编码风格</h2>
<ul>
<li>类名应采用<strong>驼峰命名法</strong>，即将<strong>类名中的每个单词的首字母都大写</strong>，而不使用下划线。实例名和模块名都采用<strong>小写格式，并在单词之间加上下划线</strong>。</li>
<li>对于每个类，都应紧跟在类定义后面包含一个<strong>文档字符串</strong>。这种文档字符串简要地描述类的功能，并遵循编写函数的文档字符串时采用的格式约定。每个模块也都应包含一个文 档字符串，对其中的类可用于做什么进行描述。</li>
<li>可使用空行来组织代码，但不要滥用。在类中，可使用<strong>一个空行来分隔方法</strong>；而在模块中，可使用<strong>两个空行来分隔类</strong></li>
<li>需要同时导入标准库中的模块和你编写的模块时，<strong>先编写导入标准库模块的import 语句，再添加一个空行</strong>，然后编写导入你自己编写的模块的import 语句。</li>
</ul>
<h2 id="类的继承"><a class="markdownIt-Anchor" href="#类的继承"></a> 类的继承</h2>
<ul>
<li>编写类时，并非总是要从空白开始。如果你要编写的类是另一个现成类的特殊版本，可使用继承 。一个类继承另一个类时，它将自动获得另一个类的所有属性和方法；原有的类称为父类 ，而新类称为子类 。<strong>子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法</strong>。</li>
<li>创建子类时，<strong>父类必须包含在当前文件中，且位于子类前面</strong>。</li>
<li>定义子类时，必须<strong>在括号内指定父类的名称</strong>。</li>
<li>子类的方法<code>__init__()</code>
<ul>
<li>创建子类的实例时，Python首先需要完成的任务是给父类的所有属性赋值。为此，<strong>子类的方法__init__() 需要父类施以援手</strong>。</li>
<li><code>super()</code> 是一个特殊函数，帮助Python将父类和子类关联起来。使用这个函数让Python调用父类的方法<code>__init__()</code> ，让该子类包含父类的所有属性。</li>
</ul>
</li>
<li>让一个类继承另一个类后，可<strong>添加区分子类和父类所需的新属性和方法</strong>,属性在调用<code>super()</code>函数后之后添加，方法可以在类中任意定义。</li>
<li><strong>重写父类的方法</strong>：
<ul>
<li>对于<strong>父类的方法</strong>，只要它不符合子类模拟的实物的行为，都可对其进行重写。</li>
<li>重写父类的方法只需要在<strong>子类中定义一个同名的方法</strong>，就会自动覆盖掉父类的该方法。</li>
</ul>
</li>
<li><strong>将实例用作属性</strong>：类中属性可以是<strong>引用类型</strong>。如：<code>self.battery = Battery()</code>,其中<code>Battery()</code>是Battery类的构造方法。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"># 父类
class Car():
   &quot;&quot;&quot;一次模拟汽车的简单尝试&quot;&quot;&quot; 
   def __init__(self, make, model, year): 
     self.make &#x3D; make 
     self.model &#x3D; model 
     self.year &#x3D; year 
     self.odometer_reading &#x3D; 0 

   def get_descriptive_name(self): 
     long_name &#x3D; str(self.year) + &#39; &#39; + self.make + &#39; &#39; + self.model
     return long_name.title() 

   def read_odometer(self): 
     print(&quot;This car has &quot; + str(self.odometer_reading) + &quot; miles on it.&quot;) 

   def update_odometer(self, mileage): 
     if mileage &gt;&#x3D; self.odometer_reading: 
       self.odometer_reading &#x3D; mileage else:print(&quot;You can&#39;t roll back an odometer!&quot;) 
       
   def increment_odometer(self, miles): 
     self.odometer_reading +&#x3D; miles  
    
   def gas_gank():
     print(&quot;油箱信息&quot;)
# 子类     
class ElectricCar(Car): 
  &quot;&quot;&quot;电动汽车的独特之处&quot;&quot;&quot; 
   def __init__(self, make, model, year): 
     &quot;&quot;&quot;初始化父类的属性&quot;&quot;&quot; 
      super().__init__(make, model, year) 
      self.battery_size &#x3D; 70 
      
   def describe_battery(self): 
     &quot;&quot;&quot;打印一条描述电瓶容量的消息&quot;&quot;&quot; 
     print(&quot;This car has a &quot; + str(self.battery_size) + &quot;-kWh battery.&quot;)
   
   # 重写父类方法
   def gas_gank():
    print(&quot;电动车没有油箱&quot;)</code></pre>
<h2 id="导入类"><a class="markdownIt-Anchor" href="#导入类"></a> 导入类</h2>
<ul>
<li>类和函数一样都可以<strong>封装在模块中</strong>，进行导入。</li>
<li>在模块文件的首部写<strong>个模块级文档字符串，对该模块的内容做简要的描述</strong>。</li>
<li>从模块中导入类的语法和导入函数一致。</li>
<li>一个模块中可以存储一个或者多个类。</li>
<li>模块示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;一组可用于表示电动汽车的类&quot;&quot;&quot;  
from car import Car

class Battery(): 
    ...... 

class ElectricCar(Car): 
    .......</code></pre>
<h2 id="python标准库"><a class="markdownIt-Anchor" href="#python标准库"></a> Python标准库</h2>
<ul>
<li>Python标准库是一组模块，安装的Python都包含它。</li>
<li>可使用标准库中的任何函数和类，为此，只需在程序开头包含一条简单的import 语句。</li>
<li>注：你还可以从其他地方下载外部模块。</li>
</ul>
<h1 id="json存储数据"><a class="markdownIt-Anchor" href="#json存储数据"></a> JSON存储数据</h1>
<ul>
<li>**JSON（JavaScript Object Notation）**格式最初是为JavaScript开发的，但随后成了一种常见格式，被包括Python在内的众多语言采用。</li>
<li>模块json 让你能够将简单的Python<strong>数据结构转储到文件</strong>中，并在程序再次运行时加载该文件中的数据。</li>
<li>可以使用json在Python程序之间分享数据。</li>
<li>JSON数据格式并非Python专用的，这让你能够将以<strong>JSON格式存储的数据与使用其他编程语言</strong>的人分享。</li>
<li>JSON在Python中是一个<strong>模块</strong>，使用JSON格式时需要先导入json模块。</li>
<li><code>json.dump()</code>:这个函数能够将数据结构转存到文件中。</li>
<li><code>json.load()</code>:将以json方式存储到文件的数据结构读取到内存中去。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import json 
# 如果以前存储了用户名，就加载它 
# 否则，就提示用户输入用户名并存储它 
filename &#x3D; &#39;username.json&#39; 
try:  
  with open(filename) as f_obj:  
    username &#x3D; json.load(f_obj) 
  except FileNotFoundError: 
     username &#x3D; input(&quot;What is your name? &quot;)  
     with open(filename, &#39;w&#39;) as f_obj: 
       json.dump(username, f_obj) 
       print(&quot;We&#39;ll remember you when you come back, &quot; + username + &quot;!&quot;) 
  else:
    print(&quot;Welcome back, &quot; + username + &quot;!&quot;)</code></pre>
<h1 id="python测试"><a class="markdownIt-Anchor" href="#python测试"></a> Python测试</h1>
<ul>
<li>Python标准库中的<strong>模块unittest</strong>提供了代码测试工具。</li>
<li><strong>单元测试</strong>用于核实函数的某个方面没有问题。</li>
<li><strong>测试用例</strong>是一组单元测试，这些单元测试一起核实函数在各种情形下的行为都符合要求。</li>
<li><strong>全覆盖测试用例</strong>包含一整套单元测试，涵盖了各种可能的函数使用方式。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import unittest 
from name_function import get_formatted_name 

class NamesTestCase(unittest.TestCase): 
  &quot;&quot;&quot;测试name_function.py &quot;&quot;&quot; 
  def test_first_last_name(self): 
    &quot;&quot;&quot;能够正确地处理像Janis Joplin这样的姓名吗？&quot;&quot;&quot; 
    formatted_name &#x3D; get_formatted_name(&#39;janis&#39;, &#39;joplin&#39;) 
    self.assertEqual(formatted_name, &#39;Janis Joplin&#39;) 

  def test_first_last_middle_name(self): 
    &quot;&quot;&quot;能够正确地处理像Wolfgang Amadeus Mozart这样的姓名吗？&quot;&quot;&quot; 
     formatted_name &#x3D; get_formatted_name( &#39;wolfgang&#39;, &#39;mozart&#39;, &#39;amadeus&#39;) 
     self.assertEqual(formatted_name, &#39;Wolfgang Amadeus Mozart&#39;) 
     
unittest.main()</code></pre>
<ul>
<li>
<p>可先导入<strong>模块unittest</strong>以及要<strong>测试的函数</strong>;</p>
</li>
<li>
<p>再创建一个<strong>继承unittest.TestCase 的类</strong>，在这个类中编写一系列<strong>方法</strong>对函数行为的不同方面进行测试。</p>
<ul>
<li>你可随便给这个类命名，但最好让它看起来与要测试的函数相关，并包含字样Test。</li>
</ul>
</li>
<li>
<p>在类中用于测试函数不同方面的方法名称<strong>必须以test打头，我们运行该测试程序的时候，所有以test打头的方法都将自动运行</strong>。</p>
</li>
<li>
<p>最后需要<strong>调用<code>unittest.main()</code>方法，用于运行测试程序</strong>。</p>
</li>
<li>
<p><strong>断言</strong>：断言方法用来核实得到的<strong>结果是否与期望的结果一致</strong>。</p>
<ul>
<li>在python中断言的一种实现方式是使用通过<code>unint.TestCase</code>类中的<code>assertEqual()</code>方法,如：<code>self.assertEqual(formatted_name, 'Wolfgang Amadeus Mozart')</code>,前面的参数是测试的结果，后面的参数是预期的结果。</li>
<li><code>assertEqual(a, b)</code>: 核实a == b</li>
<li><code>assertNotEqual(a, b)</code>: 核实a != b</li>
<li><code>assertTrue(x)</code>: 核实x 为True</li>
<li><code>assertFalse(x)</code>: 核实x 为False</li>
<li><code>assertIn(item , list )</code> 核实 item 在 list 中</li>
<li><code>assertNotIn(item , list )</code>: 核实 item 不在 list 中</li>
</ul>
</li>
<li>
<p>和函数的测试相似的，也可以对类进行测试：</p>
<ul>
<li>类的测试就是将原来测试函数中调用函数的地方，修改为调用类中的方法。</li>
<li><strong>使用<code>setUp()</code>方法</strong>将测试类初始化：
<ul>
<li><code>unittest.TestCase</code>类包含方法<code>setUp()</code> ，让我们<strong>只需创建这些对象一次，并在每个测试方法中使用它们</strong>。如果你在TestCase 类中包含了方法<code>setUp()</code> ，<strong>Python将先运行它，再运行各个以test_打头的方法</strong>。这样，在你编写的每个测试方法中都可使用在方法<code>setUp()</code> 中创建的对象了。</li>
</ul>
</li>
<li>类测试示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import unittest 
from survey import AnonymousSurvey 

class TestAnonymousSurvey(unittest.TestCase): 
  &quot;&quot;&quot;针对AnonymousSurvey类的测试&quot;&quot;&quot; 
  def setUp(self): 
    &quot;&quot;&quot; 创建一个调查对象和一组答案，供使用的测试方法使用 &quot;&quot;&quot; 
    question &#x3D; &quot;What language did you first learn to speak?&quot; 
    self.my_survey &#x3D; AnonymousSurvey(question) 
    self.responses &#x3D; [&#39;English&#39;, &#39;Spanish&#39;, &#39;Mandarin&#39;] 
    
  def test_store_single_response(self): 
    &quot;&quot;&quot;测试单个答案会被妥善地存储&quot;&quot;&quot; 
    self.my_survey.store_response(self.responses[0]) 
    self.assertIn(self.responses[0], self.my_survey.responses) 
    
  def test_store_three_responses(self): 
    &quot;&quot;&quot;测试三个答案会被妥善地存储&quot;&quot;&quot; 
    for response in self.responses: 
      self.my_survey.store_response(response) 
    for response in self.responses: 
      self.assertIn(response, self.my_survey.responses) 

unittest.main()</code></pre>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">











</code></pre>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Python/" rel="tag"># Python</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/GDB/index.html" rel="prev" title="GDB">
                  <i class="fa fa-angle-left"></i> GDB
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Java/java/index.html" rel="next" title="java">
                  java <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Zestaken</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">678k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:17</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js" integrity="sha256-4mJNT2bMXxcc1GCJaxBmMPdmah5ji0Ldnd79DKd1hoM=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha256-AjM0J5XIbiB590BrznLEgZGLnOQWrt62s3BEq65Q/I0=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha256-9cmf7tcLdXpKsPi/2AWE93PbZpTp4M4tqzFk+lWomjU=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
