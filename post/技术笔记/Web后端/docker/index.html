<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.zestaken.top","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":true,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Docker概述 参考教程  Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。 Docker的应用场景：  Web 应用的自动化打包和发布。 自动化测试和持续集成、发布。 在服务型环境中部署和调整数据库或其他的后台应用。 从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。     Dock">
<meta property="og:type" content="article">
<meta property="og:title" content="docker">
<meta property="og:url" content="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/docker/index.html">
<meta property="og:site_name" content="ZestJourney">
<meta property="og:description" content="Docker概述 参考教程  Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。 Docker的应用场景：  Web 应用的自动化打包和发布。 自动化测试和持续集成、发布。 在服务型环境中部署和调整数据库或其他的后台应用。 从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。     Dock">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201125085937.jpg">
<meta property="article:published_time" content="2020-11-23T08:34:04.000Z">
<meta property="article:modified_time" content="2022-09-17T11:27:52.250Z">
<meta property="article:author" content="Zestaken">
<meta property="article:tag" content="后端">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201125085937.jpg">


<link rel="canonical" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/docker/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/docker/index.html","path":"/post/技术笔记/Web后端/docker/index.html","title":"docker"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>docker | ZestJourney</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">ZestJourney</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">乐游记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#docker%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text"> Docker概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#docker%E6%9E%B6%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text"> Docker架构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker%E5%AE%89%E8%A3%85"><span class="nav-number">2.</span> <span class="nav-text"> Docker安装</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="nav-number">3.</span> <span class="nav-text"> Docker的基础使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8Chelloworld"><span class="nav-number">3.1.</span> <span class="nav-text"> 运行helloworld</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="nav-number">3.2.</span> <span class="nav-text"> 运行交互式容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8%E5%90%8E%E5%8F%B0%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.3.</span> <span class="nav-text"> 启动容器（后台模式）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8"><span class="nav-number">4.</span> <span class="nav-text"> Docker容器使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#docker%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">4.1.</span> <span class="nav-text"> Docker客户端</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">4.2.</span> <span class="nav-text"> 容器的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E9%95%9C%E5%83%8F"><span class="nav-number">4.2.1.</span> <span class="nav-text"> 获取镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="nav-number">4.2.2.</span> <span class="nav-text"> 启动容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E5%B7%B2%E5%81%9C%E6%AD%A2%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-number">4.2.3.</span> <span class="nav-text"> 启动已停止的容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C"><span class="nav-number">4.2.4.</span> <span class="nav-text"> 后台运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="nav-number">4.2.5.</span> <span class="nav-text"> 停止容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8"><span class="nav-number">4.2.6.</span> <span class="nav-text"> 进入容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BC%E5%87%BA%E5%92%8C%E5%AF%BC%E5%85%A5%E5%AE%B9%E5%99%A8"><span class="nav-number">4.2.7.</span> <span class="nav-text"> 导出和导入容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%AE%B9%E5%99%A8"><span class="nav-number">4.2.8.</span> <span class="nav-text"> 删除容器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#web%E5%BA%94%E7%94%A8%E4%BD%BF%E7%94%A8"><span class="nav-number">4.3.</span> <span class="nav-text"> web应用使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AAweb%E5%BA%94%E7%94%A8"><span class="nav-number">4.3.1.</span> <span class="nav-text"> 运行一个web应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8Bweb%E5%BA%94%E7%94%A8%E5%AE%B9%E5%99%A8"><span class="nav-number">4.3.2.</span> <span class="nav-text"> 查看web应用容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8Bweb%E5%BA%94%E7%94%A8%E7%9A%84%E6%97%A5%E5%BF%97%E4%BF%A1%E6%81%AF"><span class="nav-number">4.3.3.</span> <span class="nav-text"> 查看web应用的日志信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8Bweb%E5%BA%94%E7%94%A8%E5%AE%B9%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="nav-number">4.3.4.</span> <span class="nav-text"> 查看web应用容器的进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">4.3.5.</span> <span class="nav-text"> 检查web应用程序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8"><span class="nav-number">5.</span> <span class="nav-text"> Docker镜像使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E5%87%BA%E9%95%9C%E5%83%8F%E5%88%97%E8%A1%A8"><span class="nav-number">5.1.</span> <span class="nav-text"> 列出镜像列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%96%B0%E9%95%9C%E5%83%8F"><span class="nav-number">5.2.</span> <span class="nav-text"> 获取新镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E9%95%9C%E5%83%8F"><span class="nav-number">5.3.</span> <span class="nav-text"> 查找镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F"><span class="nav-number">5.4.</span> <span class="nav-text"> 删除镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="nav-number">5.5.</span> <span class="nav-text"> 创建镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E9%95%9C%E5%83%8F"><span class="nav-number">5.5.1.</span> <span class="nav-text"> 更新镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="nav-number">5.5.2.</span> <span class="nav-text"> 构建镜像</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E9%95%9C%E5%83%8F%E6%A0%87%E7%AD%BE"><span class="nav-number">5.6.</span> <span class="nav-text"> 设置镜像标签</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker%E5%AE%B9%E5%99%A8%E8%BF%9E%E6%8E%A5"><span class="nav-number">6.</span> <span class="nav-text"> Docker容器连接</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84"><span class="nav-number">6.1.</span> <span class="nav-text"> 网络端口映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#docker%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94"><span class="nav-number">6.2.</span> <span class="nav-text"> Docker容器互联</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E5%91%BD%E5%90%8D"><span class="nav-number">6.2.1.</span> <span class="nav-text"> 容器命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA%E7%BD%91%E7%BB%9C"><span class="nav-number">6.2.2.</span> <span class="nav-text"> 新建网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%AE%B9%E5%99%A8"><span class="nav-number">6.2.3.</span> <span class="nav-text"> 连接容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AEdns"><span class="nav-number">6.2.4.</span> <span class="nav-text"> 配置DNS</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86"><span class="nav-number">7.</span> <span class="nav-text"> Docker仓库管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#dockerhub"><span class="nav-number">7.1.</span> <span class="nav-text"> DockerHub</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C"><span class="nav-number">7.1.1.</span> <span class="nav-text"> 注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%99%BB%E5%BD%95%E5%92%8C%E9%80%80%E5%87%BA"><span class="nav-number">7.1.2.</span> <span class="nav-text"> 登录和退出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F"><span class="nav-number">7.1.3.</span> <span class="nav-text"> 查找和拉取镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A8%E9%80%81%E9%95%9C%E5%83%8F"><span class="nav-number">7.1.4.</span> <span class="nav-text"> 推送镜像</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#dockerfile"><span class="nav-number">8.</span> <span class="nav-text"> Dockerfile</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#dockermachine"><span class="nav-number">9.</span> <span class="nav-text"> Dockermachine</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker%E5%AE%89%E8%A3%85%E7%9A%84ubuntu%E9%97%AE%E9%A2%98"><span class="nav-number">10.</span> <span class="nav-text"> docker安装的Ubuntu问题</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zestaken</p>
  <div class="site-description" itemprop="description">吾好梦中读书~</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">84</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">60</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/docker/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="docker | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          docker
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-23 16:34:04" itemprop="dateCreated datePublished" datetime="2020-11-23T16:34:04+08:00">2020-11-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:27:52" itemprop="dateModified" datetime="2022-09-17T19:27:52+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="docker概述"><a class="markdownIt-Anchor" href="#docker概述"></a> Docker概述</h1>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-tutorial.html">参考教程</a></p>
<ul>
<li>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。</li>
<li>Docker的应用场景：
<ul>
<li>Web 应用的自动化打包和发布。</li>
<li>自动化测试和持续集成、发布。</li>
<li>在服务型环境中部署和调整数据库或其他的后台应用。</li>
<li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li>
</ul>
</li>
</ul>
<h2 id="docker架构"><a class="markdownIt-Anchor" href="#docker架构"></a> Docker架构</h2>
<ul>
<li>Docker 包括三个基本概念:
<ul>
<li>镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li>
<li>容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li>
<li>仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。</li>
</ul>
</li>
<li>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。</li>
<li>Docker 容器通过 Docker 镜像来创建。容器与镜像的关系类似于面向对象编程中的对象与类。</li>
</ul>
<h1 id="docker安装"><a class="markdownIt-Anchor" href="#docker安装"></a> Docker安装</h1>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/ubuntu-docker-install.html">参考资料</a></p>
<h1 id="docker的基础使用"><a class="markdownIt-Anchor" href="#docker的基础使用"></a> Docker的基础使用</h1>
<h2 id="运行helloworld"><a class="markdownIt-Anchor" href="#运行helloworld"></a> 运行helloworld</h2>
<ul>
<li>命令：<code>docker run ubuntu:15.10 /bin/echo &quot;Hello world&quot;</code>
<ul>
<li>docker: Docker 的二进制执行文件。</li>
<li>run: 与前面的 docker 组合来运行一个容器。</li>
<li>ubuntu:15.10 指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。</li>
<li>/bin/echo “Hello world”: 在启动的容器里执行的命令。</li>
</ul>
</li>
<li>以上命令完整的意思可以解释为：Docker 以 ubuntu15.10 镜像创建一个新容器，然后在容器里执行 bin/echo “Hello world”，然后输出结果。</li>
</ul>
<h2 id="运行交互式容器"><a class="markdownIt-Anchor" href="#运行交互式容器"></a> 运行交互式容器</h2>
<ul>
<li>我们通过 docker 的两个参数 -i -t，让 docker 运行的容器实现&quot;对话&quot;的能力；
<ul>
<li>-t: 在新容器内指定一个伪终端或终端。</li>
<li>-i: 允许你对容器内的标准输入 (STDIN) 进行交互。</li>
</ul>
</li>
<li>命令示例：<code>docker run -i -t ubuntu:15.10</code>，-i，-t两个参数必须同时使用，如果只使用-t则会只有一个终端界面，但是输入命令不会有反应。</li>
<li>我们可以通过运行 exit 命令或者使用 CTRL+D 来退出容器。</li>
</ul>
<h2 id="启动容器后台模式"><a class="markdownIt-Anchor" href="#启动容器后台模式"></a> 启动容器（后台模式）</h2>
<ul>
<li>命令:<code>docker run -d ubuntu:15.10 /bin/echo &quot;helloworld&quot;</code>
<ul>
<li>在输出中，我们没有看到期望的 “hello world”，而是一串长字符串2b1b7a428627c51ab8810d541d759f072b4fc75487eed05812646b8534a2fe63。这个长字符串叫做容器 ID，对每个容器来说都是唯一的，我们可以通过容器 ID 来查看对应的容器发生了什么。</li>
</ul>
</li>
<li>确认容器有在运行，可以通过 docker ps 来查看：
<ul>
<li>输出详情介绍：
<ul>
<li>CONTAINER ID: 容器 ID。</li>
<li>IMAGE: 使用的镜像。</li>
<li>COMMAND: 启动容器时运行的命令。</li>
<li>CREATED: 容器的创建时间。</li>
<li>STATUS: 容器状态。
<ul>
<li>状态有7种：
<ul>
<li>created（已创建）</li>
<li>restarting（重启中）</li>
<li>running 或 Up（运行中）</li>
<li>removing（迁移中）</li>
<li>paused（暂停）</li>
<li>exited（停止）</li>
<li>dead（死亡）</li>
</ul>
</li>
</ul>
</li>
<li>PORTS: 容器的端口信息和使用的连接类型（tcp\udp）。</li>
<li>NAMES: 自动分配的容器名称。</li>
</ul>
</li>
</ul>
</li>
<li>在宿主主机内使用 docker logs 命令，查看容器内的标准输出：
<ul>
<li>示例：<code>docker logs 2b1b7a428627</code>(这串数字是容器id的前面一部分)</li>
</ul>
</li>
<li>我们使用 docker stop 命令来停止容器：
<ul>
<li>示例：<code>docker stop 2b1b7a428627</code></li>
</ul>
</li>
</ul>
<h1 id="docker容器使用"><a class="markdownIt-Anchor" href="#docker容器使用"></a> Docker容器使用</h1>
<h2 id="docker客户端"><a class="markdownIt-Anchor" href="#docker客户端"></a> Docker客户端</h2>
<ul>
<li>docker 客户端非常简单 ,我们可以直接输入 <code>docker</code>命令来查看到 Docker 客户端的所有命令选项。</li>
<li>可以通过命令 <code>docker &lt;command&gt; --help</code>更深入的了解指定的 Docker 命令使用方法。例如我们要查看 docker stats 指令的具体使用方法：<code>docker stats --help</code></li>
</ul>
<h2 id="容器的使用"><a class="markdownIt-Anchor" href="#容器的使用"></a> 容器的使用</h2>
<h3 id="获取镜像"><a class="markdownIt-Anchor" href="#获取镜像"></a> 获取镜像</h3>
<ul>
<li>如果我们本地没有 ubuntu 镜像，我们可以使用 docker pull 命令来载入 ubuntu 镜像：<code>docker pull ubuntu</code></li>
</ul>
<h3 id="启动容器"><a class="markdownIt-Anchor" href="#启动容器"></a> 启动容器</h3>
<ul>
<li>以下命令使用 ubuntu 镜像启动一个容器，参数为以命令行模式进入该容器：<code>docker run -it ubuntu /bin/bash</code>;</li>
<li>参数说明：
<ul>
<li>-i: 交互式操作。</li>
<li>-t: 终端。</li>
<li>ubuntu: ubuntu 镜像。</li>
<li>/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。（省略/bin/bash也能达到同样的效果）</li>
</ul>
</li>
<li>要退出终端，直接输入 exit;</li>
<li>docker的许多命令都需要使用<code>sudo</code>权限；</li>
</ul>
<h3 id="启动已停止的容器"><a class="markdownIt-Anchor" href="#启动已停止的容器"></a> 启动已停止的容器</h3>
<ul>
<li>查看所有的容器命令：<code>docker ps -a</code>,不加参数名，则只有表头，没有具体容器的信息。</li>
<li>查看最后一次创建的容器<code>docker ps -l</code>。</li>
<li>使用 docker start 启动一个已停止的容器：<code>docker start b750bbbcfd88</code>,最后那串数字是容器id的开头一部分，终端会自动识别出整个容器ID。但是这样容器启动后并不会输出相应的数据，我们能看见的只是终端上<strong>打印出的容器id</strong>.</li>
</ul>
<h3 id="后台运行"><a class="markdownIt-Anchor" href="#后台运行"></a> 后台运行</h3>
<ul>
<li>在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过参数<code>-d</code> 指定容器的运行模式为后台运行。</li>
<li>加了<code>-d</code> 参数默认不会进入容器，想要进入容器需要使用指令 <code>docker exec</code></li>
<li>后台运行的指令成功后，终端只会打印容器的id。示例:<code>docker run -itd --name ubuntu-test ubuntu /bin/bash</code></li>
</ul>
<h3 id="停止容器"><a class="markdownIt-Anchor" href="#停止容器"></a> 停止容器</h3>
<ul>
<li>停止容器的命令如下：<code>docker stop &lt;容器 ID&gt;</code></li>
<li>停止的容器和正在运行的容器可以通过 docker restart 重启：<code>docker restart &lt;容器 ID&gt;</code></li>
</ul>
<h3 id="进入容器"><a class="markdownIt-Anchor" href="#进入容器"></a> 进入容器</h3>
<ul>
<li>在使用 -d 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：</li>
<li><code>docker attach</code>：
<ul>
<li>示例：<code>docker attach 1e560fca3906</code>,没有参数之类的东西，直接使用容器id进入即可。</li>
</ul>
</li>
<li><code>docker exec</code>：推荐大家使用 docker exec 命令，因为使用此命令在退出容器终端后，不会导致容器的停止。
<ul>
<li>示例：<code>docker exec -it 243c32535da7 /bin/bash</code>,就像普通打开一个容器一样，docker exec命令后要有完整的参数，容器id和运行的命令（此处的/bin/bash）不可省略，退出终端仍然使用exit。</li>
</ul>
</li>
</ul>
<h3 id="导出和导入容器"><a class="markdownIt-Anchor" href="#导出和导入容器"></a> 导出和导入容器</h3>
<ul>
<li>如果要导出本地某个容器，可以使用<code>docker export</code> 命令。
<ul>
<li>示例:<code>docker export 1e560fca3906 &gt; ./test/ubuntu.tar</code>,导出容器 1e560fca3906 快照到本地文件 ubuntu.tar。</li>
</ul>
</li>
<li>可以使用<code>docker import</code> 从容器快照文件中再导入为镜像，以下实例将快照文件 ubuntu.tar 导入到镜像 test/ubuntu:v1:<code>cat test/ubuntu.tar | sudo docker import - ubuntu1</code>.</li>
<li>此外，也可以通过指定 URL 或者某个目录来导入，例如：<code>docker import http://example.com/exampleimage.tgz example/imagerepo</code></li>
<li>导出和导入的实际上都是镜像，要使用的话，还需根据镜像创建容器。</li>
</ul>
<h3 id="删除容器"><a class="markdownIt-Anchor" href="#删除容器"></a> 删除容器</h3>
<ul>
<li>删除容器使用 docker rm 命令，删除的容器必须是终止的，否则会报错。
<ul>
<li>示例：<code>docker rm -f 1e560fca390</code>,这串数字是容器id。</li>
</ul>
</li>
<li>下面的命令可以清理掉所有处于终止状态的容器:<code>docker container prune</code></li>
</ul>
<h2 id="web应用使用"><a class="markdownIt-Anchor" href="#web应用使用"></a> web应用使用</h2>
<h3 id="运行一个web应用"><a class="markdownIt-Anchor" href="#运行一个web应用"></a> 运行一个web应用</h3>
<ul>
<li>我们尝试使用 docker 构建一个 web 应用程序。我们将在docker容器中运行一个 Python Flask 应用来运行一个web应用。</li>
<li>载入镜像：<code>docker pull training/webapp</code></li>
<li>后台运行：<code>docker run -d -P training/webapp python app.py</code>
<ul>
<li>参数说明:
<ul>
<li>-d:让容器在后台运行。</li>
<li>-P:将容器内部使用的网络端口随机映射到我们使用的主机上。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="查看web应用容器"><a class="markdownIt-Anchor" href="#查看web应用容器"></a> 查看web应用容器</h3>
<ul>
<li>使用<code>sudo docker ps -a</code>来查看web应用容器。
<ul>
<li>这里多了端口信息。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">PORTS
0.0.0.0:32769-&gt;5000&#x2F;tcp</code></pre>
<ul>
<li>Docker 开放了 5000 端口（默认 Python Flask 端口）映射到主机端口 32769 上。这时我们可以通过浏览器访问WEB应用. 在浏览器地址栏输入<code>localhost:32769</code>即可访问web应用。</li>
<li>我们也可以通过<code>-p</code> 参数来设置不一样的端口：<code>docker run -d -p 5000:5000 training/webapp python app.py</code>容器内部的 5000 端口映射到我们本地主机的 5000 端口上。</li>
<li>查看端口号的快捷方式：<code>docker port &lt;容器id&gt;/&lt;容器名&gt;</code>来直接查看容器的端口的映射情况。</li>
</ul>
<h3 id="查看web应用的日志信息"><a class="markdownIt-Anchor" href="#查看web应用的日志信息"></a> 查看web应用的日志信息</h3>
<ul>
<li><code>docker logs &lt;容器id&gt;/&lt;容器名&gt;</code> 可以查看容器内部的标准输出。示例：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">docker logs -f bf08b7f2cd89
 * Running on http:&#x2F;&#x2F;0.0.0.0:5000&#x2F; (Press CTRL+C to quit)
192.168.239.1 - - [09&#x2F;May&#x2F;2016 16:30:37] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 200 -
192.168.239.1 - - [09&#x2F;May&#x2F;2016 16:30:37] &quot;GET &#x2F;favicon.ico HTTP&#x2F;1.1&quot; 404 -</code></pre>
<ul>
<li>-f: 让 docker logs 像使用 tail -f 一样来输出容器内部的标准输出。</li>
</ul>
<h3 id="查看web应用容器的进程"><a class="markdownIt-Anchor" href="#查看web应用容器的进程"></a> 查看web应用容器的进程</h3>
<ul>
<li>我们还可以使用 <code>docker top &lt;容器id&gt;/&lt;容器名&gt;</code> 来查看容器内部运行的进程。</li>
</ul>
<h3 id="检查web应用程序"><a class="markdownIt-Anchor" href="#检查web应用程序"></a> 检查web应用程序</h3>
<ul>
<li>使用<code>docker inspect &lt;容器id&gt;/&lt;容器名&gt;</code> 来查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息.</li>
</ul>
<h1 id="docker镜像使用"><a class="markdownIt-Anchor" href="#docker镜像使用"></a> Docker镜像使用</h1>
<ul>
<li>当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。</li>
</ul>
<h2 id="列出镜像列表"><a class="markdownIt-Anchor" href="#列出镜像列表"></a> 列出镜像列表</h2>
<ul>
<li>我们可以使用 <code>docker images</code> 来列出本地主机上的镜像。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">runoob@runoob:~$ docker images           
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ubuntu              14.04               90d5884b1ee0        5 days ago          188 MB
php                 5.6                 f40e9e0f10c8        9 days ago          444.8 MB
nginx               latest              6f8d099c3adc        12 days ago         182.7 MB
mysql               5.6                 f2e8d6c772c0        3 weeks ago         324.6 MB
httpd               latest              02ef73cf1bc0        3 weeks ago         194.4 MB
ubuntu              15.10               4e3b13c8a266        4 weeks ago         136.3 MB
hello-world         latest              690ed74de00f        6 months ago        960 B
training&#x2F;webapp     latest              6fae60ef3446        11 months ago       348.8 MB</code></pre>
<ul>
<li>各个选项说明:
<ul>
<li>REPOSITORY：表示镜像的仓库源</li>
<li>TAG：镜像的标签
<ul>
<li>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</li>
<li>如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。</li>
</ul>
</li>
<li>IMAGE ID：镜像ID</li>
<li>CREATED：镜像创建时间</li>
<li>SIZE：镜像大小</li>
</ul>
</li>
</ul>
<h2 id="获取新镜像"><a class="markdownIt-Anchor" href="#获取新镜像"></a> 获取新镜像</h2>
<ul>
<li>当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 <code>docker pull &lt;镜像名&gt;:&lt;标签&gt;</code>命令来下载它。</li>
</ul>
<h2 id="查找镜像"><a class="markdownIt-Anchor" href="#查找镜像"></a> 查找镜像</h2>
<ul>
<li>我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></li>
<li>我们也可以使用<code>docker search &lt;镜像名&gt;</code> 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 <code>docker search httpd</code> 来寻找适合我们的镜像。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201125085937.jpg" alt="" /></li>
<li>选项说明：
<ul>
<li>NAME: 镜像仓库源的名称</li>
<li>DESCRIPTION: 镜像的描述</li>
<li>OFFICIAL: 是否 docker 官方发布</li>
<li>stars: 类似 Github 里面的 star，表示点赞、喜欢的意思。</li>
<li>AUTOMATED: 自动构建。</li>
</ul>
</li>
</ul>
<h2 id="删除镜像"><a class="markdownIt-Anchor" href="#删除镜像"></a> 删除镜像</h2>
<ul>
<li>镜像删除使用<code>docker rmi &lt;镜像名&gt;:&lt;标签&gt;</code> 命令，比如我们删除 hello-world 镜像：<code>docker rmi hello-world</code>,省略标签，则默认只会删除标签为latest的镜像。</li>
</ul>
<h2 id="创建镜像"><a class="markdownIt-Anchor" href="#创建镜像"></a> 创建镜像</h2>
<ul>
<li>当我们从 docker 镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改。
<ol>
<li>从<strong>已经创建的容器中更新镜像</strong>，并且提交这个镜像;</li>
<li>使用 <strong>Dockerfile 指令</strong>来创建一个新的镜像;</li>
</ol>
</li>
</ul>
<h3 id="更新镜像"><a class="markdownIt-Anchor" href="#更新镜像"></a> 更新镜像</h3>
<ul>
<li>更新镜像之前，我们需要使用镜像来<strong>创建一个容器</strong>。</li>
<li>示例：
<ul>
<li><code>docker run -t -i ubuntu:15.10 /bin/bash</code></li>
<li>在运行的容器内使用 apt-get update 命令进行更新。</li>
<li>在完成操作之后，输入 exit 命令来退出这个容器。</li>
<li>此时 ID 为 e218edb10161 的容器，是按我们的需求更改的容器。我们可以通过命令<code>docker commit</code>来提交容器副本。</li>
<li><code>docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2</code></li>
</ul>
</li>
<li><code>docker commit</code>的各个参数说明：
<ul>
<li>-m: 提交的描述信息</li>
<li>-a: 指定镜像作者</li>
<li>e218edb10161：容器 ID</li>
<li>runoob/ubuntu:v2: 指定要创建的目标镜像名</li>
</ul>
</li>
</ul>
<h3 id="构建镜像"><a class="markdownIt-Anchor" href="#构建镜像"></a> 构建镜像</h3>
<ul>
<li>我们使用命令<code>docker build</code> ， 从零开始来创建一个新的镜像。为此，我们需要创建一个<code>Dockerfile</code>文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">runoob@runoob:~$ cat Dockerfile 
FROM    centos:6.7
MAINTAINER      Fisher &quot;fisher@sudops.com&quot;

RUN     &#x2F;bin&#x2F;echo &#39;root:123456&#39; |chpasswd
RUN     useradd runoob
RUN     &#x2F;bin&#x2F;echo &#39;runoob:123456&#39; |chpasswd
RUN     &#x2F;bin&#x2F;echo -e &quot;LANG&#x3D;\&quot;en_US.UTF-8\&quot;&quot; &gt;&#x2F;etc&#x2F;default&#x2F;local
EXPOSE  22
EXPOSE  80
CMD     &#x2F;usr&#x2F;sbin&#x2F;sshd -D</code></pre>
<ul>
<li>每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。</li>
<li>第一条FROM，指定使用哪个<strong>镜像源</strong></li>
<li>RUN 指令告诉docker 在镜像内执行命令，安装了什么。。。</li>
<li>然后，我们使用Dockerfile 文件，通过 docker build 命令来构建一个镜像。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">runoob@runoob:~$ docker build -t runoob&#x2F;centos:6.7 .
Sending build context to Docker daemon 17.92 kB
Step 1 : FROM centos:6.7
 ---&gt; d95b5ca17cc3
Step 2 : MAINTAINER Fisher &quot;fisher@sudops.com&quot;
 ---&gt; Using cache
 ---&gt; 0c92299c6f03
Step 3 : RUN &#x2F;bin&#x2F;echo &#39;root:123456&#39; |chpasswd
 ---&gt; Using cache
 ---&gt; 0397ce2fbd0a
Step 4 : RUN useradd runoob
......</code></pre>
<ul>
<li>参数说明：
<ul>
<li>-t ：指定要创建的目标镜像名</li>
<li>. ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径</li>
</ul>
</li>
</ul>
<h2 id="设置镜像标签"><a class="markdownIt-Anchor" href="#设置镜像标签"></a> 设置镜像标签</h2>
<ul>
<li>我们可以使用<code>docker tag</code>命令，为镜像添加一个新的标签。</li>
<li>示例：<code>docker tag 860c279d2fec runoob/centos:dev</code></li>
<li><code>docker tag 镜像ID 用户名称/镜像源名(repository name):新的标签名(tag)</code></li>
</ul>
<h1 id="docker容器连接"><a class="markdownIt-Anchor" href="#docker容器连接"></a> Docker容器连接</h1>
<ul>
<li>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</li>
</ul>
<h2 id="网络端口映射"><a class="markdownIt-Anchor" href="#网络端口映射"></a> 网络端口映射</h2>
<ul>
<li>创建了一个 python 应用的容器：<code>docker run -d -P training/webapp python app.py</code></li>
<li>我们使用 <code>-P</code> 参数创建一个容器，使用 docker ps 可以看到容器端口 5000 绑定主机端口 32768。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">runoob@runoob:~$ docker ps
CONTAINER ID    IMAGE               COMMAND            ...           PORTS                     NAMES
fce072cc88ce    training&#x2F;webapp     &quot;python app.py&quot;    ...     0.0.0.0:32768-&gt;5000&#x2F;tcp   grave_hopper</code></pre>
<ul>
<li>我们也可以使用 <code>-p</code> 标识来指定容器端口绑定到主机端口。</li>
<li>两种方式的区别是:
<ul>
<li><code>-P</code> :是容器内部端口<strong>随机</strong>映射到主机的高端口。</li>
<li><code>-p</code> : 是容器内部端口<strong>绑定</strong>到指定的主机端口,需要自己指定映射关系(如果不指定，则会报错）。</li>
<li><code>docker run -d -p 5000:5000 training/webapp python app.py</code></li>
</ul>
</li>
<li>另外，我们可以指定容器绑定的<strong>网络地址</strong>，比如绑定 127.0.0.1：<code>docker run -d -p 127.0.0.1:5001:5000 training/webapp python app.py</code>.</li>
<li>上面的例子中，默认都是绑定 tcp 端口，如果要绑定 UDP 端口，可以在端口后面加上 <code>/udp</code>。<code>docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</code>。</li>
</ul>
<h2 id="docker容器互联"><a class="markdownIt-Anchor" href="#docker容器互联"></a> Docker容器互联</h2>
<ul>
<li>端口映射并不是唯一把docker 连接到另一个容器的方法。docker 有一个连接系统允许将多个容器连接在一起，共享连接信息。docker 连接会创建一个父子关系，其中父容器可以看到子容器的信息。</li>
</ul>
<h3 id="容器命名"><a class="markdownIt-Anchor" href="#容器命名"></a> 容器命名</h3>
<ul>
<li>当我们创建一个容器的时候，docker 会<strong>自动对它进行命名</strong>。另外，我们也可以使用 <code>--name</code>标识来命名容器，例如：<code>docker run -d -P --name runoob training/webapp python app.py</code></li>
</ul>
<h3 id="新建网络"><a class="markdownIt-Anchor" href="#新建网络"></a> 新建网络</h3>
<ul>
<li>创建一个新的 Docker 网络:<code>docker network create -d bridge test-net</code></li>
<li>参数说明：
<ul>
<li>-d：参数指定 Docker 网络类型，有 bridge、overlay。</li>
<li><code>docker nerwork create</code>是固定的指令</li>
<li><code>test-net</code>是网络的名称。</li>
</ul>
</li>
<li>通过<code>docker network ls</code>来查看已经存在的网络。</li>
</ul>
<h3 id="连接容器"><a class="markdownIt-Anchor" href="#连接容器"></a> 连接容器</h3>
<ul>
<li>运行一个容器并连接到新建的 test-net 网络:<code>docker run -itd --name test1 --network test-net ubuntu /bin/bash</code>
<ul>
<li><code>--network</code>参数指定要连接的网络名。</li>
</ul>
</li>
<li>打开新的终端，再运行一个容器并加入到 test-net 网络:<code>docker run -itd --name test2 --network test-net ubuntu /bin/bash</code></li>
<li>下面通过 <code>ping</code> 来证明 test1 容器和 test2 容器建立了互联关系。
<ul>
<li>如果 test1、test2 容器内中无 ping 命令，则在容器内执行以下命令安装 ping（即学即用：可以在一个容器里安装好，提交容器到镜像，在以新的镜像重新运行以上两个个容器）。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">apt-get update
apt install iputils-ping</code></pre>
<ul>
<li>
<p>在test1容器内输入<code>ping test2</code>（test2中同理），即可连接。</p>
</li>
<li>
<p>如果有多个容器之间需要互相连接，推荐使用 Docker Compose。</p>
</li>
</ul>
<h3 id="配置dns"><a class="markdownIt-Anchor" href="#配置dns"></a> 配置DNS</h3>
<ul>
<li>我们可以在宿主机的 /etc/docker/daemon.json 文件中增加以下内容来设置全部容器的 DNS：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#123;
  &quot;dns&quot; : [
    &quot;114.114.114.114&quot;,
    &quot;8.8.8.8&quot;
  ]
&#125;</code></pre>
<ul>
<li>设置后，启动容器的 DNS 会自动配置为 114.114.114.114 和 8.8.8.8。配置完，需要重启 docker 才能生效。</li>
<li>查看容器的 DNS 是否生效可以使用以下命令，它会输出容器的 DNS 信息：<code>docker run -it --rm ubuntu cat etc/resolv.conf</code></li>
<li>如果只想在<strong>指定的容器设置 DNS</strong>，则可以使用以下命令：<code>docker run -it --rm -h host_ubuntu --dns=114.114.114.114 --dns-search=test.com ubuntu</code></li>
<li>参数说明：
<ul>
<li>–rm：容器退出时自动清理容器内部的文件系统。</li>
<li>-h HOSTNAME 或者 --hostname=HOSTNAME： 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts。</li>
<li>–dns=IP_ADDRESS： 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。</li>
<li>–dns-search=DOMAIN： 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索` host，还会搜索 <a target="_blank" rel="noopener" href="http://host.example.com">host.example.com</a>。</li>
</ul>
</li>
<li>如果在容器启动时没有指定 --dns 和 --dns-search，Docker 会默认用宿主主机上的 /etc/resolv.conf 来配置容器的 DNS。</li>
</ul>
<h1 id="docker仓库管理"><a class="markdownIt-Anchor" href="#docker仓库管理"></a> Docker仓库管理</h1>
<ul>
<li>仓库（Repository）是集中存放镜像的地方。以下介绍一下 Docker Hub。当然不止 docker hub，只是远程的服务商不一样，操作都是一样的。</li>
</ul>
<h2 id="dockerhub"><a class="markdownIt-Anchor" href="#dockerhub"></a> DockerHub</h2>
<ul>
<li>目前 Docker 官方维护了一个公共仓库 Docker Hub。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</li>
</ul>
<h3 id="注册"><a class="markdownIt-Anchor" href="#注册"></a> 注册</h3>
<ul>
<li>在 <a target="_blank" rel="noopener" href="https://hub.docker.com">DockerHub</a> 免费注册一个 Docker 账号。</li>
</ul>
<h3 id="登录和退出"><a class="markdownIt-Anchor" href="#登录和退出"></a> 登录和退出</h3>
<ul>
<li>登录需要输入用户名和密码，登录成功后，我们就可以从 docker hub 上拉取自己账号下的全部镜像。<code>docker login</code>;</li>
<li>退出 docker hub 可以使用以下命令：<code>docker logout</code></li>
</ul>
<h3 id="查找和拉取镜像"><a class="markdownIt-Anchor" href="#查找和拉取镜像"></a> 查找和拉取镜像</h3>
<ul>
<li>你可以通过 docker search 命令来查找官方仓库中的镜像，并利用 docker pull 命令来将它下载到本地。</li>
<li>查找：<code>docker search &lt;镜像名&gt;</code>,必须带有镜像名；</li>
<li>拉取：<code>docker pull &lt;镜像名&gt;</code>.</li>
</ul>
<h3 id="推送镜像"><a class="markdownIt-Anchor" href="#推送镜像"></a> 推送镜像</h3>
<ul>
<li>在登录进了dockerhub的前提下：</li>
<li>首先需要将本地的镜像名改为<code>(dockerhub的用户名)/镜像名</code>的格式。示例：<code>docker tag ubuntu:18.04 zestaken/ubuntu:18.04</code>(其中zestaken是我的dockerhub用户名)。</li>
<li>之后再使用<code>docker push &lt;镜像名&gt;</code>将镜像推送到dockerhub。</li>
<li>被自己推送到自己仓库的镜像可以直接使用<code>docker pull &lt;镜像名&gt;</code>拉取下来，但是search不能够搜到(因为开启这个功能需要花钱升级dockerhub账号到pro版）。</li>
</ul>
<h1 id="dockerfile"><a class="markdownIt-Anchor" href="#dockerfile"></a> Dockerfile</h1>
<h1 id="dockermachine"><a class="markdownIt-Anchor" href="#dockermachine"></a> Dockermachine</h1>
<h1 id="docker安装的ubuntu问题"><a class="markdownIt-Anchor" href="#docker安装的ubuntu问题"></a> docker安装的Ubuntu问题</h1>
<ul>
<li>通过镜像安装的ubuntu容器为纯净的环境，其好多命令执行不了，即缺少很多可执行脚本，安装即可~~~</li>
</ul>
<p>执行一切安装之前请先执行 apt-get update</p>
<ol>
<li>lsb_release</li>
</ol>
<p>apt-get install lsb-release</p>
<ol start="2">
<li>ifconfig</li>
</ol>
<p>apt install net-tools</p>
<ol start="3">
<li>ping</li>
</ol>
<p>apt install iputils-ping</p>
<ol start="4">
<li>sudo</li>
</ol>
<p>apt-get install sudo</p>
<ol start="5">
<li>vim</li>
</ol>
<p>apt-get install vim</p>
<ol start="6">
<li>add-apt-repository</li>
</ol>
<p>sudo apt-get install software-properties-common</p>
<p>同理可安装git ,Python等</p>
<p>（</p>
<p>apt-get install git python-virtualenv libssl-dev libffi-dev build-essential libpython-dev python2.7-minimal authbind<br />
）</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag"># 后端</a>
              <a href="/tags/Docker/" rel="tag"># Docker</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Linux/linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/index.html" rel="prev" title="linux虚拟文件系统">
                  <i class="fa fa-angle-left"></i> linux虚拟文件系统
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/JDBC/index.html" rel="next" title="JDBC">
                  JDBC <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">蜀ICP备2021022902号-1 </a>
      <img src="/images/beian_icon.png" alt="">
  </div>
  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Zestaken</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">678k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:17</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js" integrity="sha256-4mJNT2bMXxcc1GCJaxBmMPdmah5ji0Ldnd79DKd1hoM=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha256-AjM0J5XIbiB590BrznLEgZGLnOQWrt62s3BEq65Q/I0=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha256-9cmf7tcLdXpKsPi/2AWE93PbZpTp4M4tqzFk+lWomjU=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
