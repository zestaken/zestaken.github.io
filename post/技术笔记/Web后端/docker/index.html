<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <head>
    <link href="/styles/main.css" rel="stylesheet" type="text/css"/>

    <meta charset="UTF-8">
    
    <title>docker - ZestJourney</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/bootstrap/4.6.1/css/bootstrap.min.css">
    <script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/bootstrap/4.6.1/js/bootstrap.min.js"></script>

<script src="https://npm.elemecdn.com/@waline/client@v2/dist/waline.js"></script>
<link
  rel="stylesheet"
  href="https://npm.elemecdn.com/@waline/client@v2/dist/waline.css"
/>
<meta name="generator" content="Hexo 5.4.2"></head>

</head>

<body>
    


        <div>
            <div class="container-fluid position-relative">
                <nav class="navbar navbar-expand-lg navbar-dark  text-white bg-transparent">
                    <div class="container">
                        
                        <a class="navbar-brand" href="/">💖我们的秘密基地💖</a>
                        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarText"
                            aria-controls="navbarText" aria-expanded="false" aria-label="Toggle navigation">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                        <div class="collapse navbar-collapse" id="navbarText">
                            <ul class="navbar-nav mr-auto">
                            </ul>
                            <span class="navbar-text">
                                💕愿你三冬暖，愿你春不寒🍂
                            </span>
                        </div>
                    </div>
                </nav>
                <section class="lover-background"
                    style="background-image: url(/img/banner.jpg)">
                </section>
                <section
                    class="container lover-container d-flex flex-column align-content-center justify-content-center">
                    <div class="row align-items-center pb-5 lover">
                        <div class="col">
                            <div class="d-flex flex-column">
                                <img class="mx-auto avatar-img rounded-circle"
                                    src="/img/zestaken.jpg" alt="">
                                <h4 class="mx-auto text-white pt-2">  
                                    zestaken
                                </h4>
                            </div>
                        </div>
                        <div class="col">
                            <div class="d-flex justify-content-center">
                                <div class="heart"></div>
                            </div>
                        </div>
                        <div class="col">
                            <div class="d-flex flex-column">
                                <img class="mx-auto avatar-img rounded-circle"
                                    src="/img/zinny.jpg" alt="">
                                <h4 class="mx-auto text-white pt-2">
                                    zinny
                                </h4>
                            </div>
                        </div>
                    </div>
                </section>
                <section class="main-hero-waves-area waves-area">
                    <svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
                        viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
                        <defs>
                            <path id="gentle-wave"
                                d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z">
                            </path>
                        </defs>
                        <g class="parallax">
                            <use xlink:href="#gentle-wave" x="48" y="0"></use>
                            <use xlink:href="#gentle-wave" x="48" y="3"></use>
                            <use xlink:href="#gentle-wave" x="48" y="5"></use>
                            <use xlink:href="#gentle-wave" x="48" y="7"></use>
                        </g>
                    </svg>
                </section>
            </div>

            <div id="Pjax">

  <div class="list-content mx-auto mt-5">
      <div id="article" class="list-top">
          <h5 class="list-text"> docker
          </h5>
          <article>
              <article>
                <h1 id="docker概述"><a class="markdownIt-Anchor" href="#docker概述"></a> Docker概述</h1>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-tutorial.html">参考教程</a></p>
<ul>
<li>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。</li>
<li>Docker的应用场景：
<ul>
<li>Web 应用的自动化打包和发布。</li>
<li>自动化测试和持续集成、发布。</li>
<li>在服务型环境中部署和调整数据库或其他的后台应用。</li>
<li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li>
</ul>
</li>
</ul>
<h2 id="docker架构"><a class="markdownIt-Anchor" href="#docker架构"></a> Docker架构</h2>
<ul>
<li>Docker 包括三个基本概念:
<ul>
<li>镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li>
<li>容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li>
<li>仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。</li>
</ul>
</li>
<li>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。</li>
<li>Docker 容器通过 Docker 镜像来创建。容器与镜像的关系类似于面向对象编程中的对象与类。</li>
</ul>
<h1 id="docker安装"><a class="markdownIt-Anchor" href="#docker安装"></a> Docker安装</h1>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/ubuntu-docker-install.html">参考资料</a></p>
<h1 id="docker的基础使用"><a class="markdownIt-Anchor" href="#docker的基础使用"></a> Docker的基础使用</h1>
<h2 id="运行helloworld"><a class="markdownIt-Anchor" href="#运行helloworld"></a> 运行helloworld</h2>
<ul>
<li>命令：<code>docker run ubuntu:15.10 /bin/echo &quot;Hello world&quot;</code>
<ul>
<li>docker: Docker 的二进制执行文件。</li>
<li>run: 与前面的 docker 组合来运行一个容器。</li>
<li>ubuntu:15.10 指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。</li>
<li>/bin/echo “Hello world”: 在启动的容器里执行的命令。</li>
</ul>
</li>
<li>以上命令完整的意思可以解释为：Docker 以 ubuntu15.10 镜像创建一个新容器，然后在容器里执行 bin/echo “Hello world”，然后输出结果。</li>
</ul>
<h2 id="运行交互式容器"><a class="markdownIt-Anchor" href="#运行交互式容器"></a> 运行交互式容器</h2>
<ul>
<li>我们通过 docker 的两个参数 -i -t，让 docker 运行的容器实现&quot;对话&quot;的能力；
<ul>
<li>-t: 在新容器内指定一个伪终端或终端。</li>
<li>-i: 允许你对容器内的标准输入 (STDIN) 进行交互。</li>
</ul>
</li>
<li>命令示例：<code>docker run -i -t ubuntu:15.10</code>，-i，-t两个参数必须同时使用，如果只使用-t则会只有一个终端界面，但是输入命令不会有反应。</li>
<li>我们可以通过运行 exit 命令或者使用 CTRL+D 来退出容器。</li>
</ul>
<h2 id="启动容器后台模式"><a class="markdownIt-Anchor" href="#启动容器后台模式"></a> 启动容器（后台模式）</h2>
<ul>
<li>命令:<code>docker run -d ubuntu:15.10 /bin/echo &quot;helloworld&quot;</code>
<ul>
<li>在输出中，我们没有看到期望的 “hello world”，而是一串长字符串2b1b7a428627c51ab8810d541d759f072b4fc75487eed05812646b8534a2fe63。这个长字符串叫做容器 ID，对每个容器来说都是唯一的，我们可以通过容器 ID 来查看对应的容器发生了什么。</li>
</ul>
</li>
<li>确认容器有在运行，可以通过 docker ps 来查看：
<ul>
<li>输出详情介绍：
<ul>
<li>CONTAINER ID: 容器 ID。</li>
<li>IMAGE: 使用的镜像。</li>
<li>COMMAND: 启动容器时运行的命令。</li>
<li>CREATED: 容器的创建时间。</li>
<li>STATUS: 容器状态。
<ul>
<li>状态有7种：
<ul>
<li>created（已创建）</li>
<li>restarting（重启中）</li>
<li>running 或 Up（运行中）</li>
<li>removing（迁移中）</li>
<li>paused（暂停）</li>
<li>exited（停止）</li>
<li>dead（死亡）</li>
</ul>
</li>
</ul>
</li>
<li>PORTS: 容器的端口信息和使用的连接类型（tcp\udp）。</li>
<li>NAMES: 自动分配的容器名称。</li>
</ul>
</li>
</ul>
</li>
<li>在宿主主机内使用 docker logs 命令，查看容器内的标准输出：
<ul>
<li>示例：<code>docker logs 2b1b7a428627</code>(这串数字是容器id的前面一部分)</li>
</ul>
</li>
<li>我们使用 docker stop 命令来停止容器：
<ul>
<li>示例：<code>docker stop 2b1b7a428627</code></li>
</ul>
</li>
</ul>
<h1 id="docker容器使用"><a class="markdownIt-Anchor" href="#docker容器使用"></a> Docker容器使用</h1>
<h2 id="docker客户端"><a class="markdownIt-Anchor" href="#docker客户端"></a> Docker客户端</h2>
<ul>
<li>docker 客户端非常简单 ,我们可以直接输入 <code>docker </code>命令来查看到 Docker 客户端的所有命令选项。</li>
<li>可以通过命令 <code>docker &lt;command&gt; --help </code>更深入的了解指定的 Docker 命令使用方法。例如我们要查看 docker stats 指令的具体使用方法：<code>docker stats --help</code></li>
</ul>
<h2 id="容器的使用"><a class="markdownIt-Anchor" href="#容器的使用"></a> 容器的使用</h2>
<h3 id="获取镜像"><a class="markdownIt-Anchor" href="#获取镜像"></a> 获取镜像</h3>
<ul>
<li>如果我们本地没有 ubuntu 镜像，我们可以使用 docker pull 命令来载入 ubuntu 镜像：<code>docker pull ubuntu</code></li>
</ul>
<h3 id="启动容器"><a class="markdownIt-Anchor" href="#启动容器"></a> 启动容器</h3>
<ul>
<li>以下命令使用 ubuntu 镜像启动一个容器，参数为以命令行模式进入该容器：<code> docker run -it ubuntu /bin/bash</code>;</li>
<li>参数说明：
<ul>
<li>-i: 交互式操作。</li>
<li>-t: 终端。</li>
<li>ubuntu: ubuntu 镜像。</li>
<li>/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。（省略/bin/bash也能达到同样的效果）</li>
</ul>
</li>
<li>要退出终端，直接输入 exit;</li>
<li>docker的许多命令都需要使用<code>sudo</code>权限；</li>
</ul>
<h3 id="启动已停止的容器"><a class="markdownIt-Anchor" href="#启动已停止的容器"></a> 启动已停止的容器</h3>
<ul>
<li>查看所有的容器命令：<code>docker ps -a</code>,不加参数名，则只有表头，没有具体容器的信息。</li>
<li>查看最后一次创建的容器<code>docker ps -l</code>。</li>
<li>使用 docker start 启动一个已停止的容器：<code>docker start b750bbbcfd88</code>,最后那串数字是容器id的开头一部分，终端会自动识别出整个容器ID。但是这样容器启动后并不会输出相应的数据，我们能看见的只是终端上<strong>打印出的容器id</strong>.</li>
</ul>
<h3 id="后台运行"><a class="markdownIt-Anchor" href="#后台运行"></a> 后台运行</h3>
<ul>
<li>在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过参数<code>-d</code> 指定容器的运行模式为后台运行。</li>
<li>加了<code>-d</code> 参数默认不会进入容器，想要进入容器需要使用指令 <code>docker exec</code></li>
<li>后台运行的指令成功后，终端只会打印容器的id。示例:<code>docker run -itd --name ubuntu-test ubuntu /bin/bash</code></li>
</ul>
<h3 id="停止容器"><a class="markdownIt-Anchor" href="#停止容器"></a> 停止容器</h3>
<ul>
<li>停止容器的命令如下：<code>docker stop &lt;容器 ID&gt;</code></li>
<li>停止的容器和正在运行的容器可以通过 docker restart 重启：<code>docker restart &lt;容器 ID&gt;</code></li>
</ul>
<h3 id="进入容器"><a class="markdownIt-Anchor" href="#进入容器"></a> 进入容器</h3>
<ul>
<li>在使用 -d 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：</li>
<li><code>docker attach</code>：
<ul>
<li>示例：<code>docker attach 1e560fca3906 </code>,没有参数之类的东西，直接使用容器id进入即可。</li>
</ul>
</li>
<li><code>docker exec</code>：推荐大家使用 docker exec 命令，因为使用此命令在退出容器终端后，不会导致容器的停止。
<ul>
<li>示例：<code>docker exec -it 243c32535da7 /bin/bash</code>,就像普通打开一个容器一样，docker exec命令后要有完整的参数，容器id和运行的命令（此处的/bin/bash）不可省略，退出终端仍然使用exit。</li>
</ul>
</li>
</ul>
<h3 id="导出和导入容器"><a class="markdownIt-Anchor" href="#导出和导入容器"></a> 导出和导入容器</h3>
<ul>
<li>如果要导出本地某个容器，可以使用<code>docker export</code> 命令。
<ul>
<li>示例:<code>docker export 1e560fca3906 &gt; ./test/ubuntu.tar</code>,导出容器 1e560fca3906 快照到本地文件 ubuntu.tar。</li>
</ul>
</li>
<li>可以使用<code>docker import</code> 从容器快照文件中再导入为镜像，以下实例将快照文件 ubuntu.tar 导入到镜像 test/ubuntu:v1:<code>cat test/ubuntu.tar | sudo docker import - ubuntu1</code>.</li>
<li>此外，也可以通过指定 URL 或者某个目录来导入，例如：<code>docker import http://example.com/exampleimage.tgz example/imagerepo</code></li>
<li>导出和导入的实际上都是镜像，要使用的话，还需根据镜像创建容器。</li>
</ul>
<h3 id="删除容器"><a class="markdownIt-Anchor" href="#删除容器"></a> 删除容器</h3>
<ul>
<li>删除容器使用 docker rm 命令，删除的容器必须是终止的，否则会报错。
<ul>
<li>示例：<code>docker rm -f 1e560fca390</code>,这串数字是容器id。</li>
</ul>
</li>
<li>下面的命令可以清理掉所有处于终止状态的容器:<code>docker container prune</code></li>
</ul>
<h2 id="web应用使用"><a class="markdownIt-Anchor" href="#web应用使用"></a> web应用使用</h2>
<h3 id="运行一个web应用"><a class="markdownIt-Anchor" href="#运行一个web应用"></a> 运行一个web应用</h3>
<ul>
<li>我们尝试使用 docker 构建一个 web 应用程序。我们将在docker容器中运行一个 Python Flask 应用来运行一个web应用。</li>
<li>载入镜像：<code>docker pull training/webapp</code></li>
<li>后台运行：<code>docker run -d -P training/webapp python app.py</code>
<ul>
<li>参数说明:
<ul>
<li>-d:让容器在后台运行。</li>
<li>-P:将容器内部使用的网络端口随机映射到我们使用的主机上。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="查看web应用容器"><a class="markdownIt-Anchor" href="#查看web应用容器"></a> 查看web应用容器</h3>
<ul>
<li>使用<code>sudo docker ps -a</code>来查看web应用容器。
<ul>
<li>这里多了端口信息。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">PORTS
0.0.0.0:32769-&gt;5000&#x2F;tcp</code></pre>
<ul>
<li>Docker 开放了 5000 端口（默认 Python Flask 端口）映射到主机端口 32769 上。这时我们可以通过浏览器访问WEB应用. 在浏览器地址栏输入<code>localhost:32769</code>即可访问web应用。</li>
<li>我们也可以通过<code>-p</code> 参数来设置不一样的端口：<code> docker run -d -p 5000:5000 training/webapp python app.py</code>容器内部的 5000 端口映射到我们本地主机的 5000 端口上。</li>
<li>查看端口号的快捷方式：<code>docker port &lt;容器id&gt;/&lt;容器名&gt;</code>来直接查看容器的端口的映射情况。</li>
</ul>
<h3 id="查看web应用的日志信息"><a class="markdownIt-Anchor" href="#查看web应用的日志信息"></a> 查看web应用的日志信息</h3>
<ul>
<li><code>docker logs &lt;容器id&gt;/&lt;容器名&gt;</code> 可以查看容器内部的标准输出。示例：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">docker logs -f bf08b7f2cd89
 * Running on http:&#x2F;&#x2F;0.0.0.0:5000&#x2F; (Press CTRL+C to quit)
192.168.239.1 - - [09&#x2F;May&#x2F;2016 16:30:37] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 200 -
192.168.239.1 - - [09&#x2F;May&#x2F;2016 16:30:37] &quot;GET &#x2F;favicon.ico HTTP&#x2F;1.1&quot; 404 -</code></pre>
<ul>
<li>-f: 让 docker logs 像使用 tail -f 一样来输出容器内部的标准输出。</li>
</ul>
<h3 id="查看web应用容器的进程"><a class="markdownIt-Anchor" href="#查看web应用容器的进程"></a> 查看web应用容器的进程</h3>
<ul>
<li>我们还可以使用 <code>docker top &lt;容器id&gt;/&lt;容器名&gt; </code> 来查看容器内部运行的进程。</li>
</ul>
<h3 id="检查web应用程序"><a class="markdownIt-Anchor" href="#检查web应用程序"></a> 检查web应用程序</h3>
<ul>
<li>使用<code>docker inspect &lt;容器id&gt;/&lt;容器名&gt;</code> 来查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息.</li>
</ul>
<h1 id="docker镜像使用"><a class="markdownIt-Anchor" href="#docker镜像使用"></a> Docker镜像使用</h1>
<ul>
<li>当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。</li>
</ul>
<h2 id="列出镜像列表"><a class="markdownIt-Anchor" href="#列出镜像列表"></a> 列出镜像列表</h2>
<ul>
<li>我们可以使用 <code>docker images</code> 来列出本地主机上的镜像。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">runoob@runoob:~$ docker images           
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ubuntu              14.04               90d5884b1ee0        5 days ago          188 MB
php                 5.6                 f40e9e0f10c8        9 days ago          444.8 MB
nginx               latest              6f8d099c3adc        12 days ago         182.7 MB
mysql               5.6                 f2e8d6c772c0        3 weeks ago         324.6 MB
httpd               latest              02ef73cf1bc0        3 weeks ago         194.4 MB
ubuntu              15.10               4e3b13c8a266        4 weeks ago         136.3 MB
hello-world         latest              690ed74de00f        6 months ago        960 B
training&#x2F;webapp     latest              6fae60ef3446        11 months ago       348.8 MB</code></pre>
<ul>
<li>各个选项说明:
<ul>
<li>REPOSITORY：表示镜像的仓库源</li>
<li>TAG：镜像的标签
<ul>
<li>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</li>
<li>如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。</li>
</ul>
</li>
<li>IMAGE ID：镜像ID</li>
<li>CREATED：镜像创建时间</li>
<li>SIZE：镜像大小</li>
</ul>
</li>
</ul>
<h2 id="获取新镜像"><a class="markdownIt-Anchor" href="#获取新镜像"></a> 获取新镜像</h2>
<ul>
<li>当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 <code>docker pull &lt;镜像名&gt;:&lt;标签&gt;</code>命令来下载它。</li>
</ul>
<h2 id="查找镜像"><a class="markdownIt-Anchor" href="#查找镜像"></a> 查找镜像</h2>
<ul>
<li>我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></li>
<li>我们也可以使用<code>docker search &lt;镜像名&gt;</code> 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 <code>docker search httpd</code> 来寻找适合我们的镜像。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201125085937.jpg" alt="" /></li>
<li>选项说明：
<ul>
<li>NAME: 镜像仓库源的名称</li>
<li>DESCRIPTION: 镜像的描述</li>
<li>OFFICIAL: 是否 docker 官方发布</li>
<li>stars: 类似 Github 里面的 star，表示点赞、喜欢的意思。</li>
<li>AUTOMATED: 自动构建。</li>
</ul>
</li>
</ul>
<h2 id="删除镜像"><a class="markdownIt-Anchor" href="#删除镜像"></a> 删除镜像</h2>
<ul>
<li>镜像删除使用<code>docker rmi &lt;镜像名&gt;:&lt;标签&gt;</code> 命令，比如我们删除 hello-world 镜像：<code>docker rmi hello-world</code>,省略标签，则默认只会删除标签为latest的镜像。</li>
</ul>
<h2 id="创建镜像"><a class="markdownIt-Anchor" href="#创建镜像"></a> 创建镜像</h2>
<ul>
<li>当我们从 docker 镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改。
<ol>
<li>从<strong>已经创建的容器中更新镜像</strong>，并且提交这个镜像;</li>
<li>使用 <strong>Dockerfile 指令</strong>来创建一个新的镜像;</li>
</ol>
</li>
</ul>
<h3 id="更新镜像"><a class="markdownIt-Anchor" href="#更新镜像"></a> 更新镜像</h3>
<ul>
<li>更新镜像之前，我们需要使用镜像来<strong>创建一个容器</strong>。</li>
<li>示例：
<ul>
<li><code>docker run -t -i ubuntu:15.10 /bin/bash</code></li>
<li>在运行的容器内使用 apt-get update 命令进行更新。</li>
<li>在完成操作之后，输入 exit 命令来退出这个容器。</li>
<li>此时 ID 为 e218edb10161 的容器，是按我们的需求更改的容器。我们可以通过命令<code>docker commit</code>来提交容器副本。</li>
<li><code>docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2</code></li>
</ul>
</li>
<li><code>docker commit</code>的各个参数说明：
<ul>
<li>-m: 提交的描述信息</li>
<li>-a: 指定镜像作者</li>
<li>e218edb10161：容器 ID</li>
<li>runoob/ubuntu:v2: 指定要创建的目标镜像名</li>
</ul>
</li>
</ul>
<h3 id="构建镜像"><a class="markdownIt-Anchor" href="#构建镜像"></a> 构建镜像</h3>
<ul>
<li>我们使用命令<code>docker build</code> ， 从零开始来创建一个新的镜像。为此，我们需要创建一个<code>Dockerfile</code>文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">runoob@runoob:~$ cat Dockerfile 
FROM    centos:6.7
MAINTAINER      Fisher &quot;fisher@sudops.com&quot;

RUN     &#x2F;bin&#x2F;echo &#39;root:123456&#39; |chpasswd
RUN     useradd runoob
RUN     &#x2F;bin&#x2F;echo &#39;runoob:123456&#39; |chpasswd
RUN     &#x2F;bin&#x2F;echo -e &quot;LANG&#x3D;\&quot;en_US.UTF-8\&quot;&quot; &gt;&#x2F;etc&#x2F;default&#x2F;local
EXPOSE  22
EXPOSE  80
CMD     &#x2F;usr&#x2F;sbin&#x2F;sshd -D</code></pre>
<ul>
<li>每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。</li>
<li>第一条FROM，指定使用哪个<strong>镜像源</strong></li>
<li>RUN 指令告诉docker 在镜像内执行命令，安装了什么。。。</li>
<li>然后，我们使用Dockerfile 文件，通过 docker build 命令来构建一个镜像。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">runoob@runoob:~$ docker build -t runoob&#x2F;centos:6.7 .
Sending build context to Docker daemon 17.92 kB
Step 1 : FROM centos:6.7
 ---&gt; d95b5ca17cc3
Step 2 : MAINTAINER Fisher &quot;fisher@sudops.com&quot;
 ---&gt; Using cache
 ---&gt; 0c92299c6f03
Step 3 : RUN &#x2F;bin&#x2F;echo &#39;root:123456&#39; |chpasswd
 ---&gt; Using cache
 ---&gt; 0397ce2fbd0a
Step 4 : RUN useradd runoob
......</code></pre>
<ul>
<li>参数说明：
<ul>
<li>-t ：指定要创建的目标镜像名</li>
<li>. ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径</li>
</ul>
</li>
</ul>
<h2 id="设置镜像标签"><a class="markdownIt-Anchor" href="#设置镜像标签"></a> 设置镜像标签</h2>
<ul>
<li>我们可以使用<code>docker tag</code>命令，为镜像添加一个新的标签。</li>
<li>示例：<code>docker tag 860c279d2fec runoob/centos:dev</code></li>
<li><code>docker tag 镜像ID 用户名称/镜像源名(repository name):新的标签名(tag)</code></li>
</ul>
<h1 id="docker容器连接"><a class="markdownIt-Anchor" href="#docker容器连接"></a> Docker容器连接</h1>
<ul>
<li>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</li>
</ul>
<h2 id="网络端口映射"><a class="markdownIt-Anchor" href="#网络端口映射"></a> 网络端口映射</h2>
<ul>
<li>创建了一个 python 应用的容器：<code>docker run -d -P training/webapp python app.py</code></li>
<li>我们使用 <code>-P</code> 参数创建一个容器，使用 docker ps 可以看到容器端口 5000 绑定主机端口 32768。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">runoob@runoob:~$ docker ps
CONTAINER ID    IMAGE               COMMAND            ...           PORTS                     NAMES
fce072cc88ce    training&#x2F;webapp     &quot;python app.py&quot;    ...     0.0.0.0:32768-&gt;5000&#x2F;tcp   grave_hopper</code></pre>
<ul>
<li>我们也可以使用 <code>-p</code> 标识来指定容器端口绑定到主机端口。</li>
<li>两种方式的区别是:
<ul>
<li><code>-P</code> :是容器内部端口<strong>随机</strong>映射到主机的高端口。</li>
<li><code>-p</code> : 是容器内部端口<strong>绑定</strong>到指定的主机端口,需要自己指定映射关系(如果不指定，则会报错）。</li>
<li><code>docker run -d -p 5000:5000 training/webapp python app.py</code></li>
</ul>
</li>
<li>另外，我们可以指定容器绑定的<strong>网络地址</strong>，比如绑定 127.0.0.1：<code> docker run -d -p 127.0.0.1:5001:5000 training/webapp python app.py</code>.</li>
<li>上面的例子中，默认都是绑定 tcp 端口，如果要绑定 UDP 端口，可以在端口后面加上 <code>/udp</code>。<code>docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</code>。</li>
</ul>
<h2 id="docker容器互联"><a class="markdownIt-Anchor" href="#docker容器互联"></a> Docker容器互联</h2>
<ul>
<li>端口映射并不是唯一把docker 连接到另一个容器的方法。docker 有一个连接系统允许将多个容器连接在一起，共享连接信息。docker 连接会创建一个父子关系，其中父容器可以看到子容器的信息。</li>
</ul>
<h3 id="容器命名"><a class="markdownIt-Anchor" href="#容器命名"></a> 容器命名</h3>
<ul>
<li>当我们创建一个容器的时候，docker 会<strong>自动对它进行命名</strong>。另外，我们也可以使用 <code>--name</code>标识来命名容器，例如：<code>docker run -d -P --name runoob training/webapp python app.py</code></li>
</ul>
<h3 id="新建网络"><a class="markdownIt-Anchor" href="#新建网络"></a> 新建网络</h3>
<ul>
<li>创建一个新的 Docker 网络:<code>docker network create -d bridge test-net</code></li>
<li>参数说明：
<ul>
<li>-d：参数指定 Docker 网络类型，有 bridge、overlay。</li>
<li><code>docker nerwork create</code>是固定的指令</li>
<li><code>test-net</code>是网络的名称。</li>
</ul>
</li>
<li>通过<code>docker network ls</code>来查看已经存在的网络。</li>
</ul>
<h3 id="连接容器"><a class="markdownIt-Anchor" href="#连接容器"></a> 连接容器</h3>
<ul>
<li>运行一个容器并连接到新建的 test-net 网络:<code>docker run -itd --name test1 --network test-net ubuntu /bin/bash</code>
<ul>
<li><code>--network</code>参数指定要连接的网络名。</li>
</ul>
</li>
<li>打开新的终端，再运行一个容器并加入到 test-net 网络:<code>docker run -itd --name test2 --network test-net ubuntu /bin/bash</code></li>
<li>下面通过 <code>ping</code> 来证明 test1 容器和 test2 容器建立了互联关系。
<ul>
<li>如果 test1、test2 容器内中无 ping 命令，则在容器内执行以下命令安装 ping（即学即用：可以在一个容器里安装好，提交容器到镜像，在以新的镜像重新运行以上两个个容器）。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apt-get update
apt install iputils-ping</code></pre>
<ul>
<li>
<p>在test1容器内输入<code>ping test2</code>（test2中同理），即可连接。</p>
</li>
<li>
<p>如果有多个容器之间需要互相连接，推荐使用 Docker Compose。</p>
</li>
</ul>
<h3 id="配置dns"><a class="markdownIt-Anchor" href="#配置dns"></a> 配置DNS</h3>
<ul>
<li>我们可以在宿主机的 /etc/docker/daemon.json 文件中增加以下内容来设置全部容器的 DNS：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#123;
  &quot;dns&quot; : [
    &quot;114.114.114.114&quot;,
    &quot;8.8.8.8&quot;
  ]
&#125;</code></pre>
<ul>
<li>设置后，启动容器的 DNS 会自动配置为 114.114.114.114 和 8.8.8.8。配置完，需要重启 docker 才能生效。</li>
<li>查看容器的 DNS 是否生效可以使用以下命令，它会输出容器的 DNS 信息：<code>docker run -it --rm  ubuntu  cat etc/resolv.conf</code></li>
<li>如果只想在<strong>指定的容器设置 DNS</strong>，则可以使用以下命令：<code>docker run -it --rm -h host_ubuntu  --dns=114.114.114.114 --dns-search=test.com ubuntu</code></li>
<li>参数说明：
<ul>
<li>–rm：容器退出时自动清理容器内部的文件系统。</li>
<li>-h HOSTNAME 或者 --hostname=HOSTNAME： 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts。</li>
<li>–dns=IP_ADDRESS： 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。</li>
<li>–dns-search=DOMAIN： 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索` host，还会搜索 <a target="_blank" rel="noopener" href="http://host.example.com">host.example.com</a>。</li>
</ul>
</li>
<li>如果在容器启动时没有指定 --dns 和 --dns-search，Docker 会默认用宿主主机上的 /etc/resolv.conf 来配置容器的 DNS。</li>
</ul>
<h1 id="docker仓库管理"><a class="markdownIt-Anchor" href="#docker仓库管理"></a> Docker仓库管理</h1>
<ul>
<li>仓库（Repository）是集中存放镜像的地方。以下介绍一下 Docker Hub。当然不止 docker hub，只是远程的服务商不一样，操作都是一样的。</li>
</ul>
<h2 id="dockerhub"><a class="markdownIt-Anchor" href="#dockerhub"></a> DockerHub</h2>
<ul>
<li>目前 Docker 官方维护了一个公共仓库 Docker Hub。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</li>
</ul>
<h3 id="注册"><a class="markdownIt-Anchor" href="#注册"></a> 注册</h3>
<ul>
<li>在 <a target="_blank" rel="noopener" href="https://hub.docker.com">DockerHub</a> 免费注册一个 Docker 账号。</li>
</ul>
<h3 id="登录和退出"><a class="markdownIt-Anchor" href="#登录和退出"></a> 登录和退出</h3>
<ul>
<li>登录需要输入用户名和密码，登录成功后，我们就可以从 docker hub 上拉取自己账号下的全部镜像。<code>docker login</code>;</li>
<li>退出 docker hub 可以使用以下命令：<code>docker logout</code></li>
</ul>
<h3 id="查找和拉取镜像"><a class="markdownIt-Anchor" href="#查找和拉取镜像"></a> 查找和拉取镜像</h3>
<ul>
<li>你可以通过 docker search 命令来查找官方仓库中的镜像，并利用 docker pull 命令来将它下载到本地。</li>
<li>查找：<code>docker search &lt;镜像名&gt;</code>,必须带有镜像名；</li>
<li>拉取：<code>docker pull &lt;镜像名&gt;</code>.</li>
</ul>
<h3 id="推送镜像"><a class="markdownIt-Anchor" href="#推送镜像"></a> 推送镜像</h3>
<ul>
<li>在登录进了dockerhub的前提下：</li>
<li>首先需要将本地的镜像名改为<code>(dockerhub的用户名)/镜像名</code>的格式。示例：<code>docker tag ubuntu:18.04 zestaken/ubuntu:18.04</code>(其中zestaken是我的dockerhub用户名)。</li>
<li>之后再使用<code>docker push &lt;镜像名&gt;</code>将镜像推送到dockerhub。</li>
<li>被自己推送到自己仓库的镜像可以直接使用<code>docker pull &lt;镜像名&gt;</code>拉取下来，但是search不能够搜到(因为开启这个功能需要花钱升级dockerhub账号到pro版）。</li>
</ul>
<h1 id="dockerfile"><a class="markdownIt-Anchor" href="#dockerfile"></a> Dockerfile</h1>
<h1 id="dockermachine"><a class="markdownIt-Anchor" href="#dockermachine"></a> Dockermachine</h1>
<h1 id="docker安装的ubuntu问题"><a class="markdownIt-Anchor" href="#docker安装的ubuntu问题"></a> docker安装的Ubuntu问题</h1>
<ul>
<li>通过镜像安装的ubuntu容器为纯净的环境，其好多命令执行不了，即缺少很多可执行脚本，安装即可~~~</li>
</ul>
<p>执行一切安装之前请先执行 apt-get update</p>
<ol>
<li>lsb_release</li>
</ol>
<p>apt-get install lsb-release</p>
<ol start="2">
<li>ifconfig</li>
</ol>
<p>apt install net-tools</p>
<ol start="3">
<li>ping</li>
</ol>
<p>apt install iputils-ping</p>
<ol start="4">
<li>sudo</li>
</ol>
<p>apt-get install sudo</p>
<ol start="5">
<li>vim</li>
</ol>
<p>apt-get install vim</p>
<ol start="6">
<li>add-apt-repository</li>
</ol>
<p>sudo apt-get install software-properties-common</p>
<p>同理可安装git ,Python等</p>
<p>（</p>
<p>apt-get install git python-virtualenv libssl-dev libffi-dev build-essential libpython-dev python2.7-minimal authbind<br />
）</p>

              </article>
          </article>
      </div>
  </div>

</div>



        </div>


        <!-- <div class="p-5 text-center ">
  <p class="h6"> <a href="https://beian.miit.gov.cn/" target="_blank">蜀ICP备2021022902号-1</a> ※ <a
          href="https://beian.mps.gov.cn/#/query/webSearch" target="_blank">川公网安备51010802032250号</a></p>
</div> -->

<div class="p-5 text-center">
  <img src="/img/beian_icon.png" alt="备案图标" class="icon" style="max-width: 48px; max-height: 48px; vertical-align: middle;">
  <p class="h6">
    <a href="https://beian.miit.gov.cn/" target="_blank">蜀ICP备2021022902号-1</a> ※
    <a href="https://beian.mps.gov.cn/#/query/webSearch" target="_blank">川公网安备51010802032250号</a>
  </p>
</div>
</body>

</html>