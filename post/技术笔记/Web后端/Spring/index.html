<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <head>
    <link href="/styles/main.css" rel="stylesheet" type="text/css"/>

    <meta charset="UTF-8">
    
    <title>Spring - ZestJourney</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/bootstrap/4.6.1/css/bootstrap.min.css">
    <script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/bootstrap/4.6.1/js/bootstrap.min.js"></script>

<script src="https://npm.elemecdn.com/@waline/client@v2/dist/waline.js"></script>
<link
  rel="stylesheet"
  href="https://npm.elemecdn.com/@waline/client@v2/dist/waline.css"
/>
<meta name="generator" content="Hexo 5.4.2"></head>

</head>

<body>
    


        <div>
            <div class="container-fluid position-relative">
                <nav class="navbar navbar-expand-lg navbar-dark  text-white bg-transparent">
                    <div class="container">
                        
                        <a class="navbar-brand" href="/">💖我们的秘密基地💖</a>
                        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarText"
                            aria-controls="navbarText" aria-expanded="false" aria-label="Toggle navigation">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                        <div class="collapse navbar-collapse" id="navbarText">
                            <ul class="navbar-nav mr-auto">
                            </ul>
                            <span class="navbar-text">
                                💕愿你三冬暖，愿你春不寒🍂
                            </span>
                        </div>
                    </div>
                </nav>
                <section class="lover-background"
                    style="background-image: url(/img/banner.jpg)">
                </section>
                <section
                    class="container lover-container d-flex flex-column align-content-center justify-content-center">
                    <div class="row align-items-center pb-5 lover">
                        <div class="col">
                            <div class="d-flex flex-column">
                                <img class="mx-auto avatar-img rounded-circle"
                                    src="/img/zestaken.jpg" alt="">
                                <h4 class="mx-auto text-white pt-2">  
                                    zestaken
                                </h4>
                            </div>
                        </div>
                        <div class="col">
                            <div class="d-flex justify-content-center">
                                <div class="heart"></div>
                            </div>
                        </div>
                        <div class="col">
                            <div class="d-flex flex-column">
                                <img class="mx-auto avatar-img rounded-circle"
                                    src="/img/zinny.jpg" alt="">
                                <h4 class="mx-auto text-white pt-2">
                                    zinny
                                </h4>
                            </div>
                        </div>
                    </div>
                </section>
                <section class="main-hero-waves-area waves-area">
                    <svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
                        viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
                        <defs>
                            <path id="gentle-wave"
                                d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z">
                            </path>
                        </defs>
                        <g class="parallax">
                            <use xlink:href="#gentle-wave" x="48" y="0"></use>
                            <use xlink:href="#gentle-wave" x="48" y="3"></use>
                            <use xlink:href="#gentle-wave" x="48" y="5"></use>
                            <use xlink:href="#gentle-wave" x="48" y="7"></use>
                        </g>
                    </svg>
                </section>
            </div>

            <div id="Pjax">

  <div class="list-content mx-auto mt-5">
      <div id="article" class="list-top">
          <h5 class="list-text"> Spring
          </h5>
          <article>
              <article>
                <h1 id="spring简介"><a class="markdownIt-Anchor" href="#spring简介"></a> Spring简介</h1>
<ul>
<li>历史：
<ol>
<li>2002年，首次推出Spring框架的雏形：interface21框架</li>
<li>2004年3月24日，基于interface21框架，发布了Spring框架的1.0版本（本次学习使用的是Spring5）</li>
<li>Spring Framework的创始人：Rod Johnson</li>
</ol>
</li>
<li>Spring理念：使现有技术更加容易使用，本身整合了现有的很多技术框架。</li>
<li>SSH:struct2+Spring+Hibernate</li>
<li>SSM:SpringMVC+Spring+Mybatis</li>
<li><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-framework">官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://repo.spring.io/realse/org/springframework/spring">官网下载地址</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework">github地址</a></li>
<li>maven坐标：</li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- 安装这个包，会自动添加其它依赖的包--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;
    &lt;version&gt;5.3.3&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;

&lt;!-- 和mybatis整合需要的包 --&gt;
&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework&#x2F;spring-webmvc --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;
    &lt;version&gt;5.3.3&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>
<ul>
<li>
<p>Spring优点：</p>
<ol>
<li>是一个开源的免费的框架；</li>
<li>轻量级，非入侵式框架；</li>
<li><strong>控制反转（IOC）</strong></li>
<li><strong>面向切面编程（AOP）</strong></li>
<li>支持事务的处理</li>
<li>支持框架整合</li>
</ol>
</li>
<li>
<p>缺点：配置繁琐</p>
</li>
<li>
<p>Spring的组成：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210210093918.jpg" alt="" /></p>
</li>
<li>
<p>Spring的拓展：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210210094952.jpg" alt="" /></p>
<ul>
<li>SpringBoot：
<ul>
<li>一个快速开发的脚手架；</li>
<li>基于SpringBoot可以快速开发单个的微服务；</li>
<li>约定大于配置</li>
</ul>
</li>
<li>SpringCloud:
<ul>
<li>SpringCloud是基于SpringBoot实现的。</li>
</ul>
</li>
<li>学习SpringBoot的前提是Spring及SpringMVC</li>
</ul>
</li>
</ul>
<h1 id="ioc"><a class="markdownIt-Anchor" href="#ioc"></a> IOC</h1>
<h2 id="ioc原型"><a class="markdownIt-Anchor" href="#ioc原型"></a> IOC原型</h2>
<ul>
<li>普通接口实现：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.service;

import com.zestaken.dao.UserDao;
import com.zestaken.dao.UserDaoImpl;

&#x2F;&#x2F;在service层调用Dao层的方法进行业务操作
public class UserServiceImpl implements UserService&#123;
    &#x2F;&#x2F;直接在编写程序时写好UserDao属性
    private UserDao userDao &#x3D; new UserDaoImpl();

    @Override
    public void getUsers() &#123;
        userDao.getUsers();
    &#125;
&#125;</code></pre>
<ul>
<li>IOC注入思想实现：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.service;

import com.zestaken.dao.UserDao;

public class UserServiceImpl implements UserService&#123;
    &#x2F;&#x2F;编写程序将UserDao对象设置为从外界获取注入的值，而不是直接由程序员设置
    private UserDao userDao;

    &#x2F;&#x2F;注入UserDao的值
    public void setUserDao(UserDao userDao) &#123;
        this.userDao &#x3D; userDao;
    &#125;

    @Override
    public void getUsers() &#123;
        userDao.getUsers();
    &#125;
&#125;</code></pre>
<ul>
<li>用普通的方法实现，每一次新增UserDao接口的实现类，都需要修改UserService实现类的代码。</li>
<li>普通实现方法:程序是<strong>主动创建对象</strong>，控制权在程序员的手上。</li>
<li>IOC思想实现：使用set注入后，程序<strong>不再具有主动性</strong>，而是被动接受传递的对象。</li>
<li>优点：程序员不用再去管理对象的创建了，系统的耦合性大大降低。</li>
</ul>
<h2 id="ioc本质"><a class="markdownIt-Anchor" href="#ioc本质"></a> IOC本质</h2>
<ul>
<li>控制反转（Inversion Of Control），是一种设计思想，DI（Dependency Injection，依赖注入）是实现IOC的一种方式。</li>
<li>未使用IOC思想的面向对象编程中，对象的创建和对象间的依赖关系，完全硬编码在程序中，<strong>对象的创建由程序自己控制</strong>，使用IOC思想后，<strong>对象的创建转移给第三方</strong>，控制反转即<strong>获得依赖对象的方式反转了</strong>。</li>
<li>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式；</li>
<li>在Spring中实现IOC的是<strong>IOC容器</strong>，其<strong>实现方法是DI（依赖注入）</strong>。</li>
</ul>
<h2 id="spring的ioc实现"><a class="markdownIt-Anchor" href="#spring的ioc实现"></a> Spring的IOC实现</h2>
<ol>
<li>书写接口实现类：</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;Dao层实现
package com.zestaken.dao;

public class UserDaoImpl implements UserDao&#123;
    @Override
    public void getUsers() &#123;
        System.out.println(&quot;sql查询&quot;);
    &#125;
&#125;
&#x2F;&#x2F;Service层实现
package com.zestaken.service;

import com.zestaken.dao.UserDao;

public class UserServiceImpl implements UserService&#123;
    private UserDao userDao ;

    &#x2F;&#x2F;注入UserDao的值
    &#x2F;&#x2F;使用Spring管理的类的属性，必须由set方法设定
    public void setUserDao(UserDao userDao) &#123;
        this.userDao &#x3D; userDao;
    &#125;

    @Override
    public void getUsers() &#123;
        userDao.getUsers();
    &#125;
&#125;</code></pre>
<ol start="2">
<li>将实现类用xml的方式交给Spring管理</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;
       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans
        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;

&lt;!--    在Spring中使用bean来创建对象，--&gt;
&lt;!--    id是该类生成的对象名，class是完全限定类名--&gt;
    &lt;bean id&#x3D;&quot;userDaoImpl&quot; class&#x3D;&quot;com.zestaken.dao.UserDaoImpl&quot;&#x2F;&gt;
    &lt;bean id&#x3D;&quot;userServiceImpl&quot; class&#x3D;&quot;com.zestaken.service.UserServiceImpl&quot;&gt;
&lt;!--        name指定需要赋值的属性 ref指定传递的对象--&gt;
        &lt;property name&#x3D;&quot;userDao&quot; ref&#x3D;&quot;userDaoImpl&quot;&#x2F;&gt;
    &lt;&#x2F;bean&gt;

&lt;&#x2F;beans&gt;</code></pre>
<ol start="3">
<li>测试：</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.service;

import org.junit.jupiter.api.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class ServiceTest &#123;
    @Test
    public void userServiceImplTest()&#123;
        &#x2F;&#x2F;获取Spring的上下文对象,参数是配置文件名
        ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        &#x2F;&#x2F;现在所有的对象都交由Spring管理了，要想使用对象，只需要从Spring中取出即可（Spring中这些对象叫做bean）
        UserServiceImpl userServiceImpl &#x3D; (UserServiceImpl) context.getBean(&quot;userServiceImpl&quot;);
        &#x2F;&#x2F;获取出对象之后，即可正常使用
        userServiceImpl.getUsers();
    &#125;
&#125;</code></pre>
<ul>
<li>控制：传统的程序的对象是由程序本身控制创建的，使用Spring的对象是由Spring来创建的；</li>
<li>反转：程序本身不创建对象，而变成<strong>被动的接收对象</strong>。</li>
<li>IOC即对象由Spring来创建，管理和装配。我们只需要修改相应的配置文件，例如此处由xml文件配置，则修改xml文件即可修改程序实现。</li>
</ul>
<h2 id="spring中ioc创建对象的方式"><a class="markdownIt-Anchor" href="#spring中ioc创建对象的方式"></a> Spring中IOC创建对象的方式</h2>
<ol>
<li>通过类的无参构造方法类构造对象，默认使用这种。</li>
<li>使用有参的构造方法构造：
<ol>
<li>下标赋值：</li>
</ol>
 <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id&#x3D;&quot;exampleBean&quot; class&#x3D;&quot;examples.ExampleBean&quot;&gt;
&lt;constructor-arg index&#x3D;&quot;0&quot; value&#x3D;&quot;7500000&quot;&#x2F;&gt;
&lt;constructor-arg index&#x3D;&quot;1&quot; value&#x3D;&quot;42&quot;&#x2F;&gt;
&lt;&#x2F;bean&gt;</code></pre>
<ol start="2">
<li>类型赋值：</li>
</ol>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id&#x3D;&quot;exampleBean&quot; class&#x3D;&quot;examples.ExampleBean&quot;&gt;
 &lt;constructor-arg type&#x3D;&quot;int&quot; value&#x3D;&quot;7500000&quot;&#x2F;&gt;
 &lt;constructor-arg type&#x3D;&quot;java.lang.String&quot; value&#x3D;&quot;42&quot;&#x2F;&gt;
&lt;&#x2F;bean&gt;</code></pre>
<ol start="3">
<li>参数名赋值(常用)：</li>
</ol>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id&#x3D;&quot;exampleBean&quot; class&#x3D;&quot;examples.ExampleBean&quot;&gt;
 &lt;constructor-arg name&#x3D;&quot;years&quot; value&#x3D;&quot;7500000&quot;&#x2F;&gt;
 &lt;constructor-arg name&#x3D;&quot;ultimateAnswer&quot; value&#x3D;&quot;42&quot;&#x2F;&gt;
&lt;&#x2F;bean&gt;</code></pre>
</li>
</ol>
<h1 id="spring配置"><a class="markdownIt-Anchor" href="#spring配置"></a> Spring配置</h1>
<h2 id="alias别名"><a class="markdownIt-Anchor" href="#alias别名"></a> alias(别名)</h2>
<ul>
<li>如果配置了别名，我们也可以使用别名来获取到这个对象：</li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;alias name&#x3D;&quot;userDaoImpl&quot; alias&#x3D;&quot;userDaoImpl2&quot;&#x2F;&gt;</code></pre>
<h2 id="bean配置"><a class="markdownIt-Anchor" href="#bean配置"></a> Bean配置</h2>
<ul>
<li>id:bean的唯一标识符，相当于对象名；</li>
<li>class：bean对象所对应的类的完全限定类名</li>
<li>name：也是别名，而且那么可以同时取多个别名，并且别名之间可以用空格，<code>,</code>,<code>;</code>等来分隔</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id&#x3D;&quot;userDaoImpl&quot; class&#x3D;&quot;com.zestaken.dao.UserDaoImpl&quot; name&#x3D;&quot;zhangjie lisi,zestaken;zhangsan&quot;&#x2F;&gt;</code></pre>
<h2 id="import配置"><a class="markdownIt-Anchor" href="#import配置"></a> import配置</h2>
<ul>
<li>一般用于团队开发使用，可以将多个配置文件导入到一个配置文件从而合并为一个配置文件:</li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;import resource&#x3D;&quot;bean1.xml&quot;&#x2F;&gt;
&lt;import resource&#x3D;&quot;bean2.xml&quot;&#x2F;&gt;
&lt;import resource&#x3D;&quot;bean3.xml&quot;&#x2F;&gt;</code></pre>
<h1 id="依赖注入di"><a class="markdownIt-Anchor" href="#依赖注入di"></a> 依赖注入(DI)</h1>
<h2 id="一构造器注入"><a class="markdownIt-Anchor" href="#一构造器注入"></a> 一：构造器注入</h2>
<ul>
<li>构造器注入即有参数的构造方法来构造对象，在构造时将对象属性初始化。</li>
<li>三种方式：
<ol>
<li>下标赋值：</li>
</ol>
  <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id&#x3D;&quot;exampleBean&quot; class&#x3D;&quot;examples.ExampleBean&quot;&gt;
&lt;constructor-arg index&#x3D;&quot;0&quot; value&#x3D;&quot;7500000&quot;&#x2F;&gt;
&lt;constructor-arg index&#x3D;&quot;1&quot; value&#x3D;&quot;42&quot;&#x2F;&gt;
&lt;&#x2F;bean&gt;</code></pre>
<ol start="2">
<li>类型赋值：</li>
</ol>
 <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id&#x3D;&quot;exampleBean&quot; class&#x3D;&quot;examples.ExampleBean&quot;&gt;
 &lt;constructor-arg type&#x3D;&quot;int&quot; value&#x3D;&quot;7500000&quot;&#x2F;&gt;
 &lt;constructor-arg type&#x3D;&quot;java.lang.String&quot; value&#x3D;&quot;42&quot;&#x2F;&gt;
&lt;&#x2F;bean&gt;</code></pre>
<ol start="3">
<li>参数名赋值(常用)：</li>
</ol>
 <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id&#x3D;&quot;exampleBean&quot; class&#x3D;&quot;examples.ExampleBean&quot;&gt;
 &lt;constructor-arg name&#x3D;&quot;years&quot; value&#x3D;&quot;7500000&quot;&#x2F;&gt;
 &lt;constructor-arg name&#x3D;&quot;ultimateAnswer&quot; value&#x3D;&quot;42&quot;&#x2F;&gt;
&lt;&#x2F;bean&gt;</code></pre>
</li>
</ul>
<h2 id="二setter方法注入"><a class="markdownIt-Anchor" href="#二setter方法注入"></a> 二:setter方法注入</h2>
<ul>
<li>依赖：bean对象的创建依赖于容器；</li>
<li>注入:bean对象中的所有属性由容器来注入。</li>
<li>使用这种方式注入的属性，必须全部使用setter方法来设置属性。</li>
<li>不同类型的属性的注入方式不同：
<ol>
<li>基本类型以及String类型的注入：通过<code>value</code>来实现</li>
</ol>
  <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;zhangjie&quot;&#x2F;&gt;</code></pre>
<ol start="2">
<li>bean类型注入（即属性类型是类类型，且这个类的实现对象必须在Spring中注册）：使用<code>ref</code>:</li>
</ol>
 <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id&#x3D;&quot;address&quot; class&#x3D;&quot;com.zestaken.pojo.Address&quot;&#x2F;&gt;
&lt;bean id&#x3D;&quot;person&quot; class&#x3D;&quot;com.zestaken.pojo.Person&quot;&gt;
     &lt;property name&#x3D;&quot;address&quot; ref&#x3D;&quot;address&quot;&#x2F;&gt;
&lt;&#x2F;bean&gt;</code></pre>
<ol start="3">
<li>数组，list集合 map集合,set集合类型的注入，需要使用专门的标签：</li>
</ol>
 <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">   &lt;!-- 数组 --&gt;
       &lt;property name&#x3D;&quot;books&quot;&gt;
        &lt;array&gt;
            &lt;value&gt;红楼梦&lt;&#x2F;value&gt;
            &lt;value&gt;西游记&lt;&#x2F;value&gt;
        &lt;&#x2F;array&gt;
    &lt;&#x2F;property&gt;
    &lt;!--list集合  --&gt;
    &lt;property name&#x3D;&quot;hobbys&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;写代码&lt;&#x2F;value&gt;
            &lt;value&gt;看书&lt;&#x2F;value&gt;
        &lt;&#x2F;list&gt;
    &lt;&#x2F;property&gt;
    &lt;!--map集合  --&gt;
    &lt;property name&#x3D;&quot;card&quot;&gt;
        &lt;map&gt;
            &lt;entry key&#x3D;&quot;身份证&quot; value&#x3D;&quot;123435&quot;&#x2F;&gt;
            &lt;entry key&#x3D;&quot;银行卡&quot; value&#x3D;&quot;2340273&quot;&#x2F;&gt;
        &lt;&#x2F;map&gt;
    &lt;&#x2F;property&gt;
&lt;!--set集合  --&gt;
    &lt;property name&#x3D;&quot;games&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;lol&lt;&#x2F;value&gt;
            &lt;value&gt;csgo&lt;&#x2F;value&gt;
            &lt;value&gt;overwatch&lt;&#x2F;value&gt;
        &lt;&#x2F;set&gt;
    &lt;&#x2F;property&gt;</code></pre>
<ol start="4">
<li>Properties类型的注入：</li>
</ol>
  <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;property name&#x3D;&quot;properties&quot;&gt;
    &lt;props&gt;
        &lt;prop key&#x3D;&quot;username&quot;&gt;zhangjie&lt;&#x2F;prop&gt;
        &lt;prop key&#x3D;&quot;password&quot;&gt;12435325&lt;&#x2F;prop&gt;
    &lt;&#x2F;props&gt;
&lt;&#x2F;property&gt;</code></pre>
<ol start="5">
<li>赋值为null的注入：</li>
</ol>
  <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;property name&#x3D;&quot;girlfriend&quot;&gt;
    &lt;null&#x2F;&gt;
&lt;&#x2F;property&gt;</code></pre>
</li>
</ul>
<h2 id="三c命名空间注入"><a class="markdownIt-Anchor" href="#三c命名空间注入"></a> 三：c命名空间注入</h2>
<ul>
<li>对应构造器注入的方式，c命名空间相当于constructor-arg标签，所以必须有有参数的构造方法才能使用这种方式。</li>
<li>使用c命名空间，必须先导入对应的xml约束：</li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">xmlns:c&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;c&quot;</code></pre>
<ul>
<li>示例；</li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- c-namespace declaration with argument names --&gt;
   &lt;bean id&#x3D;&quot;beanOne&quot; class&#x3D;&quot;x.y.ThingOne&quot; c:thingTwo-ref&#x3D;&quot;beanTwo&quot;
       c:thingThree-ref&#x3D;&quot;beanThree&quot; c:email&#x3D;&quot;something@somewhere.com&quot;&#x2F;&gt;</code></pre>
<h2 id="四p命名空间注入"><a class="markdownIt-Anchor" href="#四p命名空间注入"></a> 四：p命名空间注入</h2>
<ul>
<li>对应setter的注入方式，p命名空间相当于property标签，所以必须有setter方法才能使用这种方法。</li>
<li>使用p命名空间，也必须先导入相应的xml约束：</li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;</code></pre>
<ul>
<li>示例：</li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean name&#x3D;&quot;p-namespace&quot; class&#x3D;&quot;com.example.ExampleBean&quot;
    p:email&#x3D;&quot;someone@somewhere.com&quot;&#x2F;&gt;</code></pre>
<h1 id="bean的作用域"><a class="markdownIt-Anchor" href="#bean的作用域"></a> Bean的作用域</h1>
<ol>
<li>单例模式:从一个bean中无论获取多少次获取的都是同一个对象。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210220100546.jpg" alt="" />
<ul>
<li>单例模式是bean的默认作用域，也可以显式设置：</li>
</ul>
 <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.something.DefaultAccountService&quot;&#x2F;&gt;

&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;
&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.something.DefaultAccountService&quot; scope&#x3D;&quot;singleton&quot;&#x2F;&gt;</code></pre>
</li>
<li>原型模式：每次从bean中获取的对象都是新的对象。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210220100858.jpg" alt="" />
<ul>
<li>设置原型模式：</li>
</ul>
 <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.something.DefaultAccountService&quot; scope&#x3D;&quot;prototype&quot;&#x2F;&gt;</code></pre>
</li>
<li>Request</li>
<li>Session</li>
<li>Application</li>
<li>WebSocket （后面的四个都是在web开发中使用的）</li>
</ol>
<h1 id="bean的自动装配"><a class="markdownIt-Anchor" href="#bean的自动装配"></a> Bean的自动装配</h1>
<ul>
<li>装配：有些对象的属性是另一个由Spring管理的对象，给这个属性赋值就是装配。所以不是所有由Spring管理的对象都需要装配。</li>
<li>自动装配：Spring会在上下文中自动寻找，并<strong>自动给bean装配属性</strong>。</li>
<li>Spring中的三种装配方式：
<ol>
<li>在xml中显式的配置</li>
<li>在java中显式的配置</li>
<li>隐式的自动装配bean</li>
</ol>
</li>
<li>自动装配的两种方式：
<ol>
<li>byName：会自动在容器上下文中寻找id属性值和自己对象的set方法后面的名称相同的bean。
<ol>
<li>使用byName需要保证所有bean的id唯一，并且这个bean的id值需要和自动注入的属性的对应的set方法值一致。</li>
<li>示例：</li>
</ol>
</li>
</ol>
 <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id&#x3D;&quot;userServiceImpl&quot; class&#x3D;&quot;com.zestaken.service.UserServiceImpl&quot; autowire&#x3D;&quot;byName&quot;&gt;
 &lt;!--        name指定需要赋值的属性 ref指定传递的对象--&gt;
 &lt;!--        &lt;property name&#x3D;&quot;userDao&quot; ref&#x3D;&quot;userDaoImpl&quot;&#x2F;&gt; --&gt;
&lt;&#x2F;bean&gt;</code></pre>
<ol start="2">
<li>byType:会自动在容器上下文中寻找和自己对象的类型相同的bean。</li>
<li>使用byType需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致。</li>
<li>示例：</li>
</ol>
  <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id&#x3D;&quot;userServiceImpl&quot; class&#x3D;&quot;com.zestaken.service.UserServiceImpl&quot; autowire&#x3D;&quot;byType&quot;&gt;
&lt;!--        name指定需要赋值的属性 ref指定传递的对象--&gt;
&lt;!--        &lt;property name&#x3D;&quot;userDao&quot; ref&#x3D;&quot;userDaoImpl&quot;&#x2F;&gt; --&gt;
&lt;&#x2F;bean&gt;</code></pre>
</li>
</ul>
<h1 id="spring注解开发"><a class="markdownIt-Anchor" href="#spring注解开发"></a> Spring注解开发</h1>
<ul>
<li><strong>开启注解</strong>：
<ul>
<li>扫描包中的注解：如扫描<code>@Component</code>注解<code>&lt;context:component-scan base-package=&quot;com.zestaken&quot;/&gt;</code></li>
<li>配置注解的支持：<code>&lt;context:annotation-config/&gt;</code></li>
</ul>
</li>
<li>xml与注解优缺点：
<ul>
<li>xml更加万能，维护更加方便；</li>
<li>注解需要能够修改类中的代码，维护相对困难；</li>
</ul>
</li>
<li>xml与注解配合使用：
<ul>
<li>xml用来管理bean；</li>
<li>注解只负责属性注入，即<code>@Value</code>。</li>
</ul>
</li>
</ul>
<h2 id="注解注册bean"><a class="markdownIt-Anchor" href="#注解注册bean"></a> 注解注册bean</h2>
<ul>
<li><code>@Component</code>注解：
<ul>
<li>组件注解，==放在类上==,说明这个类被Spring管理了，即==注册lbean==；</li>
<li>自动注入的bean对象名是==类名的首字母小写==形成的。</li>
<li>等价于<code>&lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.zestaken.dao.UserDaoImpl&quot; /&gt;</code></li>
</ul>
</li>
<li><code>@Component</code>为mvc模式形成的衍生注解,这些==注解功能完全相同==，只是为了更好的区分架构层而使用：
<ul>
<li>dao层:<code>@Repository</code></li>
<li>service层：<code>@Service</code></li>
<li>controller层：<code>@Controller</code></li>
</ul>
</li>
</ul>
<h2 id="注解注入属性"><a class="markdownIt-Anchor" href="#注解注入属性"></a> 注解注入属性</h2>
<ul>
<li><code>@Value(&quot;属性值&quot;)</code>注解：
<ul>
<li>在基本类型以及字符串类型对象上使用，为创建的对象的的对应属性赋值。</li>
<li>等价于<code>&lt;property name=&quot;name&quot; value=&quot;zestaken&quot;/&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="注解配置作用域"><a class="markdownIt-Anchor" href="#注解配置作用域"></a> 注解配置作用域</h2>
<ul>
<li><code>@Scope(&quot;作用域&quot;)</code>注解：
<ul>
<li>用于配置bean对象的作用域，如：<code>@Scope(&quot;prototype&quot;)</code></li>
</ul>
</li>
</ul>
<h2 id="注解实现自动装配"><a class="markdownIt-Anchor" href="#注解实现自动装配"></a> 注解实现自动装配</h2>
<ul>
<li>注解使用配置：
<ol>
<li>导入约束：
<ul>
<li><code>xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</code></li>
<li><code> http://www.springframework.org/schema/context</code></li>
<li><code>https://www.springframework.org/schema/context/spring-context.xsd&quot;</code><br />
2.配置注解的支持：<code>&lt;context:annotation-config/&gt;</code></li>
</ul>
</li>
<li>示例：</li>
</ol>
  <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;
    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
    xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;
    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans
        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd
        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context
        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;

    &lt;context:annotation-config&#x2F;&gt;

&lt;&#x2F;beans&gt;</code></pre>
</li>
<li><code>@Autowired</code>注解：
<ul>
<li>使用该注解在类中需要导入包:<code>import org.springframework.beans.factory.annotation.Autowired;</code>
<ul>
<li>这个包需要在maven中配置导入。</li>
</ul>
</li>
<li>直接在==属性==上使用即可，也可以在set方法上使用。</li>
<li>使用这个注解，可以==不用编写属性对应的set方法==。前提是要被装配的属性在Spring容器中存在。</li>
<li>配置注解<code>@Autowired(required = false)</code>可以使属性可以为空，默认不能。与注解<code>@Nullable</code>作用相同。</li>
<li><code>@Autowird</code>注解：会自动根据该属性的==类型或者名字==来自动装配;
<ul>
<li>可以配合使用<code>@Qualifier(value = &quot;属性名&quot;)</code>来限定根据bean id的名字来装配。</li>
</ul>
</li>
<li>示例：</li>
</ul>
  <pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.service;

import com.zestaken.dao.UserDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;

public class UserServiceImpl implements UserService&#123;
    @Autowired
    @Qualifier(value &#x3D; &quot;userDaoImpl&quot;)
    private UserDao userDao ;

    &#x2F;&#x2F;注入UserDao的值
    &#x2F;&#x2F;使用Spring管理的类的属性，必须由set方法设定
    public void setUserDao(UserDao userDao) &#123;
        this.userDao &#x3D; userDao;
    &#125;

    @Override
    public void getUsers() &#123;
        userDao.getUsers();
    &#125;
&#125;</code></pre>
</li>
<li><code>@Resource</code>注解：
<ul>
<li><code>@Resource</code>注解是java==原生==的，无需导入包；</li>
<li><code>@Resource</code>相当于拥有<code>@Autowired</code>和<code>@Qualifier</code>两个注解的功能。</li>
<li>直接使用该注解，和<code>@Autowired</code>一样；</li>
<li>该注解可以设置参数，限定查找的bean id属性名，如：<code>@Resource(name = &quot;userDaoImpl&quot;)</code>.</li>
</ul>
</li>
</ul>
<h1 id="使用java来配置spring"><a class="markdownIt-Anchor" href="#使用java来配置spring"></a> 使用Java来配置Spring</h1>
<ul>
<li>本质：使用一个java配置类通过注解的方式来完全取代xml配置文件。</li>
</ul>
<ol>
<li>配置类：</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.config;

import com.zestaken.dao.UserDao;
import com.zestaken.dao.UserDaoImpl;
import com.zestaken.service.UserService;
import com.zestaken.service.UserServiceImpl;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig &#123;

    @Bean
    public UserDao userDao() &#123;
        return new UserDaoImpl();
    &#125;

    @Bean
    public UserService userService() &#123;
        return new UserServiceImpl();
    &#125;
&#125;</code></pre>
<ul>
<li><code>@Configuration</code>注解：在配置类上面使用，代表这是一个配置类。（这个配置类的底层实质也是一个被Spring容器管理的类）</li>
<li><code>@Bean</code>注解：类似xml文件中的bean标签的作用，用于设置bean对象的方法之上：
<ul>
<li>这个==方法的名字，相当于bean对象中的id属性==；</li>
<li>这个==方法的返回值，相当于bean对象中的class属性==。</li>
</ul>
</li>
<li>还有一些诸如扫描包，导入其它配置类的注解等。</li>
</ul>
<ol start="2">
<li>被注册到Spring容器的类</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;UserDao
package com.zestaken.dao;

import org.springframework.stereotype.Component;

@Component
public class UserDaoImpl implements UserDao&#123;
    @Override
    public void getUsers() &#123;
        System.out.println(&quot;sql查询&quot;);
    &#125;
&#125;

&#x2F;&#x2F;UserService
package com.zestaken.service;

import com.zestaken.dao.UserDao;

import org.springframework.stereotype.Component;

import javax.annotation.Resource;

@Component
public class UserServiceImpl implements UserService&#123;

    @Resource
    private UserDao userDao ;

    &#x2F;&#x2F;注入UserDao的值
    &#x2F;&#x2F;使用Spring管理的类的属性，必须由set方法设定
    public void setUserDao(UserDao userDao) &#123;
        this.userDao &#x3D; userDao;
    &#125;

    @Override
    public void getUsers() &#123;
        userDao.getUsers();
    &#125;
&#125;</code></pre>
<ul>
<li>和普通注解开发一样。</li>
<li>测试：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.service;

import com.zestaken.config.AppConfig;
import org.junit.jupiter.api.Test;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class ServiceTest &#123;
    @Test
    public void  userServiceImplTest()&#123;
        &#x2F;&#x2F;获取Spring的上下文对象,此处使用AnnotationConfig
        AnnotationConfigApplicationContext annotationConfigApplicationContext &#x3D; new AnnotationConfigApplicationContext(AppConfig.class);
        &#x2F;&#x2F;现在所有的对象都交由Spring管理了，要想使用对象，只需要从Spring中取出即可（Spring中这些对象叫做bean）
        UserService userServiceImpl &#x3D; (UserService)annotationConfigApplicationContext.getBean(&quot;userService&quot;);
        &#x2F;&#x2F;获取出对象之后，即可正常使用
        userServiceImpl.getUsers();
    &#125;
&#125;</code></pre>
<ul>
<li><strong>获取上下文的方式</strong>：<code>AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);</code>
<ul>
<li><strong>参数</strong>:参数是要使用的配置类的class属性值。</li>
</ul>
</li>
</ul>
<h1 id="aop"><a class="markdownIt-Anchor" href="#aop"></a> AOP</h1>
<ul>
<li><strong>AOP(Aspect Oriented Programming)</strong>:面向切面编程，通过==预编译技术和运行期间动态代理==实现程序功能的统一维护的一种技术。</li>
<li>Spring中AOP：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210228205043.jpg" alt="" /></li>
<li>AOP在Spring中的作用：
<ul>
<li>提供声明式事务：允许用户自定义切面。</li>
</ul>
</li>
</ul>
<h2 id="spring中aop概念"><a class="markdownIt-Anchor" href="#spring中aop概念"></a> Spring中AOP概念</h2>
<ul>
<li><strong>横切关注点</strong>：
<ul>
<li>跨越应用程序多个模块的方法或功能。</li>
<li>与我们业务逻辑无关的，但是需要我们关注的的部分，就是横切关注点，如日志，安全，缓存和事务等。</li>
</ul>
</li>
<li><strong>切面（Aspect）</strong>:
<ul>
<li>横切关注点被模块化的特殊对象；</li>
<li>切面==是一个类==。</li>
</ul>
</li>
<li><strong>通知（Advice）</strong>:
<ul>
<li>切面必须要完成的工作；</li>
<li>==通知是切面类中的一个方法==。</li>
<li>Spring中支持五种类型的Advice:
<ol>
<li><strong>前置通知</strong>:
<ol>
<li>连接点：方法前；</li>
<li>实现接口：<code>org.springframework.aop.MethodBeforeAdvice</code></li>
</ol>
</li>
<li><strong>后置通知</strong>：
<ol>
<li>连接点：方法后；</li>
<li>实现接口：<code>org.springframework.aop.AfterReturningAdvice</code></li>
</ol>
</li>
<li><strong>环绕通知</strong>：
<ol>
<li>连接点：方法前后；</li>
<li>实现接口：<code>org.aopalliance.intercept.MethodInterceptor</code></li>
</ol>
</li>
<li><strong>异常抛出通知</strong>：
<ol>
<li>连接点：方法抛出异常；</li>
<li>实现接口：<code> org.springframework.aop.ThrowsAdvice</code></li>
</ol>
</li>
<li><strong>引介通知</strong>：
<ol>
<li>连接点：类中增加新的方法属性。</li>
<li>实现接口：<code>org.springframework.aop.IntroductionInterceptor</code></li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li><strong>目标（Target）</strong>：
<ul>
<li>被通知的对象</li>
</ul>
</li>
<li><strong>代理(Proxy)</strong>:
<ul>
<li>向目标对象应用通知之后创建的==对象==；</li>
</ul>
</li>
<li><strong>切入点（PointCut）</strong>：
<ul>
<li>切面通知执行“地点”的定义；</li>
</ul>
</li>
<li><strong>连接点（JointPoint）</strong>：
<ul>
<li>与切入点匹配的执行点。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210228211039.jpg" alt="" /></li>
</ul>
</li>
</ul>
<h2 id="spring实现aop"><a class="markdownIt-Anchor" href="#spring实现aop"></a> Spring实现AOP</h2>
<ul>
<li>不论采用何种方法，首先都需要先导入一个织入包：</li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.aspectj&#x2F;aspectjweaver --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt;
    &lt;version&gt;1.9.6&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>
<h3 id="方式一使用spring的api接口实现aop"><a class="markdownIt-Anchor" href="#方式一使用spring的api接口实现aop"></a> 方式一：使用Spring的API接口实现AOP</h3>
<ul>
<li>主功能的接口：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.service;

public interface UserService &#123;
    void add();
    void delete();
&#125;</code></pre>
<ul>
<li>实现主功能的类：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.service;

public class UserServiceImpl implements UserService &#123;
    @Override
    public void add() &#123;
        System.out.println(&quot;add...&quot;);
    &#125;

    @Override
    public void delete() &#123;
        System.out.println(&quot;delete...&quot;);
    &#125;
&#125;</code></pre>
<ul>
<li>在主功能的方法前加上日志的类：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.log;

import org.springframework.aop.MethodBeforeAdvice;

import java.lang.reflect.Method;

public class Log implements MethodBeforeAdvice &#123;
    @Override
    public void before(Method method, Object[] args, Object target) throws Throwable &#123;
        System.out.println(target.getClass().getName()+&quot;的&quot;+method.getName()+&quot;方法被执行了&quot;);
    &#125;
&#125;</code></pre>
<ul>
<li>before方法的参数：
<ul>
<li>method:要执行的目标对象的方法</li>
<li>args：要执行的目标方法的参数</li>
<li>target：目标对象</li>
</ul>
</li>
<li>要增加到切点的的类，应该==根据这个类中方法插入的位置，来实现不用的Spring的aop的API接口==.</li>
<li>在applicationContext.xml文件中==注册主功能类和增加日志方法的类,并配置aop==：</li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;
       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
       xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;
       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans
        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd
        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop
        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt;

&lt;!--    注册主功能类和增加日志功能的类--&gt;
    &lt;bean id&#x3D;&quot;userServiceImpl&quot; class&#x3D;&quot;com.zestaken.service.UserServiceImpl&quot;&#x2F;&gt;
    &lt;bean id&#x3D;&quot;log&quot; class&#x3D;&quot;com.zestaken.log.Log&quot;&#x2F;&gt;

&lt;!--    配置aop，需要导入约束--&gt;
    &lt;aop:config&gt;
&lt;!--        配置切入点--&gt;
&lt;!--        id是切入点的名字--&gt;
&lt;!--        expression描述切入点的位置,使用execution表达式,execution表达式的格式为（修饰词，返回值，类名，方法名，参数）--&gt;
        &lt;aop:pointcut id&#x3D;&quot;pointcut1&quot; expression&#x3D;&quot;execution(* com.zestaken.service.UserService.*(..))&quot;&#x2F;&gt;
&lt;!--        配置增加到切入点的方法--&gt;
        &lt;aop:advisor advice-ref&#x3D;&quot;log&quot; pointcut-ref&#x3D;&quot;pointcut1&quot;&#x2F;&gt;
    &lt;&#x2F;aop:config&gt;

&lt;&#x2F;beans&gt;</code></pre>
<ul>
<li>导入的约束：
<ul>
<li><code>xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</code></li>
<li><code>http://www.springframework.org/schema/aop</code></li>
<li><code>https://www.springframework.org/schema/aop/spring-aop.xsd</code></li>
</ul>
</li>
<li>excution表达式描述切入点的位置，==其中可以用<code>*</code>通配符来表示适用于各种修饰词，返回值，方法名，用<code>(..)</code>表示方法的任何参数==。</li>
<li>测试aop：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import com.zestaken.service.UserService;

import org.junit.jupiter.api.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class MyTest &#123;
    @Test
    public void aopTest() &#123;
        &#x2F;&#x2F;获取配置文件生成上下文对象
        ApplicationContext classPathXmlApplicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        &#x2F;&#x2F;获取接口
        UserService userService &#x3D; (UserService)classPathXmlApplicationContext.getBean(&quot;userServiceImpl&quot;);
        &#x2F;&#x2F;测试方法
        userService.add();
        userService.delete();
    &#125;
&#125;</code></pre>
<ul>
<li><strong>==注意：aop的本质是动态代理，动态代理的是接口，所以从容器中获取出来的应该是接口类型的对象==</strong>。</li>
</ul>
<h3 id="方法二自定义方法实现aop"><a class="markdownIt-Anchor" href="#方法二自定义方法实现aop"></a> 方法二：自定义方法实现AOP</h3>
<ul>
<li>主功能类与接口不变。</li>
<li>在主功能类前增加日志功能的类：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Log &#123;
    void before()&#123;
        System.out.println(&quot;before....&quot;);
    &#125;
&#125;</code></pre>
<ul>
<li>==无需实现接口==，只是一个普通的类。</li>
<li>配置文件：</li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;aop:config&gt;
    &lt;aop:aspect ref&#x3D;&quot;log&quot;&gt;
        &lt;aop:pointcut id&#x3D;&quot;pointcut2&quot; expression&#x3D;&quot;execution(* com.zestaken.service.UserServiceImpl.*(..))&quot;&#x2F;&gt;
        &lt;aop:before method&#x3D;&quot;before&quot; pointcut-ref&#x3D;&quot;pointcut2&quot;&#x2F;&gt;
    &lt;&#x2F;aop:aspect&gt;
&lt;&#x2F;aop:config&gt;</code></pre>
<ul>
<li>在类注册好，以及导入必须的约束的情况下，修改aop的配置。</li>
<li><code>&lt;aop:aspect&gt;</code>标签中，用==属性ref设置需要放入切面的方法==</li>
<li><code>&lt;aop:pointcut&gt;</code>标签中，正常设置切入点。</li>
<li><code>&lt;aop:before&gt;</code>以及<code>&lt;aop:after&gt;</code>等标签设置将绑定的方法==放入哪个位置，以及放入的方式==。</li>
</ul>
<h3 id="方法三使用注解实现aop"><a class="markdownIt-Anchor" href="#方法三使用注解实现aop"></a> 方法三：使用注解实现AOP</h3>
<ul>
<li><strong>只修改实现增强功能的类以及xml文件</strong>。</li>
<li>实现增强功能的类:</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect
public class Log &#123;

    @Before(&quot;execution(* com.zestaken.service.UserServiceImpl.*(..))&quot;)
    void before()&#123;
        System.out.println(&quot;before....&quot;);
    &#125;
&#125;</code></pre>
<ul>
<li><code>@Aspect</code>注解：表示该类是用于切面的增强功能的类。</li>
<li><code>@Before</code>注解：表示切入的方式，参数是切入点的位置。
<ul>
<li>可以有多种切入方式。如<code>@After</code>，<code>@Around</code>等。</li>
</ul>
</li>
<li>可以给通知方法传递参数**<code>ProceedingJoinPoint joinPoint</code>连接点对象**，作用是获取切入点的信息。如方法名之类的。</li>
<li>xml配置文件：==省去aop配置，开启aop的注解功能==。但是aop的相关约束还是要有。</li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;aop:aspectj-autoproxy proxy-target-class&#x3D;&quot;false&quot;&#x2F;&gt;</code></pre>
<ul>
<li>在注册了相关的bean之后，再开启aop的注解。</li>
<li>aop的动态代理默认是用jdk方式实现的 ，将proxy-target-class属性设为true会改为使用cglib实现。</li>
<li>proxy-target-class属性可以省略，这样默认使用jdk方式。</li>
</ul>
<h1 id="spring整合mybatis"><a class="markdownIt-Anchor" href="#spring整合mybatis"></a> Spring整合Mybatis</h1>
<h2 id="导入相关jar包"><a class="markdownIt-Anchor" href="#导入相关jar包"></a> 导入相关jar包</h2>
<ol>
<li>junit</li>
</ol>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;
    &lt;version&gt;4.13&lt;&#x2F;version&gt;
    &lt;scope&gt;test&lt;&#x2F;scope&gt;
&lt;&#x2F;dependency&gt;</code></pre>
<ol start="2">
<li>mybatis</li>
</ol>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;
    &lt;version&gt;3.5.6&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>
<ol start="3">
<li>mysql数据库</li>
</ol>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;
    &lt;version&gt;8.0.23&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>
<ol start="4">
<li>Spring基本包</li>
</ol>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;
    &lt;version&gt;5.3.3&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>
<ol start="5">
<li>Spring的AOP织入包</li>
</ol>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt;
    &lt;version&gt;1.9.6&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>
<ol start="6">
<li>Spring操作数据库必须的包</li>
</ol>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;
    &lt;version&gt;5.3.4&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>
<ol start="7">
<li>整合Mybatis和Spring的包：mybatis-spring</li>
</ol>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt;
    &lt;version&gt;2.0.6&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>
<h2 id="spring整合mybatis方式一"><a class="markdownIt-Anchor" href="#spring整合mybatis方式一"></a> Spring整合Mybatis方式一</h2>
<p><a target="_blank" rel="noopener" href="http://mybatis.org/spring/zh/index.html">Mybatis-spring文档</a></p>
<ol>
<li>编写Spring对Mybatis的配置文件：</li>
</ol>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;!--suppress ALL --&gt;
&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;
       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans
        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;
&lt;!--    注册DataSource 使用Spring的提供的JDBC来替换Mybatis的数据源配置--&gt;
    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.cj.jdbc.Driver&quot;&#x2F;&gt;
        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;youth_study&quot;&#x2F;&gt;
        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;
        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;
    &lt;&#x2F;bean&gt;

&lt;!--    sqlSessionFactory--&gt;
    &lt;bean id&#x3D;&quot;sqlSessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;
&lt;!--        绑定Mybatis的配置文件，使这两个配置文件同时作用，各自负责一部分配置--&gt;
        &lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;classpath:mybatis-config.xml&quot;&#x2F;&gt;
        &lt;!-- 绑定mapper.xml文件，起到注册mapper的作用 --&gt;
        &lt;property name&#x3D;&quot;mapperLocations&quot; value&#x3D;&quot;classpath:com&#x2F;zestaken&#x2F;dao&#x2F;T_collegeMapper.xml&quot;&#x2F;&gt;
    &lt;&#x2F;bean&gt;

&lt;!--    sqlSessionTemplate：就是实际使用的sqlSession--&gt;
    &lt;bean id&#x3D;&quot;sqlSessionTemplate&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;
&lt;!--        只能使用构造器注入sqlSessionFactory，因为没有set方法--&gt;
        &lt;constructor-arg index&#x3D;&quot;0&quot; ref&#x3D;&quot;sqlSessionFactory&quot;&#x2F;&gt;
    &lt;&#x2F;bean&gt;
&lt;&#x2F;beans&gt;</code></pre>
<ul>
<li>这是一个Spring配置文件，==Spring配置文件的约束要有==。</li>
<li><strong>配置数据源（datasource）</strong>：使用<code>org.springframework.jdbc.datasource.DriverManagerDataSource</code>类。具体配置与mybatis一样。</li>
<li><strong>配置sqlSessionFactory</strong>：
<ul>
<li>使用<code>org.mybatis.spring.SqlSessionFactoryBean</code>类；</li>
<li>配置使用的数据源；</li>
<li>导入mybatis本来的配置；</li>
<li>导入mapper的配置。</li>
</ul>
</li>
<li><strong>配置sqlSessionTemplate</strong>:
<ul>
<li>使用<code>org.mybatis.spring.SqlSessionTemplate</code>类；</li>
<li>用以==取代原来的sqlSession对象。</li>
<li>向sqlSessionTemplate==注入sqlSessionFactory==，并且只能使用构造器注入，因为没有set方法。</li>
</ul>
</li>
<li><strong>将mapper实现类注册为bean</strong>：
<ul>
<li>==将sqlSessionTemplate==注入到mapper实现类中去。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>编写mapper实现类</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.dao;

import com.zestaken.pojo.T_college;

import org.mybatis.spring.SqlSessionTemplate;

import java.util.List;

public class T_collegeMapperImpl implements T_collegeMapper &#123;

&#x2F;&#x2F;    需要导入包，SqlSessionTemplate模板或得sqlSession来执行操作
    private SqlSessionTemplate sqlSession;

&#x2F;&#x2F;设置sqlSession的set方法，方便Spring的注入
    public void setSqlSession(SqlSessionTemplate sqlSession) &#123;
        this.sqlSession &#x3D; sqlSession;
    &#125;


    public List&lt;T_college&gt; getT_collegeList() &#123;
        T_collegeMapper t_collegeMapper &#x3D; sqlSession.getMapper(T_collegeMapper.class);
        List&lt;T_college&gt; t_collegeList &#x3D; t_collegeMapper.getT_collegeList();

        return t_collegeList;
    &#125;
&#125;</code></pre>
<ul>
<li>这个实现类需要实现mapper接口中的方法；</li>
<li>同时==还需创建SqlSessionTemplate属性，并设置它对应的set方法==。
<ul>
<li><code>SqlSessionTemplate属性</code>需要导入包：<code>org.mybatis.spring.SqlSessionTemplate</code></li>
</ul>
</li>
<li>相当于将==实际使用时获取mapper，执行对应sql语句的步骤直接放到这个实现类中去完成==，实际使用的时候，只需==获取该实现类的bean，调用相应的方法即可==。<br />
4.Spring配置文件：</li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;!--suppress ALL --&gt;
&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;
       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans
        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;
&lt;!--将数据库操作实现类注册到Spring--&gt;
    &lt;bean id&#x3D;&quot;t_collegeMapperImpl&quot; class&#x3D;&quot;com.zestaken.dao.T_collegeMapperImpl&quot;&gt;
        &lt;property name&#x3D;&quot;sqlSession&quot; ref&#x3D;&quot;sqlSessionTemplate&quot;&#x2F;&gt;
    &lt;&#x2F;bean&gt;
&lt;&#x2F;beans&gt;</code></pre>
<ol start="5">
<li>mybatis-config.xml配置文件：</li>
</ol>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;
        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;
&lt;!-- 核心配置文件 --&gt;
&lt;configuration&gt;

&lt;&#x2F;configuration&gt;</code></pre>
<ol start="6">
<li>测试：</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void getT_collegeListTest()&#123;
    ClassPathXmlApplicationContext classPathXmlApplicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;spring-dao.xml&quot;);
    T_collegeMapper t_collegeMapperImpl &#x3D; classPathXmlApplicationContext.getBean(&quot;t_collegeMapperImpl&quot;, T_collegeMapper.class);

    List&lt;T_college&gt; t_collegeList &#x3D; t_collegeMapperImpl.getT_collegeList();
    for(T_college college : t_collegeList)&#123;
        System.out.println(college);
    &#125;
&#125;</code></pre>
<ul>
<li>Spring整合Mybatis的常用配置方法：
<ul>
<li>mybatis自己的配置文件(一般是mybatis-config.xml)中只放别名和设置的配置；(==将与Spring对Mybaits的配置相同的配置全部移除，如数据源配置，mapper注册等==)</li>
<li>关于Spring的Mybatis配置单独创建一个Spring配置文件来管理；</li>
<li>Spring自己的配置（如注册bean等）用一个单独的Spring配置文件来管理。</li>
</ul>
</li>
</ul>
<h2 id="spring整合mybatis方式二"><a class="markdownIt-Anchor" href="#spring整合mybatis方式二"></a> Spring整合Mybatis方式二</h2>
<ul>
<li>在方式一的基础上==只对mapper实现类获取SqlSessionTemplate的方式作了简化==；</li>
<li>mapper实现类：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.dao;

import com.zestaken.pojo.T_college;

import org.apache.ibatis.session.SqlSession;
import org.mybatis.spring.support.SqlSessionDaoSupport;

import java.util.List;

public class T_collegeMapperImpl extends SqlSessionDaoSupport implements T_collegeMapper &#123;

    public List&lt;T_college&gt; getT_collegeList() &#123;
        SqlSession sqlSession &#x3D; getSqlSession();
        T_collegeMapper t_collegeMapper &#x3D; sqlSession.getMapper(T_collegeMapper.class);
        List&lt;T_college&gt; t_collegeList &#x3D; t_collegeMapper.getT_collegeList();

        return t_collegeList;
    &#125;
&#125;</code></pre>
<ul>
<li>mapper实现类需要==继承SqlSessionDaoSupport类==，使用这个类需要导入包：<code>org.mybatis.spring.support.SqlSessionDaoSupport</code></li>
<li>实现类==无需再设置SqlSessionTemplate属性==，可以直接通过==getSqlSession方法获取SqlSessionTemplate对象==。</li>
<li>mapper实现类注册bean</li>
</ul>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--将数据库操作实现类注册到Spring--&gt;
    &lt;bean id&#x3D;&quot;t_collegeMapperImpl&quot; class&#x3D;&quot;com.zestaken.dao.T_collegeMapperImpl&quot;&gt;
        &lt;property name&#x3D;&quot;sqlSessionFactory&quot; ref&#x3D;&quot;sqlSessionFactory&quot;&#x2F;&gt;
    &lt;&#x2F;bean&gt;</code></pre>
<ul>
<li>虽然无需再向mapper实现类中注入sqlSessionTemplate，但是需要==注入sqlSessionFactory==,用来产生SqlSessionTemplate对象。</li>
</ul>
<h2 id="spring中事务管理"><a class="markdownIt-Anchor" href="#spring中事务管理"></a> Spring中事务管理</h2>
<ul>
<li><strong>事务(Transaction)</strong>：把一组业务绑在一起，看成一个业务，这些业务当且仅当所有业务都执行成功时，每一个业务才能成功执行，只要有一个业务没有成功，那么最后，所有业务都是失败的结果。</li>
<li><strong>事务作用</strong>：确保数据的完整性与一致性。</li>
<li><strong>事务的ACID属性</strong>：
<ol>
<li><strong>原子性（atomicity）</strong>。一个事务是一个不可分割的工作单位，事务中包括的操作==要么都做，要么都不做==。</li>
<li><strong>一致性（consistency）</strong>。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。</li>
<li><strong>隔离性（isolation）</strong>。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，==并发执行的各个事务之间不能互相干扰==。</li>
<li><strong>持久性（durability）</strong>。持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</li>
</ol>
</li>
<li>Spring支持两种事务：
<ul>
<li>声明式事务（又称交由容器管理事务）；</li>
<li>编程式事务：在程序中通过try/catch实现事务。</li>
</ul>
</li>
</ul>
<h3 id="声明式事务配置"><a class="markdownIt-Anchor" href="#声明式事务配置"></a> 声明式事务配置</h3>
<ol>
<li>在Spring对Mybatis的配置文件中==开启声明式事务==：</li>
</ol>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--    配置声明式事务--&gt;
    &lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;
    &lt;&#x2F;bean&gt;</code></pre>
<ul>
<li>需要给transactionManger==注入datasource数据源==。</li>
</ul>
<ol start="2">
<li>结合AOP实现事务的织入：</li>
</ol>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--    结合aop实现事务的织入--&gt;
&lt;!--    配置事务通知--&gt;
    &lt;tx:advice id&#x3D;&quot;txAdvice&quot; transaction-manager&#x3D;&quot;transactionManager&quot;&gt;
&lt;!--        给具体的方法配置事务--&gt;
&lt;!--配置每个方法事务的特性,如传播性propagation--&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name&#x3D;&quot;getT_collegeList&quot; propagation&#x3D;&quot;REQUIRED&quot;&#x2F;&gt;
        &lt;&#x2F;tx:attributes&gt;
    &lt;&#x2F;tx:advice&gt;

&lt;!--    配置事务切入--&gt;
    &lt;aop:config&gt;
        &lt;aop:pointcut id&#x3D;&quot;txPointCut&quot;  expression&#x3D;&quot;execution(* com.zestaken.dao.*.*(..))&quot;&#x2F;&gt;
        &lt;aop:advisor advice-ref&#x3D;&quot;txAdvice&quot; pointcut-ref&#x3D;&quot;txPointCut&quot;&#x2F;&gt;
    &lt;&#x2F;aop:config&gt;</code></pre>
<ul>
<li>配置事务通知（即使用tx标签）需要导入tx的约束：
<ul>
<li><code>xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</code></li>
<li><code> http://www.springframework.org/schema/tx</code></li>
<li><code>http://www.springframework.org/schema/tx/spring-tx.xsd</code></li>
</ul>
</li>
<li>给具体的方法配置事务：
<ul>
<li>以后在切入点，只要==方法名和配置相同的方法，就会被配置上事务==。</li>
</ul>
</li>
<li>配置事务的切入：
<ul>
<li>通过切入的方式，使事务在具体的位置生效。</li>
</ul>
</li>
<li>最终效果：
<ul>
<li>一个配置了事务的方法中，对数据库的操作中，只要有一个失败了，其余的所有操作都不会生效。</li>
</ul>
</li>
</ul>

              </article>
          </article>
      </div>
  </div>

</div>



        </div>


        <!-- <div class="p-5 text-center ">
  <p class="h6"> <a href="https://beian.miit.gov.cn/" target="_blank">蜀ICP备2021022902号-1</a> ※ <a
          href="https://beian.mps.gov.cn/#/query/webSearch" target="_blank">川公网安备51010802032250号</a></p>
</div> -->

<!-- <div class="p-5 text-center">
  <img src="/img/beian_icon.png" alt="备案图标" class="icon" style="max-width: 48px; max-height: 48px; vertical-align: middle;">
  <p class="h6">
    <a href="https://beian.miit.gov.cn/" target="_blank">蜀ICP备2021022902号-1</a> ※
    <a href="https://beian.mps.gov.cn/#/query/webSearch" target="_blank">川公网安备51010802032250号</a>
  </p>
</div> -->

<div class="p-5 text-center ">
  <p class="h6"> zestaken ❤️ zinny </p>
</div>
</body>

</html>