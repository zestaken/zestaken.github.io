<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.zestaken.top","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":true,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="总结  String类的charAt()与toCharArray()实现原理  例题：ip-地址无效化-1108 看一下charAt()的源码：  public char charAt(int index) &amp;#123;     if ((index &lt; 0) || (index &gt;&#x3D; value.length)) &amp;#123;         throw new Stri">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode-字符串">
<meta property="og:url" content="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/LeetCode-%E5%AD%97%E7%AC%A6%E4%B8%B2/index.html">
<meta property="og:site_name" content="ZestJourney">
<meta property="og:description" content="总结  String类的charAt()与toCharArray()实现原理  例题：ip-地址无效化-1108 看一下charAt()的源码：  public char charAt(int index) &amp;#123;     if ((index &lt; 0) || (index &gt;&#x3D; value.length)) &amp;#123;         throw new Stri">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210611201714.png">
<meta property="og:image" content="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210611202515.png">
<meta property="og:image" content="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210611204856.png">
<meta property="og:image" content="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210611205634.png">
<meta property="og:image" content="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210611211051.png">
<meta property="og:image" content="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/BuLLAf.png">
<meta property="og:image" content="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210907223838.png">
<meta property="og:image" content="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210908095417.png">
<meta property="og:image" content="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210909224120.png">
<meta property="og:image" content="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/dzELwI.png">
<meta property="og:image" content="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210911131211.png">
<meta property="og:image" content="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211114114926.png">
<meta property="article:published_time" content="2021-06-11T11:49:16.000Z">
<meta property="article:modified_time" content="2022-09-17T11:41:22.000Z">
<meta property="article:author" content="Zestaken">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210611201714.png">


<link rel="canonical" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/LeetCode-%E5%AD%97%E7%AC%A6%E4%B8%B2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/LeetCode-%E5%AD%97%E7%AC%A6%E4%B8%B2/index.html","path":"/post/技术笔记/LeetCode/LeetCode-字符串/index.html","title":"Leetcode-字符串"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Leetcode-字符串 | ZestJourney</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">ZestJourney</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">乐游记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.</span> <span class="nav-text"> 总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#string%E7%B1%BB%E7%9A%84charat%E4%B8%8Etochararray%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.1.</span> <span class="nav-text"> String类的charAt()与toCharArray()实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stringbuilder%E7%9A%84append%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">1.2.</span> <span class="nav-text"> StringBuilder的append()方法的参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stringbuilder%E7%9A%84insert%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8"><span class="nav-number">1.3.</span> <span class="nav-text"> StringBuilder的insert()方法使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string%E4%B8%8Estringbuilder"><span class="nav-number">1.4.</span> <span class="nav-text"> String与StringBuilder</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#foreach%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">1.5.</span> <span class="nav-text"> foreach循环的原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-ip-%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96-1108"><span class="nav-number">2.</span> <span class="nav-text"> 1. IP 地址无效化 1108</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#java%E8%A7%A3%E6%B3%95"><span class="nav-number">2.1.</span> <span class="nav-text"> java解法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D-242"><span class="nav-number">3.</span> <span class="nav-text"> 2. 有效的字母异位词 242</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#java%E8%A7%A3%E6%B3%95-2"><span class="nav-number">3.1.</span> <span class="nav-text"> Java解法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2-205"><span class="nav-number">4.</span> <span class="nav-text"> 3. 同构字符串 205</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#java%E8%A7%A3%E6%B3%95-3"><span class="nav-number">4.1.</span> <span class="nav-text"> Java解法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-647"><span class="nav-number">5.</span> <span class="nav-text"> 4. 回文子串 647</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#java%E8%A7%A3%E6%B3%95-4"><span class="nav-number">5.1.</span> <span class="nav-text"> Java解法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E8%AE%A1%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2-696"><span class="nav-number">6.</span> <span class="nav-text"> 5. 计数二进制子串 696</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#java%E8%A7%A3%E6%B3%95-5"><span class="nav-number">6.1.</span> <span class="nav-text"> Java解法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8-ii-227"><span class="nav-number">7.</span> <span class="nav-text"> 6. 基本计算器 II 227</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#java%E8%A7%A3%E6%B3%95-6"><span class="nav-number">7.1.</span> <span class="nav-text"> Java解法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E5%AE%9E%E7%8E%B0-strstr-28"><span class="nav-number">8.</span> <span class="nav-text"> 7. 实现 strStr() 28</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#java%E8%A7%A3%E6%B3%95-7"><span class="nav-number">8.1.</span> <span class="nav-text"> Java解法</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zestaken</p>
  <div class="site-description" itemprop="description">吾好梦中读书~</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">84</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">60</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/LeetCode-%E5%AD%97%E7%AC%A6%E4%B8%B2/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Leetcode-字符串 | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Leetcode-字符串
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-11 19:49:16" itemprop="dateCreated datePublished" datetime="2021-06-11T19:49:16+08:00">2021-06-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:41:22" itemprop="dateModified" datetime="2022-09-17T19:41:22+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>20k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>19 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<h2 id="string类的charat与tochararray实现原理"><a class="markdownIt-Anchor" href="#string类的charat与tochararray实现原理"></a> String类的charAt()与toCharArray()实现原理</h2>
<ul>
<li>例题：<a href="#1-ip-%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96-1108">ip-地址无效化-1108</a></li>
<li>看一下charAt()的源码：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public char charAt(int index) &#123;
    if ((index &lt; 0) || (index &gt;&#x3D; value.length)) &#123;
        throw new StringIndexOutOfBoundsException(index);
    &#125;
    return value[index];
&#125;</code></pre>
<ul>
<li>这就是直接在数组中取值的方法。那么value是什么东西呢？</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** The value is used for character storage. *&#x2F;
private final char value[];

&#x2F;&#x2F;再看看构造方法
public String() &#123;
    this.value &#x3D; &quot;&quot;.value;
&#125;

public String(String original) &#123;
    this.value &#x3D; original.value;
    this.hash &#x3D; original.hash;
&#125;

&#x2F;&#x2F;这个体现得最好，直接就是字符数组之间的copy
public String(char value[]) &#123;
    this.value &#x3D; Arrays.copyOf(value, value.length);
&#125;</code></pre>
<ul>
<li><code>value</code>的声明为一个字符数组，而且构造方法中通过<code>original.value</code>的方法赋值，也是将这个String对象中的value字符数组，赋给新的这个String对象。所以说白了，String类，就是一个字符数组给它加上一大堆方法封装而成的。（倒和C语言本质差不多）。</li>
<li>String类的核心是字符数组，所以能轻易把它转换为字符数组也不奇怪了，toCharArray的实质就是把封装在String中的字符数组value取出来用：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public char[] toCharArray() &#123;
    &#x2F;&#x2F; Cannot use Arrays.copyOf because of class initialization order issues
    char result[] &#x3D; new char[value.length];
    System.arraycopy(value, 0, result, 0, value.length);
    return result;
&#125;</code></pre>
<h2 id="stringbuilder的append方法的参数"><a class="markdownIt-Anchor" href="#stringbuilder的append方法的参数"></a> StringBuilder的append()方法的参数</h2>
<ul>
<li>例题：<a href="#1-ip-%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96-1108">ip-地址无效化-1108</a></li>
<li>append方法既能传字符，也能直接传字符串。事实上，不仅是字符和字符串，基本上其它类型如int，long等都能传，因为它们都能转为字符啊。看一下append是如何实现的：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public AbstractStringBuilder append(char c) &#123;
    ensureCapacityInternal(count + 1);
    &#x2F;&#x2F;直接在字符数组最后一位后加一个字符
    value[count++] &#x3D; c;
    return this;
&#125;

public AbstractStringBuilder append(int i) &#123;
    if (i &#x3D;&#x3D; Integer.MIN_VALUE) &#123;
        append(&quot;-2147483648&quot;);
        return this;
    &#125;
    int appendedLength &#x3D; (i &lt; 0) ? Integer.stringSize(-i) + 1
                                 : Integer.stringSize(i);
    int spaceNeeded &#x3D; count + appendedLength;
    ensureCapacityInternal(spaceNeeded);
    &#x2F;&#x2F;将整型转化合适长度的字符存入value字符数组中
    Integer.getChars(i, spaceNeeded, value);
    count &#x3D; spaceNeeded;
    return this;
&#125;

public AbstractStringBuilder append(String str) &#123;
    if (str &#x3D;&#x3D; null)
        return appendNull();
    int len &#x3D; str.length();
    ensureCapacityInternal(count + len);
    str.getChars(0, len, value, count);
    count +&#x3D; len;
    return this;
&#125;</code></pre>
<ul>
<li>结合String的本质是字符数组这一点来看，这一切都十分简单：只要最后能转为char，什么都可以往字符数组里塞。</li>
</ul>
<h2 id="stringbuilder的insert方法使用"><a class="markdownIt-Anchor" href="#stringbuilder的insert方法使用"></a> StringBuilder的insert()方法使用</h2>
<ul>
<li>例题： <a href="#1-ip-%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96-1108">1-ip-地址无效化-1108</a></li>
<li>首先看一下insert方法插入字符的源码，了解它的主要实现逻辑：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public AbstractStringBuilder insert(int offset, char c) &#123;
    ensureCapacityInternal(count + 1);
    &#x2F;&#x2F;将当前位置字符及其后面的字符依次向后挪一位
    System.arraycopy(value, offset, value, offset + 1, count - offset);
    &#x2F;&#x2F;当前位置赋值为指定字符
    value[offset] &#x3D; c;
    &#x2F;&#x2F;字符串总长度加一
    count +&#x3D; 1;
    return this;
&#125;</code></pre>
<ul>
<li>根据insert方法的实现逻辑，insert方法是将当前位置及其以后的字符依次向后移一位，然后当前位置变为指定字符。所以插入一个字符后，原来字符的下标就变为了<code>offsetn + 1</code>（原来字符及其以后的字符的下标都加一）,原来字符之前的字符相对位置不变。</li>
<li>此外，类似append方法，insert方法也是可以直接插入字符串的（不仅字符串，还有许多其它的类型，如字符数组，浮点数（float），int，boolean等，只是最终效果都是添加成字符串）：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;举两个例子
    &#x2F;**
     * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;
     *&#x2F;
    @Override
    public StringBuilder insert(int dstOffset, CharSequence s,
                                int start, int end)
    &#123;
        super.insert(dstOffset, s, start, end);
        return this;
    &#125;

    &#x2F;**
     * @throws StringIndexOutOfBoundsException &#123;@inheritDoc&#125;
     *&#x2F;
    @Override
    public StringBuilder insert(int offset, Object obj) &#123;
            super.insert(offset, obj);
            return this;
    &#125;</code></pre>
<h2 id="string与stringbuilder"><a class="markdownIt-Anchor" href="#string与stringbuilder"></a> String与StringBuilder</h2>
<ul>
<li>要说String和StringBuilder有什么不同，最直观的使用体验就是，String是不能变的，初始化时是啥就是一直是啥，想要改String的内容，就只能重新初始化一个String在其中加上想要改的内容。而StringBuider呢，从它特有的append和insert方法就可以看出，这兄弟的内容和长短可以随便改。</li>
<li>String和StringBuilder的本质都是字符数组，但是其中又有不同：
<ul>
<li>String：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** The value is used for character storage. *&#x2F;
 private final char value[];</code></pre>
<ul>
<li>StringBuilder:继承自AbstractStringBuilder，我们大致看一下AbstractStringBuilder就可以了解情况了。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
&#x2F;**
 * The value is used for character storage.
 *&#x2F;
char[] value;

&#x2F;&#x2F;再看一个在append和insert方法中都出现了的方法：用于实现动态扩容
private void ensureCapacityInternal(int minimumCapacity) &#123;
    &#x2F;&#x2F; overflow-conscious code
    if (minimumCapacity - value.length &gt; 0) &#123;
        value &#x3D; Arrays.copyOf(value,
                newCapacity(minimumCapacity));
    &#125;
&#125;</code></pre>
<ul>
<li>这下其实就很明显了，String核心是一个<code>final char[]</code>，而StringBuilder就是一个普通的<code>char[]</code>。final修饰的是初始化之后就不能改变的变量。而StringBuilder用着普通的字符数组，还为它配备了像ensureCapacityInternal这种动态扩容的方法以insert和append这种改变字符数组内容的方法，所以它可以随意变化值或长度。</li>
<li>不得不说，这就是，铁打的字符数组，流水的方法。。。</li>
</ul>
<h2 id="foreach循环的原理"><a class="markdownIt-Anchor" href="#foreach循环的原理"></a> foreach循环的原理</h2>
<ul>
<li>例题：<a href="#1-ip-%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96-1108">1-ip-地址无效化-1108</a></li>
<li>foreach循环可以用来遍历数组或者集合。虽然遍历这两者的用法相同，但是实现原理却不一样。</li>
<li>首先看看遍历数组时是什么情况,将我们遍历字符数组的代码编译后反编译一下：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;自己编写的源码
    &#x2F;&#x2F;将String转为字符数组，利用foreach循环遍历
    public String deFangIpaddr5 (String address) &#123;
        StringBuilder newAddress &#x3D; new StringBuilder();
        for(char temp : address.toCharArray()) &#123;
            if(temp &#x3D;&#x3D; &#39;.&#39;) &#123;
                newAddress.append(&quot;[.]&quot;);
            &#125; else &#123;
                newAddress.append(temp);
            &#125;
        &#125;
        return newAddress.toString();
    &#125;

&#x2F;&#x2F;编译后反编译得到的源码
   public String deFangIpaddr5(String address) &#123;
      StringBuilder newAddress &#x3D; new StringBuilder();
      char[] var3 &#x3D; address.toCharArray();
      int var4 &#x3D; var3.length;

      for(int var5 &#x3D; 0; var5 &lt; var4; ++var5) &#123;
         char temp &#x3D; var3[var5];
         if (temp &#x3D;&#x3D; &#39;.&#39;) &#123;
            newAddress.append(&quot;[.]&quot;);
         &#125; else &#123;
            newAddress.append(temp);
         &#125;
      &#125;

      return newAddress.toString();
   &#125;</code></pre>
<ul>
<li>二者对比一下，就可以看出，foreach循环做的事就是将我们以前遍历取值的的标准for循环封装了一下：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">for(int var5 &#x3D; 0; var5 &lt; var4; ++var5) &#123;
    char temp &#x3D; var3[var5];
    ...
&#125;

&#x2F;&#x2F;等价于

for(char temp : address.toCharArray()) &#123;
    ...
&#125;</code></pre>
<ul>
<li>这其中也要注意一个小细节，用于接收值的变量是每一次循环都要重新声明的，所以foreach循环中的临时变量只能现场声明，不能用之前声明好的。</li>
<li>遍历集合的情况，偷个懒，等遇到了再说。。。</li>
</ul>
<hr />
<h1 id="1-ip-地址无效化-1108"><a class="markdownIt-Anchor" href="#1-ip-地址无效化-1108"></a> 1. IP 地址无效化 1108</h1>
<ul>
<li>题目：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。
所谓无效化 IP 地址，其实就是用 &quot;[.]&quot; 代替了每个 &quot;.&quot;

示例 1：

输入：address &#x3D; &quot;1.1.1.1&quot;
输出：&quot;1[.]1[.]1[.]1&quot;
示例 2：

输入：address &#x3D; &quot;255.100.50.0&quot;
输出：&quot;255[.]100[.]50[.]0&quot;
 

提示：
给出的 address 是一个有效的 IPv4 地址</code></pre>
<h2 id="java解法"><a class="markdownIt-Anchor" href="#java解法"></a> java解法</h2>
<ul>
<li>法一：
<ul>
<li>遍历整个字符串，同时新建一个空的StringBuilder，遇到<code>.</code>的时候，加上<code>[]</code>使用<code>append()</code>添加进入StringBuilder中去。</li>
<li>评测结果：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210611201714.png" alt="" /></li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;解题代码
    public String deFangIpaddr1 (String address) &#123;
        StringBuilder newAddress &#x3D; new StringBuilder();
        for(int i &#x3D; 0; i &lt; address.length(); i++) &#123;
            char temp &#x3D; address.charAt(i);
            if(temp &#x3D;&#x3D; &#39;.&#39;) &#123;
                newAddress.append(&#39;[&#39;);
                newAddress.append(&#39;.&#39;);
                newAddress.append(&#39;]&#39;);
            &#125; else &#123;
                newAddress.append(temp);
            &#125;
        &#125;

        return newAddress.toString();
    &#125;

&#x2F;&#x2F;JUnit测试用例
    @Test
    public void testDeFangIpaddr1() &#123;
        DefangIPaddr test &#x3D; new DefangIPaddr();
        String res &#x3D; test.deFangIpaddr1(&quot;127.0.0.1&quot;);
        String expRes &#x3D; &quot;127[.]0[.]0[.]1&quot;;
        assert res.equals(expRes) : res;
    &#125;</code></pre>
<ul>
<li>法二
<ul>
<li>调用String的<code>replace()</code>方法，直接将<code>.</code>替换为<code>[.]</code></li>
<li>评测结果：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210611202515.png" alt="" /></li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;解题代码
    public String deFangIpaddr2(String address) &#123;
        return address.replace(&quot;.&quot;, &quot;[.]&quot;);
    &#125;

&#x2F;&#x2F;测试用例
    @Test
    public void testDeFangIpaddr2() &#123;
        DefangIPaddr test &#x3D; new DefangIPaddr();
        String res &#x3D; test.deFangIpaddr2(&quot;127.0.0.1&quot;);
        String expRes &#x3D; &quot;127[.]0[.]0[.]1&quot;;
        assert res.equals(expRes) : res;
    &#125;</code></pre>
<ul>
<li>法三：
<ul>
<li>创建StringBuilder对象，并把原字符串赋给它，调用其<code>insert</code>方法，在<code>.</code>的前后插入<code>[]</code>。</li>
<li>评测结果：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210611204856.png" alt="" /></li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;解题代码
    &#x2F;&#x2F;StringBuilder的insert
    public String deFangIpaddr3 (String address) &#123;
        StringBuilder newAddress &#x3D; new StringBuilder(address);
        for(int i &#x3D; 0; i &lt; newAddress.length(); i++) &#123;
            if(newAddress.charAt(i) &#x3D;&#x3D; &#39;.&#39;) &#123;
                &#x2F;&#x2F;insert是当前计数位变为指定字符，原来的字符到下一位
                newAddress.insert(i + 1, &#39;]&#39;); &#x2F;&#x2F;先插后面的括号，这样.的位置还未改变，方便添加前面的括号
                newAddress.insert(i, &#39;[&#39;);
                i +&#x3D; 3;
                continue;
            &#125;
        &#125;
        return newAddress.toString();
    &#125;
&#x2F;&#x2F;测试用例
    @Test
    public void testDeFangIpaddr3() &#123;
        DefangIPaddr test &#x3D; new DefangIPaddr();
        String res &#x3D; test.deFangIpaddr3(&quot;127.0.0.1&quot;);
        String expRes &#x3D; &quot;127[.]0[.]0[.]1&quot;;
        assert res.equals(expRes) : res;
    &#125;</code></pre>
<ul>
<li>法四：
<ul>
<li>同一一样，但是append方法可以直接添加字符串。。。</li>
<li>评测结果：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210611205634.png" alt="" /></li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;解题代码
    &#x2F;&#x2F;StringBuilder的append可以直接添加字符串。。。
    public String deFangIpaddr4 (String address) &#123;
        StringBuilder newAddress &#x3D; new StringBuilder();
        for(int i &#x3D; 0; i &lt; address.length(); i++) &#123;
            char temp &#x3D; address.charAt(i);
            if(temp &#x3D;&#x3D; &#39;.&#39;) &#123;
&#x2F;&#x2F;                newAddress.append(&#39;[&#39;);
&#x2F;&#x2F;                newAddress.append(&#39;.&#39;);
&#x2F;&#x2F;                newAddress.append(&#39;]&#39;);
                newAddress.append(&quot;[.]&quot;);
            &#125; else &#123;
                newAddress.append(temp);
            &#125;
        &#125;

        return newAddress.toString();
    &#125;
&#x2F;&#x2F;测试用例
    @Test
    public void testDeFangIpaddr4() &#123;
        DefangIPaddr test &#x3D; new DefangIPaddr();
        String res &#x3D; test.deFangIpaddr4(&quot;127.0.0.1&quot;);
        String expRes &#x3D; &quot;127[.]0[.]0[.]1&quot;;
        assert res.equals(expRes) : res;
    &#125;</code></pre>
<ul>
<li>法五：
<ul>
<li>将String转为字符数组，利用foreach循环遍历</li>
<li>评测结果：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210611211051.png" alt="" /></li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;解题代码
    &#x2F;&#x2F;将String转为字符数组，利用foreach循环遍历
    public String deFangIpaddr5 (String address) &#123;
        StringBuilder newAddress &#x3D; new StringBuilder();
        for(char temp : address.toCharArray()) &#123;
            if(temp &#x3D;&#x3D; &#39;.&#39;) &#123;
                newAddress.append(&quot;[.]&quot;);
            &#125; else &#123;
                newAddress.append(temp);
            &#125;
        &#125;
        return newAddress.toString();
    &#125;
&#x2F;&#x2F;测试用例
    @Test
    public void testDeFangIpaddr5() &#123;
        DefangIPaddr test &#x3D; new DefangIPaddr();
        String res &#x3D; test.deFangIpaddr5(&quot;127.0.0.1&quot;);
        String expRes &#x3D; &quot;127[.]0[.]0[.]1&quot;;
        assert res.equals(expRes) : res;
    &#125;</code></pre>
<h1 id="2-有效的字母异位词-242"><a class="markdownIt-Anchor" href="#2-有效的字母异位词-242"></a> 2. 有效的字母异位词 242</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-anagram/">题目</a></li>
</ul>
<hr />
<p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。<br />
注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。<br />
示例 1:</p>
<pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;
输出: true</code></pre>
<p>示例 2:</p>
<pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;
输出: false</code></pre>
<p>提示:</p>
<pre class="line-numbers language-none"><code class="language-none">1 &lt;&#x3D; s.length, t.length &lt;&#x3D; 5 * 104
s 和 t 仅包含小写字母</code></pre>
<h2 id="java解法-2"><a class="markdownIt-Anchor" href="#java解法-2"></a> Java解法</h2>
<ul>
<li>法一：字母异位代表着相同字母的出现次数一样。用一个26位的数组存储字母出现的次数（下标对应字母），遍历一次第一个字符串，存储各个字母的次数，然后再遍历第二个字符串，减去各个字母的次数，最后的数组值全为0，则说明字母异位。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/BuLLAf.png" alt="BuLLAf" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ValidAnagram242 &#123;

    public boolean isAnagram(String s, String t) &#123;
        &#x2F;&#x2F;存储判断结果
        boolean res &#x3D; true;
        &#x2F;&#x2F;用长度为26的整数数组表示每个字母出现的次数（下标表示字母，值代表出现次数）
        int[] abc &#x3D; new int[26];
        &#x2F;&#x2F;将字符串转换为字符数组遍历，将字母转化为数字，存储出现次数
        for(char i : s.toCharArray()) &#123;
            abc[i - &#39;a&#39;]++;
        &#125;
        &#x2F;&#x2F;遍历第二个字符数组，出现一个字母则对应位置次数减一
        for(char i : t.toCharArray()) &#123;
            abc[i - &#39;a&#39;]--;
        &#125;

        &#x2F;&#x2F;遍历数组，如果有对应位置字母出现次数不同，则对应位置的值不为0，返回false
        for(int i &#x3D; 0; i &lt; 26; i++) &#123;
            if(abc[i] !&#x3D; 0) &#123;
                return res &#x3D; false;
            &#125;
        &#125;
        &#x2F;&#x2F;所有元素都相等
        return res;
    &#125;
&#125;</code></pre>
<h1 id="3-同构字符串-205"><a class="markdownIt-Anchor" href="#3-同构字符串-205"></a> 3. 同构字符串 205</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/isomorphic-strings/">题目</a></li>
</ul>
<hr />
<p>给定两个字符串 s 和 t，判断它们是否是同构的。<br />
如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。<br />
每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</p>
<pre class="line-numbers language-none"><code class="language-none">示例 1:

输入：s &#x3D; &quot;egg&quot;, t &#x3D; &quot;add&quot;
输出：true
示例 2：

输入：s &#x3D; &quot;foo&quot;, t &#x3D; &quot;bar&quot;
输出：false
示例 3：

输入：s &#x3D; &quot;paper&quot;, t &#x3D; &quot;title&quot;
输出：true</code></pre>
<p>提示：<br />
可以假设 s 和 t 长度相同。</p>
<h2 id="java解法-3"><a class="markdownIt-Anchor" href="#java解法-3"></a> Java解法</h2>
<ul>
<li>法一：关键在于确定字母之间的映射关系，然后检测这种关系是否矛盾。字母之间的映射关系是通过字母出现的位置来决定的，字母第一次出现时就与同样位置的另一个字符相映射，如果之后这个字母再次出现，则对应的位置应还是哪个字符，也就是说，那个字符第一次出现的位置应相同。（本题偷懒使用两个哈希表实现，这样还不如直接用一个哈希表中将字母映射关系存好，直接对比。其实用26位的字符数组用以上思路应该也能做出来）
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210907223838.png" alt="" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class IsomorphicStrings205 &#123;
    public boolean isIsomorphic(String s, String t) &#123;
        &#x2F;&#x2F;将字符串转化为字符数组，便于遍历
        char[] s1 &#x3D; s.toCharArray();
        char[] s2 &#x3D; t.toCharArray();
        &#x2F;&#x2F;创建两个哈希集合，存储字符串中字符值及其第一次出现的位置
        Map&lt;Character, Integer&gt; map1 &#x3D; new HashMap&lt;&gt;();
        Map&lt;Character, Integer&gt; map2 &#x3D; new HashMap&lt;&gt;();

        &#x2F;&#x2F;遍历两个字符数组，同时记录位置，如果对应位置的字符的第一次出现的位置不同，则不是同构字符串
        for(int i &#x3D; 0; i &lt; s1.length; i++) &#123;
            &#x2F;&#x2F;用两个变量记录对应位置字母第一次出现的位置
            int pos1 &#x3D; i;
            int pos2 &#x3D; i;
            &#x2F;&#x2F;如果当前位置的字母是第一次出现，则存入哈希表，如果不是，则取出第一次出现位置
            if(!map1.containsKey(s1[i])) &#123;
                map1.put(s1[i], i);
            &#125; else &#123;
               pos1 &#x3D; map1.get(s1[i]);
            &#125;

            if(!map2.containsKey(s2[i])) &#123;
                map2.put(s2[i], i);
            &#125; else &#123;
                pos2 &#x3D; map2.get(s2[i]);
            &#125;
            &#x2F;&#x2F;如果两个字母第一次出现的位置不同，则不是同构字符串
            if(pos1 !&#x3D; pos2) &#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;
&#125;</code></pre>
<h1 id="4-回文子串-647"><a class="markdownIt-Anchor" href="#4-回文子串-647"></a> 4. 回文子串 647</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindromic-substrings/">题目</a></li>
</ul>
<hr />
<p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。<br />
回文字符串 是正着读和倒过来读一样的字符串。<br />
子字符串 是字符串中的由连续字符组成的一个序列。<br />
具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<pre class="line-numbers language-none"><code class="language-none">示例 1：

输入：s &#x3D; &quot;abc&quot;
输出：3
解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;
示例 2：

输入：s &#x3D; &quot;aaa&quot;
输出：6
解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</code></pre>
<p>提示：</p>
<p>1 &lt;= s.length &lt;= 1000<br />
s 由小写英文字母组成</p>
<h2 id="java解法-4"><a class="markdownIt-Anchor" href="#java解法-4"></a> Java解法</h2>
<ul>
<li>法一：回文子串的本质就是前后对称，对称的关键就是对称轴。所以我们以每一个元素确认当前对称轴，然后找寻对称轴前后的元素是否相同，来判断是否是回文子串。需要注意的是，奇数个元素和偶数个元素的对称的对称轴情况不同，需要区别处理。（应该可以通过除法，取余等操作将两个遍历循环合并）
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210908095417.png" alt="" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class PalindromicSubstrings647 &#123;

    public int countSubstrings(String s) &#123;

        &#x2F;&#x2F;将字符串转化为字符数组
        char[] s1 &#x3D; s.toCharArray();
        int length &#x3D; s1.length;
        int count &#x3D; 0;

        &#x2F;&#x2F;遍历字符数组，用当前元素确认中轴，找寻前后元素，看是否对称
        for(int i &#x3D; 0; i &lt; length; i++) &#123;
            &#x2F;&#x2F;要区分回文子串是偶数个还是奇数个
            &#x2F;&#x2F;偶数个的中轴在当前元素和下一元素之间（或者说中轴是两个元素）
            &#x2F;&#x2F;奇数个的中轴就在当前元素上
            int l &#x3D; i;
            int r1 &#x3D; i;
            int r2 &#x3D; i + 1;
            &#x2F;&#x2F;查找奇数个数的回文子串
            while(l &gt;&#x3D; 0 &amp;&amp; r1 &lt; length &amp;&amp; s1[l] &#x3D;&#x3D; s1[r1]) &#123;
                count++;
                l--;
                r1++;
            &#125;
            &#x2F;&#x2F;复原l的值
            l &#x3D; i;
            &#x2F;&#x2F;查找偶数个的回文子串
            while(l &gt;&#x3D; 0 &amp;&amp; r2 &lt; length &amp;&amp; s1[l] &#x3D;&#x3D; s1[r2]) &#123;
                count++;
                l--;
                r2++;
            &#125;
        &#125;

        return count;
    &#125;
&#125;</code></pre>
<h1 id="5-计数二进制子串-696"><a class="markdownIt-Anchor" href="#5-计数二进制子串-696"></a> 5. 计数二进制子串 696</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-binary-substrings/">题目</a></li>
</ul>
<hr />
<p>给定一个字符串 s，计算具有相同数量 0 和 1 的非空（连续）子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是连续的。<br />
重复出现的子串要计算它们出现的次数。</p>
<pre class="line-numbers language-none"><code class="language-none">示例 1 :

输入: &quot;00110011&quot;
输出: 6
解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。

请注意，一些重复出现的子串要计算它们出现的次数。

另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。
示例 2 :

输入: &quot;10101&quot;
输出: 4
解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。</code></pre>
<p>提示：<br />
s.length 在1到50,000之间。<br />
s 只包含“0”或“1”字符。</p>
<h2 id="java解法-5"><a class="markdownIt-Anchor" href="#java解法-5"></a> Java解法</h2>
<ul>
<li>法一：利用如果满足条件，必须前后不同字符连续出现的次数相同，所以关键在于计算同一字符连续出现的次数，如果之前字符连续出现的次数不小于当前字符连续出现的次数，那么必然可以构成一组。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210909224120.png" alt="" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CountBinarySubstrings696 &#123;

    public int countBinarySubstrings2(String s) &#123;
        &#x2F;&#x2F;统计结果
        int count &#x3D; 0;
        &#x2F;&#x2F;将字符串转为字符数组，便于遍历
        char[] s1 &#x3D; s.toCharArray();
        &#x2F;&#x2F;记录当前字符和之前不同字符的连续出现次数
        int pre &#x3D; 0, cur &#x3D; 0;

        &#x2F;&#x2F;遍历字符数组，记录当前字符连续出现次数，以及之前相对当前字符不同的字符的连续出现次数
        &#x2F;&#x2F;temp标记当前字符是0还是1
        char temp &#x3D; &#39;0&#39;;
        for(char c : s1) &#123;

            if(c &#x3D;&#x3D; temp) &#123;
                &#x2F;&#x2F;如果字符没变，则计数加一
                cur++;
            &#125; else &#123;
                &#x2F;&#x2F;如果字符变化了，则将之前记录的字符连续次数，赋给统计之前次数的变量，重新开始计数
                pre &#x3D; cur;
                cur &#x3D; 1;
                &#x2F;&#x2F;修改当前字符种类
                temp &#x3D; c;
            &#125;
            &#x2F;&#x2F;当之前连续出现的字符的次数的不小于当前字符连续出现次数时，可以构成对称，计数一次
            if(pre &gt;&#x3D; cur) &#123;
                count++;
            &#125;
        &#125;

        return count;
    &#125;
&#125;</code></pre>
<h1 id="6-基本计算器-ii-227"><a class="markdownIt-Anchor" href="#6-基本计算器-ii-227"></a> 6. 基本计算器 II 227</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/basic-calculator-ii/">题目</a></li>
</ul>
<hr />
<p>给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。<br />
整数除法仅保留整数部分。</p>
<pre class="line-numbers language-none"><code class="language-none">示例 1：

输入：s &#x3D; &quot;3+2*2&quot;
输出：7
示例 2：

输入：s &#x3D; &quot; 3&#x2F;2 &quot;
输出：1
示例 3：

输入：s &#x3D; &quot; 3+5 &#x2F; 2 &quot;
输出：5</code></pre>
<p>提示：</p>
<pre class="line-numbers language-none"><code class="language-none">1 &lt;&#x3D; s.length &lt;&#x3D; 3 * 105
s 由整数和算符 (&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;&#x2F;&#39;) 组成，中间由一些空格隔开
s 表示一个 有效表达式
表达式中的所有整数都是非负整数，且在范围 [0, 231 - 1] 内
题目数据保证答案是一个 32-bit 整数</code></pre>
<h2 id="java解法-6"><a class="markdownIt-Anchor" href="#java解法-6"></a> Java解法</h2>
<ul>
<li>法一：用两个队列分别存储数值和运算符。遍历字符串时，从队列尾部插入，尾部读取，把队列当作栈使用，如果遇到比存入队列中的的运算符优先级高的运算符，则将该运算符前后的数值获取，计算出结果再存入数值队列中。遍历字符串结束后，需要从左到右计算，从队列头部读取，从队列头部插入，因为高优先级运算符已经转换为运算结果，所以运算时都是同级的运算符，只需从左到右运算即可。从左到右运算时，将每一次运算的结果插入队列头部，作为下一次运算的左运算数。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/dzELwI.png" alt="dzELwI" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BasicCalculatorII227 &#123;

    &#x2F;&#x2F;用于临时存储连续的数字以便计算数值
    ArrayList&lt;Integer&gt; tempNums &#x3D; new ArrayList&lt;&gt;();

    &#x2F;**
     * 主计算函数，遍历字符串，按序获取对应的数值以及运算符
     * @param s
     * @return 表达式计算结果
     *&#x2F;
    public int calculate(String s) &#123;
        &#x2F;&#x2F;将字符串转换为字符数组，便于遍历
        char[] s1 &#x3D; s.toCharArray();
        &#x2F;&#x2F;用两个双端队列，按序存储数值和运算符
        Deque&lt;Integer&gt; nums &#x3D; new LinkedList&lt;&gt;();
        Deque&lt;Character&gt; ops &#x3D; new LinkedList&lt;&gt;();
        &#x2F;&#x2F;存储运算结果
        int res &#x3D; 0;

        &#x2F;&#x2F;遍历整个字符数组
        for(int i &#x3D; 0; i &lt; s1.length;) &#123;
            &#x2F;&#x2F;获取当前位置的值
            char c &#x3D; s1[i];

            &#x2F;&#x2F;如果是数字，则获取接下来连续出现的数字，存储到动态数组中，并修改下标
            if(isNum(c)) &#123;
                i &#x3D; getNums(s1, i);
            &#125;
            &#x2F;&#x2F;如果是空格
            if(isSpace(c)) &#123;
                &#x2F;&#x2F;空格是连续数字的分隔符，计算数值，存入数值队列中
                if(!tempNums.isEmpty()) &#123;
                    nums.addLast(getNum(tempNums));
                &#125;
                &#x2F;&#x2F;下标前进到下一位，进入下一次循环
                i++;
                continue;
            &#125; else if(isOp(c)) &#123;
                &#x2F;&#x2F;如果是运算符
                if(!tempNums.isEmpty()) &#123;
                    &#x2F;&#x2F;运算符也是数字的分隔符，计算数值，存入数值队列
                    nums.addLast(getNum(tempNums));
                &#125;
                &#x2F;&#x2F;如果运算符队列为空，则直接存入运算符，进入下一次循环
                if(ops.isEmpty()) &#123;
                    ops.addLast(c);
                    i++;
                    continue;
                &#125;
                &#x2F;&#x2F;运算符队列不为空，获取队列尾运算符
               char temp &#x3D; ops.getLast();
                &#x2F;&#x2F;如果队列尾运算符是+或-
               if(temp &#x3D;&#x3D; &#39;+&#39; || temp &#x3D;&#x3D; &#39;-&#39; ) &#123;
                   &#x2F;&#x2F;* &#x2F; 的优先级比 + -高，先将乘除运算结束，将结果存入数值队列中
                   if (c &#x3D;&#x3D; &#39;*&#39; ) &#123;
                       &#x2F;&#x2F;获取数值队列末尾元素
                       int num1 &#x3D; nums.pollLast();
                       &#x2F;&#x2F;获取当前运算符之后的连续数字并得出其值
                       i &#x3D; getNums(s1, i + 1);
                       int num2 &#x3D; getNum(tempNums);
                       &#x2F;&#x2F;运算，结果存入数值队列尾
                       int num3;
                       num3 &#x3D; num2 * num1;
                       nums.addLast(num3);
                   &#125; else if (c &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;
                       int num1 &#x3D; nums.pollLast();
                       i &#x3D; getNums(s1, i + 1);
                       int num2 &#x3D; getNum(tempNums);
                       int num3;
                       num3 &#x3D; num1 &#x2F; num2;
                       nums.addLast(num3);
                   &#125; else &#123;
                       &#x2F;&#x2F;如果当前运算符是+ -，则直接存入运算符队列
                       i++;
                       ops.addLast(c);
                       continue;
                   &#125;
               &#125; else &#123;
                   &#x2F;&#x2F;没有比 * &#x2F;优先级高的运算，直接存入运算符队列
                   i++;
                   ops.addLast(c);
                   continue;
               &#125;

            &#125;
        &#125;
        &#x2F;&#x2F;因为以空格和运算符作为连续数字的分隔符，所以末尾的数字有可能没有存入数值队列
        if(!tempNums.isEmpty()) &#123;
            nums.addLast(getNum(tempNums));
        &#125;
        &#x2F;&#x2F;如果运算符队列为空，则说明数值队列只有一个数，无需运算，直接返回
        if(ops.isEmpty()) &#123;
            return nums.pollFirst();
        &#125;
        &#x2F;&#x2F;从队列头部取出数值和运算符进行运算
        &#x2F;&#x2F;运算规则是从左到右，如果还是用栈的思路，就是从右到左计算
        &#x2F;&#x2F;因为高优先级的运算符都已经计算为结果了，所以都是同一优先级的运算
        while(!nums.isEmpty() &amp;&amp; !ops.isEmpty()) &#123;
            int num1 &#x3D; nums.pollFirst();
            int num2 &#x3D; nums.pollFirst();
            char op &#x3D; ops.pollFirst();
            if(op &#x3D;&#x3D; &#39;+&#39;) &#123;
                res &#x3D; num1 + num2;
            &#125; else if (op &#x3D;&#x3D; &#39;-&#39;)&#123;
                res &#x3D; num1 - num2;
            &#125; else if (op &#x3D;&#x3D; &#39;*&#39;) &#123;
                res &#x3D; num1 * num2;
            &#125; else if(op &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;
                res &#x3D; num1 &#x2F; num2;
            &#125;
            &#x2F;&#x2F;每一次运算的结果是下一次运算的前一位运算数，重新存入数值队列头部
            nums.addFirst(res);
        &#125;

        return res;
    &#125;

    &#x2F;**
     * 判断字符是否是数字
     * @param c
     * @return
     *&#x2F;
    public boolean isNum(char c) &#123;
        if (c &gt;&#x3D; &#39;0&#39; &amp;&amp; c &lt;&#x3D; &#39;9&#39;) &#123;
            return true;
        &#125;
        return false;
    &#125;

    &#x2F;**
     * 判断字符是否是运算符
     * @param c
     * @return
     *&#x2F;
    public boolean isOp(char c) &#123;
        if(c &#x3D;&#x3D; &#39;+&#39; || c &#x3D;&#x3D; &#39;-&#39; || c &#x3D;&#x3D; &#39;*&#39; || c &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;
            return true;
        &#125;
        return false;
    &#125;

    &#x2F;**
     * 判断字符是否是空格
     * @param c
     * @return
     *&#x2F;
    public boolean isSpace(char c) &#123;
        if(c &#x3D;&#x3D; &#39; &#39;) &#123;
            return true;
        &#125;
        return false;
    &#125;

    &#x2F;**
     * 将连续的数字转换为值
     * @param list
     * @return
     *&#x2F;
    public int getNum(ArrayList&lt;Integer&gt; list) &#123;
        int length &#x3D; list.size();
        int i &#x3D; 0;
        int res &#x3D; 0;

        &#x2F;&#x2F;遍历数字，将每位数乘上其10的幂，加在最后的结果上
        for(int num : list) &#123;
            res +&#x3D; num * Math.pow(10, length - i - 1);
            i++;
        &#125;
        &#x2F;&#x2F;清空集合
        list.clear();

        return res;
    &#125;

    &#x2F;**
     * 获取连续数字，并依次存入集合中
     * @param s
     * @param start 开始位置
     * @return 返回下一个非数字字符位置
     *&#x2F;
    public int getNums(char[] s, int start) &#123;
        int i;
        int j;
        &#x2F;&#x2F;如果开始是连续的空格，则跳过，知道有数字出现为止
        for(i &#x3D; start; i &lt; s.length; i++) &#123;
            char c &#x3D; s[i];
            if(!isSpace(c)) &#123;
                break;
            &#125;
        &#125;
        &#x2F;&#x2F;从跳过空格后的位置开始读取数字
        for(j &#x3D; i; j &lt; s.length; j++) &#123;
            char c &#x3D; s[j];
            if(isNum(c)) &#123;
                tempNums.add(c - &#39;0&#39;);
            &#125; else &#123;
                break;
            &#125;
        &#125;
        return j;
    &#125;
&#125;</code></pre>
<h1 id="7-实现-strstr-28"><a class="markdownIt-Anchor" href="#7-实现-strstr-28"></a> 7. 实现 strStr() 28</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-strstr/">题目</a></li>
</ul>
<hr />
<p>实现 strStr() 函数。<br />
给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。<br />
说明：<br />
当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。<br />
对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。</p>
<pre class="line-numbers language-none"><code class="language-none">示例 1：

输入：haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;
输出：2
示例 2：

输入：haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;
输出：-1
示例 3：

输入：haystack &#x3D; &quot;&quot;, needle &#x3D; &quot;&quot;
输出：0

提示：

0 &lt;&#x3D; haystack.length, needle.length &lt;&#x3D; 5 * 104
haystack 和 needle 仅由小写英文字符组成</code></pre>
<h2 id="java解法-7"><a class="markdownIt-Anchor" href="#java解法-7"></a> Java解法</h2>
<ul>
<li>法一：双指针遍历两个字符串，直到找到匹配的子串或者余下的长度比子串长度还小时停止。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210911131211.png" alt="" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ImplementStrStr28 &#123;

    public int strStr(String haystack, String needle) &#123;
        &#x2F;&#x2F;将字符串转化为字符数组，方便遍历
        char[] s1 &#x3D; haystack.toCharArray();
        char[] s2 &#x3D; needle.toCharArray();
        int l1 &#x3D; s1.length;
        int l2 &#x3D; s2.length;
        &#x2F;&#x2F;如果子串为空字符串，返回0
        if(s2.length &#x3D;&#x3D; 0) &#123;
            return 0;
        &#125;
        &#x2F;&#x2F;结果默认为-1
        int res &#x3D; -1;

        &#x2F;&#x2F;遍历字符串，直到所剩长度比子串长度小
        for(int i &#x3D; 0; i + l2 &lt;&#x3D; l1; i++) &#123;
            &#x2F;&#x2F;如果当前字符与子串第一个字符相同，则继续比较之后的字符
            if(s1[i] &#x3D;&#x3D; s2[0]) &#123;
                int j &#x3D; i + 1;
                int t &#x3D; 1;
                &#x2F;&#x2F;当子串只有一位字符时，可以直接返回
                if(t &#x3D;&#x3D; l2) &#123;
                    return res &#x3D; i;
                &#125;
                &#x2F;&#x2F;双指针，遍历两个字符串，逐个比较字符是否相同，直到子串遍历完
                while (t &lt; l2) &#123;
                    if(s1[j] !&#x3D; s2[t]) &#123;
                        break;
                    &#125;
                    t++;
                    j++;
                &#125;
                &#x2F;&#x2F;如果子串被遍历完了，说明完全匹配，返回开始下标即可
                if(t &#x3D;&#x3D; l2) &#123;
                    return res &#x3D; i;
                &#125;
            &#125;
        &#125;
        &#x2F;&#x2F;到达这里，说明前面没有找到匹配子串，直接返回默认值-1
        return res;
    &#125;
&#125;</code></pre>
<ul>
<li>法二：KMP(字符串模式匹配算法)<a href="https://www.zestaken.top/post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%B2">KMP解析</a>:其中心思想是利用子串的对称性来在比较的时候跳过一些对称的部分，以起到加速匹配的效果。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211114114926.png" alt="" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public int strStr(String haystack, String needle) &#123;
    char[] s1 &#x3D; haystack.toCharArray();
    char[] s2 &#x3D; needle.toCharArray();
    int l1 &#x3D; s1.length;
    int l2 &#x3D; s2.length;
    int result &#x3D; -1; &#x2F;&#x2F;结果默认为-1
    &#x2F;&#x2F;子串为空串直接返回0
    if(l2 &#x3D;&#x3D; 0) &#123;
        result &#x3D; 0;
        return  result;
    &#125;

    &#x2F;&#x2F;求子串每一个元素的next数组（即当前元素之前对称的元素对数）
    int i &#x3D; 0, k &#x3D; -1;
    int[] next &#x3D; new int[l2];
    next[0] &#x3D; -1; &#x2F;&#x2F;第一个元素设为-1，因为它之前没有元素
    while(i &lt; l2 - 1) &#123; &#x2F;&#x2F;最后一个元素在倒数第二个元素遍历时已经记录
        if(k &#x3D;&#x3D; -1 || s2[i] &#x3D;&#x3D; s2[k]) &#123;
            i++; &#x2F;&#x2F;若之前有元素相等，则记在下一个元素的next值上
            k++; &#x2F;&#x2F;k值从-1开始，与i对应元素依此比过来，如果相等则k与i同时移位，如果不等k回溯到它的next值处再比较，i不变
            &#x2F;&#x2F;next值的求取实质是子串前半部分与后半部分比较，得元素对应相等个数；可以看成是两个串的匹配，又可以用next回溯的思想，有点递归的感觉
            next[i] &#x3D; k; &#x2F;&#x2F;k的值代表着对称相等的元素对数
        &#125; else &#123;
            k &#x3D; next[k];
        &#125;
    &#125;

    int j &#x3D; 0, m &#x3D; 0;
    while(j + l2 - m &lt;&#x3D; l1 &amp;&amp; m &lt; l2) &#123;
        if(m &#x3D;&#x3D; -1 || s2[m] &#x3D;&#x3D; s1[j]) &#123; &#x2F;&#x2F;m等于负一说明子串从头开始寻找，主串后移一位
            j++;
            m++;
        &#125; else &#123;
            m &#x3D; next[m];
        &#125;

        if(m  &#x3D;&#x3D; l2) &#123;
            result &#x3D; j - m; &#x2F;&#x2F;当前位置是子串最后一个元素对应的位置，减去子串长度即为开始匹配的位置
        &#125;

    &#125;

    return result;
&#125;</code></pre>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
              <a href="/tags/LeetCode/" rel="tag"># LeetCode</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Linux/Linux%E4%B8%ADman%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/index.html" rel="prev" title="Linux中man命令的使用">
                  <i class="fa fa-angle-left"></i> Linux中man命令的使用
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/%E9%A1%B9%E7%9B%AE/Python%E5%AE%9E%E7%8E%B0%E8%AF%8D%E4%BA%91/index.html" rel="next" title="Python实现词云">
                  Python实现词云 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Zestaken</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">678k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:17</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js" integrity="sha256-4mJNT2bMXxcc1GCJaxBmMPdmah5ji0Ldnd79DKd1hoM=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha256-AjM0J5XIbiB590BrznLEgZGLnOQWrt62s3BEq65Q/I0=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha256-9cmf7tcLdXpKsPi/2AWE93PbZpTp4M4tqzFk+lWomjU=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
