<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <head>
    <link href="/styles/main.css" rel="stylesheet" type="text/css"/>

    <meta charset="UTF-8">
    
    <title>Leetcode-栈 - ZestJourney</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/bootstrap/4.6.1/css/bootstrap.min.css">
    <script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/bootstrap/4.6.1/js/bootstrap.min.js"></script>

<script src="https://npm.elemecdn.com/@waline/client@v2/dist/waline.js"></script>
<link
  rel="stylesheet"
  href="https://npm.elemecdn.com/@waline/client@v2/dist/waline.css"
/>
<meta name="generator" content="Hexo 5.4.2"></head>

</head>

<body>
    


        <div>
            <div class="container-fluid position-relative">
                <nav class="navbar navbar-expand-lg navbar-dark  text-white bg-transparent">
                    <div class="container">
                        
                        <a class="navbar-brand" href="/">💖我们的秘密基地💖</a>
                        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarText"
                            aria-controls="navbarText" aria-expanded="false" aria-label="Toggle navigation">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                        <div class="collapse navbar-collapse" id="navbarText">
                            <ul class="navbar-nav mr-auto">
                            </ul>
                            <span class="navbar-text">
                                💕愿你三冬暖，愿你春不寒🍂
                            </span>
                        </div>
                    </div>
                </nav>
                <section class="lover-background"
                    style="background-image: url(/img/banner.jpg)">
                </section>
                <section
                    class="container lover-container d-flex flex-column align-content-center justify-content-center">
                    <div class="row align-items-center pb-5 lover">
                        <div class="col">
                            <div class="d-flex flex-column">
                                <img class="mx-auto avatar-img rounded-circle"
                                    src="/img/zestaken.jpg" alt="">
                                <h4 class="mx-auto text-white pt-2">  
                                    zestaken
                                </h4>
                            </div>
                        </div>
                        <div class="col">
                            <div class="d-flex justify-content-center">
                                <div class="heart"></div>
                            </div>
                        </div>
                        <div class="col">
                            <div class="d-flex flex-column">
                                <img class="mx-auto avatar-img rounded-circle"
                                    src="/img/zinny.jpg" alt="">
                                <h4 class="mx-auto text-white pt-2">
                                    zinny
                                </h4>
                            </div>
                        </div>
                    </div>
                </section>
                <section class="main-hero-waves-area waves-area">
                    <svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
                        viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
                        <defs>
                            <path id="gentle-wave"
                                d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z">
                            </path>
                        </defs>
                        <g class="parallax">
                            <use xlink:href="#gentle-wave" x="48" y="0"></use>
                            <use xlink:href="#gentle-wave" x="48" y="3"></use>
                            <use xlink:href="#gentle-wave" x="48" y="5"></use>
                            <use xlink:href="#gentle-wave" x="48" y="7"></use>
                        </g>
                    </svg>
                </section>
            </div>

            <div id="Pjax">

  <div class="list-content mx-auto mt-5">
      <div id="article" class="list-top">
          <h5 class="list-text"> Leetcode-栈
          </h5>
          <article>
              <article>
                <h1 id="代码地址"><a class="markdownIt-Anchor" href="#代码地址"></a> 代码地址</h1>
<p><a target="_blank" rel="noopener" href="https://github.com/zestaken/newblog/tree/master/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/Code/src/main/java/stack">github</a></p>
<h1 id="1-删除最外层的括号-1021"><a class="markdownIt-Anchor" href="#1-删除最外层的括号-1021"></a> 1. 删除最外层的括号 1021</h1>
<ul>
<li>题目：</li>
</ul>
<hr />
<p>有效括号字符串为空 (“”)、“(” + A + “)” 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，“”，“()”，“(())()” 和 “(()(()))” 都是有效的括号字符串。</p>
<p>如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。</p>
<p>给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。</p>
<p>对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。</p>
<p></p>
<p>示例 1：</p>
<p>输入：“(()())(())”<br />
输出：“()()()”<br />
解释：<br />
输入字符串为 “(()())(())”，原语化分解得到 “(()())” + “(())”，<br />
删除每个部分中的最外层括号后得到 “()()” + “()” = “()()()”。<br />
示例 2：</p>
<p>输入：“(()())(())(()(()))”<br />
输出：“()()()()(())”<br />
解释：<br />
输入字符串为 “(()())(())(()(()))”，原语化分解得到 “(()())” + “(())” + “(()(()))”，<br />
删除每个部分中的最外层括号后得到 “()()” + “()” + “()(())” = “()()()()(())”。<br />
示例 3：</p>
<p>输入：“()()”<br />
输出：“”<br />
解释：<br />
输入字符串为 “()()”，原语化分解得到 “()” + “()”，<br />
删除每个部分中的最外层括号后得到 “” + “” = “”。</p>
<h2 id="java解法"><a class="markdownIt-Anchor" href="#java解法"></a> java解法</h2>
<ul>
<li>法一：
<ul>
<li>使用一个栈来压入左括号，并将最外层括号设置为<code>*</code>来表示，再设置一个StringBuilder来录入除最外层括号的括号。</li>
<li>每一次栈遇到右括号就弹出，以此来逐个匹配括号，从而判断谁为最外层的括号。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
import java.util.Stack;

public class Solution &#123;
    public String removeOuterParentheses(String S) &#123;
        Stack&lt;Character&gt; stack &#x3D; new Stack&lt;&gt;();
        StringBuilder stringBuilder &#x3D; new StringBuilder();

        &#x2F;&#x2F;遍历字符串
        for(char i : S.toCharArray()) &#123;
            &#x2F;&#x2F;如果栈不为空，则证明不是最外层的左括号，存入stringBulider
            if(i &#x3D;&#x3D; &#39;(&#39; &amp;&amp; !stack.isEmpty()) &#123;
                   stringBuilder.append(i);
                    stack.push(i);
            &#125;else if(i &#x3D;&#x3D; &#39;(&#39; &amp;&amp; stack.isEmpty()) &#123;
                stack.push(&#39;*&#39;);
            &#125; else &#123; &#x2F;&#x2F;如果为右括号，则栈中内容弹出，并根据边界记号来判断是否到边界，如果不是，则将右括号也存入stringBuilder
                char temp1 &#x3D; stack.pop();
                if(temp1 !&#x3D; &#39;*&#39;) &#123;
                    stringBuilder.append(i);
                &#125;
            &#125;
        &#125;
        return String.valueOf(stringBuilder);
    &#125;

    public static void main(String[] args) &#123;
        String s &#x3D; &quot;(()())(()(()))&quot;;
        Solution solution &#x3D; new Solution();
        System.out.println(solution.removeOuterParentheses(s));
    &#125;
&#125;</code></pre>
<ul>
<li>法二：
<ul>
<li>设置一个数字来记录括号的层数，最外层的括号的层数为1，当层数不为1时将括号存入stringBuilder对象中。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public String removeOuterParentheses(String S) &#123;
    StringBuilder stringBuilder &#x3D; new StringBuilder();
    int level &#x3D; 0;
    for(char i : S.toCharArray()) &#123;
        &#x2F;&#x2F;层数按照左括号来记录
        if(i &#x3D;&#x3D; &#39;(&#39;) &#123;
            level++;
        &#125;
        &#x2F;&#x2F;层数大于1时存入，需要放在level减1之前，否则右括号存不进去
        if(level &gt; 1) &#123;
            stringBuilder.append(i);
        &#125;
        &#x2F;&#x2F;当出现右括号时，将当前的层数减一，类似于用栈记录的出栈效果
        if(i &#x3D;&#x3D; &#39;)&#39;)&#123;
            level--;
        &#125;

    &#125;

    return String.valueOf(stringBuilder);
&#125;</code></pre>
<h1 id="2-剑指-offer-09-用两个栈实现队列"><a class="markdownIt-Anchor" href="#2-剑指-offer-09-用两个栈实现队列"></a> 2. 剑指 Offer 09. 用两个栈实现队列</h1>
<ul>
<li>题目：</li>
</ul>
<hr />
<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<p></p>
<p>示例 1：</p>
<p>输入：<br />
[“CQueue”,“appendTail”,“deleteHead”,“deleteHead”]<br />
[[],[3],[],[]]<br />
输出：[null,null,3,-1]<br />
示例 2：</p>
<p>输入：<br />
[“CQueue”,“deleteHead”,“appendTail”,“appendTail”,“deleteHead”,“deleteHead”]<br />
[[],[],[5],[2],[],[]]<br />
输出：[null,-1,null,null,5,2]<br />
提示：</p>
<p>1 &lt;= values &lt;= 10000<br />
最多会对 appendTail、deleteHead 进行 10000 次调用</p>
<ul>
<li>题目解释：</li>
</ul>
<hr />
<p>输入：</p>
<p><code>[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;] </code><br />
这一行表示每一行代码的操作,其CQueue方法是构造器方法，即是创建队列的操作。</p>
<p><code>[[],[3],[],[]]</code><br />
这个表示每一行代码操作所需要的参数</p>
<h2 id="java解法-2"><a class="markdownIt-Anchor" href="#java解法-2"></a> java解法</h2>
<ol>
<li>法一：
<ol>
<li>设置两个栈，每次添加数据时就向第一个栈中添加数据，每次输出数据时就先将第一个栈中的数据弹出并压入第二个栈中，再依次弹出第二个栈中的数据。</li>
</ol>
</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
package stack;

import java.util.Stack;

public class CQueue &#123;
    Stack&lt;Integer&gt; stack1;
    Stack&lt;Integer&gt; stack2;

    public CQueue()&#123;
        stack1 &#x3D; new Stack&lt;&gt;();
        stack2 &#x3D; new Stack&lt;&gt;();
    &#125;

    public void appendTail(int value) &#123;
        stack1.push(value);
    &#125;

    public int deleteHead()&#123;
        int temp;

        while(!stack1.isEmpty()) &#123;
            temp &#x3D; stack1.pop();
            stack2.push(temp);
        &#125;

        if(stack2.isEmpty()) &#123;
            return -1;
        &#125;

        int value &#x3D; stack2.pop();

        while(!stack2.isEmpty()) &#123;
            temp &#x3D; stack2.pop();
            stack1.push(temp);
        &#125;

        return value;
    &#125;

    public static void main(String[] args) &#123;
        CQueue cQueue &#x3D; new CQueue();

        cQueue.appendTail(1);
        cQueue.appendTail(2);
        cQueue.appendTail(3);

        cQueue.deleteHead();
        Stack&lt;Integer&gt; stack &#x3D; cQueue.stack1;
        while(!stack.isEmpty()) &#123;
            System.out.println(stack.pop());
        &#125;
    &#125;

&#125;</code></pre>
<h1 id="3-1047-删除字符串中的所有相邻重复项"><a class="markdownIt-Anchor" href="#3-1047-删除字符串中的所有相邻重复项"></a> 3. 1047. 删除字符串中的所有相邻重复项</h1>
<ul>
<li>题目：</li>
</ul>
<hr />
<p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p>示例：</p>
<pre class="line-numbers language-none"><code class="language-none">输入：&quot;abbaca&quot;
输出：&quot;ca&quot;
解释：
例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。</code></pre>
<p>提示：<br />
1 &lt;= S.length &lt;= 20000<br />
S 仅由小写英文字母组成。</p>
<h2 id="java解法-3"><a class="markdownIt-Anchor" href="#java解法-3"></a> java解法</h2>
<ul>
<li>法一：
<ul>
<li>设置一个栈，依次将字符串中字符压栈，栈顶内容始终是当前字符的相邻的前一个字符。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;
    public String removeDuplicates(String S) &#123;
        Stack&lt;Character&gt; stack &#x3D; new Stack&lt;&gt;();
        &#x2F;&#x2F;遍历字符串，将字符串删除重复后存入栈中
        for(char i : S.toCharArray()) &#123;
            if(stack.isEmpty()) &#123;
                stack.push(i);
                continue;
            &#125;
            char temp &#x3D; stack.pop();

            &#x2F;&#x2F;如果栈顶的内容与刚读取的字符相同，则弹出栈顶内容，并进行下一次循环；如果相同，则将新字符压入栈
            if(temp &#x3D;&#x3D; i) &#123;
                continue;
            &#125; else &#123;
                stack.push(temp);
                stack.push(i);
            &#125;
        &#125;

        StringBuilder s1 &#x3D; new StringBuilder();

        &#x2F;&#x2F;将栈中内容从头插入新字符串
        while(!stack.isEmpty()) &#123;
            char temp  &#x3D; stack.pop();
            s1.insert(0,temp);
        &#125;
        return s1.toString();
    &#125;

    public static void main(String[] args) &#123;
        String s &#x3D; &quot;abbaca&quot;;

        Solution solution &#x3D; new Solution();

        String s1 &#x3D; solution.removeDuplicates(s);

        System.out.println(s1);
    &#125;
&#125;</code></pre>
<ul>
<li>法二：
<ul>
<li>设置一个存储所有可能的重复情况的集合，然后将字符串与集合中所有内容比较，如果有相同的则替换为空字符串。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public String removeDuplicates(String S) &#123;
    HashSet&lt;String&gt; duplicates &#x3D; new HashSet&lt;&gt;();
    StringBuilder sb &#x3D; new StringBuilder();

    &#x2F;&#x2F;将重复字符串&quot;aa&quot;到&quot;zz&quot;存入集合中，使用哈希集合的原因是这种集合内部不允许内容重复
    for(char i &#x3D; &#39;a&#39;; i &lt;&#x3D; &#39;z&#39;; i++) &#123;
        sb.setLength(0);
        sb.append(i);
        sb.append(i);
        duplicates.add(sb.toString());
    &#125;

    &#x2F;&#x2F;遍历集合，与字符串内容比较，如果字符串中有相同内容则替换为空字符串
    &#x2F;&#x2F;设置一个记录字符串长度的变量，如果两次while循环之后的长度没变，说明字符串中的重复字符串已经被替换完了
    int preLength &#x3D; -1;
    while(preLength !&#x3D; S.length()) &#123;
        preLength &#x3D; S.length();
        for(String d : duplicates) &#123;
            S &#x3D; S.replace(d,&quot;&quot;);
        &#125;
    &#125;
    return S;
&#125;</code></pre>
<h1 id="4-682-棒球比赛"><a class="markdownIt-Anchor" href="#4-682-棒球比赛"></a> 4. 682. 棒球比赛</h1>
<ul>
<li>题目：</li>
</ul>
<hr />
<p>你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。</p>
<p>比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则：</p>
<p>整数 x - 表示本回合新获得分数 x<br />
“+” - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。<br />
“D” - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。<br />
“C” - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。<br />
请你返回记录中所有得分的总和。</p>
<p></p>
<p>示例 1：</p>
<p>输入：ops = [“5”,“2”,“C”,“D”,“+”]<br />
输出：30<br />
解释：<br />
“5” - 记录加 5 ，记录现在是 [5]<br />
“2” - 记录加 2 ，记录现在是 [5, 2]<br />
“C” - 使前一次得分的记录无效并将其移除，记录现在是 [5].<br />
“D” - 记录加 2 * 5 = 10 ，记录现在是 [5, 10].<br />
“+” - 记录加 5 + 10 = 15 ，记录现在是 [5, 10, 15].<br />
所有得分的总和 5 + 10 + 15 = 30<br />
示例 2：</p>
<p>输入：ops = [“5”,“-2”,“4”,“C”,“D”,“9”,“+”,“+”]<br />
输出：27<br />
解释：<br />
“5” - 记录加 5 ，记录现在是 [5]<br />
“-2” - 记录加 -2 ，记录现在是 [5, -2]<br />
“4” - 记录加 4 ，记录现在是 [5, -2, 4]<br />
“C” - 使前一次得分的记录无效并将其移除，记录现在是 [5, -2]<br />
“D” - 记录加 2 * -2 = -4 ，记录现在是 [5, -2, -4]<br />
“9” - 记录加 9 ，记录现在是 [5, -2, -4, 9]<br />
“+” - 记录加 -4 + 9 = 5 ，记录现在是 [5, -2, -4, 9, 5]<br />
“+” - 记录加 9 + 5 = 14 ，记录现在是 [5, -2, -4, 9, 5, 14]<br />
所有得分的总和 5 + -2 + -4 + 9 + 5 + 14 = 27<br />
示例 3：</p>
<p>输入：ops = [“1”]<br />
输出：1</p>
<p>提示：</p>
<p>1 &lt;= ops.length &lt;= 1000<br />
ops[i] 为 “C”、“D”、“+”，或者一个表示整数的字符串。整数范围是 [-3 * 104, 3 * 104]<br />
对于 “+” 操作，题目数据保证记录此操作时前面总是存在两个有效的分数<br />
对于 “C” 和 “D” 操作，题目数据保证记录此操作时前面总是存在一个有效的分数</p>
<h2 id="java解法-4"><a class="markdownIt-Anchor" href="#java解法-4"></a> java解法</h2>
<ul>
<li>法一：
<ul>
<li>依次读出字符串数组中的字符串，如果是特殊字符，则执行该字符对应的操作，如果是数字则转换为整型压入栈中,最后遍历栈计算和。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;
    public int calPoints(String[] ops) &#123;
        Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;();

        for(String op : ops) &#123;
            if(op.equals(&quot;C&quot;)) &#123;
                stack.pop();
            &#125;else if(op.equals(&quot;D&quot;)) &#123;
                stack.push(stack.peek() * 2);
            &#125;else if(op.equals(&quot;+&quot;)) &#123;
                int top &#x3D; stack.pop();
                int newTop &#x3D; top + stack.peek();
                stack.push(top);
                stack.push(newTop);
            &#125;else &#123;
                stack.push(Integer.parseInt(op));
            &#125;
        &#125;

        int sum &#x3D; 0;
        for(int point : stack) &#123;
            sum +&#x3D; point;
        &#125;
        return sum;
    &#125;

    public static void main(String[] args) &#123;
        String[] ops &#x3D; &#123;&quot;5&quot;,&quot;-2&quot;,&quot;4&quot;,&quot;C&quot;,&quot;D&quot;,&quot;9&quot;,&quot;+&quot;,&quot;+&quot;&#125;;
        Solution solution &#x3D; new Solution();
        int points &#x3D; solution.calPoints(ops);
        System.out.println(points);
    &#125;
&#125;</code></pre>
<h1 id="5-用栈实现队列-232"><a class="markdownIt-Anchor" href="#5-用栈实现队列-232"></a> 5. 用栈实现队列 232</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">题目</a></li>
</ul>
<hr />
<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p>
<p>实现 MyQueue 类：</p>
<p>void push(int x) 将元素 x 推到队列的末尾<br />
int pop() 从队列的开头移除并返回元素<br />
int peek() 返回队列开头的元素<br />
boolean empty() 如果队列为空，返回 true ；否则，返回 false</p>
<p>说明：</p>
<p>你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。<br />
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</p>
<p>进阶：</p>
<p>你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。</p>
<pre class="line-numbers language-none"><code class="language-none">示例：

输入：
[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 1, 1, false]

解释：
MyQueue myQueue &#x3D; new MyQueue();
myQueue.push(1); &#x2F;&#x2F; queue is: [1]
myQueue.push(2); &#x2F;&#x2F; queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); &#x2F;&#x2F; return 1
myQueue.pop(); &#x2F;&#x2F; return 1, queue is [2]
myQueue.empty(); &#x2F;&#x2F; return false</code></pre>
<p>提示：</p>
<p>1 &lt;= x &lt;= 9<br />
最多调用 100 次 push、pop、peek 和 empty<br />
假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）</p>
<h2 id="java解法-5"><a class="markdownIt-Anchor" href="#java解法-5"></a> Java解法</h2>
<ul>
<li>法一：用两个栈来实现队列，一个栈负责接收输入，一个栈负责pop和peek。通过在两个栈之间的倒腾，来颠倒元素的顺序，负负得正，变为先入先出
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210720215034.png" alt="" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MyQueue &#123;
    Stack&lt;Integer&gt; in;
    Stack&lt;Integer&gt; out;

    public MyQueue()&#123;
        in &#x3D; new Stack&lt;&gt;();
        out &#x3D; new Stack&lt;&gt;();
    &#125;

    public void push(int x) &#123;
        in.push(x);
    &#125;

    public int pop() &#123;
        while(!in.isEmpty()) &#123;
            int temp &#x3D; in.pop();
            out.push(temp);
        &#125;
        int res &#x3D;  out.pop();
        while(!out.isEmpty()) &#123;
            int temp &#x3D; out.pop();
            in.push(temp);
        &#125;
        return res;
    &#125;

    public int peek() &#123;
        while(!in.isEmpty()) &#123;
            int temp &#x3D; in.pop();
            out.push(temp);
        &#125;
        int res &#x3D; out.peek();
        while(!out.isEmpty()) &#123;
            int temp &#x3D; out.pop();
            in.push(temp);
        &#125;
        return res;
    &#125;

    public boolean empty() &#123;
        return in.isEmpty();
    &#125;
&#125;</code></pre>
<h1 id="6-最小栈-155"><a class="markdownIt-Anchor" href="#6-最小栈-155"></a> 6. 最小栈 155</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-stack/">题目</a></li>
</ul>
<hr />
<p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>push(x) —— 将元素 x 推入栈中。<br />
pop() —— 删除栈顶的元素。<br />
top() —— 获取栈顶元素。<br />
getMin() —— 检索栈中的最小元素。</p>
<pre class="line-numbers language-none"><code class="language-none">示例:

输入：
[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack &#x3D; new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --&gt; 返回 -3.
minStack.pop();
minStack.top();      --&gt; 返回 0.
minStack.getMin();   --&gt; 返回 -2.</code></pre>
<p>提示：</p>
<p>pop、top 和 getMin 操作总是在 非空栈 上调用。</p>
<h2 id="java解法-6"><a class="markdownIt-Anchor" href="#java解法-6"></a> Java解法</h2>
<ul>
<li>法一：使用一个辅助栈，将当前最小的元素压入栈顶，每次pop的时候检查元素是否与辅助栈的栈顶元素相同，如果相同则将辅助栈栈顶元素也弹出。因为栈先进后出的特性，所以当当前最小元素弹出后顶替上来的元素值在栈中一定还存在。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/d58FXH.png" alt="d58FXH" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MinStack155 &#123;
    Stack&lt;Integer&gt; value;
    Stack&lt;Integer&gt; min;

    public MinStack155() &#123;
        value &#x3D; new Stack&lt;&gt;();
        min &#x3D; new Stack&lt;&gt;();
    &#125;

    public void push(int val) &#123;
        &#x2F;&#x2F;若当前值比栈中存的最小值小，则存入最小值栈中
        if(min.isEmpty()) &#123;
            min.push(val);
        &#125;else if(val &lt;&#x3D; min.peek()) &#123; &#x2F;&#x2F;注意与最小值相等也要再压一次，弹出的时候才能持平
            min.push(val);
        &#125;
        value.push(val);
    &#125;

    public int pop() &#123;
        if(value.peek().equals(min.peek())) &#123;
            min.pop();
        &#125;

        return value.pop();
    &#125;

    public int top() &#123;
        return value.peek();
    &#125;

    public int getMin() &#123;
        return min.peek();
    &#125;

&#125;</code></pre>
<h1 id="7-有效的括号-20"><a class="markdownIt-Anchor" href="#7-有效的括号-20"></a> 7. 有效的括号 20</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-parentheses/">题目</a></li>
</ul>
<hr />
<p>给定一个只包括 ‘(’，‘)’，‘{’，‘}’，‘[’，‘]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br />
左括号必须以正确的顺序闭合。</p>
<pre class="line-numbers language-none"><code class="language-none">示例 1：

输入：s &#x3D; &quot;()&quot;
输出：true
示例 2：

输入：s &#x3D; &quot;()[]&#123;&#125;&quot;
输出：true
示例 3：

输入：s &#x3D; &quot;(]&quot;
输出：false
示例 4：

输入：s &#x3D; &quot;([)]&quot;
输出：false
示例 5：

输入：s &#x3D; &quot;&#123;[]&#125;&quot;
输出：true</code></pre>
<p>提示：</p>
<p>1 &lt;= s.length &lt;= 104<br />
s 仅由括号 ‘()[]{}’ 组成</p>
<h2 id="java解法-7"><a class="markdownIt-Anchor" href="#java解法-7"></a> Java解法</h2>
<ul>
<li>法一：利用栈的先进先出特性，左括号进栈，遇右括号则出栈匹配
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/XBDlRE.png" alt="XBDlRE" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ValidParentheses20 &#123;

    public boolean isValid(String s) &#123;
        Stack&lt;Character&gt; stack &#x3D; new Stack&lt;&gt;();
        int len &#x3D; s.length();

        if(len % 2 !&#x3D; 0) &#123; &#x2F;&#x2F;括号数为奇数肯定不对
            return false;
        &#125;

        &#x2F;&#x2F;遍历括号，左括号进栈，右括号出栈比对
        int i;
        for(i &#x3D; 0; i &lt; len; i++) &#123;
            char temp &#x3D; s.charAt(i);
            if(temp &#x3D;&#x3D; &#39;(&#39; || temp &#x3D;&#x3D; &#39;[&#39; || temp &#x3D;&#x3D; &#39;&#123;&#39;) &#123;
                stack.push(temp);
            &#125; else &#123;
                char temp2;
                if(!stack.isEmpty()) &#123;
                    temp2 &#x3D; stack.pop();
                &#125; else &#123;
                    return false;
                &#125;
                if(temp2 &#x3D;&#x3D; &#39;(&#39; &amp;&amp; temp &#x3D;&#x3D; &#39;)&#39;) &#123;
                    continue;
                &#125; else if(temp2 &#x3D;&#x3D; &#39;[&#39; &amp;&amp; temp &#x3D;&#x3D; &#39;]&#39;) &#123;
                    continue;
                &#125; else if(temp2 &#x3D;&#x3D; &#39;&#123;&#39; &amp;&amp; temp &#x3D;&#x3D; &#39;&#125;&#39;) &#123;
                    continue;
                &#125; else &#123;
                    return false;
                &#125;
            &#125;
        &#125;

        &#x2F;&#x2F;最终字符串遍历完并且栈空则说明配对成功
        if(stack.isEmpty() || i &#x3D;&#x3D; len - 1) &#123;
            return true;
        &#125; else &#123;
            return false;
        &#125;
    &#125;

&#125;</code></pre>
<h1 id="8-每日温度-739"><a class="markdownIt-Anchor" href="#8-每日温度-739"></a> 8. 每日温度 739</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/daily-temperatures/">题目</a></li>
</ul>
<hr />
<p>请根据每日 气温 列表 temperatures ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<pre class="line-numbers language-none"><code class="language-none">示例 1:

输入: temperatures &#x3D; [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
示例 2:

输入: temperatures &#x3D; [30,40,50,60   ]
输出: [1,1,1,0]
示例 3:

输入: temperatures &#x3D; [30,60,90]
输出: [1,1,0]
 

提示：

1 &lt;&#x3D; temperatures.length &lt;&#x3D; 105
30 &lt;&#x3D; temperatures[i] &lt;&#x3D; 100</code></pre>
<h2 id="java解法-8"><a class="markdownIt-Anchor" href="#java解法-8"></a> Java解法</h2>
<ul>
<li>法一：单调栈的思路：用栈存储温度对应的下标，每遇到温度较高的则出栈存储，温度小的则入栈，保证栈中对应温度呈递减排列
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/l6kYqI.png" alt="l6kYqI" /></li>
<li>与<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-chunks-to-make-sorted/">最多能完成排序的块</a>类似，因为都是根据值的大小来划分位置，所以存值不重要，存位置下标才重要。此外，都利用了在关键结果出现前左右两边的值都是单纯的比关键结果小或者大的单调性。</li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DailyTemperatures739 &#123;

    public int[] dailyTemperatures(int[] temperatures) &#123;
        int len &#x3D; temperatures.length;
        &#x2F;&#x2F;存储下标的栈
        Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;();
        &#x2F;&#x2F;用来存储结果的数组
        int[] days &#x3D; new int[len];

        &#x2F;&#x2F;遍历整个温度数组
        for(int i &#x3D; 0; i &lt; len; i++) &#123;
            &#x2F;&#x2F;当栈为空，或者当前遍历到的温度不大于栈中下标对应的温度，则将对应下标压入栈中
            if(stack.isEmpty() || temperatures[i] &lt;&#x3D; temperatures[stack.peek()]) &#123;
                stack.push(i);
                continue;
            &#125;
            
            &#x2F;&#x2F;当栈不为空，或者当前温度高于栈顶下标对应的温度
            while(!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;
                &#x2F;&#x2F;当遇到比自己温度高的，出栈，将下标相减就是间隔天数
                int index &#x3D; stack.pop();
                days[index] &#x3D; i - index;
            &#125;
            stack.push(i);
        &#125;
        
        &#x2F;&#x2F;最后还留在栈中的就是没有找到之后比自己温度高的，直接赋为0
        while(!stack.isEmpty()) &#123;
            int index &#x3D; stack.pop();
            days[index] &#x3D; 0;
        &#125;

        return days;
    &#125;

&#125;</code></pre>

              </article>
          </article>
      </div>
  </div>

</div>



        </div>


        <!-- <div class="p-5 text-center ">
  <p class="h6"> <a href="https://beian.miit.gov.cn/" target="_blank">蜀ICP备2021022902号-1</a> ※ <a
          href="https://beian.mps.gov.cn/#/query/webSearch" target="_blank">川公网安备51010802032250号</a></p>
</div> -->

<div class="p-5 text-center">
  <img src="/img/beian_icon.png" alt="备案图标" class="icon" style="max-width: 48px; max-height: 48px; vertical-align: middle;">
  <p class="h6">
    <a href="https://beian.miit.gov.cn/" target="_blank">蜀ICP备2021022902号-1</a> ※
    <a href="https://beian.mps.gov.cn/#/query/webSearch" target="_blank">川公网安备51010802032250号</a>
  </p>
</div>
</body>

</html>