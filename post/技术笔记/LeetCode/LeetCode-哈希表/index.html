<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <head>
    <link href="/styles/main.css" rel="stylesheet" type="text/css"/>

    <meta charset="UTF-8">
    
    <title>LeetCode-哈希表 - ZestJourney</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/bootstrap/4.6.1/css/bootstrap.min.css">
    <script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/bootstrap/4.6.1/js/bootstrap.min.js"></script>

<script src="https://npm.elemecdn.com/@waline/client@v2/dist/waline.js"></script>
<link
  rel="stylesheet"
  href="https://npm.elemecdn.com/@waline/client@v2/dist/waline.css"
/>
<meta name="generator" content="Hexo 5.4.2"></head>

</head>

<body>
    


        <div>
            <div class="container-fluid position-relative">
                <nav class="navbar navbar-expand-lg navbar-dark  text-white bg-transparent">
                    <div class="container">
                        
                        <a class="navbar-brand" href="/">💖我们的秘密基地💖</a>
                        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarText"
                            aria-controls="navbarText" aria-expanded="false" aria-label="Toggle navigation">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                        <div class="collapse navbar-collapse" id="navbarText">
                            <ul class="navbar-nav mr-auto">
                            </ul>
                            <span class="navbar-text">
                                💕愿你三冬暖，愿你春不寒🍂
                            </span>
                        </div>
                    </div>
                </nav>
                <section class="lover-background"
                    style="background-image: url(/img/banner.jpg)">
                </section>
                <section
                    class="container lover-container d-flex flex-column align-content-center justify-content-center">
                    <div class="row align-items-center pb-5 lover">
                        <div class="col">
                            <div class="d-flex flex-column">
                                <img class="mx-auto avatar-img rounded-circle"
                                    src="/img/zestaken.jpg" alt="">
                                <h4 class="mx-auto text-white pt-2">  
                                    zestaken
                                </h4>
                            </div>
                        </div>
                        <div class="col">
                            <div class="d-flex justify-content-center">
                                <div class="heart"></div>
                            </div>
                        </div>
                        <div class="col">
                            <div class="d-flex flex-column">
                                <img class="mx-auto avatar-img rounded-circle"
                                    src="/img/zinny.jpg" alt="">
                                <h4 class="mx-auto text-white pt-2">
                                    zinny
                                </h4>
                            </div>
                        </div>
                    </div>
                </section>
                <section class="main-hero-waves-area waves-area">
                    <svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
                        viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
                        <defs>
                            <path id="gentle-wave"
                                d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z">
                            </path>
                        </defs>
                        <g class="parallax">
                            <use xlink:href="#gentle-wave" x="48" y="0"></use>
                            <use xlink:href="#gentle-wave" x="48" y="3"></use>
                            <use xlink:href="#gentle-wave" x="48" y="5"></use>
                            <use xlink:href="#gentle-wave" x="48" y="7"></use>
                        </g>
                    </svg>
                </section>
            </div>

            <div id="Pjax">

  <div class="list-content mx-auto mt-5">
      <div id="article" class="list-top">
          <h5 class="list-text"> LeetCode-哈希表
          </h5>
          <article>
              <article>
                <h1 id="代码地址"><a class="markdownIt-Anchor" href="#代码地址"></a> 代码地址</h1>
<p><a target="_blank" rel="noopener" href="https://github.com/zestaken/newblog/tree/master/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/Code/src/main/java/hashTable">Github</a></p>
<h1 id="1-两数之和-1"><a class="markdownIt-Anchor" href="#1-两数之和-1"></a> 1. 两数之和 1</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum/">题目</a></li>
</ul>
<hr />
<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。<br />
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br />
你可以按任意顺序返回答案。</p>
<pre class="line-numbers language-none"><code class="language-none">示例 1：

输入：nums &#x3D; [2,7,11,15], target &#x3D; 9
输出：[0,1]
解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。
示例 2：

输入：nums &#x3D; [3,2,4], target &#x3D; 6
输出：[1,2]
示例 3：

输入：nums &#x3D; [3,3], target &#x3D; 6
输出：[0,1]
 

提示：

2 &lt;&#x3D; nums.length &lt;&#x3D; 104
-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109
-109 &lt;&#x3D; target &lt;&#x3D; 109
只会存在一个有效答案
进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？</code></pre>
<h2 id="java解法"><a class="markdownIt-Anchor" href="#java解法"></a> Java解法</h2>
<ul>
<li>法一: 首先遍历一次数组，将数组每个元素的值和下标以键值对的形式存入哈希表中，然后再次遍历数组，将目标值减去当前数组元素值得到一个结果，然后查询这个结果是否在哈希表中存在（注意避免查到自身的情况，如3 + 3 = 6）
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210831215434.png" alt="" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TwoSum1 &#123;

    public int[] twoSum(int[] nums, int target) &#123;

        &#x2F;&#x2F;创建哈希表，键为数组元素值，值为数组元素下标
        Map&lt;Integer, Integer&gt; hashtable &#x3D; new HashMap&lt;Integer, Integer&gt;();

        &#x2F;&#x2F;将数组元素的值和下标存入哈希表中
        for(int i &#x3D; 0; i &lt; nums.length; i++) &#123;
            hashtable.put(nums[i], i);
        &#125;

        &#x2F;&#x2F;存储结果的数组
        int[] res &#x3D; new int[2];
        &#x2F;&#x2F;遍历数组，将目标值减去数组元素值得到结果，然后查找哈希表中是否存在这个结果
        for(int i &#x3D; 0; i &lt; nums.length; i++) &#123;
            int temp &#x3D; target - nums[i];
            &#x2F;&#x2F;当在哈希表中查找到不是自身的数时，确认结果返回
            if(hashtable.containsKey(temp) &amp;&amp; hashtable.get(temp) !&#x3D; i) &#123;
                res[0] &#x3D; i;
                res[1] &#x3D; hashtable.get(temp);
                return res;
            &#125;
        &#125;

        return res;
    &#125;
&#125;</code></pre>
<h1 id="2-最长连续序列-128"><a class="markdownIt-Anchor" href="#2-最长连续序列-128"></a> 2. 最长连续序列 128</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">题目</a></li>
</ul>
<hr />
<p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。<br />
请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>
<pre class="line-numbers language-none"><code class="language-none">示例 1：

输入：nums &#x3D; [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
示例 2：

输入：nums &#x3D; [0,3,7,2,5,8,4,6,0,1]
输出：9
 

提示：

0 &lt;&#x3D; nums.length &lt;&#x3D; 105
-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</code></pre>
<h2 id="java解法-2"><a class="markdownIt-Anchor" href="#java解法-2"></a> Java解法</h2>
<ul>
<li>法一：用一个哈希集合存储数组元素（方便查找，同时去除重复的元素），然后遍历数组元素，已当前数组元素为中心向前和向后枚举与其连续的整数并在集合中查找，如果找到则在集合中删除该元素并且计数，如果没有找到则中断该方向的查找。每一次查找都能将一堆连续的数找到并清除出集合，在集合被清空时则确认得到了最长的连续整数长度。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210831231239.png" alt="" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class LongestConsecutiveSequence128 &#123;

    public int longestConsecutive(int[] nums) &#123;

        &#x2F;&#x2F;创建一个集合
        &#x2F;&#x2F;使用集合便于直接查找元素,并且利用集合的唯一性去除重复出现的元素
        Set&lt;Integer&gt; hashTable &#x3D; new HashSet&lt;&gt;();
        &#x2F;&#x2F;将数组中的值全部存入集合
        for(int i : nums) &#123;
            hashTable.add(i);
        &#125;

        &#x2F;&#x2F;最长长度
        int longestLength &#x3D; 0;

        &#x2F;&#x2F;遍历数组，在集合中找每一个数组元素的前后连续元素，然后将这些元素都删除并记录数量
        for(int num : nums) &#123;
            &#x2F;&#x2F;当集合已空则停止寻找连续元素
            if(!hashTable.isEmpty()) &#123;
                &#x2F;&#x2F;临时存储连续元素个数
                int tempRes &#x3D; 0;
                &#x2F;&#x2F;向左寻找当前元素的连续元素
                for(int i &#x3D; 0;  hashTable.contains(num - i); i++) &#123;
                    hashTable.contains(num - i);
                    hashTable.remove(num - i);
                    tempRes++;
                &#125;
                &#x2F;&#x2F;向右寻找当前元素的连续元素（不包含自身)
                for(int i &#x3D; 1; hashTable.contains(num + i); i++) &#123;
                    hashTable.contains(num + i);
                    hashTable.remove(num + i);
                    tempRes++;
                &#125;
                &#x2F;&#x2F;比较长短
                if(tempRes &gt; longestLength) &#123;
                    longestLength &#x3D; tempRes;
                &#125;
            &#125; else &#123;
                break;
            &#125;
        &#125;
        return longestLength;
    &#125;
&#125;</code></pre>
<h1 id="3-直线上最多的点数-149"><a class="markdownIt-Anchor" href="#3-直线上最多的点数-149"></a> 3. 直线上最多的点数 149</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-points-on-a-line/">题目</a></li>
</ul>
<hr />
<p>给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。求最多有多少个点在同一条直线上。<br />
示例1：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210831232314.png" alt="" /></p>
<pre class="line-numbers language-none"><code class="language-none">输入：points &#x3D; [[1,1],[2,2],[3,3]]
输出：3</code></pre>
<p>示例2：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210831232354.png" alt="" /></p>
<pre class="line-numbers language-none"><code class="language-none">输入：points &#x3D; [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
输出：4</code></pre>
<p>提示：</p>
<pre class="line-numbers language-none"><code class="language-none">1 &lt;&#x3D; points.length &lt;&#x3D; 300
points[i].length &#x3D;&#x3D; 2
-104 &lt;&#x3D; xi, yi &lt;&#x3D; 104
points 中的所有点 互不相同</code></pre>
<h2 id="java解法-3"><a class="markdownIt-Anchor" href="#java解法-3"></a> Java解法</h2>
<ul>
<li>法一：因为一条直线有一个点和斜率确定，所以我们遍历数组取出点，然后计算这个点与其它点的斜率，将这个斜率和其出现的次数存入哈希表中，在一个点与其它点的关系计算结束后，取出哈希表中出现次数最多的斜率，然后清空哈希表，进行下一轮的计算。因为一旦与前面的点能构成直线，在前面点计算时已经包含，所以只用计算当前点之后的点（按照在数组中出现的次序而言）。这个解法虽然通过了，但是有缺陷：如果计算的斜率超出了double的小数范围，就有可能不准确。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210901134149.png" alt="" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MaxPointsOnALine149 &#123;

    public int maxPoints(int[][] points) &#123;

        &#x2F;&#x2F;如果少于三个点则无需计算
        if(points.length &lt; 2) &#123;
            return points.length;
        &#125;
        &#x2F;&#x2F;创建哈希表，键为斜率，值为斜率出现的次数
        Map&lt;Double, Integer&gt; hashMap &#x3D; new HashMap&lt;&gt;();
        &#x2F;&#x2F;记录构成直线的最多点数
        int res &#x3D; 0;

        &#x2F;&#x2F;遍历点数组，计算之后的点与自己构成直线的次数（因为一旦与前面的点能构成直线，在前面点计算时已经包含，所以只用计算当前点之后的点）
        for(int i &#x3D; 0; i &lt; points.length; i++) &#123;
                &#x2F;&#x2F;斜率不存在的情况单独存储
                int sameX &#x3D; 1;
                &#x2F;&#x2F;遍历当前点之后的数组，将与当前点的斜率以及出现次数存入哈希表 
                for(int j &#x3D; i + 1; j &lt; points.length; j++) &#123;
                    &#x2F;&#x2F;当斜率存在时才计算
                    if((points[i][0] - points[j][0]) !&#x3D; 0) &#123;
                        &#x2F;&#x2F;计算斜率
                        double k &#x3D; ((double)(points[i][1] - points[j][1]))&#x2F;((double)(points[i][0] - points[j][0]));
                        &#x2F;&#x2F;因为哈希表判断键时将0 和 -0看作两个不同的数，所以需要处理一下
                        if(k &#x3D;&#x3D; -0) &#123;
                            k &#x3D; 0;
                        &#125;
                        &#x2F;&#x2F;查询哈希表中是否存在该斜率，如果存在则取出，如果不存在则初始为1（因为要包含自身，一旦构成直线就是两个点）
                        int count &#x3D; hashMap.getOrDefault(k, 1);
                        &#x2F;&#x2F;将该斜率的计数加一再存入哈希表中
                        count++;
                        hashMap.remove(k);
                        hashMap.put(k, count);
                    &#125; else &#123;
                        sameX++;
                    &#125;
                &#125;
                &#x2F;&#x2F;获取经过当前点构成直线的最多点数
                int temp &#x3D; 0;
                for(int count : hashMap.values()) &#123;
                    if(count &gt; temp) &#123;
                        temp &#x3D; count;
                    &#125;
                &#125;
                if(temp &lt; sameX) &#123;
                    temp &#x3D; sameX;
                &#125;
                &#x2F;&#x2F;如果经过当前点的构成直线的最多点数比以及统计的要多则赋给最后的结果
                if(temp &gt; res) &#123;
                    res &#x3D; temp;
                &#125;
                &#x2F;&#x2F;清空当前点构成的哈希表，进入下一个点的统计
                hashMap.clear();
        &#125;

        return res;
    &#125;
&#125;</code></pre>
<h1 id="4-重新安排行程-332"><a class="markdownIt-Anchor" href="#4-重新安排行程-332"></a> 4. 重新安排行程 332</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reconstruct-itinerary/">题目</a></li>
</ul>
<hr />
<p>给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。<br />
所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。<br />
例如，行程 <code>[&quot;JFK&quot;, &quot;LGA&quot;] 与 [&quot;JFK&quot;, &quot;LGB&quot;]</code> 相比就更小，排序更靠前。<br />
假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。<br />
示例1:<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/pz0dhe.jpg" alt="pz0dhe" /></p>
<pre class="line-numbers language-none"><code class="language-none">输入：tickets &#x3D; [[&quot;MUC&quot;,&quot;LHR&quot;],[&quot;JFK&quot;,&quot;MUC&quot;],[&quot;SFO&quot;,&quot;SJC&quot;],[&quot;LHR&quot;,&quot;SFO&quot;]]
输出：[&quot;JFK&quot;,&quot;MUC&quot;,&quot;LHR&quot;,&quot;SFO&quot;,&quot;SJC&quot;]</code></pre>
<p>示例2:<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/SIHzdm.jpg" alt="SIHzdm" /></p>
<pre class="line-numbers language-none"><code class="language-none">输入：tickets &#x3D; [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]
输出：[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]
解释：另一种有效的行程是 [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;] ，但是它字典排序更大更靠后。</code></pre>
<p>提示：</p>
<pre class="line-numbers language-none"><code class="language-none">1 &lt;&#x3D; tickets.length &lt;&#x3D; 300
tickets[i].length &#x3D;&#x3D; 2
fromi.length &#x3D;&#x3D; 3
toi.length &#x3D;&#x3D; 3
fromi 和 toi 由大写英文字母组成
fromi !&#x3D; toi</code></pre>
<h2 id="java解法-4"><a class="markdownIt-Anchor" href="#java解法-4"></a> Java解法</h2>
<ul>
<li>法一：
<ul>
<li>结果：</li>
<li>代码：</li>
</ul>
</li>
</ul>

              </article>
          </article>
      </div>
  </div>

</div>



        </div>


        <!-- <div class="p-5 text-center ">
  <p class="h6"> <a href="https://beian.miit.gov.cn/" target="_blank">蜀ICP备2021022902号-1</a> ※ <a
          href="https://beian.mps.gov.cn/#/query/webSearch" target="_blank">川公网安备51010802032250号</a></p>
</div> -->

<!-- <div class="p-5 text-center">
  <img src="/img/beian_icon.png" alt="备案图标" class="icon" style="max-width: 48px; max-height: 48px; vertical-align: middle;">
  <p class="h6">
    <a href="https://beian.miit.gov.cn/" target="_blank">蜀ICP备2021022902号-1</a> ※
    <a href="https://beian.mps.gov.cn/#/query/webSearch" target="_blank">川公网安备51010802032250号</a>
  </p>
</div> -->

<div class="p-5 text-center ">
  <p class="h6"> zestaken ❤️ zinny </p>
</div>
</body>

</html>