<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <head>
    <link href="/styles/main.css" rel="stylesheet" type="text/css"/>

    <meta charset="UTF-8">
    
    <title>LeetCode-树 - ZestJourney</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/bootstrap/4.6.1/css/bootstrap.min.css">
    <script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/bootstrap/4.6.1/js/bootstrap.min.js"></script>

<script src="https://npm.elemecdn.com/@waline/client@v2/dist/waline.js"></script>
<link
  rel="stylesheet"
  href="https://npm.elemecdn.com/@waline/client@v2/dist/waline.css"
/>
<meta name="generator" content="Hexo 5.4.2"></head>

</head>

<body>
    


        <div>
            <div class="container-fluid position-relative">
                <nav class="navbar navbar-expand-lg navbar-dark  text-white bg-transparent">
                    <div class="container">
                        
                        <a class="navbar-brand" href="/">💖我们的秘密基地💖</a>
                        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarText"
                            aria-controls="navbarText" aria-expanded="false" aria-label="Toggle navigation">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                        <div class="collapse navbar-collapse" id="navbarText">
                            <ul class="navbar-nav mr-auto">
                            </ul>
                            <span class="navbar-text">
                                💕愿你三冬暖，愿你春不寒🍂
                            </span>
                        </div>
                    </div>
                </nav>
                <section class="lover-background"
                    style="background-image: url(/img/banner.jpg)">
                </section>
                <section
                    class="container lover-container d-flex flex-column align-content-center justify-content-center">
                    <div class="row align-items-center pb-5 lover">
                        <div class="col">
                            <div class="d-flex flex-column">
                                <img class="mx-auto avatar-img rounded-circle"
                                    src="/img/zestaken.jpg" alt="">
                                <h4 class="mx-auto text-white pt-2">  
                                    zestaken
                                </h4>
                            </div>
                        </div>
                        <div class="col">
                            <div class="d-flex justify-content-center">
                                <div class="heart"></div>
                            </div>
                        </div>
                        <div class="col">
                            <div class="d-flex flex-column">
                                <img class="mx-auto avatar-img rounded-circle"
                                    src="/img/zinny.jpg" alt="">
                                <h4 class="mx-auto text-white pt-2">
                                    zinny
                                </h4>
                            </div>
                        </div>
                    </div>
                </section>
                <section class="main-hero-waves-area waves-area">
                    <svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
                        viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
                        <defs>
                            <path id="gentle-wave"
                                d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z">
                            </path>
                        </defs>
                        <g class="parallax">
                            <use xlink:href="#gentle-wave" x="48" y="0"></use>
                            <use xlink:href="#gentle-wave" x="48" y="3"></use>
                            <use xlink:href="#gentle-wave" x="48" y="5"></use>
                            <use xlink:href="#gentle-wave" x="48" y="7"></use>
                        </g>
                    </svg>
                </section>
            </div>

            <div id="Pjax">

  <div class="list-content mx-auto mt-5">
      <div id="article" class="list-top">
          <h5 class="list-text"> LeetCode-树
          </h5>
          <article>
              <article>
                <h1 id="1-二叉树的最大深度-104"><a class="markdownIt-Anchor" href="#1-二叉树的最大深度-104"></a> 1. 二叉树的最大深度 104</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">题目</a></li>
</ul>
<hr />
<p>给定一个二叉树，找出其最大深度。<br />
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br />
说明: 叶子节点是指没有子节点的节点。<br />
示例：<br />
给定二叉树 <code>[3,9,20,null,null,15,7]</code><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/hKwQG4.png" alt="hKwQG4" /><br />
返回它的最大深度 3 。</p>
<h2 id="java解法"><a class="markdownIt-Anchor" href="#java解法"></a> Java解法</h2>
<ul>
<li>法一：递归进行深度优先搜索：将一一颗二叉树划为三个部分：根节点，左子树，右子树，子树的高度加上根节点的高度（1）就是整颗二叉树的高度。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/Su4uv1.png" alt="Su4uv1" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MaximumDepthOfBinaryTree104 &#123;

    public int maxDepth(TreeNode root) &#123;
        &#x2F;&#x2F;利用递归的思想来求解
        &#x2F;&#x2F;将一一颗二叉树划为三个部分：根节点，左子树，右子树，子树的高度加上根节点的高度（1）就是整颗二叉树的高度
        &#x2F;&#x2F;实质是深度优先搜索
        if(root !&#x3D; null) &#123;
            &#x2F;&#x2F;注意要加上代表根节点的1
            int depth &#x3D; 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
            return depth;
        &#125; else &#123;
            &#x2F;&#x2F;当当前二叉树的根节点为null时返回0，也是递归到底返回的条件
            return 0;
        &#125;
    &#125;
&#125;

&#x2F;&#x2F;根据一个数组构造二叉树的方法
    &#x2F;**
     * 输入值的数组，生成二叉树（null用-1替代）
     * @param nums
     * @return
     *&#x2F;
    public static TreeNode mkBT(int[] nums) &#123;
        &#x2F;&#x2F;当数组长度为0时，直接返回空
         if(nums.length &#x3D;&#x3D; 0) &#123;
             return null;
         &#125;
        &#x2F;&#x2F;先根据数组依次生成节点，存储到集合中
        ArrayList&lt;TreeNode&gt; treeNodes &#x3D; new ArrayList&lt;&gt;();
        for(int i : nums) &#123;
            if(i &#x3D;&#x3D; -1) &#123;
                treeNodes.add(null);
            &#125; else &#123;
                treeNodes.add(new TreeNode(i));
            &#125;
         &#125;
        &#x2F;&#x2F;遍历前一半的节点（因为只有这些节点不是叶子节点）
        &#x2F;&#x2F; 根据子节点与根节点的下标对应关系，找到每一个非叶子节点的左右子节点并连接
         for(int i &#x3D; 0; i &lt; nums.length &#x2F; 2; i++) &#123;
             TreeNode cur &#x3D; treeNodes.get(i);
             cur.left &#x3D; treeNodes.get(2 * (i + 1) - 1);
             cur.right &#x3D; treeNodes.get(2 * (i + 1) + 1 - 1);
         &#125;
        &#x2F;&#x2F;返回总的根节点（就是集合中的第一个节点）
         return treeNodes.get(0);
    &#125;</code></pre>
<h1 id="2-平衡二叉树-110"><a class="markdownIt-Anchor" href="#2-平衡二叉树-110"></a> 2. 平衡二叉树 110</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree/">题目</a></li>
</ul>
<hr />
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。<br />
本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。<br />
示例 1：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/IGtDFV.jpg" alt="IGtDFV" /></p>
<pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [3,9,20,null,null,15,7]
输出：true</code></pre>
<p>示例2:<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/JRslxu.jpg" alt="JRslxu" /></p>
<pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [1,2,2,3,3,null,null,4,4]
输出：false</code></pre>
<p>示例3:</p>
<pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; []
输出：true</code></pre>
<p>提示：<br />
树中的节点数在范围 [0, 5000] 内<br />
-104 &lt;= Node.val &lt;= 104</p>
<h2 id="java解法-2"><a class="markdownIt-Anchor" href="#java解法-2"></a> Java解法</h2>
<ul>
<li>法一：递归获取左右子树的高度，并比较，如果高度差不大于1，则正常返回左右子树中最大高度，否则返回-1。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/V0Yg9H.png" alt="V0Yg9H" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BalancedBinaryTree110 &#123;

    public boolean isBalanced(TreeNode root) &#123;
        if (getDepth(root) !&#x3D; -1) &#123;
            return true;
        &#125;
        return false;
    &#125;

    &#x2F;**
     * 递归获取左右子树的高度并比较，如果高度差大于1，则返回-1
     * @param root
     * @return
     *&#x2F;
    int getDepth(TreeNode root) &#123;
        &#x2F;&#x2F;当root为null，说明已遍历到底部，返回0
        if(root &#x3D;&#x3D; null) &#123;
            return 0;
        &#125;
        &#x2F;&#x2F;获取左右子树的高度，并比较
        int left &#x3D; getDepth(root.left);
        int right &#x3D; getDepth(root.right);
        &#x2F;&#x2F;如果左右子树高度返回为-1，说明左右子树内部高度差超过了1
        if(left &#x3D;&#x3D; -1 || right &#x3D;&#x3D; -1 ||Math.abs(left - right) &gt; 1) &#123;
            return -1;
        &#125;
        &#x2F;&#x2F;如果正常，返回左右子树中的最大高度
        return 1 + Math.max(left, right);
    &#125;
&#125;</code></pre>
<h1 id="3-二叉树的直径-543"><a class="markdownIt-Anchor" href="#3-二叉树的直径-543"></a> 3. 二叉树的直径 543</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">题目</a></li>
</ul>
<hr />
<p>示例 :<br />
给定二叉树<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/JuYUaG.png" alt="JuYUaG" /><br />
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。<br />
注意：两结点之间的路径长度是以它们之间边的数目表示。</p>
<h2 id="java解法-3"><a class="markdownIt-Anchor" href="#java解法-3"></a> Java解法</h2>
<ul>
<li>法一：递归获取左右子树的节点数，每层相对根节点都根据左右子树节点数计算直径，最后选择最大的直径。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/lGTZ2E.png" alt="lGTZ2E" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DiameterOfBinaryTree543 &#123;

    &#x2F;&#x2F;记录直径值，设为类属性便于在方法间传递
    int diameter;

    public int diameterOfBinaryTree(TreeNode root) &#123;
        &#x2F;&#x2F;将初始直径设置为0
        diameter &#x3D; 0;
        &#x2F;&#x2F;获取二叉树的深度的同时修改最长直径值
        getDepth(root);
        return diameter;
    &#125;

    &#x2F;**
     * 递归获取二叉树的深度的同时修改最长直径值
     * @param root
     * @return
     *&#x2F;
    int getDepth(TreeNode root) &#123;
        &#x2F;&#x2F;当当前根节点为null，说明已经递归到了叶子节点，触底返回
        if(root &#x3D;&#x3D; null) &#123;
            return 0;
        &#125;
        &#x2F;&#x2F;获取左右子树的节点数（不加一是除去了根节点，以防计算直径的时候重复计算）
        int left &#x3D; getDepth(root.left);
        int right &#x3D; getDepth(root.right);
        &#x2F;&#x2F;当前节点为根节点时的最长直径是左右子树的节点数相加
        &#x2F;&#x2F;每次比较当前节点下的最长直径与前面直径，取最大值（因为最长直径必然经过某个相对根节点）
        diameter &#x3D; Math.max(left + right, diameter);
        &#x2F;&#x2F;返回左右子树的深度（加一算上当前根节点）
        return Math.max(left, right) + 1;
    &#125;
&#125;</code></pre>
<h1 id="4-路径总和-iii-437"><a class="markdownIt-Anchor" href="#4-路径总和-iii-437"></a> 4. 路径总和 III 437</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-iii/">题目</a></li>
</ul>
<hr />
<p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。<br />
示例 1：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/n1g3RH.jpg" alt="n1g3RH" /></p>
<pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], targetSum &#x3D; 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。</code></pre>
<p>示例2:</p>
<pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22
输出：3</code></pre>
<p>提示:</p>
<pre class="line-numbers language-none"><code class="language-none">二叉树的节点个数的范围是 [0,1000]
-109 &lt;&#x3D; Node.val &lt;&#x3D; 109 
-1000 &lt;&#x3D; targetSum &lt;&#x3D; 1000 </code></pre>
<h2 id="java解法-4"><a class="markdownIt-Anchor" href="#java解法-4"></a> Java解法</h2>
<ul>
<li>法一：
<ul>
<li>结果：</li>
<li>代码：</li>
</ul>
</li>
</ul>

              </article>
          </article>
      </div>
  </div>

</div>



        </div>


        <!-- <div class="p-5 text-center ">
  <p class="h6"> <a href="https://beian.miit.gov.cn/" target="_blank">蜀ICP备2021022902号-1</a> ※ <a
          href="https://beian.mps.gov.cn/#/query/webSearch" target="_blank">川公网安备51010802032250号</a></p>
</div> -->

<!-- <div class="p-5 text-center">
  <img src="/img/beian_icon.png" alt="备案图标" class="icon" style="max-width: 48px; max-height: 48px; vertical-align: middle;">
  <p class="h6">
    <a href="https://beian.miit.gov.cn/" target="_blank">蜀ICP备2021022902号-1</a> ※
    <a href="https://beian.mps.gov.cn/#/query/webSearch" target="_blank">川公网安备51010802032250号</a>
  </p>
</div> -->

<div class="p-5 text-center ">
  <p class="h6"> zestaken ❤️ zinny </p>
</div>
</body>

</html>