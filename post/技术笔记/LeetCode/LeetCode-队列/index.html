<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <head>
    <link href="/styles/main.css" rel="stylesheet" type="text/css"/>

    <meta charset="UTF-8">
    
    <title>LeetCode-队列 - ZestJourney</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/bootstrap/4.6.1/css/bootstrap.min.css">
    <script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/bootstrap/4.6.1/js/bootstrap.min.js"></script>

<script src="https://npm.elemecdn.com/@waline/client@v2/dist/waline.js"></script>
<link
  rel="stylesheet"
  href="https://npm.elemecdn.com/@waline/client@v2/dist/waline.css"
/>
<meta name="generator" content="Hexo 5.4.2"></head>

</head>

<body>
    


        <div>
            <div class="container-fluid position-relative">
                <nav class="navbar navbar-expand-lg navbar-dark  text-white bg-transparent">
                    <div class="container">
                        
                        <a class="navbar-brand" href="/">💖我们的秘密基地💖</a>
                        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarText"
                            aria-controls="navbarText" aria-expanded="false" aria-label="Toggle navigation">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                        <div class="collapse navbar-collapse" id="navbarText">
                            <ul class="navbar-nav mr-auto">
                            </ul>
                            <span class="navbar-text">
                                💕愿你三冬暖，愿你春不寒🍂
                            </span>
                        </div>
                    </div>
                </nav>
                <section class="lover-background"
                    style="background-image: url(/img/banner.jpg)">
                </section>
                <section
                    class="container lover-container d-flex flex-column align-content-center justify-content-center">
                    <div class="row align-items-center pb-5 lover">
                        <div class="col">
                            <div class="d-flex flex-column">
                                <img class="mx-auto avatar-img rounded-circle"
                                    src="/img/zestaken.jpg" alt="">
                                <h4 class="mx-auto text-white pt-2">  
                                    zestaken
                                </h4>
                            </div>
                        </div>
                        <div class="col">
                            <div class="d-flex justify-content-center">
                                <div class="heart"></div>
                            </div>
                        </div>
                        <div class="col">
                            <div class="d-flex flex-column">
                                <img class="mx-auto avatar-img rounded-circle"
                                    src="/img/zinny.jpg" alt="">
                                <h4 class="mx-auto text-white pt-2">
                                    zinny
                                </h4>
                            </div>
                        </div>
                    </div>
                </section>
                <section class="main-hero-waves-area waves-area">
                    <svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
                        viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
                        <defs>
                            <path id="gentle-wave"
                                d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z">
                            </path>
                        </defs>
                        <g class="parallax">
                            <use xlink:href="#gentle-wave" x="48" y="0"></use>
                            <use xlink:href="#gentle-wave" x="48" y="3"></use>
                            <use xlink:href="#gentle-wave" x="48" y="5"></use>
                            <use xlink:href="#gentle-wave" x="48" y="7"></use>
                        </g>
                    </svg>
                </section>
            </div>

            <div id="Pjax">

  <div class="list-content mx-auto mt-5">
      <div id="article" class="list-top">
          <h5 class="list-text"> LeetCode-队列
          </h5>
          <article>
              <article>
                <h1 id="代码地址"><a class="markdownIt-Anchor" href="#代码地址"></a> 代码地址</h1>
<p><a target="_blank" rel="noopener" href="https://github.com/zestaken/newblog/tree/master/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/Code/src/main/java/queue">github</a></p>
<h1 id="1-合并k个升序链表-23"><a class="markdownIt-Anchor" href="#1-合并k个升序链表-23"></a> 1. 合并k个升序链表 23</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">题目</a></li>
</ul>
<hr />
<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p></p>
<p>示例 1：</p>
<pre class="line-numbers language-none"><code class="language-none">输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
将它们合并到一个有序链表中得到。
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
示例 2：

输入：lists &#x3D; []
输出：[]
示例 3：

输入：lists &#x3D; [[]]
输出：[]</code></pre>
<p>提示：</p>
<pre class="line-numbers language-none"><code class="language-none">k &#x3D;&#x3D; lists.length
0 &lt;&#x3D; k &lt;&#x3D; 10^4
0 &lt;&#x3D; lists[i].length &lt;&#x3D; 500
-10^4 &lt;&#x3D; lists[i][j] &lt;&#x3D; 10^4
lists[i] 按 升序 排列
lists[i].length 的总和不超过 10^4</code></pre>
<h2 id="java解法"><a class="markdownIt-Anchor" href="#java解法"></a> Java解法</h2>
<ul>
<li>法一：使用<a target="_blank" rel="noopener" href="https://www.apiref.com/java11-zh/java.base/java/util/PriorityQueue.html">优先队列</a>，开始将各个链表的头节点加入优先队列中，优先队列会自动按值大小顺序添加到队列中，之后弹出队列元素，因为链表自身是有序的，弹出的一定是当前最小的元素，之后将弹出元素的下一节点添加到优先队列中，则又会自动排序，直到队列为空时，所有链表的元素都已经添加完了。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/KM82lW.png" alt="KM82lW" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MergeKLists23 &#123;
    &#x2F;**
     * 创建一个实现Comparable接口的ListNode，作为优先队列的元素
     * 使用优先队列PriorityQueue需要实现Comparable接口
     *&#x2F;
    class Status implements Comparable&lt;Status&gt;&#123;
        int val;
        ListNode node;

        Status(int val, ListNode node) &#123;
            this.val &#x3D; val;
            this.node &#x3D; node;
        &#125;

        &#x2F;**
         * 新添加进优先队列的元素通过这个方法获得优先级，较小的元素优先级高放在队列前面
         * @param status2
         * @return
         *&#x2F;
        @Override
        public int compareTo(Status status2) &#123;
            return this.val - status2.val;
        &#125;
    &#125;

    public ListNode mergeKLists(ListNode[] lists) &#123;

        &#x2F;&#x2F;创建以Status作为元素的优先队列
        PriorityQueue&lt;Status&gt; queue &#x3D; new PriorityQueue&lt;&gt;();

        &#x2F;&#x2F;首先将每个链表的头节点放入优先队列中
        for(ListNode node : lists) &#123;
            if(node !&#x3D; null) &#123;
                queue.offer(new Status(node.val, node));
            &#125;
        &#125;

        &#x2F;&#x2F;创建一个不存值的头节点便于返回结果
        ListNode head &#x3D; new ListNode();
        &#x2F;&#x2F;使用tail指针便于尾插法
        ListNode tail &#x3D; head;

        &#x2F;&#x2F;逐步弹出优先队列中元素，直到队列为空
        while(!queue.isEmpty()) &#123;
            &#x2F;&#x2F;弹出队列头部节点并插入结果链表尾部
            Status temp &#x3D; queue.poll();
            tail.next &#x3D; temp.node;
            tail &#x3D; temp.node;
            &#x2F;&#x2F;将当前被弹出节点的下一节点加入优先队列中
            if(temp.node.next !&#x3D; null) &#123;
                queue.offer(new Status(temp.node.next.val, temp.node.next));
            &#125;
        &#125;
        tail.next &#x3D; null;

        return head.next;
    &#125;

&#125;</code></pre>
<h1 id="2-天际线问题-218"><a class="markdownIt-Anchor" href="#2-天际线问题-218"></a> 2. 天际线问题 218</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/the-skyline-problem/">题目</a></li>
</ul>
<hr />
<p>城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回由这些建筑物形成的 天际线 。</p>
<p>每个建筑物的几何信息由数组 buildings 表示，其中三元组 buildings[i] = [lefti, righti, heighti] 表示：</p>
<p>lefti 是第 i 座建筑物左边缘的 x 坐标。<br />
righti 是第 i 座建筑物右边缘的 x 坐标。<br />
heighti 是第 i 座建筑物的高度。<br />
天际线 应该表示为由 “关键点” 组成的列表，格式 [[x1,y1],[x2,y2],…] ，并按 x 坐标 进行 排序 。关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，y 坐标始终为 0 ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</p>
<p>注意：输出天际线中不得有连续的相同高度的水平线。例如 […[2 3], [4 5], [7 5], [11 5], [12 7]…] 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：[…[2 3], [4 5], [12 7], …]</p>
<p>示例1:<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/AIl1gT.jpg" alt="AIl1gT" /></p>
<pre class="line-numbers language-none"><code class="language-none">输入：buildings &#x3D; [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]
输出：[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]
解释：
图 A 显示输入的所有建筑物的位置和高度，
图 B 显示由这些建筑物形成的天际线。图 B 中的红点表示输出列表中的关键点。
示例 2：

输入：buildings &#x3D; [[0,2,3],[2,5,3]]
输出：[[0,3],[5,0]]
 

提示：

1 &lt;&#x3D; buildings.length &lt;&#x3D; 104
0 &lt;&#x3D; lefti &lt; righti &lt;&#x3D; 231 - 1
1 &lt;&#x3D; heighti &lt;&#x3D; 231 - 1
buildings 按 lefti 非递减排序</code></pre>
<h2 id="java解法-2"><a class="markdownIt-Anchor" href="#java解法-2"></a> Java解法</h2>
<ul>
<li>法一：首先先要观察出关键点出现的规律：1 关键点的横坐标必然在建筑物的左右边界上 2 处于建筑物左边界上的关键点的高度就是该建筑的高度，右边界上的则不然，得出建筑包含关键点的概念：大于等于建筑左坐标，小于建筑右坐标；之后使用<strong>扫描线法</strong>，逐个遍历所有的建筑的边界横坐标，并找出包含该边界的建筑物，将该建筑物信息存储。然后在所有包含该边界的建筑物中（遍历）选出最高的高度就是关键点的坐标。在基本思路清晰后，使用<strong>优先队列</strong>减少遍历包含边界的建筑物信息得出最大高度的过程：以高度为比较变量，高度最高的放在队列最前，每次只要确保队列最前的建筑包含边界即可使用其高度作为关键点高度（如果不包含，说明边界已经超过了该建筑所在区域，因为边界是从左到右遍历的，所以该建筑在确定关键点上已经失效（之后的边界它必然也不会包含），可以从队列中移除）。最后要注意每次得到新的关键点时都要确定是否<strong>与以前的关键点高度相同</strong>，如果相同则丢弃这个关键点。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210830084011.png" alt="" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SkyLine218 &#123;

    public List&lt;List&lt;Integer&gt;&gt; getSkyline(int[][] buildings) &#123;
        &#x2F;&#x2F;创建优先队列，
        PriorityQueue&lt;int[]&gt; priorityQueue &#x3D; new PriorityQueue&lt;int[]&gt;((a, b)-&gt;b[1] - a[1]);

        &#x2F;&#x2F;存储建筑物的边界的集合(建筑物的左右横坐标)
        List&lt;Integer&gt; boundaries &#x3D; new ArrayList&lt;&gt;();
        for(int[] building : buildings) &#123;
            boundaries.add(building[0]);
            boundaries.add(building[1]);
        &#125;
        &#x2F;&#x2F;对边界进行排序(从小到大)
        Collections.sort(boundaries);

        &#x2F;&#x2F;存储结果天际线的集合
        List&lt;List&lt;Integer&gt;&gt; result &#x3D; new ArrayList&lt;&gt;();

        int n &#x3D; buildings.length;
        int index &#x3D; 0;
        &#x2F;&#x2F;遍历边界一个个地找到天际线关键点
        for(int boundary : boundaries) &#123;
            &#x2F;&#x2F;从左到右遍历并找到包含该边界的建筑物，并添加到优先队列中去
            &#x2F;&#x2F;已经添加了的建筑不会再遍历
            while(index &lt; n &amp;&amp; buildings[index][0] &lt;&#x3D; boundary) &#123;
                &#x2F;&#x2F;将建筑物的右边界和高度整体存入优先队列中
                priorityQueue.offer(new int[] &#123;buildings[index][1], buildings[index][2]&#125;);
                index++;
            &#125;
            &#x2F;&#x2F;确保优先队列首部的元素包含该边界（即右横坐标大于边界坐标）
            while(!priorityQueue.isEmpty() &amp;&amp; priorityQueue.peek()[0] &lt;&#x3D; boundary) &#123;
                priorityQueue.poll();
            &#125;

            &#x2F;&#x2F;获取优先队列首部的元素（建筑物）的高度，即最大高度（同时这个高度对应的建筑包含该边界）
            int maxHeight &#x3D; priorityQueue.isEmpty() ? 0 : priorityQueue.peek()[1];
            &#x2F;&#x2F;如果这个高度没有与前面的高度相同，则和边界一起存入结果集合中
            if(result.size() &#x3D;&#x3D; 0 || maxHeight !&#x3D; result.get(result.size() - 1).get(1)) &#123;
                result.add(Arrays.asList(boundary, maxHeight));
            &#125;
        &#125;
        return result;
    &#125;
&#125;</code></pre>
<h1 id="3-滑动窗口最大值-239"><a class="markdownIt-Anchor" href="#3-滑动窗口最大值-239"></a> 3. 滑动窗口最大值 239</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> *<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sliding-window-maximum/">题目</a></h2>
<p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<pre class="line-numbers language-none"><code class="language-none">示例 1：

输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
示例 2：

输入：nums &#x3D; [1], k &#x3D; 1
输出：[1]
示例 3：

输入：nums &#x3D; [1,-1], k &#x3D; 1
输出：[1,-1]
示例 4：

输入：nums &#x3D; [9,11], k &#x3D; 2
输出：[11]
示例 5：

输入：nums &#x3D; [4,-2], k &#x3D; 2
输出：[4]

提示：

1 &lt;&#x3D; nums.length &lt;&#x3D; 105
-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104
1 &lt;&#x3D; k &lt;&#x3D; nums.length</code></pre>
<h2 id="java解法-3"><a class="markdownIt-Anchor" href="#java解法-3"></a> Java解法</h2>
<ul>
<li>法一：使用双端队列存储窗口内容，每次移动窗口就是将双端队列的最前面去掉在尾部加入新元素。将双端队列中的新元素加入优先队列中去，并且记录每个元素对应的下标。每次移动窗口后，获取优先队列的顶部元素，并根据下标判断他是否是窗口中的元素，如果不是则弹出，再取出新的顶部元素，直到属于窗口中为止，这个顶部元素就是当前窗口最大的元素，将其加入结果数组中。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/M6GE8z.png" alt="M6GE8z" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SlidingWindowMaximum239 &#123;

    public int[] maxSlidingWindow(int[] nums, int k) &#123;

        &#x2F;&#x2F;创建存储结果的数组
        int length  &#x3D; nums.length;
        int[] res &#x3D; new int[length - k + 1];
        &#x2F;&#x2F;创建双端队列
        Deque deque &#x3D; new LinkedList();
        &#x2F;&#x2F;初始化队列，将数组最前面的k位数装入队列
        for(int i &#x3D; 0; i &lt; k; i++) &#123;
            deque.offerLast(nums[i]);
        &#125;

        &#x2F;&#x2F;用于比较的栈
        Stack stack &#x3D; new Stack();
        &#x2F;&#x2F;用优先队列来比较大小,优先队列元素：&#123;num, index&#125;,数以及它对应的下标来感知最大值是否已经超出窗口
        PriorityQueue&lt;int[]&gt; priorityQueue &#x3D; new PriorityQueue&lt;int[]&gt;((a, b)-&gt;b[0] - a[0]);
        &#x2F;&#x2F;先计算出队列中的最大值
        for(int j &#x3D; 0; j &lt; k; j++) &#123;
            int temp &#x3D; (int) deque.pollLast();
            priorityQueue.offer(new int[]&#123;temp, k - j - 1&#125;);
            &#x2F;&#x2F;用栈来保存，以便复原双端队列
            stack.push(temp);
        &#125;
        &#x2F;&#x2F;复原双端队列
        while (!stack.isEmpty()) &#123;
            int temp &#x3D; (int) stack.pop();
            deque.offerLast(temp);
        &#125;

        for(int i &#x3D; 0; k + i &lt;&#x3D; length; i++) &#123;

            &#x2F;&#x2F;获取在当前窗口的最大值
            boolean flag &#x3D; false; &#x2F;&#x2F;是否获取到当前窗口最大值的标志
            while(!flag) &#123;
                if(i &lt;&#x3D; priorityQueue.peek()[1] &amp;&amp; priorityQueue.peek()[1]  &lt; k + i) &#123;
                    res[i] &#x3D; priorityQueue.peek()[0];
                    flag &#x3D; true;
                &#125; else &#123;
                    priorityQueue.poll();
                &#125;
            &#125;
            &#x2F;&#x2F;移动窗口
            if(k + i &lt; length) &#123;
                deque.pollFirst();
                deque.offerLast(nums[k + i]);
            &#125;
            &#x2F;&#x2F;将最新加入窗口的元素加入优先队列
            int temp &#x3D; (int) deque.getLast();
            priorityQueue.offer(new int[]&#123;temp, k + i&#125;);
        &#125;

        return res;
    &#125;
&#125;</code></pre>

              </article>
          </article>
      </div>
  </div>

</div>



        </div>


        <!-- <div class="p-5 text-center ">
  <p class="h6"> <a href="https://beian.miit.gov.cn/" target="_blank">蜀ICP备2021022902号-1</a> ※ <a
          href="https://beian.mps.gov.cn/#/query/webSearch" target="_blank">川公网安备51010802032250号</a></p>
</div> -->

<div class="p-5 text-center">
  <img src="/img/beian_icon.png" alt="备案图标" class="icon" style="max-width: 48px; max-height: 48px; vertical-align: middle;">
  <p class="h6">
    <a href="https://beian.miit.gov.cn/" target="_blank">蜀ICP备2021022902号-1</a> ※
    <a href="https://beian.mps.gov.cn/#/query/webSearch" target="_blank">川公网安备51010802032250号</a>
  </p>
</div>
</body>

</html>