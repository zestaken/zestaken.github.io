<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.zestaken.top","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":true,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="吾好梦中读书~">
<meta property="og:type" content="website">
<meta property="og:title" content="ZestJourney">
<meta property="og:url" content="http://www.zestaken.top/page/7/index.html">
<meta property="og:site_name" content="ZestJourney">
<meta property="og:description" content="吾好梦中读书~">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zestaken">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://www.zestaken.top/page/7/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/7/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ZestJourney</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ZestJourney</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">乐游记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zestaken</p>
  <div class="site-description" itemprop="description">吾好梦中读书~</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">84</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">60</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Nginx/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Nginx/index.html" class="post-title-link" itemprop="url">Nginx</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-07 17:53:06" itemprop="dateCreated datePublished" datetime="2020-10-07T17:53:06+08:00">2020-10-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:27:52" itemprop="dateModified" datetime="2022-09-17T19:27:52+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web后端</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="nginx概述"><a class="markdownIt-Anchor" href="#nginx概述"></a> Nginx概述</h1>
<p><a target="_blank" rel="noopener" href="http://nginx.org/en/docs/">官方文档</a></p>
<ul>
<li>Nginx(engine x)是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</li>
<li>Nginx的应用场景：
<ol>
<li>http服务器：Nginx是一个http服务器，可以独立提供http服务，可以用作网页静态服务器。</li>
<li>虚拟主机：可以实现在一台服务器虚拟出多个网站。</li>
<li>反向代理，负载均衡：当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要使用多台服务器集群时，可以使用Nginx做反向代理，并且多台服务器可以平均分担负载（即负载均衡），不会出现某台服务器负载高而宕机，而另外的某台服务器闲置的情况。</li>
</ol>
</li>
</ul>
<h1 id="nginx在linux下的安装"><a class="markdownIt-Anchor" href="#nginx在linux下的安装"></a> Nginx在linux下的安装</h1>
<p><a target="_blank" rel="noopener" href="https://www.nginx.cn/install">参考文档</a></p>
<ol>
<li>准备编译环境(Ubuntu系列）：</li>
</ol>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">apt-get install build-essential
apt-get install libtool</code></pre>
<ol start="2">
<li>安装PCRE库：
<ol>
<li><a target="_blank" rel="noopener" href="https://ftp.pcre.org/pub/pcre/">官网下载</a></li>
<li>解压到<code>/usr/local/src</code>下，需要sudo权限（在这个目录下的操作大多都需要sudo权限）sd</li>
<li>运行configure文件，生成makefile文件</li>
<li><code>make</code></li>
<li><code>sudo make install</code>,需要sudo权限。</li>
</ol>
</li>
<li>安装Zlib库：
<ol>
<li><a target="_blank" rel="noopener" href="http://zlib.net/">官网下载</a></li>
<li>解压到<code>/usr/local/src</code>下，需要sudo权限</li>
<li>运行configure文件，生成makefile文件</li>
<li><code>make</code></li>
<li><code>sudo make install</code>,需要sudo权限</li>
</ol>
</li>
<li>安装ssl
<ol>
<li><a target="_blank" rel="noopener" href="https://www.openssl.org/source/">官网下载</a></li>
<li>解压到<code>/usr/local/src</code>下，需要sudo权限</li>
</ol>
</li>
<li>安装Nginx
<ol>
<li><a target="_blank" rel="noopener" href="http://nginx.org/en/download.html">官网下载</a></li>
<li>解压到<code>/usr/local/src</code>下，需要sudo权限</li>
<li>运行configure文件，生成makefile文件，不过要配置一些参数(其中依赖库的版本要与自己安装的对应）：</li>
</ol>
</li>
</ol>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">.&#x2F;configure --sbin-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;nginx \
--conf-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;nginx.conf \
--pid-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;nginx.pid \
--with-http_gzip_static_module \
--with-http_stub_status_module \
--with-file-aio \
--with-http_realip_module \
--with-http_ssl_module \
--with-pcre&#x3D;&#x2F;usr&#x2F;local&#x2F;src&#x2F;pcre-8.44 \
--with-zlib&#x3D;&#x2F;usr&#x2F;local&#x2F;src&#x2F;zlib-1.2.11 \
--with-openssl&#x3D;&#x2F;usr&#x2F;local&#x2F;src&#x2F;openssl-1.1.1i</code></pre>
<ol start="4">
<li><code>make -j2</code>，用两个线程编译，这一步用时稍微要久一点</li>
<li><code>make install</code>。</li>
</ol>
<ul>
<li>安装好后，会在<code>/usr/local</code>目录下生成nginx目录</li>
<li>直接运行nginx目录下的nginx文件，即可启动nginx服务器，默认为80端口，可直接用本机的ip地址访问该服务器。</li>
</ul>
<h1 id="常用控制命令"><a class="markdownIt-Anchor" href="#常用控制命令"></a> 常用控制命令</h1>
<ul>
<li><code>./nginx -s stop</code>:中止服务器，非正常关闭;</li>
<li><code>./nginx -s quit</code>:正常关闭服务器;</li>
<li><code>./nginx -s reload</code>:重新加载服务器的配置文件(在服务器启动的情况下才能重新加载)</li>
<li><code>./nginx -s reopen</code>:重新打开日志文件</li>
</ul>
<h1 id="nginx部署静态页面"><a class="markdownIt-Anchor" href="#nginx部署静态页面"></a> Nginx部署静态页面</h1>
<ul>
<li>在<code>/usr/local/nginx</code>目录下，创建一个存储静态资源的目录，比如说<code>/usr/local/nginx/data</code></li>
<li>之后修改<code>/usr/local/nginx</code>目录下的<code>nginx.conf</code>文件的server模块。</li>
</ul>
<pre class="line-numbers language-conf" data-language="conf"><code class="language-conf">http &#123;
    include       mime.types;
    default_type  application&#x2F;octet-stream;

    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;

    #access_log  logs&#x2F;access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;

    server &#123;
        listen       80;# 默认端口号
        server_name  localhost; # 域名或者ip

        #charset koi8-r;

        #access_log  logs&#x2F;host.access.log  main;

        location &#x2F; &#123; 
            root    data # 默认访问资源目录 
            index  index.html index.htm; #默认访问资源文件名
        &#125;

        #error_page  404              &#x2F;404.html;

        # redirect server error pages to the static page &#x2F;50x.html
        #
        error_page   500 502 503 504  &#x2F;50x.html; # 错误资源
        location &#x3D; &#x2F;50x.html &#123;
            root   html;
        &#125;

        # proxy the PHP scripts to Apache listening on 127.0.0.1:80
        #
        #location ~ \.php$ &#123;
        #    proxy_pass   http:&#x2F;&#x2F;127.0.0.1;
        #&#125;

        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #
        #location ~ \.php$ &#123;
        #    root           html;
        #    fastcgi_pass   127.0.0.1:9000;
        #    fastcgi_index  index.php;
        #    fastcgi_param  SCRIPT_FILENAME  &#x2F;scripts$fastcgi_script_name;
        #    include        fastcgi_params;
        #&#125;

        # deny access to .htaccess files, if Apache&#39;s document root
        # concurs with nginx&#39;s one
        #
        #location ~ &#x2F;\.ht &#123;
        #    deny  all;
        #&#125;
    &#125;</code></pre>
<h1 id="配置虚拟主机"><a class="markdownIt-Anchor" href="#配置虚拟主机"></a> 配置虚拟主机</h1>
<ul>
<li>虚拟主机可以理解为在同一个服务器里面部署多个项目。</li>
<li>只需要在<code>nginx.conf</code>文件中，增加<code>server</code>模块即可。</li>
<li>端口绑定：
<ul>
<li>即修改server模块中的listen选项，用不同的端口号来访问不同的资源。</li>
</ul>
</li>
<li>域名绑定：
<ul>
<li>一个ip可以对应多个域名，所以本机的ip地址可以设置多个对应的域名（需要修改本机的hosts文件）</li>
<li>然后修改server模块的server_name为不同的域名，即可以用不同的域名来访问不同的资源。</li>
</ul>
</li>
</ul>
<h1 id="nginx的反向代理和负载均衡"><a class="markdownIt-Anchor" href="#nginx的反向代理和负载均衡"></a> Nginx的反向代理和负载均衡</h1>
<ul>
<li><strong>正向代理(代理)</strong>:意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后<strong>代理向原始服务器转交请求并将获得的内容返回给客户端</strong>。客户端才能使用正向代理。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210203122231.jpeg" alt="" /></li>
<li><strong>反向代理</strong>:反向代理服务器位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户<strong>直接访问反向代理服务器就可以获得目标服务器的资源</strong>。同时，用户不需要知道目标服务器的地址，也无须在用户端作任何设定。反向代理服务器通常可用来作为Web加速，即使用反向代理作为Web服务器的前置机来降低网络和服务器的负载，提高访问效率。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210203122317.jpeg" alt="" /></li>
</ul>
<h2 id="配置nginx的反向代理"><a class="markdownIt-Anchor" href="#配置nginx的反向代理"></a> 配置Nginx的反向代理</h2>
<ul>
<li>修改<code>nginx.conf</code>配置文件;</li>
</ul>
<pre class="line-numbers language-conf" data-language="conf"><code class="language-conf">http &#123;
  include       mime.types;
  default_type  application&#x2F;octet-stream;

  #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
  #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
  #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;

  #access_log  logs&#x2F;access.log  main;

  sendfile        on;
  #tcp_nopush     on;

  #keepalive_timeout  0;
  keepalive_timeout  65;

  #gzip  on;

  upstream tomcat1 &#123; # tomcat1是为被代理服务器自己取的名字
     server 192.168.177.129:8080 # 被代理服务器的ip地址和端口
  &#125;

  server &#123;
      listen       80;# 默认端口号
      server_name  localhost; # 域名或者ip

      #charset koi8-r;

      #access_log  logs&#x2F;host.access.log  main;

      location &#x2F; &#123; 
          root    data # 默认访问资源目录 
          proxy_pass   http:&#x2F;&#x2F;tomcat1; # 被代理服务器的的名字作为后面部分
          index  index.html index.htm; #默认访问资源文件名
      &#125;

      #error_page  404              &#x2F;404.html;

      # redirect server error pages to the static page &#x2F;50x.html
      #
      error_page   500 502 503 504  &#x2F;50x.html; # 错误资源
      location &#x3D; &#x2F;50x.html &#123;
          root   html;
      &#125;

      # proxy the PHP scripts to Apache listening on 127.0.0.1:80
      #
      #location ~ \.php$ &#123;
      #    proxy_pass   http:&#x2F;&#x2F;127.0.0.1;
      #&#125;

      # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
      #
      #location ~ \.php$ &#123;
      #    root           html;
      #    fastcgi_pass   127.0.0.1:9000;
      #    fastcgi_index  index.php;
      #    fastcgi_param  SCRIPT_FILENAME  &#x2F;scripts$fastcgi_script_name;
      #    include        fastcgi_params;
      #&#125;

      # deny access to .htaccess files, if Apache&#39;s document root
      # concurs with nginx&#39;s one
      #
      #location ~ &#x2F;\.ht &#123;
      #    deny  all;
      #&#125;
  &#125;</code></pre>
<h2 id="配置nginx的负载均衡"><a class="markdownIt-Anchor" href="#配置nginx的负载均衡"></a> 配置Nginx的负载均衡</h2>
<ul>
<li>修改<code>nginx.conf</code>的配置文件：</li>
</ul>
<pre class="highlight"><code class="conf">  http &#123;
    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
    #                  '$status $body_bytes_sent &quot;$http_referer&quot; '
    #                  '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;

    #如果配置了多台服务器在这里面，nginx会按照权重值分配对这三台服务器的访问，如果没有设置，则权重值默认为1
    upstream tomcats &#123; # tomcats是为被代理服务器自己取的名字
       server 192.168.177.129:8080 weight = 2; # 被代理服务器的ip地址和端口
       server 192.168.177.129:8081;# 被代理服务器的ip地址和端口
       server 192.168.177.129:8082; # 被代理服务器的ip地址和端口
    &#125;

    server &#123;
        listen       80;# 默认端口号
        server_name  localhost; # 域名或者ip

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / &#123; 
            root    data # 默认访问资源目录 
            proxy_pass   http://tomcats; # 被代理服务器的的名字作为后面部分
            index  index.html index.htm; #默认访问资源文件名
        &#125;

        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html; # 错误资源
        location = /50x.html &#123;
            root   html;
        &#125;

        # proxy the PHP scripts to Apache listening on 127.0.0.1:80
        #
        #location ~ \.php$ &#123;
        #    proxy_pass   http://127.0.0.1;
        #&#125;

        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #
        #location ~ \.php$ &#123;
        #    root           html;
        #    fastcgi_pass   127.0.0.1:9000;
        #    fastcgi_index  index.php;
        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
        #    include        fastcgi_params;
        #&#125;

        # deny access to .htaccess files, if Apache's document root
        # concurs with nginx's one
        #
        #location ~ /\.ht &#123;
        #    deny  all;
        #&#125;
    &#125;

</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Linux/Linux%E7%9A%84ssh%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Linux/Linux%E7%9A%84ssh%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/index.html" class="post-title-link" itemprop="url">Linux的ssh远程登录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-07 09:39:28" itemprop="dateCreated datePublished" datetime="2020-10-07T09:39:28+08:00">2020-10-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:27:52" itemprop="dateModified" datetime="2022-09-17T19:27:52+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="法一windows通过登录工具远程登录linux"><a class="markdownIt-Anchor" href="#法一windows通过登录工具远程登录linux"></a> 法一：Windows通过登录工具远程登录linux</h1>
<ol>
<li>
<p>linux中启动ssh服务</p>
<ul>
<li>安装ssh服务：<code>sudo apt-get install openssh-server</code></li>
<li>启动ssh服务: <code>sudo /etc/init.d/ssh start</code></li>
</ul>
</li>
<li>
<p>windows中安装putty</p>
</li>
</ol>
<ul>
<li>直接去<a target="_blank" rel="noopener" href="https://www.chiark.greenend.org.uk/~sgtatham/putty/">官网</a>下载安装</li>
</ul>
<ol start="3">
<li>在linux中安装net-tools来查看局域网ip</li>
</ol>
<ul>
<li>使用命令<code>sudo apt-get install net-tools</code>。</li>
<li>使用命令<code>ifconfig</code>来查看ip。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201007114241.jpg" alt="" /></li>
</ul>
<ol start="4">
<li>启动putty
<ul>
<li>在putty中输入局域网IP</li>
<li>之后开启一个黑色终端界面，在里面输入用户名和密码，连接到linux。<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201007115016.jpg" alt="" /></li>
</ul>
</li>
</ol>
<h1 id="法二ssh通过账号密码登录远程linux服务器"><a class="markdownIt-Anchor" href="#法二ssh通过账号密码登录远程linux服务器"></a> 法二：ssh通过账号密码登录远程linux服务器</h1>
<ul>
<li><code>ssh 账号@服务器地址</code>,如：<code>ssh zhangjie@106.14.197.71</code></li>
<li>前提是双方的ssh服务都启动。</li>
</ul>
<h1 id="法三使用公钥ssh远程登录到linux"><a class="markdownIt-Anchor" href="#法三使用公钥ssh远程登录到linux"></a> 法三：使用公钥ssh远程登录到linux</h1>
<ul>
<li>不用输入密码即可登录，可应用于自动登录。</li>
<li>在客户端中使用<code>ssh-keygen</code>来生成ssh秘钥和公钥</li>
<li>将公钥部署到linux服务器上去。命令为<code>ssh-copy-id -i ~/.ssh/id_rsa.pub root@111.111.111.111</code></li>
<li>在客户端中使用<code>ssh root@111.111.111.111 -p 22</code>即可登录linux服务器。<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201007172656.jpg" alt="" /></li>
</ul>
<h1 id="查看linux的网络情况"><a class="markdownIt-Anchor" href="#查看linux的网络情况"></a> 查看linux的网络情况</h1>
<ul>
<li>使用<code>ifconfig</code>命令可以查看本机的网络情况。<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201007115709.jpg" alt="" /></li>
</ul>
<h1 id="top查看工具"><a class="markdownIt-Anchor" href="#top查看工具"></a> top查看工具</h1>
<ul>
<li>top 工具是我们常用的一个查看工具，能实时的查看我们系统的一些关键信息的变化。</li>
</ul>
<ul>
<li>top 是一个在前台执行的程序，所以执行后便进入到这样的一个交互界面，正是因为交互界面我们才可以实时的获取到系统与进程的信息。在交互界面中我们可以通过一些指令来操作和筛选。</li>
<li>常用交互命令：</li>
</ul>
<table>
<thead>
<tr>
<th>常用交互命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>q</td>
<td>退出程序</td>
</tr>
<tr>
<td>I</td>
<td>切换显示平均负载和启动时间的信息</td>
</tr>
<tr>
<td>P</td>
<td>根据 CPU 使用百分比大小进行排序</td>
</tr>
<tr>
<td>M</td>
<td>根据驻留内存大小进行排序</td>
</tr>
<tr>
<td>i</td>
<td>忽略闲置和僵死的进程，这是一个开关式命令</td>
</tr>
<tr>
<td>k</td>
<td>终止一个进程，系统提示输入 PID 及发送的信号值。一般终止进程用 15 信号，不能正常结束则使用 9 信号。安全模式下该命令被屏蔽。</td>
</tr>
</tbody>
</table>
<ul>
<li>示例：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200715105949.jpg" alt="img" /></li>
<li>top 显示的第一排，</li>
</ul>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>top</td>
<td>表示当前程序的名称</td>
</tr>
<tr>
<td>10:59:28</td>
<td>表示当前的系统的时间</td>
</tr>
<tr>
<td>up 7 :06</td>
<td>表示该机器已经启动了多长时间</td>
</tr>
<tr>
<td>1 user</td>
<td>表示当前系统中只有一个用户</td>
</tr>
<tr>
<td>load average: 0.00,0.00,0.00</td>
<td>分别对应 1、5、15 分钟内 cpu 的平均负载</td>
</tr>
</tbody>
</table>
<ul>
<li>top 的第二行数据，基本上第二行是进程的一个情况统计</li>
</ul>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tasks: 384 total</td>
<td>进程总数</td>
</tr>
<tr>
<td>1 running</td>
<td>1 个正在运行的进程数</td>
</tr>
<tr>
<td>383 sleeping</td>
<td>383 个睡眠的进程数</td>
</tr>
<tr>
<td>0 stopped</td>
<td>没有停止的进程数</td>
</tr>
<tr>
<td>0 zombie</td>
<td>没有僵尸进程数</td>
</tr>
</tbody>
</table>
<ul>
<li>top 的第三行数据，这一行基本上是 CPU 的一个使用情况的统计了</li>
</ul>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cpu(s): 0.1 us</td>
<td>用户空间进程占用 CPU 百分比</td>
</tr>
<tr>
<td>0.2 sy</td>
<td>内核空间运行占用 CPU 百分比</td>
</tr>
<tr>
<td>0.0 ni</td>
<td>用户进程空间内改变过优先级的进程占用 CPU 百分比</td>
</tr>
<tr>
<td>99.7 id</td>
<td>空闲 CPU 百分比</td>
</tr>
<tr>
<td>0.0 wa</td>
<td>等待输入输出的 CPU 时间百分比</td>
</tr>
<tr>
<td>0.0 hi</td>
<td>硬中断(Hardware IRQ)占用 CPU 的百分比</td>
</tr>
<tr>
<td>0.0 si</td>
<td>软中断(Software IRQ)占用 CPU 的百分比</td>
</tr>
<tr>
<td>0.0 st</td>
<td>(Steal time) 是 hypervisor 等虚拟服务中，虚拟 CPU 等待实际 CPU 的时间的百分比</td>
</tr>
</tbody>
</table>
<ul>
<li>top 的第四行数据，这一行基本上是内存的一个使用情况的统计了：</li>
</ul>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>3908.4 total</td>
<td>物理内存总量</td>
</tr>
<tr>
<td>436.1 free</td>
<td>空闲内存总量</td>
</tr>
<tr>
<td>1253.8 used</td>
<td>使用的物理内存总量</td>
</tr>
<tr>
<td>2218.6 buff/cache</td>
<td>用作内核缓存的内存量</td>
</tr>
</tbody>
</table>
<ul>
<li>top 的第五行数据，这一行基本上是交换区的一个使用情况的统计了</li>
</ul>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>2048.0 total</td>
<td>交换区总量</td>
</tr>
<tr>
<td>2048.0 free</td>
<td>空闲交换区总量</td>
</tr>
<tr>
<td>0.0 used</td>
<td>使用的交换区总量</td>
</tr>
<tr>
<td>2379.4 avail Mem</td>
<td>缓冲的交换区总量,内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖</td>
</tr>
</tbody>
</table>
<ul>
<li>再下面就是进程的一个情况了</li>
</ul>
<table>
<thead>
<tr>
<th>列名</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>PID/进程号</td>
<td>进程 id</td>
</tr>
<tr>
<td>USER</td>
<td>该进程的所属用户</td>
</tr>
<tr>
<td>PR</td>
<td>该进程执行的优先级 priority 值</td>
</tr>
<tr>
<td>NI</td>
<td>该进程的 nice 值</td>
</tr>
<tr>
<td>VIRT</td>
<td>该进程任务所使用的虚拟内存的总数</td>
</tr>
<tr>
<td>RES</td>
<td>该进程所使用的物理内存数，也称之为驻留内存数</td>
</tr>
<tr>
<td>SHR</td>
<td>该进程共享内存的大小</td>
</tr>
<tr>
<td>S</td>
<td>该进程进程的状态: S=sleep R=running Z=zombie</td>
</tr>
<tr>
<td>%CPU</td>
<td>该进程 CPU 的利用率</td>
</tr>
<tr>
<td>%MEM</td>
<td>该进程内存的利用率</td>
</tr>
<tr>
<td>TIME+</td>
<td>该进程活跃的总时间</td>
</tr>
<tr>
<td>COMMAND</td>
<td>该进程运行的名字</td>
</tr>
</tbody>
</table>
<ul>
<li>注意：
<ul>
<li>NICE 值叫做静态优先级，是用户空间的一个优先级值，其取值范围是-20 至 19。这个值越小，表示进程”优先级”越高，而值越大“优先级”越低。nice 值中的 -20 到 19，中 -20 优先级最高， 0 是默认的值，而 19 优先级最低。</li>
<li>PR 值表示 Priority 值叫动态优先级，是进程在内核中实际的优先级值，进程优先级的取值范围是通过一个宏定义的，这个宏的名称是 MAX_PRIO，它的值为 140。Linux 实际上实现了 140 个优先级范围，取值范围是从 0-139，这个值越小，优先级越高。而这其中的 0 - 99 是实时进程的值，而 100 - 139 是给用户的。其中 PR 中的 100 to 139 值部分有这么一个对应 PR = 20 + (-20 to +19)，这里的 -20 to +19 便是 nice 值，所以说两个虽然都是优先级，而且有千丝万缕的关系，但是他们的值，他们的作用范围并不相同</li>
<li>VIRT 任务所使用的虚拟内存的总数，其中包含所有的代码，数据，共享库和被换出 swap 空间的页面等所占据空间的总数</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Java/junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Java/junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/index.html" class="post-title-link" itemprop="url">junit单元测试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-29 15:42:22" itemprop="dateCreated datePublished" datetime="2020-09-29T15:42:22+08:00">2020-09-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-09-26 21:41:56" itemprop="dateModified" datetime="2021-09-26T21:41:56+08:00">2021-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>478</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="junit简介"><a class="markdownIt-Anchor" href="#junit简介"></a> junit简介</h1>
<ul>
<li>JUnit 是一个 Java 编程语言的单元测试框架。JUnit 在测试驱动的开发方面有很重要的发展，是起源于 JUnit 的一个统称为 xUnit 的单元测试框架之一。</li>
</ul>
<h1 id="在idea中配置junit"><a class="markdownIt-Anchor" href="#在idea中配置junit"></a> 在IDEA中配置junit</h1>
<ul>
<li>安装JUnit Generator V2.0插件。<code>File--&gt;settings--&gt;Plguins</code>.</li>
</ul>
<h1 id="junit的基本使用"><a class="markdownIt-Anchor" href="#junit的基本使用"></a> junit的基本使用</h1>
<ul>
<li>
<p>测试方法必须使用 <code>@Test</code> 修饰</p>
</li>
<li>
<p>测试方法必须使用<code>public void</code>进行修饰，<strong>不能带参数</strong></p>
</li>
<li>
<p>一般使用单元测试会新建一个<strong>test 目录存放测试代码</strong>，在生产部署的时候只需要将 test 目录下代码删除即可</p>
</li>
<li>
<p>测试单元中的每个方法必须可以<strong>独立测试</strong>，方法间不能有任何依赖</p>
</li>
<li>
<p>测试类一般使用 <strong>Test 作为类名的后缀</strong></p>
</li>
<li>
<p>测试方法使一般用<strong>test 作为方法名的前缀</strong></p>
<h2 id="常用注解"><a class="markdownIt-Anchor" href="#常用注解"></a> 常用注解</h2>
</li>
<li>
<p>@Test:将一个普通方法修饰成一个<strong>测试方法</strong>.</p>
</li>
<li>
<p>@Before：会在每一个测试方法被<strong>运行前</strong>执行一次</p>
</li>
<li>
<p>@After：会在每一个测试方法<strong>运行后</strong>被执行一次</p>
</li>
<li>
<p>@Ignore：所修饰的测试方法会被测试运行器忽略.</p>
</li>
</ul>
<h2 id="基本调用方法"><a class="markdownIt-Anchor" href="#基本调用方法"></a> 基本调用方法</h2>
<ul>
<li>在需要测试的类中，使用<code>alt + insert</code>可以调用出一个窗口，在这个窗口中点击junit即可。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/LeetCode-%E9%93%BE%E8%A1%A8/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/LeetCode-%E9%93%BE%E8%A1%A8/index.html" class="post-title-link" itemprop="url">LeetCode-链表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-25 11:20:59" itemprop="dateCreated datePublished" datetime="2020-09-25T11:20:59+08:00">2020-09-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:41:22" itemprop="dateModified" datetime="2022-09-17T19:41:22+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>21k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>19 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-删除中间结点-面试题0203"><a class="markdownIt-Anchor" href="#1-删除中间结点-面试题0203"></a> 1. 删除中间结点 面试题02.03</h1>
<ul>
<li>题目：</li>
</ul>
<hr />
<p>实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。</p>
<p>示例：</p>
<p>输入：单向链表a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f中的节点c<br />
结果：不返回任何数据，但该链表变为a-&gt;b-&gt;d-&gt;e-&gt;f</p>
<ul>
<li>java解法</li>
</ul>
<hr />
<ul>
<li>因为只知道当前结点以及这个结点之后的所有结点，所以无法直接删除当前结点。</li>
<li>可以将当前结点后的一个结点的值赋给当前结点，然后删除之后的结点，达到删除当前结点的等效效果。（我变成你，再杀了你，就相当于杀了我自己）。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class ListNode &#123;
    int val;
    ListNode next;
    ListNode(int x) &#123;
        val &#x3D; x;
    &#125;
&#125;

class Solution &#123;
    public  void deleteNode(ListNode node) &#123;
        node.val &#x3D; node.next.val;
        node.next &#x3D; node.next.next;
    &#125;

    public static void main(String[] args) &#123;
        ListNode node1 &#x3D; new ListNode(1);
        ListNode node2 &#x3D; new ListNode(2);
        ListNode node3 &#x3D; new ListNode(3);
        ListNode node4 &#x3D; new ListNode(4);
        ListNode node5 &#x3D; new ListNode(5);
        node1.next &#x3D; node2;
        node2.next &#x3D; node3;
        node3.next &#x3D; node4;
        node4.next &#x3D; node5;
        node5.next &#x3D; null;

        System.out.print(node1.val);
        for(ListNode node &#x3D; node2; node !&#x3D; null; node &#x3D; node.next) &#123;
            System.out.print(&quot;-&gt;&quot;+node.val);
        &#125;
        System.out.println();

        Solution solution &#x3D; new Solution();
        solution.deleteNode(node3);

        System.out.print(node1.val);
        for(ListNode node &#x3D; node2; node !&#x3D; null; node &#x3D; node.next) &#123;
            System.out.print(&quot;-&gt;&quot;+node.val);
        &#125;
    &#125;

&#125;</code></pre>
<h1 id="2-二进制链表转整数-1290"><a class="markdownIt-Anchor" href="#2-二进制链表转整数-1290"></a> 2. 二进制链表转整数 1290</h1>
<ul>
<li>题目</li>
</ul>
<hr />
<p>给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。</p>
<p>请你返回该链表所表示数字的 十进制值 。</p>
<p></p>
<p>示例 1：</p>
<p>输入：head = [1,0,1]<br />
输出：5<br />
解释：二进制数 (101) 转化为十进制数 (5)</p>
<ul>
<li>java解法</li>
</ul>
<hr />
<ul>
<li>法一：
<ul>
<li>根据数字读取顺序确定对应位的权重</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;

public class BtoD  &#123;
    public int binaryToDecimal(SinglyLinkedList head) &#123;
        int nums &#x3D; 0;
        int result &#x3D; 0;
        int temp &#x3D; 0;
        int index &#x3D; 1;
        SinglyLinkedList node &#x3D; head;
        for( nums &#x3D; 0; node !&#x3D; null; node &#x3D; node.next, nums++);

        node &#x3D; head;
        for(; node !&#x3D; null; ) &#123;
            temp &#x3D; nums; &#x2F;&#x2F;数字是第几位
            &#x2F;&#x2F;算出对应位的权重
            for(index &#x3D; 1; temp - 1 &gt; 0; temp--) &#123;
                index *&#x3D; 2;
            &#125;
            result +&#x3D; index * node.val;
            node &#x3D; node.next;
            nums--;
        &#125;

        return result;
    &#125;

    public static void main(String[] args) &#123;
        Scanner in &#x3D; new Scanner(System.in);

        System.out.println(&quot;请输入一串二进制数字，以-1结束：&quot;);
        int temp &#x3D; in.nextInt();
        SinglyLinkedList fnode  &#x3D; new SinglyLinkedList(temp);
        SinglyLinkedList head &#x3D; fnode; &#x2F;&#x2F;保存头结点
        temp &#x3D; in.nextInt();
        while (temp !&#x3D; -1) &#123;
            SinglyLinkedList lnode &#x3D; new SinglyLinkedList(temp);
            fnode.next &#x3D; lnode;
            fnode &#x3D; lnode; &#x2F;&#x2F;使当前结点始终为链表末尾的结点
            temp &#x3D; in.nextInt();
        &#125;

        BtoD converse &#x3D; new BtoD();
        System.out.println(&quot;十进制的结果为：&quot; + converse.binaryToDecimal(head));
    &#125;
&#125;</code></pre>
<ul>
<li>法二：
<ul>
<li>使用ArrayList，将链表中的数字依次存入集合中，再根据集合的索引确定对应位的权重</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class ListNode &#123;
    int val;
    ListNode next;
    ListNode(int x) &#123;
        val &#x3D; x;
    &#125;
&#125;

class Solution &#123;

    public int getDecimalValue(ListNode head) &#123;
        ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;Integer&gt;();
        &#x2F;&#x2F;存入集合
        for(ListNode node &#x3D; head; node !&#x3D; null; node &#x3D; node.next) &#123;
            list.add(node.val);
        &#125;
        int n &#x3D; list.toArray().length - 1;
        int decimalValue &#x3D; 0;
        
        &#x2F;&#x2F;确定对应位权重并计算出结果
        for(int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123;
            decimalValue +&#x3D; list.get(i) * (int)Math.pow(2,n - i);
        &#125;

        return  decimalValue;
    &#125;


    public static void main(String[] args) &#123;
            ListNode node1 &#x3D; new ListNode(1);
            ListNode node2 &#x3D; new ListNode(0);
            ListNode node3 &#x3D; new ListNode(1);
            node1.next &#x3D; node2;
            node2.next &#x3D; node3;
            node3.next &#x3D; null;

            Solution solution &#x3D; new Solution();
            System.out.println(solution.getDecimalValue(node1));
    &#125;
&#125;</code></pre>
<ul>
<li>法三：使用位运算
<ul>
<li>当一个数进行左移或右移时候(每左移一位相当于乘上了一个2），如果是正数的情况下，空位补0，如：10 左移一位置，那么就变成 100，利用这个性质，结合这个题目，我们可知道如果将位移后出现的空位再加上我们所获得的值，就可以计算出对应的十进制。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public int getDecimalValue(ListNode head) &#123;
    int sum &#x3D; 0;
    for(ListNode node &#x3D; head; node !&#x3D; null; node &#x3D; node.next) &#123;
        sum &#x3D; (sum &lt;&lt; 1) + node.val;
    &#125;
    return  sum;
&#125;</code></pre>
<h1 id="3-链表中倒数第k个结点-剑指-offer-22"><a class="markdownIt-Anchor" href="#3-链表中倒数第k个结点-剑指-offer-22"></a> 3. 链表中倒数第k个结点 剑指 Offer 22</h1>
<ul>
<li>题目：</li>
</ul>
<hr />
<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<p></p>
<p>示例：</p>
<p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</p>
<p>返回链表 4-&gt;5.</p>
<ul>
<li>Java解法</li>
</ul>
<hr />
<ul>
<li>法一：数出链表的总结点个数，然后推出正序的排名。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public static int kthtoLast(SinglyLinkedList head, int k) &#123;
        int nums &#x3D; 1;
        SinglyLinkedList node &#x3D; head;
        
        &#x2F;&#x2F;得出当前链表的总结点个数
        while (node.next !&#x3D; null) &#123; 
            node &#x3D; node.next;
            nums++;
        &#125;

        int index &#x3D; nums - k + 1; &#x2F;&#x2F;根据逆序排名得出正序排名
        
        &#x2F;&#x2F;找到要求的结点
        node &#x3D; head;
        for (int i &#x3D; 1; i &lt; index; i++) &#123;
            node &#x3D; node.next;
        &#125;

        return node.val;
    &#125;</code></pre>
<p>测试代码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) &#123;
        Scanner in &#x3D; new Scanner(System.in);

        System.out.println(&quot;请输入一串数字，以-1结束：&quot;);
        SinglyLinkedList head &#x3D; new SinglyLinkedList();
        KthtoLast.getIn(head);

        System.out.println(&quot;输入要返回倒数第几个数：&quot;);
        int k &#x3D; in.nextInt();

        KthtoLast reverse &#x3D; new KthtoLast();
        System.out.println(&quot;结果为: &quot; + reverse.kthtoLast(head, k));


    &#125;
&#125;</code></pre>
<ul>
<li>法二：使用ArrayList来记录链表中节点的相对位置。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class ListNode &#123;
    int val;
    ListNode next;
    ListNode(int x) &#123;
        val &#x3D; x;
    &#125;
&#125;

class Solution &#123;
    public ListNode getKthFromEnd(ListNode head, int k) &#123;
        ArrayList&lt;ListNode&gt; list &#x3D; new ArrayList&lt;&gt;();
        for(ListNode node &#x3D; head; node !&#x3D; null; node &#x3D; node.next) &#123;
            list.add(node);
        &#125;
        int n &#x3D; list.toArray().length - k;

        return list.get(n);
    &#125;

    public static void main(String[] args) &#123;
        ListNode head &#x3D; new ListNode(1);
        ListNode node1 &#x3D; head;
        for(int i &#x3D; 2; i &lt;&#x3D; 6; i++) &#123;
            ListNode node &#x3D; new ListNode(i);
            node1.next &#x3D; node;
            node1 &#x3D; node1.next;
        &#125;

        Solution solution &#x3D; new Solution();
        ListNode node &#x3D; solution.getKthFromEnd(head,3);
        System.out.println(node.val);

    &#125;
&#125;</code></pre>
<ul>
<li>法三：
<ul>
<li>若只遍历一次，可使用两个指针，第一个指针先走k-1步，之后第二个指针再跟上，始终保持k-1步的距离，这样当第一个指针遍历完成时，第二个指针所在就是倒数第K个节点。</li>
<li>注意代码鲁棒性：
<ol>
<li>链表为空</li>
<li>链表节点少于K</li>
<li>k为零</li>
</ol>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class ListNode &#123;
    int val;
    ListNode next;
    ListNode()&#123;&#125;;
    ListNode(int x) &#123;
        val &#x3D; x;
    &#125;
&#125;

class Solution &#123;
    public ListNode getKthFromEnd(ListNode head, int k) &#123;
        int i &#x3D; 0;
        ListNode slow &#x3D; head;

        for(ListNode fast &#x3D; head; fast.next !&#x3D; null; fast &#x3D; fast.next) &#123;
            i++;
            if(i &gt; k - 1) &#123;
                slow &#x3D; slow.next;
            &#125;
        &#125;

        return  slow;
    &#125;

    public static void main(String[] args) &#123;
        ListNode head &#x3D; new ListNode(1);
        ListNode node1 &#x3D; head;
        for(int i &#x3D; 2; i &lt;&#x3D; 6; i++) &#123;
            ListNode node &#x3D; new ListNode(i);
            node1.next &#x3D; node;
            node1 &#x3D; node1.next;
        &#125;

        Solution solution &#x3D; new Solution();
        ListNode node &#x3D; solution.getKthFromEnd(head,3);
        System.out.println(node.val);

    &#125;
&#125;</code></pre>
<h1 id="4-从尾到头打印链表-剑指offer-06"><a class="markdownIt-Anchor" href="#4-从尾到头打印链表-剑指offer-06"></a> 4. 从尾到头打印链表 剑指offer 06.</h1>
<ul>
<li>题目：</li>
</ul>
<hr />
<p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p><strong>示例 1：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1,3,2]
输出：[2,3,1]</code></pre>
<ul>
<li>
<p>Java解法</p>
<hr />
</li>
<li>
<p>法一：</p>
<ul>
<li>每次遍历到相对的最后一个结点，通过一个计数变量来判断是否到达了最后一个结点。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"> public static int[] reversePrint(SinglyLinkedList head) &#123;
         SinglyLinkedList node &#x3D; new SinglyLinkedList();
         int nums &#x3D; 1;
         int i &#x3D; 0;
         node &#x3D; head;
 
         &#x2F;&#x2F;计算链表中有多少个元素
         &#x2F;&#x2F;注意判断链表为空的情况
         if(node &#x3D;&#x3D; null)&#123;
             nums &#x3D; 0;
         &#125;
         else &#123;
             while (node.next !&#x3D; null) &#123;
                 node &#x3D; node.next;
                 nums++;
             &#125;
         &#125;
 
         int[] result &#x3D; new int[nums];
 
         node &#x3D; head;
 
         if(nums &#x3D;&#x3D; 0) &#123;
             return result;&#x2F;&#x2F;当链表为空时直接返回一个空数组
         &#125;
         else &#123;
             do &#123;
                 &#x2F;&#x2F;每次从第一个结点开始遍历到最后一个结点，将最后一个结点的值存入数组中
                 &#x2F;&#x2F;如果有三个数，只需循环两次便可达到最后一个结点
                 for(int j &#x3D; 1; j &lt; nums; j++) &#123;
                     node &#x3D; node.next;
                 &#125;
                 result[i] &#x3D; node.val;
                 node &#x3D; head;
                 i++;
                 &#x2F;&#x2F;将链表的长度减一，表示最后一个结点已经被输出了
                 nums--;
             &#125; while(nums !&#x3D; 0);
 
             return result;
         &#125;
 &#125;
 &#x2F;&#x2F;测试代码
 @Test
 public void testReversePrint() throws Exception &#123;
     &#x2F;&#x2F;设置测试链表为｛1， 3， 2｝
     SinglyLinkedList head &#x3D; new  SinglyLinkedList();
     head.val &#x3D; 1;
     SinglyLinkedList node1 &#x3D; new SinglyLinkedList();
     head.next &#x3D; node1;
     node1.val&#x3D; 3;
     SinglyLinkedList node2 &#x3D; new SinglyLinkedList();
   node2.val &#x3D; 2;
    node1.next &#x3D; node2;

    int[] result &#x3D; new int[3];
    result &#x3D; SinglyLinkedList.reversePrint(head);
    &#x2F;&#x2F;预期结果为｛2，3，1｝
    int[] exp &#x3D; &#123;2, 3, 1&#125;;
    &#x2F;&#x2F;断言判断结果是否为｛2， 3，1｝
    Assert.assertArrayEquals(result, exp);
&#125; </code></pre>
</li>
<li>
<p>法二：先获取链表的长度，再使用一个定长的数组，但是对数组的赋值是从逆向开始的。这样避免了对链表的逆转。</p>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class ListNode &#123;
    int val;
    ListNode next;
    ListNode(int x) &#123;
        val &#x3D; x;
    &#125;
&#125;

class Solution &#123;
    public int[] reversePrint(ListNode head) &#123;
        int n &#x3D; 0;
        for(ListNode node &#x3D; head; node !&#x3D; null; node &#x3D; node.next) &#123;
            n++;
        &#125;

        int[] result &#x3D; new int[n];
        ListNode node &#x3D; head;
        for(int t &#x3D; n; t &gt; 0; t--) &#123;
            result[t - 1] &#x3D; node.val;
            node &#x3D; node.next;
        &#125;

        return result;
    &#125;

    public static void main(String[] args) &#123;
        ListNode head &#x3D; new ListNode(1);
        ListNode node1 &#x3D; head;
        for(int i &#x3D; 2; i &lt;&#x3D; 6; i++) &#123;
            ListNode node &#x3D; new ListNode(i);
            node1.next &#x3D; node;
            node1 &#x3D; node1.next;
        &#125;

        Solution solution &#x3D; new Solution();
        int[] result &#x3D; solution.reversePrint(head);
        for(int i : result) &#123;
            System.out.println(i);
        &#125;
    &#125;
&#125;</code></pre>
<ul>
<li>法三：使用栈,利用栈的先进后出特性，将压入栈的元素自然弹出，就达到来逆序的效果</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class ListNode &#123;
    int val;
    ListNode next;
    ListNode(int x) &#123;
        val &#x3D; x;
    &#125;
&#125;

class Solution &#123;
    public int[] reversePrint(ListNode head) &#123;
        Stack&lt;ListNode&gt; stack &#x3D; new Stack&lt;&gt;();
        for(ListNode node &#x3D; head; node !&#x3D; null; node &#x3D; node.next) &#123;
            stack.push(node);
        &#125;
        int n &#x3D; stack.size();
        int[] result &#x3D; new int[n];
        for(int i &#x3D; 0; i &lt; n; i++) &#123;
            result[i] &#x3D; stack.pop().val;
        &#125;
        return result;
    &#125;

    public static void main(String[] args) &#123;
        ListNode head &#x3D; new ListNode(1);
        ListNode node1 &#x3D; head;
        for(int i &#x3D; 2; i &lt;&#x3D; 6; i++) &#123;
            ListNode node &#x3D; new ListNode(i);
            node1.next &#x3D; node;
            node1 &#x3D; node1.next;
        &#125;

        Solution solution &#x3D; new Solution();
        int[] result &#x3D; solution.reversePrint(head);
        for(int i : result) &#123;
            System.out.println(i);
        &#125;

    &#125;
&#125;</code></pre>
<ul>
<li>法四：使用ArrayList集合记录链表中的节点，再反向遍历该集合，将值存到数组中。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class ListNode &#123;
    int val;
    ListNode next;
    ListNode(int x) &#123;
        val &#x3D; x;
    &#125;
&#125;

class Solution &#123;
    public int[] reversePrint(ListNode head) &#123;
        ArrayList&lt;ListNode&gt; list &#x3D; new ArrayList&lt;&gt;();
        for(ListNode node &#x3D; head; node !&#x3D; null; node &#x3D; node.next) &#123;
            list.add(node);
        &#125;
        int[] result &#x3D; new int[list.toArray().length];
        int j &#x3D; 0;
        for(int i &#x3D; list.toArray().length - 1; i &gt;&#x3D; 0; i--) &#123;
            result[j] &#x3D; list.get(i).val;
            j++;
        &#125;

        return result;
    &#125;

    public static void main(String[] args) &#123;
        ListNode head &#x3D; new ListNode(1);
        ListNode node1 &#x3D; head;
        for(int i &#x3D; 2; i &lt;&#x3D; 6; i++) &#123;
            ListNode node &#x3D; new ListNode(i);
            node1.next &#x3D; node;
            node1 &#x3D; node1.next;
        &#125;

        Solution solution &#x3D; new Solution();
        int[] result &#x3D; solution.reversePrint(head);
        for(int i : result) &#123;
            System.out.println(i);
        &#125;

    &#125;
&#125;</code></pre>
<h1 id="5-移除重复节点-面试题0201"><a class="markdownIt-Anchor" href="#5-移除重复节点-面试题0201"></a> 5. 移除重复节点 面试题02.01</h1>
<ul>
<li>
<p>题目</p>
<hr />
<p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p>
<p>示例1:</p>
<p>输入：[1, 2, 3, 3, 2, 1]<br />
输出：[1, 2, 3]</p>
</li>
<li>
<p>Java解法</p>
<hr />
<ul>
<li>法一：
<ul>
<li>将链表中的元素在逐个遍历时存入一个数组中，在遍历时进行比对，如果出现相同元素值，则跳过该元素</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;删除链表中重复结点的方法
    public SinglyLinkedList removeDuplicateNodes(SinglyLinkedList head) &#123;

        SinglyLinkedList node &#x3D; head;
        int nums &#x3D; 0;

        &#x2F;&#x2F;计算链表中元素的个数
        while(node !&#x3D; null) &#123;
            node &#x3D; node.next;
            nums++;
        &#125;
        &#x2F;&#x2F;注意排除链表为一个空链表的情形（即head为一个null）
        if(nums &#x3D;&#x3D; 0) &#123;
            return head;
        &#125;

        &#x2F;&#x2F;用于储存已经读出的元素值的数组
        int[] temp &#x3D; new int[nums];
        int i &#x3D; 0;
        int j &#x3D; 0;

        &#x2F;&#x2F;遍历数组并跳过重复结点,将遍历的结果存入数组中
        node &#x3D; head;
        while(node !&#x3D; null) &#123;
            if(i &#x3D;&#x3D; 0) &#123;
                temp[i] &#x3D; node.val;
                node &#x3D; node.next;
                i++;
            &#125;
            else &#123;
                for( j &#x3D; i - 1; j &gt;&#x3D; 0; j--) &#123;
                    if(node.val &#x3D;&#x3D; temp[j]) &#123;
                        node &#x3D; node.next;
                        nums--;
                        break;
                    &#125;
                &#125;
                if(j &gt;&#x3D; 0) &#123;
                    continue;
                &#125;
                else &#123;
                    temp[i] &#x3D; node.val;
                    node &#x3D; node.next;
                    i++;
                &#125;
            &#125;
        &#125;

        &#x2F;&#x2F;将数组中的结果重新存入链表中
        node &#x3D; head;
        for(i &#x3D; 0; i &lt; nums - 1; i++) &#123;
            node.val &#x3D; temp[i];
            node &#x3D; node.next;
        &#125;
        &#x2F;&#x2F;最后一个结点需要单独赋值，因为需要将它的next设为null
        node.val &#x3D; temp[nums - 1];
        node.next &#x3D; null;

        return head;
    &#125;
&#x2F;&#x2F;测试用例
&#x2F;**
 *
 * Method:  removeDuplicateNodes(SinglyLinkedList head)
 *
 *&#x2F;
@Test
public void testRemoveDuplicateNodes() throws Exception &#123;
    &#x2F;&#x2F;创建测试链表为｛1，2，3， 3， 2，1｝
    SinglyLinkedList head &#x3D; new  SinglyLinkedList();
    head.val &#x3D; 1;
    SinglyLinkedList node1 &#x3D; new SinglyLinkedList();
    head.next &#x3D; node1;
    node1.val&#x3D; 2;
    SinglyLinkedList node2 &#x3D; new SinglyLinkedList();
    node2.val &#x3D; 3;
    node1.next &#x3D; node2;
    SinglyLinkedList node3 &#x3D; new SinglyLinkedList();
    node3.val &#x3D; 3;
    node2.next &#x3D; node3;
    SinglyLinkedList node4 &#x3D; new SinglyLinkedList();
    node4.val &#x3D; 2;
    node3.next &#x3D; node4;
    SinglyLinkedList node5 &#x3D; new SinglyLinkedList();
    node5.val &#x3D; 1;
    node4.next &#x3D; node5;

    head &#x3D; head.removeDuplicateNodes(head);

    SinglyLinkedList node &#x3D; head;
    int nums &#x3D; 0;

    &#x2F;&#x2F;计算链表中元素的个数
    while(node !&#x3D; null) &#123;
        node &#x3D; node.next;
        nums++;
    &#125;

    &#x2F;&#x2F;用于储存读出的元素值的数组
    int[] temp &#x3D; new int[nums];
    int i &#x3D; 0;
    int j &#x3D; 0;

    &#x2F;&#x2F;遍历数组,将遍历的结果存入数组中
    node &#x3D; head;
    while(node !&#x3D; null) &#123;
        temp[i] &#x3D; node.val;
        node &#x3D; node.next;
        i++;
    &#125;

    &#x2F;&#x2F;预期结果
    int[] exp &#x3D; &#123;1, 2, 3&#125;;

    Assert.assertArrayEquals(temp, exp);

&#125;
</code></pre>
<ul>
<li>法二：
<ul>
<li>将已经出现的元素值存入ArrayList集合中，设置双指针，遍历集合，当出现重复元素时，利用双指针跳过当前节点。</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class ListNode &#123;
    int val;
    ListNode next;
    ListNode(int x) &#123;
        val &#x3D; x;
    &#125;
&#125;

class Solution &#123;
    public ListNode removeDuplicateNodes(ListNode head) &#123;
        ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();

        ListNode front &#x3D; head;
        ListNode cur &#x3D; head;
        OUT:
        while(cur !&#x3D; null) &#123;
            for(int i : list) &#123;
                if(i &#x3D;&#x3D; cur.val) &#123;
                    &#x2F;&#x2F;如果是重复元素，保持front指针不动，只移动当前元素指针cur
                    front.next &#x3D; cur.next;
                    cur &#x3D; cur.next;
                    continue OUT;
                &#125;
            &#125;
            list.add(cur.val);
            front &#x3D; cur;
            cur &#x3D; cur.next;
        &#125;

        return  head;
    &#125;

    public static void main(String[] args) &#123;
        ListNode node1 &#x3D; new ListNode(1);
        ListNode node2 &#x3D; new ListNode(2);
        ListNode node3 &#x3D; new ListNode(3);
        ListNode node4 &#x3D; new ListNode(3);
        ListNode node5 &#x3D; new ListNode(2);
        ListNode node6 &#x3D; new ListNode(1);
        node1.next &#x3D; node2;
        node2.next &#x3D; node3;
        node3.next &#x3D; node4;
        node4.next &#x3D; node5;
        node5.next &#x3D; node6;
        node6.next &#x3D; null;

        Solution solution &#x3D; new Solution();
        solution.removeDuplicateNodes(node1);
        for(ListNode node &#x3D; node1; node !&#x3D; null; node &#x3D; node.next) &#123;
            System.out.println(node.val);
        &#125;
    &#125;
&#125;</code></pre>
<ul>
<li>法三：
<ul>
<li>哈希表:思路与法二类似，只是哈希表不能存储重复元素，判断无需遍历，速度提升。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;
    public ListNode removeDuplicateNodes(ListNode head) &#123;
         if (head &#x3D;&#x3D; null) &#123;
            return head;
        &#125;
        Set&lt;Integer&gt; occurred &#x3D; new HashSet&lt;Integer&gt;();
        occurred.add(head.val);
        ListNode pos &#x3D; head;
        &#x2F;&#x2F; 枚举前驱节点
        while (pos.next !&#x3D; null) &#123;
            &#x2F;&#x2F; 当前待删除节点
            ListNode cur &#x3D; pos.next;
            if (occurred.add(cur.val)) &#123;
                pos &#x3D; pos.next;
            &#125; else &#123;
                pos.next &#x3D; pos.next.next;
            &#125;
        &#125;
        pos.next &#x3D; null;
        return head;
    &#125;
&#125;</code></pre>
<h1 id="6-反转链表-206"><a class="markdownIt-Anchor" href="#6-反转链表-206"></a> 6. 反转链表 206</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/">题目</a></li>
</ul>
<hr />
<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<p>示例1:<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/igLWdV.jpg" alt="igLWdV" /></p>
<pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1,2,3,4,5]
输出：[5,4,3,2,1]</code></pre>
<p>示例2:<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/HOrmk9.jpg" alt="HOrmk9" /></p>
<pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1,2]
输出：[2,1]</code></pre>
<p>示例3:</p>
<pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; []
输出：[]</code></pre>
<p>提示：<br />
链表中节点的数目范围是<code>[0, 5000]</code><br />
<code>-5000 &lt;= Node.val &lt;= 5000</code></p>
<h2 id="java解法"><a class="markdownIt-Anchor" href="#java解法"></a> Java解法</h2>
<ul>
<li>法一：迭代遍历法。从头遍历每个节点，并记录当前节点的前一节点和后一节点，然后使当前节点的next指向前一节点，然后当前节点移动到后一节点，直到当前节点为空。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/jBZsRi.png" alt="jBZsRi" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ReverseLinkedList206 &#123;

    public ListNode reverseList(ListNode head) &#123;
        &#x2F;&#x2F;定义前一节点和后一节点
        ListNode pre &#x3D; null; &#x2F;&#x2F; pre开始为null，因为head之前没有节点
        ListNode next;
        while(head !&#x3D; null) &#123;
            &#x2F;&#x2F;记录当前节点的下一节点
            next &#x3D; head.next;
            &#x2F;&#x2F;当前节点的下一节点变为pre
            head.next &#x3D; pre;
            &#x2F;&#x2F;同时移动当前节点和对应的前一节点到下一节点
            pre &#x3D; head;
            head &#x3D; next;
        &#125;
        &#x2F;&#x2F;最后返回pre
        &#x2F;&#x2F;因为，head此时指向空，pre是其前一位正好指向原链表的最后一节点，即新链表的头节点
        return pre;
    &#125;
&#125;</code></pre>
<ul>
<li>法二：递归的思想。逆向思考，假设当前节点的之后的节点都已经完成的反转，每一次递归只要考虑当前节点和之后已经反转好的链表之间的反向连接问题即可，每一次递归返回已经完成反转连接的当前节点。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/SeBJuw.png" alt="SeBJuw" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ReverseLinkedList206 &#123;

    &#x2F;**
     * 递归解法
     * @param head
     * @return
     *&#x2F;
    public ListNode reverseList(ListNode head) &#123;
        &#x2F;&#x2F;当当前节点或其下一节点为null时返回
        if(head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) &#123;
            return head;
        &#125;
        &#x2F;&#x2F;逆向考虑，每次调用本方法说明当前节点的前面节点都已经完成了反转
        &#x2F;&#x2F;现在只需将当前节点和前面反转好的链表反向连接好就行
        ListNode nextHead &#x3D; reverseList1(head.next);
        head.next.next &#x3D; head;
        &#x2F;&#x2F;因为是逆向思考，所以反转后当前节点的下一节点始终为null，前面的情况并不清楚
        head.next &#x3D; null;
        return nextHead;
&#125;</code></pre>
<h1 id="7-合并两个有序链表-21"><a class="markdownIt-Anchor" href="#7-合并两个有序链表-21"></a> 7. 合并两个有序链表 21</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">题目</a></li>
</ul>
<hr />
<p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br />
示例1:<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/Ohem7h.jpg" alt="Ohem7h" /></p>
<pre class="line-numbers language-none"><code class="language-none">输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]
输出：[1,1,2,3,4,4]</code></pre>
<p>示例2:</p>
<pre class="line-numbers language-none"><code class="language-none">输入：l1 &#x3D; [], l2 &#x3D; []
输出：[]</code></pre>
<p>示例3:</p>
<pre class="line-numbers language-none"><code class="language-none">输入：l1 &#x3D; [], l2 &#x3D; [0]
输出：[0]</code></pre>
<p>提示：<br />
两个链表的节点数目范围是 <code>[0, 50]</code><br />
<code>-100 &lt;= Node.val &lt;= 100</code><br />
l1 和 l2 均按 非递减顺序 排列</p>
<h2 id="java解法-2"><a class="markdownIt-Anchor" href="#java解法-2"></a> Java解法</h2>
<ul>
<li>法一：非递归解法。遍历两个链表，比较大小之后加入合并链表后。注意，如果有一条链表遍历完成了，可以直接将另一条链表的剩余部分直接连在合并链表后。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/tI6YFk.png" alt="tI6YFk" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MergeTwoSortedLists21 &#123;

    &#x2F;**
     * 非递归解法
     * @param l1
     * @param l2
     * @return
     *&#x2F;
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;

        &#x2F;&#x2F;设置一个头节点，便于链表的创建
        ListNode head &#x3D; new ListNode();
        &#x2F;&#x2F;指向合并链表的当前节点
        ListNode cur &#x3D; head;
        &#x2F;&#x2F;指向l1, l2的当前节点
        ListNode cur1 &#x3D; l1;
        ListNode cur2 &#x3D; l2;
        if(l1 &#x3D;&#x3D; null &amp;&amp; l2 &#x3D;&#x3D; null) &#123;
            return null;
        &#125;
        &#x2F;&#x2F;临时存储两个链表的当前节点的值
        int val1;
        int val2;
        &#x2F;&#x2F;当两个链表都不为空时
        while(cur1 !&#x3D; null &amp;&amp; cur2 !&#x3D; null) &#123;
            val1 &#x3D; cur1.val;
            val2 &#x3D; cur2.val;

            if(val1 &lt;&#x3D; val2) &#123;
                &#x2F;&#x2F;如果val1不大于val2
                &#x2F;&#x2F;将l1的当前节点连在合并链表末尾节点后，
                cur.next &#x3D; cur1;
                &#x2F;&#x2F;相应移动当前节点指针，l2的当前节点指针不变
                cur &#x3D; cur1;
                cur1 &#x3D; cur1.next;
            &#125; else &#123;
                cur.next &#x3D; cur2;
                cur &#x3D; cur2;
                cur2 &#x3D; cur2.next;
            &#125;
        &#125;
        &#x2F;&#x2F;如果有一个链表提前遍历完了，直接将另一个链表的剩余部分连在合并链表后
        if(cur1 &#x3D;&#x3D; null &amp;&amp; cur2 !&#x3D; null) &#123;
            cur.next &#x3D; cur2;
        &#125; else if(cur2 &#x3D;&#x3D; null &amp;&amp; cur1 !&#x3D; null) &#123;
            cur.next &#x3D; cur1;
        &#125;
        &#x2F;&#x2F;头节点是虚拟的，从它的下一节点开始才有值
        return head.next;
    &#125;
&#125;</code></pre>
<ul>
<li>法二：递归解法。比较两个链表的头节点，将头节点较小的头部截取，将截取之后的链表与另一个链表合并后，再连在该头节点之后。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/HnPiyE.png" alt="HnPiyE" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 递归解法
 * @param l1
 * @param l2
 * @return
 *&#x2F;
public ListNode mergeTwoLists1(ListNode l1, ListNode l2) &#123;
    &#x2F;&#x2F;当有链表为空时，直接返回非空链表
    if(l2 &#x3D;&#x3D; null) &#123;
        return l1;
    &#125;
    if(l1 &#x3D;&#x3D; null) &#123;
        return l2;
    &#125;
    &#x2F;&#x2F;当l2的头节点比l1小时，将
    if(l1.val &gt; l2.val) &#123;
        &#x2F;&#x2F;因为l2的头节点较小，所以将l2之后的节点和l1合并然后将其连在当前头节点之后
        l2.next &#x3D; mergeTwoLists1(l1, l2.next);
        return l2;
    &#125;
    l1.next &#x3D; mergeTwoLists1(l2, l1.next);
    return l1;
&#125;</code></pre>
<h1 id="8-两两交换链表中的节点-24"><a class="markdownIt-Anchor" href="#8-两两交换链表中的节点-24"></a> 8. 两两交换链表中的节点 24</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">题目</a></li>
</ul>
<hr />
<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br />
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br />
示例1:<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/zEFNJ0.jpg" alt="zEFNJ0" /></p>
<pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1,2,3,4]
输出：[2,1,4,3]</code></pre>
<p>示例2:</p>
<pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; []
输出：[]</code></pre>
<p>示例3:</p>
<pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1]
输出：[1]</code></pre>
<p>提示：<br />
链表中节点的数目在范围 <code>[0, 100]</code>内<br />
<code>0 &lt;= Node.val &lt;= 100</code></p>
<h2 id="java解法-3"><a class="markdownIt-Anchor" href="#java解法-3"></a> Java解法</h2>
<ul>
<li>法一：通过“指针”变化来转换节点之间的相对位置
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/2DxNqn.png" alt="2DxNqn" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SwapNodesInPairs24 &#123;

    public ListNode swapPairs(ListNode head) &#123;
        &#x2F;&#x2F;设置一个前导节点，便于连接两组交换的元素
        ListNode pre &#x3D; new ListNode();
        pre.next &#x3D; head;
        ListNode cur &#x3D; head;
        ListNode head1 &#x3D; head;
        if(head !&#x3D; null &amp;&amp; head.next !&#x3D; null) &#123;
            head1 &#x3D; head.next;
        &#125;
        &#x2F;&#x2F;遍历整个链表，然后每次处理连续两位
        while (cur !&#x3D; null &amp;&amp; cur.next !&#x3D; null) &#123;
                ListNode temp1;
                temp1 &#x3D;  cur.next;
                pre.next &#x3D; temp1;
                cur.next &#x3D; temp1.next;
                temp1.next &#x3D; cur;
                &#x2F;&#x2F;每次移动前导节点指针2位
                pre &#x3D; pre.next.next;
                &#x2F;&#x2F;每次将当前节点指针移动到前导节点指针之后
                cur &#x3D; pre.next;
        &#125;
        return head1;
    &#125;

&#125;</code></pre>
<h1 id="9-相交链表-160"><a class="markdownIt-Anchor" href="#9-相交链表-160"></a> 9. 相交链表 160</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">题目</a></li>
</ul>
<hr />
<p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。<br />
图示两个链表在节点 c1 开始相交：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/1UHBvW.jpg" alt="1UHBvW" /><br />
题目数据 保证 整个链式结构中不存在环。<br />
注意，函数返回结果后，链表必须 保持其原始结构。<br />
示例1：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/tcmvgZ.jpg" alt="tcmvgZ" /></p>
<pre class="line-numbers language-none"><code class="language-none">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3
输出：Intersected at &#39;8&#39;
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</code></pre>
<p>示例 2：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/jJzS6t.jpg" alt="jJzS6t" /></p>
<pre class="line-numbers language-none"><code class="language-none">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1
输出：Intersected at &#39;2&#39;
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</code></pre>
<p>示例3:<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/45jteX.jpg" alt="45jteX" /></p>
<pre class="line-numbers language-none"><code class="language-none">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2
输出：null
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。</code></pre>
<p>提示：</p>
<pre class="line-numbers language-none"><code class="language-none">listA 中节点数目为 m
listB 中节点数目为 n
0 &lt;&#x3D; m, n &lt;&#x3D; 3 * 104
1 &lt;&#x3D; Node.val &lt;&#x3D; 105
0 &lt;&#x3D; skipA &lt;&#x3D; m
0 &lt;&#x3D; skipB &lt;&#x3D; n
如果 listA 和 listB 没有交点，intersectVal 为 0
如果 listA 和 listB 有交点，intersectVal &#x3D;&#x3D; listA[skipA + 1] &#x3D;&#x3D; listB[skipB + 1]</code></pre>
<h2 id="java解法-4"><a class="markdownIt-Anchor" href="#java解法-4"></a> Java解法</h2>
<ul>
<li>法一：遍历一个链表，将其节点与另一个链表中所有节点对比，如果与另一个链表中的某个节点相同，则该节点就是相交节点。时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>级别，很慢。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/9REX8i.png" alt="9REX8i" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class IntersectionOfTwoLinkedLists160 &#123;

    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;
        &#x2F;&#x2F;如果两个链表头节点就相交
        if(headA &#x3D;&#x3D; headB) &#123;
            return headA;
        &#125;
        &#x2F;&#x2F;如果有一个链表为空
        if(headA &#x3D;&#x3D; null || headB &#x3D;&#x3D; null) &#123;
            return null;
        &#125;
        ListNode cur1 &#x3D; headA;
        ListNode cur2 &#x3D; headB;
        &#x2F;&#x2F;遍历链表对比节点
        while (cur1 !&#x3D; null) &#123;
            while(cur2 !&#x3D; null) &#123;
                if(cur1 !&#x3D; cur2) &#123;
                    cur2 &#x3D; cur2.next;
                &#125;else &#123;
                    return cur1;
                &#125;
            &#125;
            &#x2F;&#x2F;每次都从另一个链表的头节点开始
            cur2 &#x3D; headB;
            cur1 &#x3D; cur1.next;
        &#125;
        return null;
    &#125;
&#125;</code></pre>
<h1 id="10-回文链表-234"><a class="markdownIt-Anchor" href="#10-回文链表-234"></a> 10. 回文链表 234</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-linked-list/">题目</a></li>
</ul>
<hr />
<p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。<br />
示例1：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210924090500.png" alt="" /></p>
<pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1,2,2,1]
输出：true</code></pre>
<p>示例2：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210924090534.png" alt="" /></p>
<pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1,2]
输出：false</code></pre>
<p>提示：<br />
链表中节点数目在范围<code>[1, 105]</code>内<br />
<code>0 &lt;= Node.val &lt;= 9</code></p>
<h2 id="java解法-5"><a class="markdownIt-Anchor" href="#java解法-5"></a> Java解法</h2>
<ul>
<li>法一：回文的实质是链表前后对称。对称问题的关键在于找到对称轴。找到对称轴后利用栈的压栈和出栈来比较前后两部分是否相同。需要注意的是链表结点数为奇数和偶数的对称轴情况不太相同。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210924094116.png" alt="" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class PalindromeLinkedList234 &#123;

    public boolean isPalindrome(ListNode head) &#123;

        Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;();
        &#x2F;&#x2F;统计链表结点的数量
        ListNode node &#x3D; head;
        int count &#x3D; 0;
        while (node !&#x3D; null) &#123;
            count++;
            node &#x3D; node.next;
        &#125;
        count -&#x3D; 1;

        &#x2F;&#x2F;将链表结点数量为奇数和偶数分别处理
        if(count % 2 &#x3D;&#x3D; 0) &#123;
            &#x2F;&#x2F;链表结点数量为奇数
            &#x2F;&#x2F;找到链表的“对称轴”，将前半部分结点的压栈，然后遍历后半部分，与出栈的值比较
            ListNode node1 &#x3D; head;
            for(int i &#x3D; 0; i &lt; count &#x2F; 2; i++) &#123;
                stack.push(node1.val);
                node1 &#x3D; node1.next;
            &#125;
            &#x2F;&#x2F;奇数个结点，以中间结点为对称轴，不用比较其值，直接跳过
            node1 &#x3D; node1.next;
            for(int i &#x3D; 1 + count &#x2F; 2; i &lt;&#x3D; count; i++) &#123;
                int val &#x3D; stack.pop();
                if(val &#x3D;&#x3D; node1.val) &#123;
                    node1 &#x3D; node1.next;
                &#125; else &#123;
                    return false;
                &#125;
            &#125;
        &#125; else &#123;
            &#x2F;&#x2F;链表结点数量为偶数
            ListNode node2 &#x3D; head;
            for(int i &#x3D; 0; i &lt;&#x3D; count &#x2F; 2; i++) &#123;
                stack.push(node2.val);
                node2 &#x3D; node2.next;
            &#125;
            for(int i &#x3D; 1 + count &#x2F; 2; i &lt;&#x3D; count; i++) &#123;
                int val &#x3D; stack.pop();
                if(val &#x3D;&#x3D; node2.val) &#123;
                    node2 &#x3D; node2.next;
                &#125; else &#123;
                    return false;
                &#125;
            &#125;
        &#125;

        return true;
    &#125;
&#125;</code></pre>
<ul>
<li>法二：将链表值复制到数组，同时从数组两端向中间遍历，比较值是否相同。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Maven/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Maven/index.html" class="post-title-link" itemprop="url">Maven</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-22 00:32:53" itemprop="dateCreated datePublished" datetime="2020-09-22T00:32:53+08:00">2020-09-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:27:52" itemprop="dateModified" datetime="2022-09-17T19:27:52+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web后端</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="maven是什么"><a class="markdownIt-Anchor" href="#maven是什么"></a> maven是什么？</h1>
<p><a target="_blank" rel="noopener" href="https://mvnrepository.com/">中央仓库内容查询</a><br />
<a target="_blank" rel="noopener" href="https://www.runoob.com/maven/maven-tutorial.html">参考文档</a></p>
<ul>
<li>maven是基于POM（project object model:项目对象模型）的软件项目管理工具。</li>
<li>Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。Maven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。</li>
<li>Maven 可以统一<strong>管理所有的依赖jar包</strong>，甚至是不同的版本。程序员也可以动态地将自己写好的模块打包成jar包让它管理。需要的时候，可以直接通过简单的描述文件告诉 Maven，它会自动帮助程序员找出来，集成到项目中。并且它提供了中央仓库，能帮我们自动下载构件。</li>
<li>maven可以进行对指定目录下的代码进行单元测试，检测代码质量。</li>
<li>Maven的作用：
<ol>
<li>构建工程</li>
<li>管理Jar包</li>
<li>编译代码</li>
<li>自动运行单元测试</li>
<li>部署项目等</li>
</ol>
</li>
</ul>
<h1 id="maven的安装"><a class="markdownIt-Anchor" href="#maven的安装"></a> maven的安装</h1>
<ul>
<li>参见：<a target="_blank" rel="noopener" href="https://www.runoob.com/maven/maven-setup.html">菜鸟教程</a></li>
</ul>
<h1 id="maven-依赖管理"><a class="markdownIt-Anchor" href="#maven-依赖管理"></a> Maven-依赖管理</h1>
<ul>
<li>依赖管理：即对项目的jar包的管理</li>
<li>核心思想：将项目中所需的jar包放到jar包仓库中，而不是直接放在项目中。</li>
</ul>
<h1 id="maven-pom"><a class="markdownIt-Anchor" href="#maven-pom"></a> Maven POM</h1>
<ul>
<li><strong>POM</strong>( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元，是一个<strong>XML文件</strong>，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。执行任务或目标时，Maven会在当前目录中查找POM。它读取POM，获取所需的配置信息，然后执行目标。</li>
<li><strong>父（Super）POM</strong>是Maven默认的 POM。所有的POM都继承自一个父 POM（无论是否显式定义了这个父 POM）。父 POM 包含了一些可以被继承的默认设置。因此，当Maven发现需要下载POM中的依赖时，它会到Super POM 中配置的<a target="_blank" rel="noopener" href="https://mvnrepository.com/">默认仓库</a> 去下载。</li>
<li>POM的文件（xml）中的标签解读<a target="_blank" rel="noopener" href="https://www.runoob.com/maven/maven-pom.html">菜鸟教程</a></li>
</ul>
<h1 id="maven构建生命周期"><a class="markdownIt-Anchor" href="#maven构建生命周期"></a> maven构建生命周期</h1>
<ul>
<li>
<p>生命周期概述：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200922005205.jpg" alt="" /></p>
</li>
<li>
<p>默认生命周期：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>阶段</th>
<th>处理</th>
<th>命令｜描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>验证 validate</td>
<td>验证项目</td>
<td></td>
</tr>
<tr>
<td>编译 compile</td>
<td>执行编译</td>
<td>mvn compile</td>
</tr>
<tr>
<td>测试 Test</td>
<td>测试</td>
<td>mvn test</td>
</tr>
<tr>
<td>包装 package</td>
<td>打包</td>
<td>mvn package</td>
</tr>
<tr>
<td>检查 verify</td>
<td>检查</td>
<td></td>
</tr>
<tr>
<td>安装 install</td>
<td>安装</td>
<td>mvn install</td>
</tr>
<tr>
<td>部署 deploy</td>
<td>部署</td>
<td>mvn deploy</td>
</tr>
</tbody>
</table>
<ul>
<li>当执行到后面的生命周期时，前面的生命周期一定已经执行了。</li>
<li>清理生命周期；清除项目编译信息：<code>mvn clean</code></li>
</ul>
<h1 id="maven的仓库"><a class="markdownIt-Anchor" href="#maven的仓库"></a> Maven的仓库</h1>
<ul>
<li>Maven 仓库能帮助我们管理构件（主要是JAR），它就是放置所有JAR文件（WAR，ZIP，POM等等）的地方。即jar不是放在项目中，而是放在仓库中，实际使用的时候，maven通过jar包的坐标在<strong>仓库</strong>中定位jar包。</li>
<li>Maven 仓库有三种类型：
<ol>
<li>本地（local）</li>
<li>中央（central）</li>
<li>远程（remote）</li>
</ol>
</li>
<li>本地仓库：
<ul>
<li>运行 Maven 的时候，Maven 所需要的任何构件都是直接从本地仓库获取的。如果本地仓库没有，它会首先尝试从远程仓库下载构件至本地仓库，然后再使用本地仓库的构件。</li>
<li>Maven本地仓库默认被创建在<code>%USER_HOME%</code>目录下。要<strong>修改默认位置</strong>，在 <code>%M2_HOME%\conf</code> 目录中的Maven的settings.xml文件中定义另一个路径。当你运行Maven命令，Maven将下载依赖的文件到你指定的路径中。</li>
</ul>
  <pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;settings xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;SETTINGS&#x2F;1.0.0&quot;
xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;SETTINGS&#x2F;1.0.0 
http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;settings-1.0.0.xsd&quot;&gt;
    &lt;localRepository&gt;C:&#x2F;MyLocalRepository&lt;&#x2F;localRepository&gt;
&lt;&#x2F;settings&gt;</code></pre>
</li>
<li>中央仓库：
<ul>
<li>这个仓库由 Maven 社区管理。</li>
<li>不需要配置。</li>
<li>需要通过网络才能访问。</li>
<li>要浏览中央仓库的内容，maven社区提供了一个URL：<code>http://search.maven.org/#browse</code>。使用这个仓库，开发人员可以搜索所有可以获取的代码库。</li>
</ul>
</li>
<li>远程仓库（私服）：
<ul>
<li>如果 Maven 在中央仓库中也找不到依赖的文件，它会停止构建过程并输出错误信息到控制台。为避免这种情况，Maven 提供了远程仓库的概念，它是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的jar文件。</li>
</ul>
</li>
<li>依赖的搜索顺序：
<ol>
<li>步骤 1 － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。</li>
<li>步骤 2 － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中以备将来引用。</li>
<li>步骤 3 － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。</li>
<li>步骤 4 － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库以备将来引用，否则 Maven将停止处理并抛出错误（无法找到依赖的文件）。</li>
</ol>
</li>
</ul>
<h1 id="maven插件命令"><a class="markdownIt-Anchor" href="#maven插件命令"></a> Maven插件（命令）</h1>
<ul>
<li>每个生命周期中都包含着一系列的阶段(phase)。这些 phase 就相当于 Maven 提供的统一的接口，然后这些 phase 的实现由 Maven 的插件来完成。</li>
<li>Maven 生命周期的每一个阶段的具体实现都是由 Maven 插件实现的。Maven 实际上是一个依赖插件执行的框架，每个任务实际上是由插件完成。Maven 插件通常被用来：1.创建 jar 文件 2.创建 war 文件 3.编译代码文件 4.代码单元测试 5.创建工程文档 6.创建工程报告。</li>
<li>插件的执行：<code>&lt;code&gt;mvn [plugin-name]:[goal-name]&lt;/code&gt;</code></li>
<li>常用插件：</li>
</ul>
<table>
<thead>
<tr>
<th>插件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>clean</td>
<td>构建之后清理目标文件。删除目标目录。</td>
</tr>
<tr>
<td>compiler</td>
<td>编译 Java 源文件。</td>
</tr>
<tr>
<td>surefile</td>
<td>运行 JUnit 单元测试。创建测试报告。</td>
</tr>
<tr>
<td>jar</td>
<td>从当前工程中构建 JAR 文件。</td>
</tr>
<tr>
<td>war</td>
<td>从当前工程中构建 WAR 文件。</td>
</tr>
<tr>
<td>javadoc</td>
<td>为工程生成 Javadoc。</td>
</tr>
<tr>
<td>antrun</td>
<td>从构建过程的任意一个阶段中运行一个 ant 任务的集合。</td>
</tr>
</tbody>
</table>
<ul>
<li>插件是在 pom.xml 中使用 plugins 元素定义的。每个插件可以有多个目标。</li>
</ul>
<h1 id="maven的目录结构"><a class="markdownIt-Anchor" href="#maven的目录结构"></a> maven的目录结构</h1>
<ul>
<li>核心代码部分；</li>
<li>配置文件部分：jar包之外的部分。</li>
<li>测试代码部分；</li>
<li>测试配置文件部分。</li>
<li>maven标准目录结构：
<ul>
<li>src/main/java:核心代码部分</li>
<li>src/main/resources:配置文件部分</li>
<li>src/test/java：测试代码部分</li>
<li>src/test/resources:测试配置文件</li>
<li>src/main/webapp:页面资源，js，css，图片等。</li>
</ul>
</li>
</ul>
<h1 id="pomxml"><a class="markdownIt-Anchor" href="#pomxml"></a> pom.xml</h1>
<ul>
<li>项目对象模型：
<ul>
<li>项目自身信息</li>
<li>项目运行所依赖的jar包信息</li>
<li>项目运行环境信息，比如jdk信息。</li>
</ul>
</li>
<li>依赖管理模型：（dependency）
<ul>
<li>管理jar包</li>
<li>设置jar包的作用域来解决jar包冲突
<ul>
<li>不同的作用域的区别：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210201200309.jpg" alt="" /></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependencies&gt;
    &lt;!-- 在这里添加你的依赖 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;ldapjdk&lt;&#x2F;groupId&gt;  &lt;!-- 库名称，也可以自定义 --&gt;
        &lt;artifactId&gt;ldapjdk&lt;&#x2F;artifactId&gt;    &lt;!--库名称，也可以自定义--&gt;
        &lt;version&gt;1.0&lt;&#x2F;version&gt; &lt;!--版本号--&gt;
        &lt;scope&gt;system&lt;&#x2F;scope&gt; &lt;!--作用域--&gt;
        &lt;systemPath&gt;$&#123;basedir&#125;\src\lib\ldapjdk.jar&lt;&#x2F;systemPath&gt; &lt;!--项目根目录下的lib文件夹下--&gt;
    &lt;&#x2F;dependency&gt; 
&lt;&#x2F;dependencies&gt;</code></pre>
<ul>
<li>插件（plugins）
<ul>
<li>生命周期的每一个过程都对应底层的一个插件<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210201130751.jpg" alt="" /></li>
</ul>
</li>
<li>修改运行环境：</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;! 将服务器环境改为tomcat7--&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.tomcat.maven&lt;&#x2F;groupId&gt;
                &lt;artifactId&gt;tomcat7-maven-plugin&lt;&#x2F;artifactId&gt;
                &lt;version&gt;2.2&lt;&#x2F;version&gt;
                &lt;configuration&gt;
                    &lt;port&gt;8080&lt;&#x2F;port&gt;
                &lt;&#x2F;configuration&gt;
            &lt;&#x2F;plugin&gt;
        &lt;&#x2F;plugins&gt;
    &lt;&#x2F;build&gt;</code></pre>
<h1 id="maven配置阿里云镜像"><a class="markdownIt-Anchor" href="#maven配置阿里云镜像"></a> Maven配置阿里云镜像</h1>
<ul>
<li>因为Maven官方的中央仓库是国外的，访问很慢，所以换为Aliyun镜像。<br />
在settings.xml文件中找到<mirrors></mirrors>标签对,进行修改：</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">1 &lt;mirrors&gt;
2      &lt;mirror&gt;
3         &lt;id&gt;nexus-aliyun&lt;&#x2F;id&gt;
4         &lt;mirrorOf&gt;*&lt;&#x2F;mirrorOf&gt;
5         &lt;name&gt;Nexus aliyun&lt;&#x2F;name&gt;
6         &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&lt;&#x2F;url&gt;
7      &lt;&#x2F;mirror&gt; 
8 &lt;&#x2F;mirrors&gt;</code></pre>
<h1 id="maven导入非resources目录下的配置文件资源过滤问题"><a class="markdownIt-Anchor" href="#maven导入非resources目录下的配置文件资源过滤问题"></a> Maven导入非resources目录下的配置文件(资源过滤问题)</h1>
<ul>
<li>在pom.xml文件中配置：</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;
                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;
            &lt;&#x2F;includes&gt;
            &lt;filtering&gt;false&lt;&#x2F;filtering&gt;
        &lt;&#x2F;resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;
                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;
            &lt;&#x2F;includes&gt;
            &lt;filtering&gt;false&lt;&#x2F;filtering&gt;
        &lt;&#x2F;resource&gt;
    &lt;&#x2F;resources&gt;
&lt;&#x2F;build&gt;</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/LeetCode-%E6%95%B0%E7%BB%84/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/LeetCode-%E6%95%B0%E7%BB%84/index.html" class="post-title-link" itemprop="url">LeetCode-数组</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-20 10:01:51" itemprop="dateCreated datePublished" datetime="2020-09-20T10:01:51+08:00">2020-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:41:21" itemprop="dateModified" datetime="2022-09-17T19:41:21+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>16k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="代码地址"><a class="markdownIt-Anchor" href="#代码地址"></a> 代码地址</h1>
<p><a target="_blank" rel="noopener" href="https://github.com/zestaken/newblog/tree/master/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/Code/src/main/java/array">github</a></p>
<h1 id="1-一维数组的动态和-1480"><a class="markdownIt-Anchor" href="#1-一维数组的动态和-1480"></a> 1. 一维数组的动态和 1480</h1>
<ul>
<li>题目：</li>
</ul>
<hr />
<p>给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。</p>
<p>请返回 nums 的动态和。</p>
<p>示例 1：</p>
<p>输入：nums = [1,2,3,4]<br />
输出：[1,3,6,10]<br />
解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。</p>
<h2 id="java解法"><a class="markdownIt-Anchor" href="#java解法"></a> Java解法</h2>
<ul>
<li>法一：
<ul>
<li>设置一个新数组，每一项为前面所有项之和；</li>
<li>通过双重循环实现。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Sums &#123;

    public static int[] runningSums(int nums[]) &#123;
        int[] sums &#x3D; new int[nums.length];
        for(int i &#x3D; 0 ; i &lt; nums.length; i++) &#123;
            for(int j &#x3D; 0; j &lt;&#x3D; i; j++) &#123;
                sums[i] +&#x3D; nums[j];
            &#125;
        &#125;
        return sums;
    &#125;

    public static void main(String[] args) &#123;
        int[] nums &#x3D; &#123;1, 2, 3, 4,5&#125;;

        int[] sums &#x3D; Sums.runningSums(nums);

       for(int i : sums) &#123;
           System.out.println(i);
       &#125;
    &#125;
&#125;</code></pre>
<ul>
<li>法二：
<ul>
<li>动态求和过程中，每一项都是前一项与自身之和。</li>
<li>第一个元素没有前一个元素，对它没有操作，所以直接从第二个元素开始遍历求和。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Sums &#123;

    public static int[] runningSums (int[] nums) &#123;

        for(int i &#x3D; 1; i &lt; nums.length; i++) &#123;
&#x2F;&#x2F;            if(i &#x3D;&#x3D; 0) &#123;
&#x2F;&#x2F;                continue;
&#x2F;&#x2F;            &#125;因为0是无需操作的，所以直接从1开始就好了
            nums[i] +&#x3D; nums[i-1] ;
        &#125;
        return nums;
    &#125;

    public static void main(String[] args) &#123;
        int[] nums &#x3D; &#123;1, 2, 3,4&#125;;

        int[] sums &#x3D; Sums.runningSums(nums);
        for (int i : sums) &#123;
            System.out.println(i);
        &#125;
    &#125;
&#125;</code></pre>
<h1 id="2-拥有糖果最多的孩子-1431"><a class="markdownIt-Anchor" href="#2-拥有糖果最多的孩子-1431"></a> 2. 拥有糖果最多的孩子 1431</h1>
<ul>
<li>题目：</li>
</ul>
<hr />
<p>给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。</p>
<p>对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。</p>
<p></p>
<p>示例 1：</p>
<p>输入：candies = [2,3,5,1,3], extraCandies = 3<br />
输出：[true,true,true,false,true]<br />
解释：<br />
孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。<br />
孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。<br />
孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。<br />
孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。<br />
孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。</p>
<ul>
<li>java解法</li>
</ul>
<hr />
<ul>
<li>先找到拥有糖果数量最多的孩子，将加上补充的糖果数后的与这个最大比较</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Candy &#123;
    public static boolean[] isMax(int kids[], int extraCandies) &#123;
        &#x2F;&#x2F;找出原有最多的数
        int max &#x3D; 0;
        for(int i &#x3D; 0; i &lt; kids.length; i++) &#123;
            if(max &lt; kids[i]) &#123;
                max &#x3D; kids[i];
            &#125;
        &#125;
        &#x2F;&#x2F;设置判别数组
        boolean[] isMax &#x3D; new boolean[kids.length];
        for(int i &#x3D; 0; i &lt; kids.length; i++) &#123;
            if(kids[i] + extraCandies &gt;&#x3D; max) &#123;
                isMax[i] &#x3D; true;
            &#125; else&#123;
                isMax[i] &#x3D; false;
            &#125;
        &#125;
        return isMax;
    &#125;

    public static void main(String[] args) &#123;
        int[] kids &#x3D; &#123;2, 3, 5, 1, 3&#125;;
        int extraCandies &#x3D; 3;
        boolean[] isMax &#x3D; Candy.isMax(kids, extraCandies);
        for(boolean i : isMax) &#123;
            System.out.println(i);
        &#125;
    &#125;
&#125;</code></pre>
<h1 id="3-重新排列数组-1470"><a class="markdownIt-Anchor" href="#3-重新排列数组-1470"></a> 3. 重新排列数组 1470</h1>
<ul>
<li>题目：</li>
</ul>
<hr />
<ol start="1470">
<li>重新排列数组<br />
给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,…,xn,y1,y2,…,yn] 的格式排列。</li>
</ol>
<p>请你将数组按 [x1,y1,x2,y2,…,xn,yn] 格式重新排列，返回重排后的数组。</p>
<p>示例 1：</p>
<p>输入：nums = [2,5,1,3,4,7], n = 3<br />
输出：[2,3,5,4,1,7]<br />
解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7]</p>
<ul>
<li>Java解法：</li>
</ul>
<hr />
<ul>
<li>法一：设置一个额外的数组，用来将重排后的数据记录；</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Resort1470 &#123;
    public static int[] resort(int[] nums1)&#123;
        int n &#x3D; nums1.length &#x2F; 2;
        int[] nums2 &#x3D; new int[nums1.length];

        for(int i &#x3D; 0 ,j &#x3D; 0; j &lt; n;  i++, j++) &#123;
            nums2[i] &#x3D; nums1[j];
            nums2[++i] &#x3D; nums1[n + j];
        &#125;
    
        return nums2;
    &#125;

    public static void main(String[] args) &#123;
        int[] nums1 &#x3D; &#123;2,5,1,3,4,7&#125;;
        int[] nums2 &#x3D; Resort1470.resort(nums1);
        for(int i : nums2) &#123;
            System.out.println(i);
        &#125;
    &#125;
&#125;</code></pre>
<h1 id="4-左旋转字符串-剑指offer-58-ii"><a class="markdownIt-Anchor" href="#4-左旋转字符串-剑指offer-58-ii"></a> 4. 左旋转字符串 剑指offer 58-II</h1>
<ul>
<li>题目：</li>
</ul>
<hr />
<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。</p>
<p></p>
<p>示例 1：</p>
<p>输入: s = “abcdefg”, k = 2<br />
输出: “cdefgab”</p>
<ul>
<li>Java解法：</li>
</ul>
<hr />
<ul>
<li>将该字符串分为两个子串，然后再反向连接起来</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;

public class ReverseLeftWords &#123;

    public String reverseLeftWords(String s, int n) &#123;
         String str1 &#x3D; s.substring(0, n); &#x2F;&#x2F;读入从0到n（但是不包括下标为n的）
         String str2 &#x3D; s.substring(n); &#x2F;&#x2F;从n开始到最后（包括下标为n的）
         String  s1 &#x3D; str2 + str1;&#x2F;&#x2F;反向连接，达到左旋转的效果

         return s1;
&#x2F;&#x2F; return s.substring(n) + s.substring(o, n);

    &#125;

    public static void main(String[] args) &#123;
        String s &#x3D; &quot; &quot;;
        int n;
        Scanner in &#x3D; new Scanner(System.in);

        System.out.println(&quot;请输入字符：&quot;);
        s &#x3D; in.nextLine();

        System.out.println(&quot;请输入从哪里开始转：&quot;);
        n &#x3D; in.nextInt();

        var reverse &#x3D; new ReverseLeftWords();
        s &#x3D; reverse.reverseLeftWords(s, n);

        for(int i &#x3D; 0; i &lt; s.length(); i++) &#123;
            System.out.print(s.charAt(i) + &quot; &quot;);
        &#125;

    &#125;
&#125;</code></pre>
<ul>
<li>数组形式解法：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ReverseLeftWords &#123;
    public static char[] reverseLeftWords(char[] nums, int n) &#123;
        char[] nums1 &#x3D; new char[n];
        char[] nums2 &#x3D; new char[nums.length];

        for(int i &#x3D; 0; i &lt; nums.length; i++) &#123;
            if(i &lt; n) &#123;
                nums1[i] &#x3D; nums[i];
            &#125;else &#123;
                nums2[i - n] &#x3D; nums[i];
            &#125;
        &#125;
        for(int i &#x3D; 0; i &lt; n; i++) &#123;
            nums2[nums.length - n + i] &#x3D; nums1[i];
        &#125;

        return nums2;
    &#125;

    public static void main(String[] args) &#123;
       char[] nums &#x3D; &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;&#125;;

       char[] nums2 &#x3D; ReverseLeftWords.reverseLeftWords(nums, 2);

       for(char i : nums2) &#123;
           System.out.println(i);
       &#125;
    &#125;
&#125;</code></pre>
<h1 id="5-好数对的数目-1512"><a class="markdownIt-Anchor" href="#5-好数对的数目-1512"></a> 5. 好数对的数目 1512</h1>
<ul>
<li>题目</li>
</ul>
<hr />
<p>给你一个整数数组 nums 。</p>
<p>如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i &lt; j ，就可以认为这是一组 好数对 。</p>
<p>返回好数对的数目。</p>
<p></p>
<p>示例 1：</p>
<p>输入：nums = [1,2,3,1,1,3]<br />
输出：4<br />
解释：有 4 组好数对，分别是 (0,3), (0,4), (3,4), (2,5) ，下标从 0 开始.</p>
<ul>
<li>java解法</li>
</ul>
<hr />
<ul>
<li>法一：双重循环遍历数组，外层为数组这个计数循环，内层取寻找与当前元素相同的元素（但是只找当前位置之后的，避免重复计算）</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;

public class NumPairs1512 &#123;

    public static int numIdenticalPairs(int[] nums) &#123;
        int ans &#x3D; 0;

        for(int i &#x3D; 0; i &lt; nums.length; i++) &#123;
            for(int j &#x3D; 1; j &lt; nums.length; j++) &#123; &#x2F;&#x2F;每次统计相同的元素都是从当前位置向后遍历，这样就不会有重复的情况
                if(nums[i] &#x3D;&#x3D; nums[i+j]) &#123;
                    ans++;
                &#125;
            &#125;
        &#125;
        return ans;
    &#125;
    public static void main(String[] args) &#123;
        int[] nums &#x3D; &#123;1,2,3,1,1,3&#125;;
        System.out.println(Solution.numIdenticalPairs(nums));
    &#125;
&#125;</code></pre>
<h1 id="6-两个数组的交集-ii-350"><a class="markdownIt-Anchor" href="#6-两个数组的交集-ii-350"></a> 6. 两个数组的交集 II 350</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">题目</a>：</li>
</ul>
<hr />
<p>给定两个数组，编写一个函数来计算它们的交集。</p>
<p>示例 1：</p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]
输出：[2,2]</code></pre>
<p>示例 2:</p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]
输出：[4,9]</code></pre>
<p>说明：</p>
<p>输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。<br />
我们可以不考虑输出结果的顺序。<br />
进阶：</p>
<p>如果给定的数组已经排好序呢？你将如何优化你的算法？<br />
如果 nums1 的大小比 nums2 小很多，哪种方法更优？<br />
如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</p>
<h2 id="java题解"><a class="markdownIt-Anchor" href="#java题解"></a> Java题解</h2>
<ul>
<li>法一：遍历一个数组，将每个数出现的次数存入哈希表中，之后再遍历另一个数组并查找哈希表
<ul>
<li>代码：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Intersect350 &#123;

public int[] intersect(int[] nums1, int[] nums2) &#123;
    &#x2F;&#x2F;用哈希表存次数
    HashMap&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;Integer, Integer&gt;();

    &#x2F;&#x2F;遍历一个数组，获取每个元素值以及出现次数
    for(int i : nums1) &#123;
        if(!map.containsKey(i)) &#123;
            &#x2F;&#x2F;初始计数为1
            map.put(i, 1);
        &#125; else &#123;
            int count &#x3D; map.get(i);
            &#x2F;&#x2F;第二次出现计数加一
            count++;
            map.put(i, count);
        &#125;
    &#125;

    int[] res &#x3D; new int[(nums1.length &gt; nums2.length)?nums2.length:nums1.length];
    int index &#x3D; 0;
    for(int i : nums2) &#123;
        if(map.containsKey(i)) &#123;
            int count &#x3D; map.get(i);
            &#x2F;&#x2F;每出现一次计数减一，只在计数大于0时存入结果中，以保证出现次数与最少的数组相同
            count--;
            map.put(i, count);
            if(count &gt;&#x3D; 0) &#123;
                res[index] &#x3D; i;
                index++;
            &#125;
        &#125;
    &#125;
    return Arrays.copyOfRange(res, 0, index);
&#125;</code></pre>
</li>
<li>法二：先对两个数组进行排序，然后设置两个指针指向数组元素，每次相等的时候两个指针同时移动，不相等的时候较小的移动
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210714205354.png" alt="" /></li>
<li>代码：<pre class="line-numbers language-java" data-language="java"><code class="language-java">    &#x2F;&#x2F;先排序（升序）
Arrays.sort(nums1);
Arrays.sort(nums2);
&#x2F;&#x2F;存储结果数组
int[] res &#x3D; new int[(nums1.length &gt; nums2.length)?nums2.length:nums1.length];
int count1 &#x3D; 0;
int count2 &#x3D; 0;
int index &#x3D; 0;
while (true) &#123;
    if(nums1[count1] &#x3D;&#x3D; nums2[count2]) &#123;
        &#x2F;&#x2F;如果相等则双指针均前移
        res[index] &#x3D; nums1[count1];
        index++;
        count1++;
        count2++;
    &#125; else if(nums1[count1] &lt; nums2[count2]) &#123;
        count1++;
    &#125; else &#123;
        count2++;
    &#125;
    if(count1 &gt;&#x3D; nums1.length || count2 &gt;&#x3D; nums2.length) &#123;
        break;
    &#125;
&#125;

return Arrays.copyOfRange(res, 0, index);</code></pre>
</li>
</ul>
</li>
</ul>
<h1 id="7-找到所有数组中消失的数字-448"><a class="markdownIt-Anchor" href="#7-找到所有数组中消失的数字-448"></a> 7. 找到所有数组中消失的数字 448</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">题目</a></li>
</ul>
<hr />
<p>给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。</p>
<pre class="line-numbers language-none"><code class="language-none">示例 1：
输入：nums &#x3D; [4,3,2,7,8,2,3,1]
输出：[5,6]

示例 2：
输入：nums &#x3D; [1,1]
输出：[2]</code></pre>
<p>提示：</p>
<p>n == nums.length<br />
1 &lt;= n &lt;= 105<br />
1 &lt;= nums[i] &lt;= n</p>
<p>进阶：你能在不使用额外空间且时间复杂度为 O(n) 的情况下解决这个问题吗? 你可以假定返回的数组不算在额外空间内。</p>
<h2 id="java解法-2"><a class="markdownIt-Anchor" href="#java解法-2"></a> java解法</h2>
<ul>
<li>法一：排序后双指针扫描确定
<ul>
<li>结果：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/EEorl6.png" alt="EEorl6" /></li>
<li>代码：</li>
</ul>
  <pre class="line-numbers language-java" data-language="java"><code class="language-java">public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123;
    &#x2F;&#x2F;用于存储所有数字
    ArrayList&lt;Integer&gt; all &#x3D; new ArrayList&lt;&gt;();
    &#x2F;&#x2F;存储消失的数字
    ArrayList&lt;Integer&gt; disappear &#x3D; new ArrayList&lt;&gt;();
    int length &#x3D; nums.length;
    &#x2F;&#x2F;将范围内所有数字存入all集合
    for(int i &#x3D; 1; i &lt;&#x3D; length; i++) &#123;
        all.add(i);
    &#125;
    &#x2F;&#x2F;对数组进行排序后，通过双指针扫描两个数组确定消失的数字
    Arrays.sort(nums);

    &#x2F;&#x2F;双指针扫描两个数组&#x2F;集合
    for(int j &#x3D; 0, i &#x3D; 0; j &lt; length &amp;&amp; i &lt; length; ) &#123;
        &#x2F;&#x2F;all指针数字大于原数组指针数字，则原数组指针前移，all不变
        if(all.get(j) &gt; nums[i]) &#123;
            i++;
            &#x2F;&#x2F;判断边界，防止原数组扫描结束后all中剩余元素未被扫描
            if(i &gt;&#x3D; length) &#123;
                for(int t &#x3D; j; t &lt; length; t++) &#123;
                    disappear.add(all.get(t));
                &#125;
            &#125;
        &#125; else if(all.get(j) &#x3D;&#x3D; nums[i]) &#123;&#x2F;&#x2F; 两个指针同时迁移
            j++;
            i++;
            &#x2F;&#x2F;判断边界，防止原数组扫描结束后all中剩余元素未被扫描（all数组不可能在原数组之前扫描完）
            if(i &gt;&#x3D; length) &#123;
                for(int t &#x3D; j; t &lt; length; t++) &#123;
                    disappear.add(all.get(t));
                &#125;
            &#125;
        &#125; else if(all.get(j) &lt; nums[i]) &#123; &#x2F;&#x2F;all指针小于原数组指针数字则前移all指针，原数组不变
            disappear.add(all.get(j));
            j++;
        &#125;
    &#125;

    return disappear;
&#125;</code></pre>
</li>
<li>法二：利用数组脚标可对应连续整数，通过修改原数组指定位置的值来筛选没有出现过的数。不用排序，所以时间复杂度减少
<ul>
<li>结果：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/XfqEaq.png" alt="XfqEaq" /></li>
<li>代码：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123;
    ArrayList&lt;Integer&gt; ans &#x3D; new ArrayList&lt;&gt;();
    int length &#x3D; nums.length;

    for(int n : nums) &#123;
        int index &#x3D; (n - 1) % length;&#x2F;&#x2F;因为会加长度，导致有些位置上的数超过length，所以需要取模
        &#x2F;&#x2F;出现了的数字对应的位置的值加上长度
        nums[index] +&#x3D; length;
    &#125;
    
    &#x2F;&#x2F;再次遍历数组，如果值不大于长度length，则说明该位置脚标对应的值没有出现过
    for(int i &#x3D; 0; i &lt; length; i++) &#123;
        if(nums[i] &lt;&#x3D; length) &#123;
            ans.add(i + 1);
        &#125;
    &#125;

    return ans;
&#125;</code></pre>
</li>
</ul>
<h1 id="8-旋转图像-48"><a class="markdownIt-Anchor" href="#8-旋转图像-48"></a> 8. 旋转图像 48</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-image/">题目</a></li>
</ul>
<hr />
<p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。<br />
你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]

输入：matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]

输入：matrix &#x3D; [[1]]
输出：[[1]]

输入：matrix &#x3D; [[1,2],[3,4]]
输出：[[3,1],[4,2]]</code></pre>
<p>提示：</p>
<p>matrix.length == n<br />
matrix[i].length == n<br />
1 &lt;= n &lt;= 20<br />
-1000 &lt;= matrix[i][j] &lt;= 1000</p>
<h2 id="java解法-3"><a class="markdownIt-Anchor" href="#java解法-3"></a> java解法</h2>
<ul>
<li>法一：通过一圈一圈找到四个依次换位置的元素，来依次移动这些元素的值，来达到借助一个中间值变量实现原地旋转的效果。关键在于如何确定这些元素的下标的变化规律。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210719214209.png" alt="" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Rotate48 &#123;
    public void rotate(int[][] matrix) &#123;
        &#x2F;&#x2F;从外向内一圈圈找，用times表示在第几圈
        int times &#x3D; 0;
        &#x2F;&#x2F;nums表示矩阵的列数（行数）
        int nums &#x3D; matrix.length;

        while(times &lt;&#x3D; (nums &#x2F; 2)) &#123; &#x2F;&#x2F;比如4x4矩阵就是两圈，3x3也是两圈
            &#x2F;&#x2F;在每一圈中再确定依次交换值的四个元素
            int len &#x3D; nums - times * 2; &#x2F;&#x2F;len是圈的范围，每缩小一圈减少两个
            for(int i &#x3D; 0; i &lt; len - 1; i++) &#123;
                &#x2F;&#x2F;确定每一圈第一个元素的位置并用临时变量存储其值
                &#x2F;&#x2F;通过i来将第一个元素右移一位，其它三个元素顺势右移，遇到边界就贴着边界转换方向接着移
                int temp &#x3D; matrix[times][times + i];
                &#x2F;&#x2F;将上一个元素的值由其下一位元素的值来替代
                matrix[times][times + i] &#x3D; matrix[times + len - 1 - i][times];
                matrix[times + len - 1 - i][times] &#x3D; matrix[times + len - 1][times + len - 1 - i];
                matrix[times + len - 1][times + len - 1 - i] &#x3D; matrix[times + i][times + len - 1];
                matrix[times + i][times + len - 1] &#x3D; temp;
                &#x2F;&#x2F;虽然看起来复杂，但是每一个元素又一个坐标都是不随i的变化而变化，只要关注i对其有影响的坐标，顺势移动即可
            &#125;
            &#x2F;&#x2F;进入下一圈
            times++;
        &#125;
    &#125;
&#125;</code></pre>
<h1 id="9-搜索二维矩阵-ii-240"><a class="markdownIt-Anchor" href="#9-搜索二维矩阵-ii-240"></a> 9. 搜索二维矩阵 II 240</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">题目</a></li>
</ul>
<hr />
<p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</p>
<p>每行的元素从左到右升序排列。<br />
每列的元素从上到下升序排列。</p>
<pre class="line-numbers language-none"><code class="language-none">输入：matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 5
输出：true

输入：matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 20
输出：false
</code></pre>
<p>提示：</p>
<p>m == matrix.length<br />
n == matrix[i].length<br />
1 &lt;= n, m &lt;= 300<br />
-109 &lt;= matix[i][j] &lt;= 109<br />
每行的所有元素从左到右升序排列<br />
每列的所有元素从上到下升序排列<br />
-109 &lt;= target &lt;= 109</p>
<h2 id="java解法-4"><a class="markdownIt-Anchor" href="#java解法-4"></a> Java解法</h2>
<ul>
<li>法一：从矩阵右上角开始寻找，直到超出矩阵边界，则目标不存在。当前元素比目标小，则下移，当前元素比目标大则左移。用一个元素的眼光来看，这个元素的左侧的元素的较小，下方的元素比自己小，从递归的观点来看，对每一个元素都这样处理。如果开始从左上角开始，没有选择较小元素的余地，一旦遇见比目标的元素，只能回退
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210719232725.png" alt="" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean searchMatrix(int[][] matrix, int target) &#123;
    &#x2F;&#x2F;从右上角开始搜索
    int lines &#x3D; matrix.length;
    int rows &#x3D; matrix[0].length;

    for(int i &#x3D; 0, j &#x3D; rows - 1; i &lt; lines &amp;&amp; 0 &lt;&#x3D; j; ) &#123;
        if(matrix[i][j] &gt; target) &#123;
            &#x2F;&#x2F;比目标大，向左横向移动
            j--;
            if(j &lt; 0) &#123;
                return false;
            &#125;
        &#125;else if(matrix[i][j] &lt; target) &#123;
            &#x2F;&#x2F;比目标小，向下移动
            i++;
            if(i &gt;&#x3D; lines) &#123;
                return false;
            &#125;
        &#125; else if (matrix[i][j] &#x3D;&#x3D; target) &#123;
            return true;
        &#125;
    &#125;
    return false;
&#125;</code></pre>
<h1 id="10-最多能完成排序的块-769"><a class="markdownIt-Anchor" href="#10-最多能完成排序的块-769"></a> 10. 最多能完成排序的块 769</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-chunks-to-make-sorted/">题目</a></li>
</ul>
<hr />
<p>数组arr是[0, 1, …, arr.length - 1]的一种排列，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。</p>
<p>我们最多能将数组分成多少块？</p>
<pre class="line-numbers language-none"><code class="language-none">示例 1:

输入: arr &#x3D; [4,3,2,1,0]
输出: 1
解释:
将数组分成2块或者更多块，都无法得到所需的结果。
例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。
示例 2:

输入: arr &#x3D; [1,0,2,3,4]
输出: 4
解释:
我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。
然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。</code></pre>
<p>注意:</p>
<p>arr 的长度在 [1, 10] 之间。<br />
arr[i]是 [0, 1, …, arr.length - 1]的一种排列。</p>
<h2 id="java解法-5"><a class="markdownIt-Anchor" href="#java解法-5"></a> Java解法</h2>
<ul>
<li>法一：值为连续整数，将值与下标对应，当目前最大值与下标对应时，将数组分为左边一定比目前最大值都小，右边一定比当前最大值都大，可以划分
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/ZYfn0h.png" alt="ZYfn0h" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;连续整数的一个排列，用下标与值对应
  public int maxChunksToSorted(int[] arr) &#123;
      int max &#x3D; arr[0];
      int count &#x3D; 0;
      int length &#x3D; arr.length;
      for(int i &#x3D; 0; i &lt; length; i++) &#123;
          if(arr[i] &gt;&#x3D; max) &#123;
              max &#x3D; arr[i];
          &#125;
          &#x2F;&#x2F;每当最大值与下标相等则说明前面的数据全是比最大值小的而之后全是比最大值大的
          &#x2F;&#x2F;如果只能分为一块，说明最大值在最前面出现，最后总能遇到自己的下标，而使count加一
          if(max &#x3D;&#x3D; i) &#123;
              count++;
          &#125;
      &#125;
      return count;
  &#125;</code></pre>
<h1 id="11-区域和检索-数组不可变-303"><a class="markdownIt-Anchor" href="#11-区域和检索-数组不可变-303"></a> 11. 区域和检索 - 数组不可变 303</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-sum-query-immutable/">题目</a></li>
</ul>
<hr />
<p>给定一个整数数组 nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点。<br />
实现 NumArray 类：</p>
<pre class="line-numbers language-none"><code class="language-none">NumArray(int[] nums) 使用数组 nums 初始化对象
int sumRange(int i, int j) 返回数组 nums 从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点（也就是 sum(nums[i], nums[i + 1], ... , nums[j])）</code></pre>
<p>示例：</p>
<pre class="line-numbers language-none"><code class="language-none">输入：
[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;]
[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]
输出：
[null, 1, -1, -3]

解释：
NumArray numArray &#x3D; new NumArray([-2, 0, 3, -5, 2, -1]);
numArray.sumRange(0, 2); &#x2F;&#x2F; return 1 ((-2) + 0 + 3)
numArray.sumRange(2, 5); &#x2F;&#x2F; return -1 (3 + (-5) + 2 + (-1)) 
numArray.sumRange(0, 5); &#x2F;&#x2F; return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))</code></pre>
<p>提示：</p>
<pre class="line-numbers language-none"><code class="language-none">0 &lt;&#x3D; nums.length &lt;&#x3D; 104
-105 &lt;&#x3D; nums[i] &lt;&#x3D; 105
0 &lt;&#x3D; i &lt;&#x3D; j &lt; nums.length
最多调用 104 次 sumRange 方法</code></pre>
<h2 id="java解法-6"><a class="markdownIt-Anchor" href="#java解法-6"></a> Java解法</h2>
<ul>
<li>法一：构造一个前缀和数组，存储每个位置对应的前缀之后，以后计算中间的和，只需要使用两个前缀和相减即可。虽然感觉构造一个前缀和数组时间复杂度很大，但是可以一次计算，永久使用。（既然他要用一个数组来构造一个对象，想必也是为了这个目的）注意，为了防止越界而使前缀和数组和源数组向后错一位。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/1293N6.png" alt="1293N6" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class NumArray &#123;

    private int[] partialSum;
    public NumArray(int[] nums) &#123;
        &#x2F;&#x2F;初始默认值为0
        partialSum &#x3D; new int[nums.length + 1];
        &#x2F;&#x2F;构造前缀和数组
        for(int i &#x3D; 0; i &lt; nums.length;i++) &#123;
            &#x2F;&#x2F;向后推一位存储
            partialSum[i + 1] &#x3D; partialSum[i] + nums[i];
        &#125;
    &#125;

    public int sumRange(int left, int right) &#123;
        &#x2F;&#x2F;两边相减得到中间的和，因为前缀和数组向后推了一位，所以下标也要向后推一位
        &#x2F;&#x2F;正常是right - (left - 1)
        &#x2F;&#x2F;向后推一位的目的是防止计算第一位的前缀时超出边界
        return partialSum[right + 1] - partialSum[left];
    &#125;
&#125;</code></pre>
<h1 id="12-二维区域和检索-矩阵不可变-304"><a class="markdownIt-Anchor" href="#12-二维区域和检索-矩阵不可变-304"></a> 12. 二维区域和检索 - 矩阵不可变 304</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">题目</a></li>
</ul>
<hr />
<p>给定一个二维矩阵 matrix，以下类型的多个请求：</p>
<p>计算其子矩形范围内元素的总和，该子矩阵的左上角为<code>(row1, col1)</code> ，右下角为 <code>(row2, col2)</code> 。<br />
实现 NumMatrix 类：<br />
<code>NumMatrix(int[][] matrix)</code> 给定整数矩阵 matrix 进行初始化<br />
<code>int sumRegion(int row1, int col1, int row2, int col2)</code> 返回左上角<code>(row1, col1)</code> 、右下角 <code>(row2, col2)</code>的子矩阵的元素总和。</p>
<p>示例：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/n4dUJm.jpg" alt="n4dUJm" /></p>
<pre class="line-numbers language-none"><code class="language-none">输入: 
[&quot;NumMatrix&quot;,&quot;sumRegion&quot;,&quot;sumRegion&quot;,&quot;sumRegion&quot;]
[[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]
输出: 
[null, 8, 11, 12]

解释:
NumMatrix numMatrix &#x3D; new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]]);
numMatrix.sumRegion(2, 1, 4, 3); &#x2F;&#x2F; return 8 (红色矩形框的元素总和)
numMatrix.sumRegion(1, 1, 2, 2); &#x2F;&#x2F; return 11 (绿色矩形框的元素总和)
numMatrix.sumRegion(1, 2, 2, 4); &#x2F;&#x2F; return 12 (蓝色矩形框的元素总和)</code></pre>
<p>提示：</p>
<pre class="line-numbers language-none"><code class="language-none">m &#x3D;&#x3D; matrix.length
n &#x3D;&#x3D; matrix[i].length
1 &lt;&#x3D; m, n &lt;&#x3D; 200
-105 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 105
0 &lt;&#x3D; row1 &lt;&#x3D; row2 &lt; m
0 &lt;&#x3D; col1 &lt;&#x3D; col2 &lt; n
最多调用 104 次 sumRegion 方法</code></pre>
<h2 id="java解法-7"><a class="markdownIt-Anchor" href="#java解法-7"></a> Java解法</h2>
<ul>
<li>法一：一维前缀和叠加，设置一个二维的前缀和数组，前缀和数组的每一行，都是当行数组的一维前缀和数组。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210906220738.png" alt="" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">private int[][] partialSum;
public NumMatrix(int[][] matrix) &#123;
    &#x2F;&#x2F;初始化前缀和数组
    partialSum &#x3D; new int[matrix.length][matrix[0].length + 1];
    &#x2F;&#x2F;计算前缀和
    for(int i &#x3D; 0; i &lt; matrix.length; i++) &#123;
        for(int j &#x3D; 0; j &lt; matrix[0].length; j++) &#123;
            partialSum[i][j+1] &#x3D; partialSum[i][j] + matrix[i][j];
        &#125;
    &#125;

&#125;

public int sumRegion(int row1, int col1, int row2, int col2) &#123;
    int sum &#x3D; 0;
    &#x2F;&#x2F;逐行扫描，每一行依次用前缀和相减计算中间和
    for(int i &#x3D; row1; i &lt;&#x3D; row2; i++) &#123;
        sum +&#x3D; (partialSum[i][col2 + 1] - partialSum[i][col1]);
    &#125;
    return sum;
&#125;</code></pre>
<ul>
<li>法二：二维前缀和（积分图）
<ul>
<li>结果：</li>
<li>代码：</li>
</ul>
</li>
</ul>
<h1 id="13-和为k的子数组-560"><a class="markdownIt-Anchor" href="#13-和为k的子数组-560"></a> 13. 和为K的子数组 560</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">题目</a></li>
</ul>
<hr />
<p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。<br />
示例1:</p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [1,1,1], k &#x3D; 2
输出：2</code></pre>
<p>示例2:</p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [1,2,3], k &#x3D; 3
输出：2</code></pre>
<p>提示：</p>
<pre class="line-numbers language-none"><code class="language-none">1 &lt;&#x3D; nums.length &lt;&#x3D; 2 * 104
-1000 &lt;&#x3D; nums[i] &lt;&#x3D; 1000
-107 &lt;&#x3D; k &lt;&#x3D; 107</code></pre>
<h2 id="java解法-8"><a class="markdownIt-Anchor" href="#java解法-8"></a> Java解法</h2>
<ul>
<li>法一：一边计算当前元素的前缀和，一边查找与当前前缀和差值为0的前面的前缀和。将每次计算得到的前缀和存入哈希表中，哈希表的键为前缀和，值为前缀和目前出现的次数。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/sT7AHQ.png" alt="sT7AHQ" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SubarraySumEqualsK560 &#123;

    public int subarraySum(int[] nums, int k) &#123;
        &#x2F;&#x2F;存储子数组计数结果
        int res &#x3D; 0;
        &#x2F;&#x2F;创建前缀和数组
        Map&lt;Integer, Integer&gt; hashPartialSums &#x3D; new HashMap&lt;&gt;();
        &#x2F;&#x2F;添加一个0的和，保证从0到当前位置的连续数组和为k能被统计
        hashPartialSums.put(0, 1);
        &#x2F;&#x2F;存储当前前缀和
        int partialSum &#x3D; 0;
        &#x2F;&#x2F;初始化前缀和数组
        for(int i &#x3D; 0; i &lt; nums.length; i++) &#123;
            &#x2F;&#x2F;计算当前前缀和
            partialSum &#x3D; partialSum + nums[i];
            &#x2F;&#x2F;将当前前缀和及其所出现的次数存入哈希表中
            int count &#x3D; hashPartialSums.getOrDefault(partialSum, 0);
            &#x2F;&#x2F;查看哈希表中是否存在与当前前缀和差为k的值（这个值肯定是由这个数组前面的元素产生的，只用考虑差值为k），如果有则记录次数
            if(hashPartialSums.containsKey(partialSum - k)) &#123;
                res +&#x3D; hashPartialSums.get(partialSum - k);
            &#125;
            &#x2F;&#x2F;当前前缀和次数加一，之所以在检索之后再增加计数
            &#x2F;&#x2F; 是因为计算差值不能将自己与自己的差值算上，次数不加，说明只查找当前元素之前
            count++;
            hashPartialSums.put(partialSum, count);
        &#125;

        return res;
    &#125;
&#125;</code></pre>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Java/java/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Java/java/index.html" class="post-title-link" itemprop="url">java</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-11 16:39:07" itemprop="dateCreated datePublished" datetime="2020-09-11T16:39:07+08:00">2020-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:29:23" itemprop="dateModified" datetime="2022-09-17T19:29:23+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>69k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:03</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="java概述"><a class="markdownIt-Anchor" href="#java概述"></a> java概述</h1>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/15/docs/api/index.html">官方文档</a></p>
<ul>
<li>java EE：java企业版；java SE：java标准版；java ME：java微型版。</li>
<li>java<strong>不支持指针</strong>。</li>
<li>Application：java应用程序；Applet：java小应用程序（嵌入到web页面中，要依赖HTML文件和web浏览器，且没有main()方法）</li>
<li>Java可以编写Web服务程序。</li>
<li>Java特性：
<ul>
<li>平台无关性；</li>
<li>相对C++的简洁性。</li>
<li>java提供内存管理机制，会自动收集内存垃圾。</li>
<li>多线程</li>
<li>分布式：适用于网络</li>
<li><strong>面向对象</strong>。</li>
</ul>
</li>
<li>封装：将对象内的<strong>数据和代码</strong>联编起来，形成一个对象。</li>
<li>多态性：一个接口，有多个内在的实现。</li>
<li>继承：某一对象直接使用另一对象的所有属性和方法的过程。</li>
<li>JDK：（Java Development Kit)
<ul>
<li>Sun免费提供的Java SE，如：JDK1.8</li>
<li>GPL许可的Java平台的实现：OpenJDK。</li>
</ul>
</li>
<li>Java程序基本结构：
<ul>
<li><code>.java</code>:源程序文件
<ul>
<li>一个包声明package语句；</li>
<li>任意数量的import语句；</li>
<li>类和接口声明</li>
</ul>
</li>
<li><code>.class</code>:经编译后的字节代码程序文件。</li>
</ul>
</li>
<li>Java中的字符使用的是<strong>Unicode标准</strong>，支持汉字在内的多种文字,16位存储，且无符号。</li>
<li>Java符号：
<ol>
<li>关键字；</li>
<li>标识符：
<ol>
<li>必须由字母、下划线或美元符开头；</li>
<li>由字母，数字，下划线和美元符组成；</li>
<li>不能与关键字同名</li>
</ol>
</li>
<li>常量；</li>
<li>运算符</li>
<li>分隔符</li>
</ol>
</li>
<li>取名习惯：
<ul>
<li>类和接口名用<strong>名词</strong>，大小写混写，<strong>第一个字母大写</strong>，如：<code>class WorldTool</code></li>
<li>方法名用<strong>动词</strong>，大小写混写，<strong>第一个字母小写</strong>，如：<code>depositAccount()</code></li>
<li>变量用名词或形容词等，大小写混写，<strong>第一个字母小写</strong>，如：<code>currentCustomer</code></li>
<li>常量符号用<strong>全部大写</strong>，并用<strong>下划线将词分隔</strong>，如：<code>PERSON_COUNT</code></li>
</ul>
</li>
</ul>
<h1 id="输入和输出"><a class="markdownIt-Anchor" href="#输入和输出"></a> 输入和输出</h1>
<ul>
<li>使用<code>Scanner in = new Scanner(System.in);</code>可以定义一个可以接受输入的东西<code>in</code>（名字是任取的。）。之后要接受输入时，就使用形如<code>in.nextline()``in.nextint()</code>的语句。（其中line与int表示接受的输入的数据类型，line是字符串，int是整型）。</li>
<li>使用<code>System.out.println();</code>可以直接输出字符串并且在每一次输出后都换行，还有<code>System.out.print()</code>，它与前者的区别是在每一次输出后不换行。</li>
<li><code>System.out.prinf()</code>这个输出的用法与c语言中的printf()类似，可以有<code>System.out.printf(&quot;%.2f&quot;,i)</code>这样的类似c语言的格式限制。</li>
<li>Java的注释和c语言一样，可以用<code>//</code>和<code>/**/</code>，还有<code>/** */</code>用来为注释javadoc标明。</li>
</ul>
<h1 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h1>
<ul>
<li>变量的定义：&lt;类型名称&gt; &lt;变量名&gt;;</li>
<li>变量的名字(又叫做标识符）只能由字母，数字和下划线组成，且数字不可以出现在第一个位置上。Java的内置的关键字不可以用作变量名。</li>
<li>Java是一种强类型语言，变量在使用前必须声明，且变量具有确定的类型。</li>
<li>所有被声明的成员变量都是有默认值的。例如：数字类型的默认值为0,引用类型的默认值为<strong>null</strong>，布尔值为<strong>false</strong>。不过方法中<strong>局部变量声明后不会进行默认的初始化</strong>,所以必须进行明确初始化。</li>
</ul>
<h1 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h1>
<ul>
<li>类似变量的定义声明，常量只需要在定义时在类型前加上关键词<code>final</code>。常量只能在定义时赋值初始化，之后不能再赋值。</li>
<li>可以在类中定义final类型的实例字段。如果在定义时没有给final类型的变量赋值，那么就可以在<strong>构造器</strong>（也只有在构造器中，其他方法不行）中为它赋值</li>
<li><strong>变量的作用域</strong>：总的来说，Java中变量的作用域就是在它被定义的花括号之内。如，在for循环内部定义的就只在该循环内有效，在函数内部定义的就只在函数内部有效。</li>
<li>常量符号命名规范：全部大写，并用下划线将词分隔，如:<code>PERSON_COUNT</code>.</li>
</ul>
<h1 id="运算"><a class="markdownIt-Anchor" href="#运算"></a> 运算</h1>
<h2 id="赋值"><a class="markdownIt-Anchor" href="#赋值"></a> 赋值</h2>
<ul>
<li>同c语言一样，Java依旧使用<code>=</code>来进行赋值。</li>
<li>在定义变量的时候可以进行赋值（此时叫做变量的初始化）。</li>
<li>赋值运算是自右向左。</li>
</ul>
<h3 id="复合赋值"><a class="markdownIt-Anchor" href="#复合赋值"></a> 复合赋值</h3>
<ul>
<li>同c语言一样，Java中也有复合赋值，即<code>+=, -=, *=, /=</code>。用法与c语言完全一致。<code>a += b + c</code>与<code>a = a + (b + c)</code>完全相同。</li>
</ul>
<h2 id="四则运算"><a class="markdownIt-Anchor" href="#四则运算"></a> 四则运算</h2>
<ul>
<li>当浮点数和整数放在一起运算时，Java会将整数先转化为浮点数，之后进行浮点数的运算。</li>
<li><code>+，-，*,/ , %</code>的运算优先级和惯常的优先级一致。特别的，<code>%</code>对于小数也可以使用。</li>
<li>赋值号<code>=</code>的优先级很低，以保持和正常思维一样的运算顺序。</li>
<li>Java中同样有<code>i++, ++i</code>这种运算，用法与c语言完全相同。</li>
</ul>
<h2 id="位运算"><a class="markdownIt-Anchor" href="#位运算"></a> 位运算</h2>
<ul>
<li>位运算是用来处理整型数据的。</li>
<li>位运算符包括<code>&amp;(and), |(or), ^(xor), ~(not)，&gt;&gt;, &lt;&lt;, &gt;&gt;&gt;</code>.</li>
<li><code>&amp;, |, ^, ~</code>是对每一位进行和，或，异或，非的运算。</li>
<li><code>&gt;&gt;,&lt;&lt;</code>是将位左移或者右移。<code>&gt;&gt;</code>用符号位填充高位。
<ul>
<li>位运算是将值转换位2进制来进行移位，如：<code>1 &lt;&lt; 1</code>,表示将1的二进制数左移一位，结果是2。</li>
</ul>
</li>
<li><code>&gt;&gt;&gt;</code>进行左移，但是用0来填充高位。</li>
</ul>
<h2 id="单目运算符"><a class="markdownIt-Anchor" href="#单目运算符"></a> 单目运算符</h2>
<ul>
<li>取正<code>+</code>和取负<code>-</code>,运算优先级高于普通的双目运算符。</li>
<li><code>++</code>和<code>--</code>java也同样使用。</li>
<li><code>~</code>:按位求补。</li>
</ul>
<h2 id="条件运算符"><a class="markdownIt-Anchor" href="#条件运算符"></a> 条件运算符</h2>
<ul>
<li><code>expreBool?expression1 : expression2</code>：条件为true则执行表达式1，否则执行2.</li>
<li>如：<code>int c = (a &gt; b)? 1 : 2;</code></li>
</ul>
<h1 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h1>
<h2 id="整型"><a class="markdownIt-Anchor" href="#整型"></a> 整型</h2>
<ul>
<li>整数类型不能表达有小数部分的数。整数与整数的运算结果还是整数。</li>
<li>Java中所有的数字都是<strong>有符号</strong>的，没有无符号类型。</li>
<li><code>int</code>型：32位 ，如果整型常量后面没有L，则默认为int型</li>
<li><code>long</code>型：64位</li>
<li><code>short</code>型：16位</li>
</ul>
<h3 id="整数型常量"><a class="markdownIt-Anchor" href="#整数型常量"></a> 整数型常量</h3>
<ul>
<li>三种形式
<ol>
<li>十进制整数：是由不以0开头，0~9数字构成的数据；</li>
<li>八进制整数：是由<strong>以0开头</strong>，0~7数字组成的数据：012（与十进制数字10值相等）；</li>
<li>十六进制整数：是由<strong>0x或者0X</strong>开头，0<sub>9数字及A</sub>F的字母组成的数据：0x1F（与十进制数字31相等）</li>
</ol>
</li>
</ul>
<h2 id="浮点型"><a class="markdownIt-Anchor" href="#浮点型"></a> 浮点型</h2>
<ul>
<li>浮点数就是通常所说的小数。</li>
<li><code>double</code>型的浮点数：12.23d/12.23D/12.23（不带字母时默认小数为double类型）  64位存储</li>
<li><code>float</code>:12.23f/12.23F 32位存储</li>
<li>带指数的数：如<code>2E2</code>,他的结果是200，即E2代表科学计数法的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">10^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>,虽然<strong>结果为整数但是仍然是double类型</strong>。</li>
</ul>
<h2 id="布尔类型"><a class="markdownIt-Anchor" href="#布尔类型"></a> 布尔类型</h2>
<ul>
<li>Java中的布尔类型是用<code>boolean</code>定义的，其含义与用法与c语言中的bool类型一致。但是整型与boolean是严格区分的，即将boolean类型变量赋为0或者1是不行的。</li>
</ul>
<h2 id="字符类型"><a class="markdownIt-Anchor" href="#字符类型"></a> 字符类型</h2>
<ul>
<li>单个字符类型是char，其字符字面量是用<strong>单引号</strong>来表示的，如’a’,'4’等。Java中的字符使用的是Unicode标准，支持汉字在内的多种文字,16位存储，且无符号。</li>
<li>类似C语言中的字符类型，可以对字符变量进行加减运算。如<code>i = 'A' - 'D'</code>中的i为3，也可以强制将字符类型转换为int类型。</li>
<li><strong>逃逸字符</strong>：有些没有办法打印出来的字符，这些字符由一个反斜杠<code>\</code>开头，后面跟上一个字符，由这两个字符合起来组成一个字符。常见逃逸字符：</li>
</ul>
<table>
<thead>
<tr>
<th>字符</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>\b</td>
<td>回退一格</td>
</tr>
<tr>
<td>\t</td>
<td>到下一个表格位</td>
</tr>
<tr>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>&quot;</td>
<td>双引号</td>
</tr>
<tr>
<td>’</td>
<td>单引号</td>
</tr>
<tr>
<td><code>\\</code></td>
<td>反斜杠本身</td>
</tr>
</tbody>
</table>
<h2 id="包裹类型"><a class="markdownIt-Anchor" href="#包裹类型"></a> 包裹类型</h2>
<ul>
<li>每种基础类型（如，int，double，char）都有对应的包裹类型。</li>
<li>包裹类型除了具有和基础类型一样的功能外（如定义变量），还有许多可以实现的功能。如<code>Integer.MAX_VALUE</code>,可以得到int类型的最大值。即使用包裹类型可以调用许多java内置的方法。</li>
<li>包裹类型的第一个字母是大写的。</li>
<li>各种基础类型对应的包裹类型。</li>
</ul>
<table>
<thead>
<tr>
<th>基础类型</th>
<th>包裹类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody>
</table>
<h2 id="引用类型"><a class="markdownIt-Anchor" href="#引用类型"></a> 引用类型</h2>
<ul>
<li>引用类型（数组，class或interface）在声明变量时是<strong>不会为变量（即对象）分配存储空间</strong>的，所以即使声明了也不可直接使用，需要使用<strong>new运算符为引用类型的分配存储空间，完成初始化</strong>之后才能正常使用。</li>
</ul>
<h2 id="字符串变量"><a class="markdownIt-Anchor" href="#字符串变量"></a> 字符串变量</h2>
<ul>
<li>
<p><strong>字符串字面量</strong>：用<strong>双引号</strong>括起来的0或者多个字符为一个字符串字面量。如：“hello”</p>
<ul>
<li>字符串字面量可以直接调用String类型的方法,如：<code>&quot;hello&quot;.toUpperCase();</code></li>
<li>字符串字面量就是String类型的一个<strong>匿名对象</strong>。</li>
</ul>
</li>
<li>
<p><strong>字符串类型</strong>：<code>String</code>是字符串类型（第一个字母为大写，是一种包裹类型），String是一个类，String类型的变量是字符串的管理者而非所有者（就和数组变量和数组一样。）</p>
</li>
<li>
<p><strong>字符串变量的创建</strong>：</p>
<ul>
<li>
<p>法一：<code>String s = new String(字符串字面量)</code>.用字符串字面量初始化字符串变量。也可以直接初始化一个字面量，如<code>String s = &quot;hello&quot;</code>。</p>
<ul>
<li>
<p>相同内容的字符串字面量在内存中默认是同一个字符串对象。</p>
</li>
<li>
<p>但是同样的字符串字面量传递给String类构造器之后构造出来的就不是一个对象了。</p>
</li>
<li>
<p>示例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">String s1 &#x3D; &quot;zhangjie&quot;;
String s2 &#x3D; &quot;zhangjie&quot;;
String s3 &#x3D; new String(&quot;zhangjie&quot;);
s1 &#x3D;&#x3D; s2;&#x2F;&#x2F;true
s1 &#x3D;&#x3D; s3;&#x2F;&#x2F;false
&#x2F;&#x2F;&#x3D;&#x3D;用于对象之间，只会判断引用的是否是同一个对象，不会管内容是否相同</code></pre>
</li>
</ul>
</li>
<li>
<p>法二：使用<code>StringBuider &lt;字符串名&gt; = new StringBuilder();</code>可以创建一个空的字符串(但是这样创建的不是String类型，而是StringBuilder类型的变量了，使用<code>&lt;字符串名&gt;.append(ch)</code>或者&lt;字符串名&gt;.append(str)`来给字符串追加内容。(更多方法请查阅java.lang.StringBuilder)</p>
</li>
</ul>
</li>
<li>
<p><strong>字符串的连接</strong>：使用<code>+</code>可以将两个字符串连接起来，如果<code>+</code>两边的不是字符串类型，它会自动将非字符串类型的转为字符串类型。</p>
</li>
<li>
<p><strong>字符串的读入</strong>：使用<code>in.nextline()</code>能直接读入一个字符串，字符串之间以回车为表示。（使用<code>in.next()</code>可以读入单词，每个单词之间用空格隔开。）</p>
</li>
<li>
<p>字符串是<strong>只读</strong>的变量，不可以通过赋值来修改。</p>
</li>
<li>
<p><strong>String[]<strong>代表的是</strong>字符串数组</strong>，即一个元素类型为String类型的数组。注意与String类型的区分。</p>
</li>
</ul>
<h3 id="字符串的操作"><a class="markdownIt-Anchor" href="#字符串的操作"></a> 字符串的操作</h3>
<ul>
<li>
<p>字符串的数据是对象，可以通过<code>.</code>来调用其方法来实现对字符串的操作。</p>
</li>
<li>
<p><strong>字符串的比较</strong>：<code>s.compareTo(s1)</code>;</p>
</li>
<li>
<p><strong>获得字符串的长度</strong>：<code>s.length()</code>;</p>
</li>
<li>
<p><strong>访问字符串中的单个字符</strong>：<code>s.charAt(3)</code>.(3是字符的索引，类似数组，但不可直接像访问数组中元素一样使用a[i]这样的访问)。</p>
</li>
<li>
<p><strong>判断两个字符串是否相同</strong>：<code>s.equals(s1)</code>.</p>
<ul>
<li><code>==</code>用于对象之间，只会判断引用的是否是同一个对象，不会管内容是否相同;</li>
<li>而<code>equal()</code>判断是否相同的依据是它们的内容是否相同。</li>
</ul>
</li>
<li>
<p><strong>获得字符串的子串</strong>：<code>s.substring(2,4)</code>或者<code>s.substring(2)</code>,括号中是字符的索引，单独的2代表从索引为2以后开始的子串，但是（2，4）代表从索引为2字符以后开始，到索引为4字符之前。</p>
</li>
<li>
<p><strong>寻找字符串中的字符</strong>：<code>s.indexOf(c)</code>或者<code>s.indexOf(c,n)</code>或者<code>s.indexOf(s1)</code>。括号中只有字符c代表找到字符串中c字符所在位置的索引。（c，n）表示从n位置开始寻找c字符，s1为字符串变量，（s1）能找到字符串s1所在的位置。还可以从右边开始找<code>s.lastIndexOf(同普通的)</code>.</p>
<h2 id="stringbuffer"><a class="markdownIt-Anchor" href="#stringbuffer"></a> StringBuffer</h2>
<ul>
<li><strong>StringBuffer</strong>是线程安全的可变字符序列。每个字符串缓冲区都有一定的容量。只要字符串缓冲区所包含的字符序列的长度没有超出此容量，就无需分配新的内部缓冲区数组。如果内部缓冲区溢出，则此容量自动增大。从 JDK 5 开始，为该类补充了一个单个线程使用的等价类，即 StringBuilder。与该类相比，通常应该优先使用StringBuilder类，因为它支持所有相同的操作，但由于它是异步的，所以速度更快。</li>
</ul>
</li>
</ul>
<h2 id="强制类型转换"><a class="markdownIt-Anchor" href="#强制类型转换"></a> 强制类型转换</h2>
<ul>
<li>Java同c语言一样，有很多隐式转换。例如整型在某些条件下会自动转为浮点型。</li>
<li>但是浮点型不会自动转换为整型（<strong>大不会自动转小</strong>）。我们可以进行强制类型转换。例如：<code>int a = (int)(32 /5 .0)</code>。</li>
</ul>
<h2 id="var声明局部变量"><a class="markdownIt-Anchor" href="#var声明局部变量"></a> var声明局部变量</h2>
<ul>
<li>当变量的类型可以<strong>从它的初始值中推导出来</strong>时，可以使用var关键字来声明，而无需指明其类型。如：<code>Employee harry = new Employee();</code>可以写作<code>var harry = new Employee();</code>。</li>
<li>var关键字只能用于方法中的局部变量，<strong>参数和实例字段</strong>的类型必须明确声明。</li>
</ul>
<h1 id="关系运算"><a class="markdownIt-Anchor" href="#关系运算"></a> 关系运算</h1>
<ul>
<li>关系运算符：<code>==, &gt;, &lt;, &gt;=, &lt;=, !=</code>与C语言一致。</li>
<li>关系运算符的优先级比算术运算符低，但是比赋值运算高。例如：<code>7 &gt; 3 + 2</code>。</li>
<li>判等和判不等<code>==, !=</code>的优先级比<code>&lt;, &lt;=, &gt;, &gt;=</code>低.例如：<code>5 &gt; 3 == 6 &gt; 4</code>是可行的（但是和c语言一样，尽量不要连续使用关系运算。）</li>
<li><code>&lt;, &gt;, &gt;=, &lt;=</code>是不能连续使用的，例如：<code>a &gt; b &gt; c</code>是和你的想象完全不同的。</li>
</ul>
<h2 id="浮点数的比较"><a class="markdownIt-Anchor" href="#浮点数的比较"></a> 浮点数的比较</h2>
<ul>
<li>整型是可以与浮点数进行比较的。</li>
<li>浮点数的运算有误差。所以判断两个浮点数是否相等是用<code>Math.abs(a -b) &lt; 1e-6</code>.先用<code>Math.abs(a - b)</code>算出两个浮点数之间的差值，在让这个差值和一个很小的数比较。<code>1e-6</code>表示的是1的负6次方。</li>
</ul>
<h1 id="控制语句"><a class="markdownIt-Anchor" href="#控制语句"></a> 控制语句</h1>
<h2 id="条件语句"><a class="markdownIt-Anchor" href="#条件语句"></a> 条件语句</h2>
<h3 id="if语句"><a class="markdownIt-Anchor" href="#if语句"></a> if语句</h3>
<ul>
<li>与c语言类似，只有一个语句时可以不用花括号（但是建议不管多少语句都用花括号），但是有多条语句时必须括起来。</li>
<li>类似c语言，Java中的if语句同样可以与else连用，进行级联条件判断。</li>
</ul>
<h3 id="swich语句"><a class="markdownIt-Anchor" href="#swich语句"></a> swich语句</h3>
<ul>
<li>Java中同样有switcl-case语句。用法也与c语言相同。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">switch (控制表达式) &#123;
    case 常量：
        语句
        ...
        break;
    case 常量：
        语句
        ...
        break；
    ...
    default:
        语句
        ...
&#125;</code></pre>
<ul>
<li>控制表达式，只能是<strong>整型</strong>或者与整型相容（如byte short char）的结果，布尔型也不行；</li>
<li>每个case后面都要有<strong>break</strong>语句。</li>
<li>如果所有的case都不匹配，就执行default后面的语句；如果没有设置default语句，就什么也不做。(default后面直接接冒号，<strong>没有条件</strong>。default后面的语句<strong>不用</strong>放break来终止。）</li>
</ul>
<h2 id="循环语句"><a class="markdownIt-Anchor" href="#循环语句"></a> 循环语句</h2>
<h3 id="while"><a class="markdownIt-Anchor" href="#while"></a> while</h3>
<ul>
<li>与c语言中的while基本一致。 while是<strong>当条件满足时</strong>执行循环内的语句。</li>
<li>与c语言一样，Java中也有<code>do-while</code>循环，这个循环至少执行一次。do-while循环是一直执行直到while语句中的条件<strong>不满足</strong>。（while判断之后要接<code>;</code>）</li>
</ul>
<h3 id="for循环"><a class="markdownIt-Anchor" href="#for循环"></a> for循环</h3>
<ul>
<li>Java中也有for循环，用法与c语言基本相似。</li>
<li>但是Java可以在循环条件语句中定义变量，并且在for循环中定义的变量只能在for循环中使用，在循环体外并没有那个变量的定义。例如：<code>for(int i = 1; i &lt;= n; i = i + 1 )&#123;&#125;</code>。（for循环适合有明确结束条件的循环。）</li>
<li><code>break</code>语句在Java中与c语言中一致，用于跳出循环。</li>
<li><code>continue</code>语句也是与c语言一样，用于到达循环尾。(但是continue语句<strong>不会跳过for循环的步进语句</strong>，例如：<code>for(int i = 0; i &lt;= n; i++)&#123;continue;&#125;</code>， 每次continue语句之后还是要执行i++之后再开启下一轮循环。)。</li>
<li><strong>循环的标号</strong>：可以在循环前设置一个标号（例如;<code>out:</code>）来标示循环。使用<code>break 标号</code>和<code>continue 标号</code>可以使break和continue对标号标示的循环起作用。示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">OUt:
for(int i &#x3D; 0; i &lt;&#x3D; n1; i++)&#123;
    for(int j &#x3D; 0; j &lt;&#x3D; n2; j++)&#123;
        break OUT;
    &#125;
&#125;</code></pre>
<p>OUT标示的循环是最外层的循环，使用<code>break OUT</code>能直接跳出最外层的循环。</p>
<ul>
<li><strong>for-each</strong>循环：形如:<code>for (int i : numbers)&#123;&#125;</code>,意思是每一次循环，一次将数组numbers中的元素值赋给变量i。常用于遍历数组（foreach循环不能用于遍历字符串，即java中字符串与数组没有c语言中那么亲密的关系）。<strong>接收数组中元素的变量必须是在for中定义的</strong>。 示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">int[] numbers &#x3D; new int[100];

&#x2F;&#x2F; 依次遍历数组中每个元素，并在数组遍历完之后停止循环。
for (int i : numbers) &#123;
    if (i &#x3D;&#x3D; 23) &#123;
        System.out.println(&quot;numbers数组中有23这个数&quot;)；
        break；
    &#125;
&#125;

&#x2F;&#x2F;错误使用

int i;
for(i : numbers) &#123;
    System.out.println(i);
&#125;
</code></pre>
<h1 id="逻辑类型"><a class="markdownIt-Anchor" href="#逻辑类型"></a> 逻辑类型</h1>
<ul>
<li>关系运算的结果是一个逻辑值，true或者false。这个值保存在一个对应的逻辑类型的变量中，这个类型是boolean。与c语言的布尔类型一样，Java中的布尔类型也只有true和false这两种值。</li>
</ul>
<h2 id="逻辑运算"><a class="markdownIt-Anchor" href="#逻辑运算"></a> 逻辑运算</h2>
<ul>
<li><strong>!</strong>:逻辑非。</li>
<li><strong>&amp;&amp;</strong>：逻辑与。</li>
<li><strong>||</strong>：逻辑或。三者都与c语言中的逻辑运算的用法一致。</li>
</ul>
<h1 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h1>
<ul>
<li>数组定义：形如<code>int[] numbers = new int[100]</code>。<strong>动态初始化</strong>格式范式：<code>&lt;类型&gt;[] &lt;名字&gt; = new &lt;类型&gt;[元素个数]</code>（同c语言一样，数组的下标是从0开始的，后面方括号中是数组中元素的个数(可以为变量，但是必须有）。但是实际只有numbers[99], 而没有numbers[100].)</li>
<li>数组一旦创建，<strong>不能被改变大小</strong>。</li>
<li>数组本身是一个<strong>引用数据类型</strong>。</li>
<li>数组中的所有元素是<strong>同一类型</strong>。</li>
<li>java中的每个数组有一个内部成员length,这个变量中存储了数组中元素的个数（即创建数组时确定的元素个数）。使用示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">int[] numbers &#x3D; new int[100];

for(int i &#x3D; 0; i &lt; numbers.length; i++) &#123;
    ...
&#125;</code></pre>
<ul>
<li>数组的<strong>直接（静态）初始化</strong>：形如：<code>int[] numbers = new int[] &#123;1, 2, 3, 4, 5&#125;;</code>也可以省略书写<code>int[] numbers = &#123;1, 2,3&#125;;</code></li>
<li>初始化的语句可以拆分为两个步骤：<code>int[] array; array = new int[5]</code>或者<code>int[] array; array = new int[] &#123;1, 2, 3&#125;;</code>声明不能创建数组对象本身，只能创建一个引用。数组对象由new语句创建。</li>
<li>数组变量之间可以做赋值。例如：<code>int[] numbers = &#123;1, 2, 3, 4, 5&#125;; int[] b = numbers;</code>.数组变量的实质与c语言类似，是指向实际存储空间的“指针”，但是Java中不使用指针的概念，可以把数组变量看作是实际存储空间的管理者。所以数组变量之间的赋值，其实质是将对实际存储空间的管理权共享了出去，而不是把整个数组复制过去。因此，如果改变了b数组中，某个元素的值，numbers数组中相应的元素也会跟着改变。如<code>b [2] = 3;</code>之后会有<code>numbers[2] == 3</code>.</li>
<li><strong>拷贝</strong>数组元素到另一个数组中：<code>var a = new X[list.size]; list.toArray(a)</code>。将list数组的元素拷贝到a数组中去。（适用于各种类型的数组，包括泛型数组列表）</li>
<li>对数组对象的操作需要使用<strong>Arrays</strong>类中的方法。</li>
<li>main函数必须带的参数<code>String[] args</code>是main函数接收命令行参数的字符串类型的数组。</li>
<li>数组变量之间的比较，是在比较两个数组变量是否管理同一个数组，而不是比较两个数组是否是每个元素都对应相等。</li>
<li>刚创建的int类型数组，数组中的元素<strong>默认</strong>都是0。double类型为0.0,boolean类型为false等。</li>
<li><strong>二维数组</strong>：定义形如<code>int[][] numbers = new int[3][5];</code>;与c语言类似，通常理解为矩阵。二维数组初始化：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
int[][] numbers &#x3D; &#123;
    &#123;1, 2, 3, 4&#125;, &#x2F;&#x2F;每一行用逗号，分隔。
    &#123;5, 6, 7&#125;, &#x2F;&#x2F;第二行比第一行少了一个元素，编译器会自动补上0；
&#125;;&#x2F;&#x2F;别忘了最后的分号。</code></pre>
<ul>
<li>
<p>二维数组中仍然有length变量表示数组的长度。<code>numbers.length</code>表示数组的的行数。而每一行有多少个元素需要用<code>numbers[i].length</code>。</p>
</li>
<li>
<p>多维数组的实质是元素类型为数组的一维数组。</p>
<ul>
<li>
<p>必须对前面的维的数组（即低维数组）初始化，才能对它后面的维依次进行初始化。</p>
</li>
<li>
<p>可以每一维元素分步初始化，来创建非矩形的数组。</p>
</li>
<li>
<p>示例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">int[][] numbers &#x3D; new int[2][];
numbers[0] &#x3D; new int[5];
numbers[1] &#x3D; new int[8];</code></pre>
</li>
</ul>
</li>
</ul>
<h1 id="math类"><a class="markdownIt-Anchor" href="#math类"></a> Math类</h1>
<ul>
<li>Math类提供的很多数学操作，如取绝对值等。</li>
<li><code>abs</code>提供取绝对值操作，<code>.round</code>提供四舍五入的操作，<code>.random</code>提供取随机数（0到1之间）的操作，<code>.pow</code>可以进行幂运算。</li>
<li>使用示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
Math.abs(-12); &#x2F;&#x2F;结果为12
Math.round(10.2343); &#x2F;&#x2F;结果为10
Math.random(); 
Math.pow(2, 3); &#x2F;&#x2F;结果为2的3次方：8</code></pre>
<h1 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h1>
<h2 id="方法定义"><a class="markdownIt-Anchor" href="#方法定义"></a> 方法定义</h2>
<ul>
<li>方法可以接收0个或者多个参数，做一件事，并返回0个或者一个值。</li>
<li>方法定义：函数头（函数名，返回类型，参数表），函数体。函数定义示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public static boolean sum(int a, int b) 
&#123;
    ...
    return true;  
&#125;</code></pre>
<h2 id="方法调用"><a class="markdownIt-Anchor" href="#方法调用"></a> 方法调用</h2>
<ul>
<li>方法单独调用格式：<code>方法名（参数）</code>,注意，即使方法不需要参数，也需要括号。</li>
<li>方法可能会有返回值，此时需要有对应的变量来接收返回值。void类型的方法是没有返回值的。</li>
<li>传递给方法的参数类型要匹配，如果类型不匹配，则在某些情况下方法会自动转换。（条件是方法需要的类型比实际传进来的参数类型“宽”，如double类型比int类型宽。）。</li>
<li>传递给方法的参数，实际是传的<strong>值</strong>，即没有传进去变量本身，而只是变量值的一个副本。在方法内部是无法修改传进来的参数的值的。
<ul>
<li><strong>基本类型</strong>：在方法调用时，实际参数将其存储单元的数据赋值给形式参数；</li>
<li><strong>引用类型</strong>：在方法调用，引用类型虽然也是将其复制给形式参数，但是实际引用的对象却并没有发生改变，所以形式变量对引用中的对象值改变<strong>会影响</strong>到实际参数引用的对象值。</li>
</ul>
</li>
<li>方法调用流程：
<ol>
<li>找到方法定义；</li>
<li>参数传递；</li>
<li>执行方法体；</li>
<li>带着返回值回到方法的调用处。</li>
</ol>
</li>
</ul>
<h2 id="方法的本地变量"><a class="markdownIt-Anchor" href="#方法的本地变量"></a> 方法的本地变量</h2>
<ul>
<li>
<p>同c语言一样，Java方法内部定义的变量在方法外部是不可见的。方法内部定义的本地变量，只在方法内部有效。</p>
</li>
<li></li>
</ul>
<h1 id="类与对象"><a class="markdownIt-Anchor" href="#类与对象"></a> 类与对象</h1>
<h2 id="类的初始化"><a class="markdownIt-Anchor" href="#类的初始化"></a> 类的初始化</h2>
<h2 id="类与对象的基本定义"><a class="markdownIt-Anchor" href="#类与对象的基本定义"></a> 类与对象的基本定义</h2>
<ul>
<li><strong>类</strong>：定义同一类事物，Java中所有的代码都位于某个类里。（类的第一个字母要大写）
<ul>
<li>类包括三个部分：类声明，类成员，类的构造器（方法）。</li>
</ul>
</li>
<li>类定义示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Hero &#123;
     
    String name; &#x2F;&#x2F;姓名
     
    float hp; &#x2F;&#x2F;血量
     
    float armor; &#x2F;&#x2F;护甲
     
    int moveSpeed; &#x2F;&#x2F;移动速度
&#125;</code></pre>
<ul>
<li><strong>对象</strong>：类就像是一个模板，根据这个模板可以创建很多同一类的东西，这些根据类创建出来的东西就是对象。由类构造对象的过程叫做<strong>实例化</strong>。对象创建示例:</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Hero &#123;
     
    String name; &#x2F;&#x2F;姓名
     
    float hp; &#x2F;&#x2F;血量
     
    float armor; &#x2F;&#x2F;护甲
     
    int moveSpeed; &#x2F;&#x2F;移动速度
     
    public static void main(String[] args) &#123;
        Hero garen &#x3D;  new Hero(); &#x2F;&#x2F;对象的创建类似于数组或者String类型的变量的创建。
        garen.name &#x3D; &quot;盖伦&quot;;
        garen.hp &#x3D; 616.28f;
        garen.armor &#x3D; 27.536f;
        garen.moveSpeed &#x3D; 350;
         
        Hero teemo &#x3D;  new Hero();
        teemo.name &#x3D; &quot;提莫&quot;;
        teemo.hp &#x3D; 383f;
        teemo.armor &#x3D; 14f;
        teemo.moveSpeed &#x3D; 330;
    &#125;  
     
&#125; &#x2F;&#x2F;英雄是一个大类，而具体的每个英雄则是一个对象</code></pre>
<ul>
<li><strong>属性（成员变量）</strong>：类中定义的变量就是类的属性(类中的数据又叫做<strong>实例字段</strong>），类中的属性就像一种东西的各种属性。属性可以是基本类型（如int等）也可以是<strong>类类型</strong>（如String等）.属性名称一般是小写，但是如果由两个及以上单词组成，则从第二个单词开始，首字母大写。
<ul>
<li>类中的实例字段只能由自己类中的方法来直接访问。换句话说，成员变量的作用域在类中是<strong>全局</strong>的，能被类中所有的方法所访问。</li>
<li>所有对象的实例字段描述了对象当前状况的信息，这就是对象的<strong>状态</strong>。</li>
</ul>
</li>
<li><strong>方法</strong>：类中的东西不仅具有属性，它还会做事情，能做的事情就是类中的方法。（方法的实质是在类中定义的函数）.方法的命名方法与属性一样。方法与属性的调用方法都是通过在对象后使用<code>.</code>。
<ul>
<li>通常的类没有main方法，却有自己的实例字段和方法。要想构建一个完成的程序，会使用多个类，但是<strong>只有一个类有main方法</strong>。</li>
</ul>
</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Hero &#123;
    String name; &#x2F;&#x2F;姓名
      
    float hp; &#x2F;&#x2F;血量
      
    float armor; &#x2F;&#x2F;护甲
      
    int moveSpeed; &#x2F;&#x2F;移动速度
 
    &#x2F;&#x2F;Hero方法:坑队友
    void keng()&#123;
        System.out.println(&quot;坑队友！&quot;);
    &#125;
&#125;</code></pre>
<h2 id="对象变量"><a class="markdownIt-Anchor" href="#对象变量"></a> 对象变量</h2>
<ul>
<li>不是基本类型而是类类型的变量，又叫做<strong>对象变量</strong>，对象变量可以用来引用该类的对象。</li>
<li>对象的生命周期：
<ol>
<li>创建：声明，实例化；</li>
<li>使用：通过对象名对成员的访问；</li>
<li>销毁：实例开销的回收，由JVM自动完成，对象在被作为垃圾收集前自动调用从Object继承的<code>finalize()</code>方法来清楚自己所占用的资源。</li>
</ol>
</li>
<li>对象的创建时用<code>new Hero()</code>,但是创建的对象需要一个变量来接收才能使用，于是<code>Hero h = new Hero()</code>，此时的<code>=</code>不再是对于基本类型的赋值的意思，而是<strong>指向</strong>的意思。这个Hero类型的变量h就又叫做引用。（用c语言指针的概念来理解：就是h指向刚创建的Hero对象，但是Java中没有指针这个概念，所以只是一种理解）</li>
<li>对象变量可以<strong>赋值</strong>，如<code>Date deadline = birthday</code>(birthday也是一个对象变量，现在这两个对象变量引用同一个对象)。对象变量可以赋值为<strong>null</strong>，代表这个对象变量当前没有引用任何对象。</li>
<li>对象变量的值除了用new操作符，使用构造器获得外，还可以调用返回对象的引用的方法来赋值。如`DayOfWeek weekday = date.getDayOfWeek();</li>
<li>根据引用的概念，对象的创建又可以写为：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Hero &#123;
      
    String name; &#x2F;&#x2F;姓名
      
    float hp; &#x2F;&#x2F;血量
      
    float armor; &#x2F;&#x2F;护甲
      
    int moveSpeed; &#x2F;&#x2F;移动速度
      
    public static void main(String[] args) &#123;
        &#x2F;&#x2F;创建一个对象,但是没有引用。
        new Hero();
         
        &#x2F;&#x2F;使用一个引用来指向这个对象
        Hero h &#x3D; new Hero();
         
    &#125;  
      
&#125;</code></pre>
<ul>
<li>（类比c语言的指针），可以有多个引用指向同一个对象，但是一个引用不能同时指向多个对象。</li>
</ul>
<h2 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h2>
<ul>
<li>如果另一类东西有已经定义的某一类东西全部属性，则可以通过继承来避免属性的重复定义。</li>
<li>继承的特性：
<ol>
<li><strong>单一继承性</strong>：子类只能有<strong>一个超类</strong>。</li>
<li>子类<strong>不能继承超类的构造器</strong>，只能通过<code>super()</code>来调用超类的构造器。</li>
<li>子类的构造器<strong>首先要调用超类的构造器</strong>。</li>
<li>子类的成员<strong>隐藏和覆盖超类中相同的成员</strong>。（多态性）</li>
<li>超类的对象可以对子类的实例进行引用。（多态性）</li>
<li>由<strong>abstract修饰的类必须被继承</strong>。</li>
<li>由<strong>final修饰的类不能被继承</strong>。</li>
</ol>
</li>
<li>继承是一种<code>is-a</code>关系，即子类包含于父类中，子类的特性（字段和方法）<strong>更多</strong>。例如：人类是一个父类，而男人可以作为人类的一个子类。</li>
<li>父类又称为：超类、基类；子类又称为：派生类、孩子类。</li>
<li>子类从父类那里继承了<strong>方法</strong>和<strong>字段</strong>：
<ul>
<li>子类只可以访问从超类继承下来的三种访问权限设定的成员：<strong>public,protected以及缺省的</strong>。</li>
<li>如果是在父类中用private修饰的<strong>私有字段</strong>和<strong>私有方法</strong>（大多数时候是私有字段），虽然被子类继承，但是子类却<strong>无法访问</strong>。</li>
</ul>
</li>
<li>根据对象的多态性，可以将<strong>子类对象赋给父类引用变量</strong>，但是反之不行。因为如果将父类对象赋给子类的引用变量，如果这个变量调用子类特有的方法就会出错。但是父类中的方法，子类对象都具有，所以不会出错。
<ul>
<li>超类引用子类的的实例，只能调用超类中定义了的方法；</li>
<li>对于被覆盖的方法，java运行时是根据实例的类型来选择调用哪个方法。即如果用超类引用子类的实例，调用被子类覆盖了的方法，那么执行的是子类中重新定义的方法。</li>
</ul>
</li>
<li>继承是通过关键字<code>extends</code>来实现的。示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Item &#123;
    String name;
    int price;
&#125;

&#x2F;&#x2F; 非继承的写法，武器是一种物品。
public class Weapon&#123;
    String name;
    int price;
    int damage; &#x2F;&#x2F;攻击力
 
&#125;
&#x2F;&#x2F;继承的写法

public class Weapon extends Item&#123; &#x2F;&#x2F; 通过extends来实现继承
    int damage; &#x2F;&#x2F;攻击力
     
    public static void main(String[] args) &#123;
        Weapon infinityEdge &#x3D; new Weapon();
        infinityEdge.damage &#x3D; 65; &#x2F;&#x2F;damage属性在类Weapon中新设计的
         
        infinityEdge.name &#x3D; &quot;无尽之刃&quot;;&#x2F;&#x2F;name属性，是从Item中继承来的，就不需要重复设计了
        infinityEdge.price &#x3D; 3600;
         
    &#125;
     
&#125;</code></pre>
<h3 id="方法覆盖重写"><a class="markdownIt-Anchor" href="#方法覆盖重写"></a> 方法覆盖（重写）</h3>
<ul>
<li>父类中的某些方法可能对子类不适用，此时就需要在子类中重新写一个<strong>名字相同（方法名，参数，返回数据类型都相同）但是实现不同</strong>的方法。</li>
<li>注：方法过载是在一个类中具有相同方法名不同参数的方法。</li>
</ul>
<h3 id="super"><a class="markdownIt-Anchor" href="#super"></a> super</h3>
<ul>
<li>super关键字可以在子类中调用父类的方法。</li>
<li>super关键字可以在子类中调用父类的构造器。如<code>super(name,salry)</code>。具体调用父类的哪个构造器是由参数的数目和类型决定的。</li>
<li>另外，经常是在子类的构造器中调用父类的构造器来节省部分代码，但是<strong>super调用构造器的语句只能作为子类构造器的第一个语句</strong>出现。</li>
</ul>
<h3 id="继承层次"><a class="markdownIt-Anchor" href="#继承层次"></a> 继承层次</h3>
<ul>
<li>由一个公共父类派生出来的所有类的集合称为<strong>继承层次</strong>。</li>
<li>在继承层次中从某个特定的类到其祖先的路径称为该类的<strong>继承链</strong>。</li>
</ul>
<h3 id="阻止继承final类与方法"><a class="markdownIt-Anchor" href="#阻止继承final类与方法"></a> 阻止继承：final类与方法</h3>
<ul>
<li>被声明为final的类，是不能被继承的。声明格式<code>public final class Hello &#123;...&#125;</code>。</li>
<li>方法也可以被声明为final，这代表这个方法不能在子类中被<strong>覆盖（重写）</strong>。final类中的所有方法都被自动声明为final类型的方法（但是不会将字段自动变为final类型）。</li>
<li>字段被声明为final类型就与继承没有关系。final字段是指，该字段在对象构造出来初始化之后就不能被修改了。</li>
</ul>
<h3 id="对象引用的强制类型转换"><a class="markdownIt-Anchor" href="#对象引用的强制类型转换"></a> 对象引用的强制类型转换</h3>
<ul>
<li>在继承层次内才能进行对象引用的强制类型转换。</li>
<li>只能将父类强制类型转换为子类，并且应该使用instanceof检查要转换的两个类型之间是否为父子类关系。</li>
<li>示例：<code>boss = (Manger) staff[1]</code>。</li>
</ul>
<h3 id="对象包装器与自动装箱"><a class="markdownIt-Anchor" href="#对象包装器与自动装箱"></a> 对象包装器与自动装箱</h3>
<ul>
<li>所有的基本类型都有一个与之对应的类。（如：Integer类对应基本类型int）。这些类称为<strong>包装器</strong>。</li>
<li>包装器有：<code>Integer, Long, Float, Double, Short, Byte, Character, Boolean</code>。</li>
<li>包装器是<strong>不可变</strong>的类，包装器被构造之后，就不允许更改包装在其中的值。包装器是<strong>final</strong>类型的类，不能派生子类。</li>
<li>包装器的用途：将基本类型如int转换为对象。如：ArrayList<Integer>`。因为尖括号中必须是普通的类，所以不能使用int，此时可以用Integer达到相同的效果。</li>
<li><strong>自动装箱</strong>：在声明为包装器类的地方使用对应的基本类型，会自动将该基本类型的元素转换为对应的包装器类，这种特性叫做自动装箱。如：<code>list.add(3)</code>将自动转换成<code>list.add(Integer.valueOf(3))</code>。</li>
<li><strong>自动拆箱</strong>：在声明为基本类型的地方使用对应的包装器类，会自动将该包装器类的元素转换为对应的基本类型。</li>
<li>包装器中还有很多基本静态方法。如<code>int x = Integer.parseInt(s)</code>可以将s字符串转换为整型数值。</li>
</ul>
<h3 id="参数数量可变的方法"><a class="markdownIt-Anchor" href="#参数数量可变的方法"></a> 参数数量可变的方法</h3>
<ul>
<li>示例：<code>public PrintStream printf(String fmt, Object...args)</code>。其中<code>...</code>是java代码的一部分。，表明这个方法可以接收任意数量的对象。实际上这个方法接收两个参数，一个是格式字符串fmt，一个是<code>Object[]</code>数组。<code>Object[]</code>数组中保存着其它所有参数。</li>
</ul>
<h3 id="反射"><a class="markdownIt-Anchor" href="#反射"></a> 反射</h3>
<ul>
<li>暂时略。</li>
</ul>
<h2 id="方法重载方法过载"><a class="markdownIt-Anchor" href="#方法重载方法过载"></a> 方法重载(方法过载)</h2>
<ul>
<li>方法重载指的是<strong>方法名一样，但是参数不一样</strong>。每次调用该名字的方法时，会自动根据对应的参数类型以及数量来调用对应的方法。</li>
<li><strong>多态性</strong>的表现。</li>
<li>参数的名称，数量以及类型在重载中都是可以随便修改的。</li>
<li>但是方法重载不能修改方法的<strong>返回值类型</strong>。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ADHero extends Hero &#123;
    public void attack() &#123;
        System.out.println(name + &quot; 进行了一次攻击 ，但是不确定打中谁了&quot;);
    &#125;
 
    public void attack(Hero h1) &#123;
        System.out.println(name + &quot;对&quot; + h1.name + &quot;进行了一次攻击 &quot;);
    &#125;
 
    public void attack(Hero h1, Hero h2) &#123;
        System.out.println(name + &quot;同时对&quot; + h1.name + &quot;和&quot; + h2.name + &quot;进行了攻击 &quot;);
    &#125;
 &#x2F;&#x2F;可以给类似的方法设置同样的名字。
    public static void main(String[] args) &#123;
        ADHero bh &#x3D; new ADHero();
        bh.name &#x3D; &quot;赏金猎人&quot;;
 
        Hero h1 &#x3D; new Hero();
        h1.name &#x3D; &quot;盖伦&quot;;
        Hero h2 &#x3D; new Hero();
        h2.name &#x3D; &quot;提莫&quot;;
 
        bh.attack(h1);
        bh.attack(h1, h2);
    &#125;
 
&#125;</code></pre>
<ul>
<li>方法重载还可以通过设置<strong>可变数量的参数</strong>来实现。可变数量的参数通过数组来实现。示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ADHero extends Hero &#123;
 
    public void attack() &#123;
        System.out.println(name + &quot; 进行了一次攻击 ，但是不确定打中谁了&quot;);
    &#125;
 
    &#x2F;&#x2F; 可变数量的参数
    public void attack(Hero... heros) &#123; &#x2F;&#x2F;Hero是类型，方法的形参需要设置...&lt;数组名&gt;来表示这个函数是接受可变参数的
        for (int i &#x3D; 0; i &lt; heros.length; i++) &#123;
            System.out.println(name + &quot; 攻击了 &quot; + heros[i].name);&#x2F;&#x2F;数组设置的参数调用方法与普通数组一样。
 
        &#125;
    &#125;
 
    public static void main(String[] args) &#123;
        ADHero bh &#x3D; new ADHero();
        bh.name &#x3D; &quot;赏金猎人&quot;;
 
        Hero h1 &#x3D; new Hero();
        h1.name &#x3D; &quot;盖伦&quot;;
        Hero h2 &#x3D; new Hero();
        h2.name &#x3D; &quot;提莫&quot;;
 
        bh.attack(h1);
        bh.attack(h1, h2);
 
    &#125;
 
&#125;</code></pre>
<h2 id="构造方法"><a class="markdownIt-Anchor" href="#构造方法"></a> 构造方法</h2>
<ul>
<li>实例化：通过一个类创建一个对象的过程叫做实例化。</li>
<li><strong>构造方法（构造器）</strong>：实例化是通过调用构造方法来实现的。构造方法同其他方法一样具有一样具有参数和语句体，但是<strong>没有返回类型</strong>。构造方法不是成员方法，不能用对象来调用它。<strong>构造方法的名字与类的名字一样</strong>，包括大小写也一样。</li>
<li>每个类可以有<strong>一个以上</strong>的构造器（构造器的方法过载）。</li>
<li><strong>不要</strong>在构造方法（类中的其它方法也一样）中使用与实例字段同名的局部变量。</li>
<li>构造方法之间可以<strong>通过<code>this()</code>来相互调用</strong>。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Hero &#123;
 
    String name;
 
    float hp;
 
    float armor;
 
    int moveSpeed;
 
    &#x2F;&#x2F; 方法名和类名一样（包括大小写）
    &#x2F;&#x2F; 没有返回类型
    public Hero() &#123;
        System.out.println(&quot;实例化一个对象的时候，必然调用构造方法&quot;);
    &#125;
     
    public static void main(String[] args) &#123;
        &#x2F;&#x2F;实例化一个对象的时候，必然调用构造方法
        Hero h &#x3D; new Hero();&#x2F;&#x2F;new 后面跟的是构造方法，只是构造方法的名字与类的名字是相同的。
    &#125;
&#125;</code></pre>
<ul>
<li>如果在定义类中没有对构造方法的定义，则编译器在编译时会自动给类加上一个无参的，语句体为空的构造方法。但如果已经手动定义了一个有参的构造器，就<strong>不会</strong>再自动生成这个默认无参的构造器，此时再使用无参的构造器构造对象就是非法的。</li>
<li>构造方法总是通过<code>new</code>来调用的，如果使用的是没有参数的构造方法，则直接是<code>new &lt;类名&gt;()</code>来调用，如果有参数则需加上参数列表<code>new &lt;类名&gt;(参数列表)</code>，另外，构造方法与普通方法一样，是可以进行方法重载的。示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Hero &#123;
       
    String name; &#x2F;&#x2F;姓名
       
    float hp; &#x2F;&#x2F;血量
       
    float armor; &#x2F;&#x2F;护甲
       
    int moveSpeed; &#x2F;&#x2F;移动速度
       
    &#x2F;&#x2F;带一个参数的构造方法
    public Hero(String heroname)&#123; 
        name &#x3D; heroname;
    &#125;
     
    &#x2F;&#x2F;带两个参数的构造方法
    public Hero(String heroname,float herohp)&#123; 
        name &#x3D; heroname;
        hp &#x3D; herohp;
    &#125;
       
    public static void main(String[] args) &#123;
        Hero garen &#x3D;  new Hero(&quot;盖伦&quot;); &#x2F;&#x2F;调用构造方法创建对象时需要加上参数了。
        Hero teemo &#x3D;  new Hero(&quot;提莫&quot;,383);
    &#125;
     
&#125;</code></pre>
<h3 id="静态代码块-初始化块"><a class="markdownIt-Anchor" href="#静态代码块-初始化块"></a> 静态代码块、初始化块</h3>
<ul>
<li>静态代码块：类中用static关键修饰的块（又名<strong>类初始化块</strong>）：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class 类名称 &#123;
    static &#123;
        &#x2F;&#x2F;静态代码块的内容
    &#125;
&#125;</code></pre>
<ul>
<li>
<p>静态代码块特性：</p>
<ul>
<li>当<strong>第一次</strong>用到本类时，静态代码块执行<strong>唯一的一次</strong>；再次使用该类时，不会再执行静态代码块。</li>
<li>静态内容总是优先于非静态，所以<strong>静态代码块比构造方法先执行</strong>。</li>
<li>一个类中可以有多个静态初始化块；</li>
<li>静态初始化块的执行要早于普通初始化块；</li>
<li>用途：用来一次性地对静态成员变量进行赋值，比如需要通过计算来初始化static变量时可以声明一个static块。</li>
</ul>
</li>
<li>
<p>初始化块：没有static修饰的普通块</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
class InitDemo1&#123;
	&#123;
		System.out.println(&quot;我是普通初始化块&quot;);
	&#125;
&#125;</code></pre>
</li>
<li>
<p>初始化块特性：</p>
<ul>
<li>初始化块没有名字，不能被调用，它在对象创建时隐式执行，每次创建该类的对象都会执行初始化块。</li>
<li>一个类里可以有多个初始化块，多个初始化块之间有顺序：在前面的初始化块先执行，后边的初始化块后执行。</li>
<li>初始化块先于构造器先执行。</li>
</ul>
</li>
<li>
<p>在父子类中，执行顺序是：</p>
<p>爷爷类的静态初始化(静态属性初始化) &gt;  父类静态初始化块(静态属性初始化）&gt; 子类静态初始化块（静态属性初始化）&gt; 爷爷类普通初始化块(普通属性初始化)&gt;爷爷类构造器&gt;<br />
父类普通初始化块(普通属性初始化)&gt;父类构造器&gt;<br />
子类普通初始化块(普通属性初始化)&gt;子类构造器</p>
</li>
</ul>
<h2 id="this"><a class="markdownIt-Anchor" href="#this"></a> this</h2>
<ul>
<li>this可以顾名思义，this这个关键字代表当前对象，就相当于当前对象的名字，实际使用于类定义的内部。示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Hero &#123;
     
    String name; &#x2F;&#x2F;姓名
     
    float hp; &#x2F;&#x2F;血量
     
    float armor; &#x2F;&#x2F;护甲
     
    int moveSpeed; &#x2F;&#x2F;移动速度
 
    &#x2F;&#x2F;打印内存中的虚拟地址
    public void showAddressInMemory()&#123;
        System.out.println(&quot;打印this看到的虚拟地址：&quot;+this); &#x2F;&#x2F;this在类内部使用，因为此时类没有名字，如果要用其中的属性很不方便，所以设置this来表示当前：“对象”，相当于类的一个虚拟名字。
    &#125;
     
    public static void main(String[] args) &#123;
        Hero garen &#x3D;  new Hero();
        garen.name &#x3D; &quot;盖伦&quot;;
        &#x2F;&#x2F;直接打印对象，会显示该对象在内存中的虚拟地址
        &#x2F;&#x2F;格式：Hero@c17164 c17164即虚拟地址，每次执行，得到的地址不一定一样
 
        System.out.println(&quot;打印对象看到的虚拟地址：&quot;+garen);
        &#x2F;&#x2F;调用showAddressInMemory，打印该对象的this，显示相同的虚拟地址-&gt;表示this起始和对象名garen指向的是同一个东西
        garen.showAddressInMemory();
    &#125;
&#125;</code></pre>
<ul>
<li>使用this给对象的属性赋值。示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Hero &#123;
     
    String name; &#x2F;&#x2F;姓名
     
    &#x2F;&#x2F;参数名和属性名一样
    &#x2F;&#x2F;在方法体中，只能访问到参数name
    public void setName1(String name)&#123;
        name &#x3D; name;
    &#125;
     
    &#x2F;&#x2F;为了避免setName1中的问题，参数名不得不使用其他变量名
    public void setName2(String heroName)&#123;
        name &#x3D; heroName;
    &#125;
     
    &#x2F;&#x2F;通过this访问属性
    public void setName3(String name)&#123;
        &#x2F;&#x2F;name代表的是参数name
        &#x2F;&#x2F;this.name代表的是属性name
        this.name &#x3D; name;
    &#125;
     
    public static void main(String[] args) &#123;
        Hero  h &#x3D;new Hero();
         
        h.setName1(&quot;teemo&quot;);
        System.out.println(h.name); &#x2F;&#x2F;结果为null，即参数的值传不到对象里的属性上
         
        h.setName2(&quot;garen&quot;);
        System.out.println(h.name); &#x2F;&#x2F;结果为garen，成功，即使用this可以访问到当前对象的属性   
         
        h.setName3(&quot;死歌&quot;);
        System.out.println(h.name); &#x2F;&#x2F;结果为死歌，成功，即使用非属性名的形参，还可以将值传给属性。    
    &#125;
     
&#125;</code></pre>
<ul>
<li>this还可以用来在<strong>一个构造器内部调用该类中的另一个构造器</strong>。调用的形式为<code>this(要调用的构造器的参数)</code>。在一个构造器中调用另一个构造器的的语句只能放在该构造器的第一条语句。</li>
</ul>
<h2 id="隐式参数与显式参数"><a class="markdownIt-Anchor" href="#隐式参数与显式参数"></a> 隐式参数与显式参数</h2>
<ul>
<li>隐式参数是出现在方法之前的实例字段，在方法中被直接调用。而显式参数就是普通的位于方法名后面括号中的参数。</li>
<li>隐式参数常用this来指示，以便和局部变量区分开来。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
public class Employee &#123;
    double salary;

    public void raiseSalary (double byPercent) &#123;
        double raise &#x3D; salary * byPercent &#x2F; 100;
        salary +&#x3D; raise;
    &#125;
&#125;</code></pre>
<ul>
<li>在这个例子中，salary为隐式参数，而byPercent为显式参数。</li>
<li>可以用this指示隐式参数：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
public class Employee &#123;
    double salary;

    public void raiseSalary (double byPercent) &#123;
        double raise &#x3D; this.salary * byPercent &#x2F; 100;
        this.salary +&#x3D; raise;
    &#125;
&#125;</code></pre>
<h2 id="参数的传递"><a class="markdownIt-Anchor" href="#参数的传递"></a> 参数的传递</h2>
<ul>
<li>参数与变量一样，分为基本类型和类类型。基本类型参数与c语言基本一样，而类类型的参数有一点类似c语言中的指针参数。</li>
<li>类类型参数可以修改实际的类类型的变量指向的对象，实际类类型变量是对应对象的引用，是对象的一个地址。示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Hero &#123;
        
    String name; &#x2F;&#x2F;姓名
        
    float hp; &#x2F;&#x2F;血量
        
    float armor; &#x2F;&#x2F;护甲
        
    int moveSpeed; &#x2F;&#x2F;移动速度
     
    public Hero()&#123;
         
    &#125;
     
    public Hero(String name,float hp)&#123;
        this.name &#x3D; name;
        this.hp &#x3D; hp;
    &#125;
 
    &#x2F;&#x2F;复活
    public void revive(Hero h)&#123; &#x2F;&#x2F;传入的参数是Hero类型的引用
        h &#x3D; new Hero(&quot;提莫&quot;,383);
    &#125;
 
    public static void main(String[] args) &#123;
        Hero teemo &#x3D;  new Hero(&quot;提莫&quot;,383);
         
        &#x2F;&#x2F;受到400伤害，挂了
        teemo.hp &#x3D; teemo.hp - 400;
         
        teemo.revive(teemo); &#x2F;&#x2F; teemo中hp的值变为了383，即通过类类型传递的是可以在函数内部修改的。
         
    
         
    &#125;
      
&#125;</code></pre>
<ul>
<li>在给参数命名时，可以在名字面前加上前缀a以与实例字段区别。如<code>name = aName</code>.</li>
</ul>
<h2 id="包"><a class="markdownIt-Anchor" href="#包"></a> 包</h2>
<ul>
<li>包：类和接口的集合，即为类库。</li>
<li>把具有某种关系的类放在一个包里。包必须在<strong>类最开始的地方声明</strong>。若是缺省该语句，则默认将类指定为无名包下。</li>
<li>借助包名可以确保类名的唯一性。包名常使用因特网域名的逆序形式，一般都是用小写字母。如域名为<code>horstman.com</code>则将包名设为<code>com.horstman</code>.包名之后还可以追加一个工程名之后再写上类名。如<code>com.horstman.corejava.Employee</code>，这个也被称为该类的<strong>完全限定名</strong>.其中corejava为工程名，Employee为类名。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package charactor; &#x2F;&#x2F;在最开始的地方声明该类所处于的包名
public class Hero &#123;
        
    String name; &#x2F;&#x2F;姓名
        
    float hp; &#x2F;&#x2F;血量
        
    float armor; &#x2F;&#x2F;护甲
        
    int moveSpeed; &#x2F;&#x2F;移动速度
     
&#125;</code></pre>
<ul>
<li>包与类的关系示例：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/java.jpg" alt="java" /></li>
</ul>
<h3 id="类的导入"><a class="markdownIt-Anchor" href="#类的导入"></a> 类的导入</h3>
<ul>
<li><strong>一个类可以使用所属包中的所有类</strong>，以及其他包里的公共类。但是<strong>其他包里的公共类必须使用<code>import</code>来导入</strong>。（也可以在使用其他包里的公共类时使用其<strong>完全限定名</strong>）</li>
<li>使用<code>import 包名.*</code>引入语句，只表示了源程序所需要的类会在包中找到并引入，但是对包中其它的类或它下面的包中的类并不引入。（但是只能使用<code>*</code>导入一个包，不能导入一个包里嵌套的所有包。）</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package charactor;
 
&#x2F;&#x2F;Weapon类在其他包里，使用必须进行import
import property.Weapon;&#x2F;&#x2F;格式为 import 类的完全限定名;
 
public class Hero &#123;
        
    String name; &#x2F;&#x2F;姓名
        
    float hp; &#x2F;&#x2F;血量
        
    float armor; &#x2F;&#x2F;护甲
        
    int moveSpeed; &#x2F;&#x2F;移动速度
     
    &#x2F;&#x2F;装备一把武器
    public void equip(Weapon w)&#123;
         
    &#125;
        
&#125;</code></pre>
<h3 id="静态导入"><a class="markdownIt-Anchor" href="#静态导入"></a> 静态导入</h3>
<ul>
<li>在import关键字之后加上static修饰符可以导入某个类中的静态方法和静态字段。如：<code>import static java.lang.System.*</code>可以导入System类中的所有静态方法和静态字段。如果这样导入，<code>System.out.print()</code>就可以用<code>out.print()</code>代替（可以省略类名）。当然，也可以导入特定的方法和字段。如<code>import static java.lang.System.out</code>.</li>
</ul>
<h3 id="在包中增加类"><a class="markdownIt-Anchor" href="#在包中增加类"></a> 在包中增加类</h3>
<ul>
<li>要将类放入包中需要将包的名字放在该类源文件的开头。如<code>package com.horstman.corejava</code>.如果在源文件开头没有防止package语句，则这个类就默认属于<strong>无名包</strong>（没有名字，但是实际存在的的包）。还要注意<strong>类的源文件必须放到与完整包名匹配的目录中</strong>。</li>
<li>编译和运行类必须切换到基目录。</li>
</ul>
<h3 id="类路径"><a class="markdownIt-Anchor" href="#类路径"></a> 类路径</h3>
<ul>
<li>类的路径必须与包名相匹配。</li>
<li>通过设置<code>classpath</code>来设置类路径，以使多个程序共享类。</li>
</ul>
<h3 id="jar文件"><a class="markdownIt-Anchor" href="#jar文件"></a> JAR文件</h3>
<ul>
<li><strong>JAR文件</strong>:java的压缩包文件（使用zip格式）。在一个JAR文件中可以包含多个压缩形式的类文件和子目录，也可以包含诸如图像、声音等类型的文件。在程序中使用第三方的库文件时，需要得到相应的JAR文件。</li>
<li><strong>创建JAR文件</strong>：使用<code>jar</code>工具来制作JAR文件。类似Unix系统中的<code>tar</code>指令。[jar程序选项](<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenjfblog/p/10164967.html">https://www.cnblogs.com/chenjfblog/p/10164967.html</a></li>
<li><strong>清单文件</strong>：每个JAR文件都包含一个清单文件（manifest），用于描述JAR文件的某些特性。<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_33801856/article/details/86247641">清单文件具体使用</a>.</li>
<li><strong>可执行JAR文件</strong>：需要为JAR包装的程序指定入口点，即在需要调用java程序启动器时指定的类。可以使用<code>jar</code>命令的e选项，来指定入口点。</li>
</ul>
<h2 id="成员变量的修饰符"><a class="markdownIt-Anchor" href="#成员变量的修饰符"></a> 成员变量的修饰符</h2>
<h3 id="类之间的关系"><a class="markdownIt-Anchor" href="#类之间的关系"></a> 类之间的关系</h3>
<ul>
<li><strong>依赖</strong>：&quot;use-a&quot;关系，即一个类的方法使用或者操纵另一个类的对象，就是一个类依赖于另一个类。</li>
<li><strong>聚合</strong>：&quot;has-a&quot;关系，即一个类中的对象包含另一个类的一些对象。</li>
<li><strong>继承</strong>：&quot;is-a&quot;关系，表示一个更特殊的类与更一般的类之间的关系。，这个更特殊的类中不但包含了原来的类中的所有对象和方法，还增加一些额外的功能。</li>
<li><strong>UML</strong>:unified Modeling Language:统一建模语言，可以用来绘制类图。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200922073144.jpg" alt="" /></li>
</ul>
<h3 id="private"><a class="markdownIt-Anchor" href="#private"></a> private</h3>
<ul>
<li>使用private修饰的变量，只有<strong>这种类的对象</strong>才可以访问，子类不可以继承，其它的类就更不能访问了。</li>
</ul>
<h3 id="缺省"><a class="markdownIt-Anchor" href="#缺省"></a> 缺省</h3>
<ul>
<li>没有修饰符的成员变量，自身的对象可以访问，同包的类可以访问，同包子类可以继承，不同包子类也可以继承，但是不同包的类不可以访问。</li>
</ul>
<h3 id="proteced"><a class="markdownIt-Anchor" href="#proteced"></a> proteced</h3>
<ul>
<li>使用protected修饰的成员字段或者方法，<strong>同包类可以访问和继承</strong>，不同包的类不可以访问和继承。</li>
</ul>
<h3 id="public"><a class="markdownIt-Anchor" href="#public"></a> public</h3>
<ul>
<li>任何地方，都可以访问和继承。</li>
<li>在一个源文件中（.java）中只能有<strong>一个public类</strong>（这个类就是文件名），但可以有任意数目的非公共类。</li>
<li>由一个源文件编译而成的类文件（.class），将包含main方法的类名提供给解释器以启动这个程序。</li>
</ul>
<h2 id="类属性static"><a class="markdownIt-Anchor" href="#类属性static"></a> 类属性（static）</h2>
<ul>
<li>当类中的属性被static修饰时，这个属性就叫做<strong>类属性</strong>，又叫做<strong>静态属性</strong>或<strong>静态字段</strong>。如果某个属性被声明为类属性，那么该类所有的对象都共享这个值,不管有没有实例化得到的对象，这个属性都存在，不管有多少个对象（甚至从未创建过该类的对象），都共用一个静态字段，静态字段只属于类，不属于任何单个的对象。静态属性中常用的是<strong>静态常量</strong>。类属性事实上提供了<strong>全局变量和全局方法</strong>。</li>
<li>与类属性相对的（类中没有static修饰的属性）叫做<strong>对象属性</strong>，又叫做<strong>非静态属性</strong>，<strong>实例属性</strong>。示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package charactor;
 
public class Hero &#123;
    public String name; &#x2F;&#x2F;实例属性，对象属性，非静态属性
    protected float hp;
    static String copyright;&#x2F;&#x2F;类属性,静态属性
     
    public static void main(String[] args) &#123;
           Hero garen &#x3D;  new Hero();
           garen.name &#x3D; &quot;盖伦&quot;;
            
           Hero.copyright &#x3D; &quot;版权由Riot Games公司所有&quot;; &#x2F;&#x2F;对类属性的赋值
            
           System.out.println(garen.name);
           System.out.println(garen.copyright);
            
           Hero teemo &#x3D;  new Hero();
           teemo.name &#x3D; &quot;提莫&quot;;
           System.out.println(teemo.name);    
           System.out.println(teemo.copyright);
         
    &#125;
     
&#125;</code></pre>
<ul>
<li>对类属性的访问通过<strong>直接使用类名</strong>来完成<code>Hero.copyright =</code>.也可以通过实际的对象来调用，不过一般还是使用类来直接调用，这样更符合类对象的概念。</li>
</ul>
<h2 id="类方法静态方法"><a class="markdownIt-Anchor" href="#类方法静态方法"></a> 类方法（静态方法）</h2>
<ul>
<li><strong>类方法</strong>，又叫静态方法。同类对象相似，类方法也是通过在方法名前面加上<code>static</code>关键字来实现的。
<ul>
<li>static方法仅能调用其他的static方法；</li>
<li>static方法只能访问static数据；</li>
<li>static方法不能以任何方式引用this或者super。</li>
</ul>
</li>
<li>静态方法不使用对象中的实例字段（也可以理解为静态方法中没有this参数，它所需要的所有参数都通过显示参数提供），计算结果与实际对象无关。</li>
<li>与类方法相对的是<strong>对象方法</strong>，对象方法又叫实例方法，非静态方法。示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package charactor;
 
public class Hero &#123;
    public String name;
    protected float hp;
 
    &#x2F;&#x2F;实例方法,对象方法，非静态方法
    &#x2F;&#x2F;必须有对象才能够调用
    public void die()&#123;
        hp &#x3D; 0;
    &#125;
     
    &#x2F;&#x2F;类方法，静态方法
    &#x2F;&#x2F;通过类就可以直接调用
    public static void battleWin()&#123;
        System.out.println(&quot;battle win&quot;);
    &#125;
     
    public static void main(String[] args) &#123;
           Hero garen &#x3D;  new Hero();
           garen.name &#x3D; &quot;盖伦&quot;;
           &#x2F;&#x2F;必须有一个对象才能调用
           garen.die();
            
           Hero teemo &#x3D;  new Hero();
           teemo.name &#x3D; &quot;提莫&quot;;
            
           &#x2F;&#x2F;无需对象，直接通过类调用
           Hero.battleWin();
         
    &#125;
&#125;</code></pre>
<ul>
<li><strong>对象方法必须用实际创建的对象才能调用</strong>，而类方法可以使用类来直接调用，也可以使用对象来调用。（同类对象的情况一致）。</li>
<li>当某个方法没有涉及到具体对象的属性时，设计为类方法，而当涉及具体对象的属性时，则一般设计为对象方法。示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public String getName()&#123;
	return name;
&#125;

public static void printGameDuration()&#123;
    System.out.println(&quot;已经玩了10分50秒&quot;);
&#125;</code></pre>
<h3 id="工厂方法"><a class="markdownIt-Anchor" href="#工厂方法"></a> 工厂方法</h3>
<ul>
<li>静态方法的另一个用途就是静态工厂方法，工厂方法实际上是构造器方法的延伸。使用工厂方法可以生成不同风格的对象。</li>
</ul>
<h3 id="main方法"><a class="markdownIt-Anchor" href="#main方法"></a> main方法</h3>
<ul>
<li>main方法启动时还没有任何对象，所以main方法不对任何对象进行操作，main方法<strong>必须声明为static</strong>方法。</li>
<li>每个类都可以有一个main方法，用于对每个类进行单元测试。</li>
<li>包含main方法的类<strong>声明为public类</strong>。</li>
<li>main方法是<strong>程序运行的入口</strong>。</li>
</ul>
<h2 id="属性初始化"><a class="markdownIt-Anchor" href="#属性初始化"></a> 属性初始化</h2>
<ul>
<li>对象属性初始化。
<ol>
<li>在声明时初始化；</li>
<li>在块中初始化，初始化块的前面还是可以加上修饰符的；</li>
<li>在构造方法中初始化。</li>
<li><strong>初始化的顺序</strong>：如果三种初始化方式同时出现，则不管构造方法中初始化的相对位置在哪里，它的初始化都是最后执行的。</li>
<li>示例：</li>
</ol>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Hero &#123;
    public String name &#x3D; &quot;some hero&quot;; &#x2F;&#x2F;声明该属性的时候初始化
    protected float hp;
    float maxHP;
     
    &#123;
        maxHP &#x3D; 200; &#x2F;&#x2F;初始化块,单独用花括号给出一个用来初始化属性的块。
    &#125;  
     
    public Hero()&#123;
        hp &#x3D; 100; &#x2F;&#x2F;构造方法中初始化
         
    &#125;
     
&#125;</code></pre>
<ul>
<li>类属性初始化
<ol>
<li>声明时初始化</li>
<li>静态初始化块:在普通花括号形成的块前面加上关键字<code>static</code>形成静态初始化块。</li>
<li>示例：</li>
</ol>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Hero &#123;
    public String name;
    protected float hp;
    float maxHP;
     
    &#x2F;&#x2F;物品栏的容量
    public static int itemCapacity &#x3D; 8; &#x2F;&#x2F;声明的时候 初始化
     
    static&#123;
        itemCapacity &#x3D; 6;&#x2F;&#x2F;静态初始化块 初始化
    &#125;
     
    public Hero()&#123;
         
    &#125;
     
    public static void main(String[] args) &#123;
        System.out.println(Hero.itemCapacity);
    &#125;
     
&#125;</code></pre>
<h2 id="单例模式"><a class="markdownIt-Anchor" href="#单例模式"></a> 单例模式</h2>
<ul>
<li><strong>单例模式</strong>又叫<strong>Singleton</strong>模式，表示的是一个类，在一个JVM（Java虚拟机）中只有一个实例存在。</li>
</ul>
<h3 id="饿汉式单例模式"><a class="markdownIt-Anchor" href="#饿汉式单例模式"></a> 饿汉式单例模式</h3>
<ul>
<li>饿汉式单例模式通过使用private使构造方法无法在外部通过new来创建对象，并创建一个新的方法指定在类中定义的对象，每次使用该方法都只能产生一个唯一的对象从而实现单例模式。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class GiantDragon &#123;
 
    &#x2F;&#x2F;私有化构造方法使得该类无法在外部通过new 进行实例化
    private GiantDragon()&#123;
         
    &#125;
 
    &#x2F;&#x2F;准备一个类属性，指向一个实例化对象。 因为是类属性，所以只有一个
 
    private static GiantDragon instance &#x3D; new GiantDragon();
     
    &#x2F;&#x2F;public static 方法，提供给调用者获取前面定义的instance对象
    public static GiantDragon getInstance()&#123;
        return instance;
    &#125;
     
&#125;</code></pre>
<h3 id="懒汉式单例模式"><a class="markdownIt-Anchor" href="#懒汉式单例模式"></a> 懒汉式单例模式</h3>
<ul>
<li>懒汉式与饿汉式的区别在于懒汉式只有在调用创建对象的方法时才第一次创建对象。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class GiantDragon &#123;
  
    &#x2F;&#x2F;私有化构造方法使得该类无法在外部通过new 进行实例化
    private GiantDragon()&#123;       
    &#125;
  
    &#x2F;&#x2F;准备一个类属性，用于指向一个实例化对象，但是暂时指向null
    private static GiantDragon instance;
      
    &#x2F;&#x2F;public static 方法，返回实例对象
    public static GiantDragon getInstance()&#123;
        &#x2F;&#x2F;第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象
        if(null&#x3D;&#x3D;instance)&#123;
            instance &#x3D; new GiantDragon();
        &#125;
        &#x2F;&#x2F;返回 instance指向的对象
        return instance;
    &#125;
      
&#125;</code></pre>
<h2 id="枚举类型"><a class="markdownIt-Anchor" href="#枚举类型"></a> 枚举类型</h2>
<ul>
<li>枚举类型包括有限个命名的值。例如：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
enum Size&#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;;&#x2F;&#x2F;定义枚举类型Size。
Size s &#x3D; Size.MEDIUM;&#x2F;&#x2F;声明枚举类型的变量s并进行初始化。</code></pre>
<ul>
<li>枚举类型的变量中只能存储这个类型的声明中给定的<strong>某个枚举值</strong>，或者null（表示这个变量没有设置任何值）。</li>
</ul>
<h1 id="接口与继承"><a class="markdownIt-Anchor" href="#接口与继承"></a> 接口与继承</h1>
<h2 id="接口interface"><a class="markdownIt-Anchor" href="#接口interface"></a> 接口（Interface）</h2>
<ul>
<li>接口不是类，而是对希望符合这个接口的类的一组需求（应该做什么）。接口是抽象的，它的所有成员方法都是抽象方法（abstract）（语句体都是空的。</li>
<li>接口的所有成员变量都默认是<code>public static final</code>类型，创建成员变量时可以省略这些修饰符。即接口中的所有成员变量都可以直接用接口名来访问。</li>
<li>但是在接口中声明的成员方法都默认是<code>public abstract</code>方法，也可以省略这两个修饰符。</li>
<li>接口可以作为一个引用类型来使用：
<ul>
<li>任何实现了该接口的类的实例都可以存储在该接口类型的变量中；</li>
<li>通过接口类型的变量可以访问类中所实现的该接口的方法。</li>
</ul>
</li>
<li>接口不能包含<strong>实例字段</strong>，但可以包含<strong>常量</strong>。</li>
<li>接口的创建：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package charactor;
 
public interface AD &#123; &#x2F;&#x2F;接口的创建使用关键字interface。
        &#x2F;&#x2F;物理伤害
    public void physicAttack(); &#x2F;&#x2F;接口的成员函数都是抽象函数，只有其形，而实际里面什么也没有。
&#125;</code></pre>
<ul>
<li>接口的使用：（接口在类中具体实现时的public不能省略）</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package charactor;
 
public class ADHero extends Hero implements AD&#123; &#x2F;&#x2F;ADHero是从Hero继承而来的的子类，并且使用关键字implements加入了AD接口

    @Override
    public void physicAttack() &#123; &#x2F;&#x2F;接口在实际使用的时候再定义具体操作的实现。这是方法的重写，需要有Override注解
        System.out.println(&quot;进行物理攻击&quot;);
    &#125;
 
&#125;</code></pre>
<ul>
<li>接口使用关键字<code>implements</code>来加入，并且可以<strong>同时加入多个接口</strong>，如<code>...implements AD,AP</code>.</li>
</ul>
<h3 id="接口的属性"><a class="markdownIt-Anchor" href="#接口的属性"></a> 接口的属性</h3>
<ul>
<li>接口<strong>不是类</strong>，不能使用new来实例化一个接口。</li>
<li>可以声明<strong>接口类型的变量</strong>，这个接口类型的变量必须引用实现了这个的类对象。</li>
<li>可以使用<code>instanceof</code>来判断一个对象是否实现了某个特定的接口。如：<code>if(anObject instanceof Comparable) &#123;...&#125;</code>。</li>
<li>接口与类一样，也可以进行扩展，形成<strong>接口链</strong>，从通用性较高的接口扩展到专用性较高的接口。对接口进行扩展同样使用<code>extends</code>关键字，基本扩展规则与类的扩展相似。<strong>接口可以实现多重继承，即一个接口同时继承其它多个接口</strong>。</li>
</ul>
<h3 id="接口与抽象类"><a class="markdownIt-Anchor" href="#接口与抽象类"></a> 接口与抽象类</h3>
<ul>
<li>接口与抽象类的最大区别是：每个类<strong>只能扩展一个类</strong>。但是每个类却可以实现多个接口。</li>
</ul>
<h3 id="默认方法"><a class="markdownIt-Anchor" href="#默认方法"></a> 默认方法</h3>
<ul>
<li>接口中允许对一些方法进行实现，以使用这个接口的类不用在类中在对该方法进行实现，这种接口中实现了的方法称为<strong>默认方法</strong>。</li>
<li>默认方法必须再前面加上<code>default</code>关键字。</li>
</ul>
<h3 id="标记接口"><a class="markdownIt-Anchor" href="#标记接口"></a> 标记接口</h3>
<ul>
<li>普通接口的作用是确保一个类实现一些方法。而标记接口中不包含任何方法，它唯一的作用就是允许在类型查询中使用<code>instanceof</code>。如：Cloneable就是一个标记接口。</li>
</ul>
<h3 id="lambda表达式"><a class="markdownIt-Anchor" href="#lambda表达式"></a> lambda表达式</h3>
<ul>
<li>lambda表达式是用来实现对一些代码块的复用，避免每次使用一些方法就得构造一个对象。（类似于模拟c语言中普通的函数）。</li>
<li>Lambda 表达式可以对某些接口进行简单的实现，但并不是所有的接口都可以使用 Lambda 表达式来实现。<strong>Lambda 规定接口中只能有一个需要被实现的方法</strong>，不是规定接口中只能有一个方法。jdk8中有另一个新特性：default， 被 default 修饰的方法会有默认实现，不是必须被实现的方法，所以不影响 Lambda 表达式的使用。</li>
<li>lambda表达式的形式：(parameters) -&gt; expression或(parameters) -&gt;{ statements; }。
<ul>
<li><code>()</code>:接口中抽象方法的参数列表，没有参数就空着；</li>
<li><code>-&gt;</code>:传递的意思，把参数传递给方法体。</li>
<li><code>&#123;&#125;</code>:重写接口的抽象方法的方法体。</li>
</ul>
</li>
<li>lambda表达式的重点是使代码延迟执行。这种延迟执行可以用于：
<ol>
<li>在一个单独的线程中运行代码；</li>
<li>多次运行代码；</li>
<li>在算法的适当位置执行代码等。</li>
</ol>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
&#x2F;&#x2F;多个参数
(String first, String second) -&gt; &#123;
    if (first.length() &lt; second.length())
        return -1;
    else if (first.length() &gt; second.length())
        return 1;
    else 
        return 0;
&#125;

&#x2F;&#x2F;没有参数
() -&gt; ｛for（intI&#x3D; 100; i &gt;&#x3D; 0; ; i--) System.out.println(); ｝

&#x2F;&#x2F;一个参数
event -&gt; &#123;
    System.out.println(event);
&#125;

&#x2F;&#x2F;只有一个表达式
(String first, String second) -&gt; first.length - second.length();</code></pre>
<h4 id="函数式接口"><a class="markdownIt-Anchor" href="#函数式接口"></a> 函数式接口</h4>
<ul>
<li>对于<strong>只有一个抽象方法的接口</strong>，需要这种接口的对象时，就可以提供一个lambda表达式，这种接口称为<strong>函数式接口</strong>。</li>
<li>可以将lambda表达式转换为函数式接口。</li>
</ul>
<h4 id="lambda的方法引用"><a class="markdownIt-Anchor" href="#lambda的方法引用"></a> lambda的方法引用</h4>
<ul>
<li>当lambda表达式只调用一个方法而不做其他操作时，可以把lambda表达式重写为<strong>方法引用</strong>。</li>
<li>方法引用有三种情况：
<ol>
<li><code>对象 :: 普通方法</code> ：等价于向方法传递参数的lambda表达式，如<code>System.out::println</code>等价于<code>x -&gt; System.out.println(x)</code>.</li>
<li><code>类 :: 普通方法</code> ：在这种情况下第一个参数会称为方法的隐式参数，如： <code>String::compareToTgnoreCase</code>等价于<code>(x, y) -&gt; x.compareToIgnoreCase(y)</code>.</li>
<li><code>类 :: 静态方法</code> ：所有参数都传递到静态方法，如<code>Math::pow</code>等价于<code>(x, y) -&gt; Math.pow(x, y)</code>。</li>
</ol>
</li>
<li>还可以在方法引用中使用<code>this</code>和<code>super</code>.如：<code>this::equals</code>等价于<code>x -&gt; this.equals(x)</code>.</li>
</ul>
<h4 id="构造器引用"><a class="markdownIt-Anchor" href="#构造器引用"></a> 构造器引用</h4>
<ul>
<li>构造器引用与方法引用类似，只不过将方法名统一为new。如<code>int[]::new</code>等价于<code>x -&gt; new int[x]</code>.</li>
</ul>
<h3 id="服务加载器"><a class="markdownIt-Anchor" href="#服务加载器"></a> 服务加载器</h3>
<p>。。。</p>
<h3 id="代理"><a class="markdownIt-Anchor" href="#代理"></a> 代理</h3>
<p>。。。</p>
<h2 id="对象转型"><a class="markdownIt-Anchor" href="#对象转型"></a> 对象转型</h2>
<h3 id="引用类型和对象类型"><a class="markdownIt-Anchor" href="#引用类型和对象类型"></a> 引用类型和对象类型</h3>
<ul>
<li>在<code>Hero a = new Hero()</code>中，a是引用，a的类型即是引用类型（此例中为a前面的Hero类类型），而<code>new Hero()</code>创建的就是对象，对象类型就是Hero类类型。</li>
</ul>
<h3 id="子类转父类向上转型"><a class="markdownIt-Anchor" href="#子类转父类向上转型"></a> 子类转父类（向上转型）</h3>
<ul>
<li>类型转换发生在引用类型和对象类型不一致的时候。（类似基本类型中<code>=</code>两边的类型不一致时。）类型转换不一定会成功。（就像基本类型转换也会有失败的时候，就像int不能转换为double）。子类是可以转换为父类的（就像基本类型中，长的可以转换为短的，如double可以转换为int）。</li>
</ul>
<h3 id="父类转子类向下转型"><a class="markdownIt-Anchor" href="#父类转子类向下转型"></a> 父类转子类（向下转型）</h3>
<ul>
<li>父类转子类需要进行强制类型转换，如<code>a = (ADHero)h</code>.</li>
</ul>
<h3 id="没有继承关系的类"><a class="markdownIt-Anchor" href="#没有继承关系的类"></a> 没有继承关系的类</h3>
<ul>
<li>没有继承关系的类之间转换一定会失败，即使用强制类型转换也会出现异常报错。</li>
</ul>
<h3 id="实现类转换为接口向上转型"><a class="markdownIt-Anchor" href="#实现类转换为接口向上转型"></a> 实现类转换为接口(向上转型)</h3>
<h3 id="接口转换为实现类向下转型"><a class="markdownIt-Anchor" href="#接口转换为实现类向下转型"></a> 接口转换为实现类（向下转型）</h3>
<h2 id="instanceof语句"><a class="markdownIt-Anchor" href="#instanceof语句"></a> instanceof语句</h2>
<ul>
<li>instanceof语句用来判断一个引用所指向的对象是否是某种类的实例化或者其子类的实例化。使用示例：<code>h instanceof Hero</code>判断引用h指向的对象是否是Hero类或者Hero子类的，如果是则结果为true，否则为false。</li>
</ul>
<h2 id="重写"><a class="markdownIt-Anchor" href="#重写"></a> 重写</h2>
<ul>
<li>子类可以继承父类的对象方法，如果子类对从父类继承过来的对象方法进行了修改（即在子类中对相同名字的对象方法在写一遍，故称为重写），这就叫做方法的重写。示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package property;
 
&#x2F;&#x2F;父类
public class Item &#123;
    String name;
    
    public void effect() &#123;
        System.out.println(&quot;物品使用后，可以有效果&quot;);
    &#125;
 
&#125;

&#x2F;&#x2F;从Item中继承的子类
public class LifePotion extends Item&#123;
     
     &#x2F;&#x2F;对Item中的effect方法进行了重写
    public void effect()&#123;
        System.out.println(&quot;血瓶使用后，可以回血&quot;);
    &#125;
     
&#125;</code></pre>
<h2 id="多态"><a class="markdownIt-Anchor" href="#多态"></a> 多态</h2>
<h3 id="操作符的多态"><a class="markdownIt-Anchor" href="#操作符的多态"></a> 操作符的多态</h3>
<ul>
<li>操作符的多态是指同一个操作符在不同的情景下的作用不同。如<code>+</code>，在算术运算中是加法的作用，而在字符串中是连接字符串的作用。</li>
</ul>
<h3 id="类的多态"><a class="markdownIt-Anchor" href="#类的多态"></a> 类的多态</h3>
<ul>
<li>同一个类的同一个方法，输出不同的结果是类的一种多态现象。示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package property;
 
public class Item &#123;
    String name;
    int price;
 
    public void buy()&#123;
        System.out.println(&quot;购买&quot;);
    &#125;
    public void effect() &#123;
        System.out.println(&quot;物品使用后，可以有效果 &quot;);
    &#125;
     
    public static void main(String[] args) &#123;
        Item i1&#x3D; new LifePotion(); &#x2F;&#x2F;LifePotion和MagicPotion是类Item的两个子类。而且这两个子类中都有方法的重写。
        Item i2 &#x3D; new MagicPotion(); &#x2F;&#x2F;引用是父类类型的。
        System.out.print(&quot;i1  是Item类型，执行effect打印:&quot;); &#x2F;&#x2F;由于两个子类的重写方法不同，导致调用同一个方法会有不同的输出
        i1.effect();
        System.out.print(&quot;i2也是Item类型，执行effect打印:&quot;);
        i2.effect();
    &#125;
 
&#125;</code></pre>
<ul>
<li>实现类的多态的条件:
<ol>
<li>父类（接口）指向子类的对象；</li>
<li>调用的方法被重写。</li>
</ol>
</li>
</ul>
<h3 id="对象变量的多态"><a class="markdownIt-Anchor" href="#对象变量的多态"></a> 对象变量的多态</h3>
<ul>
<li>一个对象变量可以指示多种实际类型的现象称为多态。</li>
<li>这种情况常出现在父类和子类的对象中。如,父类为Father，子类为Kid。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
var people &#x3D; new Father[2];

Kid person1 &#x3D; new Kid();
Father person2 &#x3D; new Father();

for(Father e : people) &#123;
    e.age++;
&#125;</code></pre>
<ul>
<li>在这个例子中，对象变量e既有可能指向Father类型，也有可能指向Kid类型。</li>
</ul>
<h2 id="隐藏"><a class="markdownIt-Anchor" href="#隐藏"></a> 隐藏</h2>
<ul>
<li>与重写类似。重写是子类对父类的<strong>对象方法</strong>的覆盖，而隐藏是对父类的<strong>类方法的覆盖</strong>。示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package charactor;
  
public class Hero &#123;
    public String name;
    protected float hp;
  
    &#x2F;&#x2F;类方法，静态方法
    &#x2F;&#x2F;通过类就可以直接调用
    public static void battleWin()&#123;
        System.out.println(&quot;hero battle win&quot;);
    &#125;
      
&#125;

public class ADHero extends Hero &#123;
  
    &#x2F;&#x2F;隐藏父类的battleWin方法
    public static void battleWin()&#123;
        System.out.println(&quot;ad hero battle win&quot;);
    &#125;   
     
    public static void main(String[] args) &#123;
        Hero.battleWin(); &#x2F;&#x2F;输出的是hero battle win
        ADHero.battleWin(); &#x2F;&#x2F;输出的是ad hero battle win
    &#125;
  
&#125;</code></pre>
<h2 id="super关键字"><a class="markdownIt-Anchor" href="#super关键字"></a> super关键字</h2>
<ul>
<li>super是在子类中调用父类被隐藏的属性，方法的关键字。
<ol>
<li>显式调用父类构造方法；如<code>super(参数)</code></li>
<li>调用父类的属性：如<code>super.name</code></li>
<li>调用父类的普通方法:如<code>super.useItem()</code>.</li>
</ol>
</li>
<li><code>super()</code><strong>必须是子类构造函数的第一个执行语句</strong>。</li>
</ul>
<h2 id="object类"><a class="markdownIt-Anchor" href="#object类"></a> Object类</h2>
<ul>
<li>Object默认是<strong>所有类的父类</strong>。（全名：java.lang.Object:java.lang这个包是默认导入到每一个类中的）</li>
<li>Object类中提供的方法所有类都默认含有。</li>
<li>Objiect类中有很多方法，如<code>toString(), finalize(),equals()...</code>。</li>
</ul>
<h3 id="object类型的变量"><a class="markdownIt-Anchor" href="#object类型的变量"></a> Object类型的变量</h3>
<ul>
<li>可以使用Object类型的变量引用所有类型的<strong>对象</strong>。如：<code>Object obj = new Employee();</code>。（注意：除了基本类型（int，char，boolean…)不是对象，其他所有类型都是对象。）</li>
<li>所有的数组类型，不管是基本类型的数组还是对象数组都是Object类的扩展。如</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Employee[] staff &#x3D; new Employee[10];
obj &#x3D; staff; &#x2F;&#x2F;ok
obj &#x3D; int[10]; &#x2F;&#x2F;ok</code></pre>
<h3 id="equals方法"><a class="markdownIt-Anchor" href="#equals方法"></a> equals方法</h3>
<ul>
<li>Object中equals的实现：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">   &#x2F;&#x2F;第一种
public boolean equals(Object obj) &#123;
  return (this &#x3D;&#x3D; obj);
  &#x2F;&#x2F;第二种</code></pre>
<ul>
<li>Objects类中equals的实现：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
static boolean equals(Object a, Object b) &#123;
    ...
&#125;</code></pre>
<ul>
<li>equals方法是用来检测一个对象是否等于另一个对象的(Object中的equals方法适用于两个参数都不为null的情况，Objects类中的equals方法两个参数都为null时返回true，一个为null是返回false，两个都不为null时<strong>返回a.equals(b)的结果</strong>，即进行正常比较。不过object类中直接判断两个对象的引用是否相等来判断对象是否想等的方法有时会不够，所以equals方法经常会在子类中被<strong>重写</strong>。如：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Employee&#123;
    ...
    @override &#x2F;&#x2F;用@override标记来表明这是对超类方法的覆盖，以避免出现参数类型不一致等情况（会报错）
    public boolean equals(Object otherObject)&#123;&#x2F;&#x2F;参数类型必须为Object才能覆盖Object类中的equals方法
        &#x2F;&#x2F;快速检查对象是否相同
        if(this&#x3D;&#x3D;otherObject) return true;
        
        &#x2F;&#x2F;如果EcPLID参数为空，则必须返回false
        if(otherObject&#x3D;&#x3D;null) return false;
        
        &#x2F;&#x2F;如果类不匹配，它们就不能相等。
        if(getClass()!&#x3D;otherObject.getClass())
            return false;
        
        &#x2F;&#x2F;现在我们知道另一个对象是非空雇员，将其强制类型转换为对应的类型
        Employee other &#x3D;(Employee)otherObject;
        
        &#x2F;&#x2F;测试字段是否具有相同的值
        return Object.equals(other.name);
        &amp;&amp; salary&#x3D;&#x3D;other.salary
        &amp;&amp; hireDay.equals(other.hireDay);
    &#125;
&#125;</code></pre>
<ul>
<li>equals方法的设计一般要遵循<strong>自反性</strong>，<strong>对称性</strong>，<strong>传递性</strong>，<strong>一致性</strong>，<strong>非空性</strong>。</li>
</ul>
<h3 id="hashcode方法"><a class="markdownIt-Anchor" href="#hashcode方法"></a> hashCode方法</h3>
<ul>
<li>散列码是由对象导出的一个整型值。没有规律，两个不同的对象的散列码基本不会相同。Object类的散列码是由对象的存储地址导出的。</li>
<li>hashCode方法：<code>int hashCode()</code>。返回对象的散列码。</li>
</ul>
<h3 id="tostring方法"><a class="markdownIt-Anchor" href="#tostring方法"></a> toString方法</h3>
<ul>
<li>toString方法会返回表示对象值的一个字符串：类名[字段值]。</li>
<li>Object类中的toString方法会打印对象的类名和散列码。toString 方法经常会在子类中被重写。如：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public String toString() &#123;
    return getClass().getName() + &quot;name&#x3D;&quot; + name +&quot;salary&#x3D;&quot; + salary;
&#125;</code></pre>
<ul>
<li>使用getClass和getName方法确保子类也可以调用该方法。</li>
<li>只要一个对象与一个字符串通过<code>+</code>相连，java编译器就会自动地调用toString方法来或得这个对象的字符串描述并与另一个字符串相连。</li>
</ul>
<h2 id="final修饰词"><a class="markdownIt-Anchor" href="#final修饰词"></a> final修饰词</h2>
<ul>
<li>final在修饰类、方法、基本类型变量、引用是分别有不同的意思。</li>
</ul>
<h3 id="final修饰类"><a class="markdownIt-Anchor" href="#final修饰类"></a> final修饰类</h3>
<ul>
<li>final修饰类时表示该类不能被继承。使用示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package charactor;
 
public final class Hero extends Object &#123;
        
    String name; &#x2F;&#x2F;姓名
        
    float hp; &#x2F;&#x2F;血量
        
&#125;</code></pre>
<h3 id="final修饰方法"><a class="markdownIt-Anchor" href="#final修饰方法"></a> final修饰方法</h3>
<ul>
<li>如果类中的方法被final修饰，则代表该方法不能在子类中被重写。使用示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Hero &#123;
        
    String name; &#x2F;&#x2F;姓名
        
   
     
    public final void useItem()&#123;
        System.out.println(&quot;hero use item&quot;);
    &#125;   
     
  
    public static void main(String[] args) &#123;
        new Hero();
    &#125;
      
&#125;</code></pre>
<h3 id="final修饰基本类型变量"><a class="markdownIt-Anchor" href="#final修饰基本类型变量"></a> final修饰基本类型变量</h3>
<ul>
<li>final修饰基本类型变量表示该类型只有一次赋值机会（即变量在第一次被手动初始化后便是只读的变量，再不可修改了），如：<code>final int hp = 2;</code></li>
</ul>
<h3 id="final修饰引用"><a class="markdownIt-Anchor" href="#final修饰引用"></a> final修饰引用</h3>
<ul>
<li>被final修饰的引用代表该引用只有一次被赋予指向对象的机会（类似基本类型变量只有一次赋值机会）。</li>
</ul>
<h2 id="抽象类"><a class="markdownIt-Anchor" href="#抽象类"></a> 抽象类</h2>
<h3 id="抽象方法"><a class="markdownIt-Anchor" href="#抽象方法"></a> 抽象方法</h3>
<ul>
<li>没有实现体的方法，是抽象方法。抽象方法使用<code>abstract</code>关键字标识。示例：<code>public abstract void attack();</code></li>
</ul>
<h3 id="抽象类-2"><a class="markdownIt-Anchor" href="#抽象类-2"></a> 抽象类</h3>
<ul>
<li><strong>包含抽象方法的类必须声明为抽象类</strong>，使用关键字<code>abstract</code>。</li>
<li>没有包含抽象方法的类也可以声明为抽象类。</li>
<li>抽象类不可以被直接实例化。即不可以使用<code>new</code>来创建抽象类的对象。但是<strong>抽象类类型的引用变量</strong>却是可以声明的。如果Person是一个抽象类，<code>new Person()</code>是错误的，但是<code>Person p;</code>却是可行的。</li>
<li><strong>构造方法，类方法（static修饰的方法），私有方法</strong>不可以作为抽象方法定义。</li>
<li><strong>抽象类与接口区别</strong>：一个子类只可以继承一个抽象类，但是可以实现多个接口。抽象类和接口都是为子类的具体实现提供了一个框架。</li>
<li>抽象类与接口中都可以包含实体的方法，这些实体方法被叫做<strong>默认方法</strong>。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class Hero &#123; &#x2F;&#x2F;声明为抽象类
    String name;
             
    public static void main(String[] args) &#123;
        &#x2F;&#x2F;虽然没有抽象方法，但是一旦被声明为了抽象类，就不能够直接被实例化
        Hero h&#x3D; new Hero();
    &#125;
          
&#125;</code></pre>
<h2 id="内部类"><a class="markdownIt-Anchor" href="#内部类"></a> 内部类</h2>
<ul>
<li>在一个类内部声明的类就是<strong>内部类</strong>，相应的外面的类为<strong>外部类</strong>。</li>
<li>内部类对同一个包中的其他类隐藏；</li>
<li>内部类方法可以访问定义这个类的类的作用域中的成员变量和成员方法，包括原本的<strong>私有变量和方法</strong>。</li>
<li>内部类<strong>不可以声明类变量和类方法</strong>（即内部类的成员变量和方法不可以用static来修饰）</li>
</ul>
<h3 id="非静态内部类"><a class="markdownIt-Anchor" href="#非静态内部类"></a> 非静态内部类</h3>
<ul>
<li>直接在类内部定义(类前面没有任何修饰词），只有在外部类存在的时候才有意义。实例化的语法：<code>new &lt;外部类&gt;().new &lt;内部类&gt;</code>或者<code>&lt;外部类引用&gt;.new &lt;内部类&gt;</code>.示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package charactor;
 
public class Hero &#123;
    private String name; &#x2F;&#x2F; 姓名
 
    &#x2F;&#x2F; 非静态内部类，只有一个外部类对象存在的时候，才有意义
    &#x2F;&#x2F; 战斗成绩只有在一个英雄对象存在的时候才有意义
    class BattleScore &#123; &#x2F;&#x2F;直接在内部定义，前面没有修饰词
        int kill;
        int die;
        int assit;
 
        public void legendary() &#123;
            if (kill &gt;&#x3D; 8)
                System.out.println(name + &quot;超神！&quot;);
            else
                System.out.println(name + &quot;尚未超神！&quot;);
        &#125;
    &#125;
 
    public static void main(String[] args) &#123;
        Hero garen &#x3D; new Hero();
        garen.name &#x3D; &quot;盖伦&quot;;
        &#x2F;&#x2F; 实例化内部类
        &#x2F;&#x2F; BattleScore对象只有在一个英雄对象存在的时候才有意义
        &#x2F;&#x2F; 所以其实例化必须建立在一个外部类对象的基础之上
        BattleScore score &#x3D; garen.new BattleScore();
        score.kill &#x3D; 9;
        score.legendary();
    &#125;
 
&#125;</code></pre>
<h3 id="静态内部类"><a class="markdownIt-Anchor" href="#静态内部类"></a> 静态内部类</h3>
<ul>
<li>静态内部类在外部类里面定义时加上了<code>static</code>修饰，此时的内部类与普通类相比，除了内部类可以访问外部类的私有静态成员外，没有任何区别。</li>
<li>静态内部类不依赖于外部类的对象，所以可以直接实例化。如<code>h = new Hero.EnemyCrystal()</code>.</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package charactor;
  
public class Hero &#123;
    public String name;
    protected float hp;
  
    private static void battleWin()&#123;
        System.out.println(&quot;battle win&quot;);
    &#125;
     
    &#x2F;&#x2F;敌方的水晶
    static class EnemyCrystal&#123;
        int hp&#x3D;5000;
         
        &#x2F;&#x2F;如果水晶的血量为0，则宣布胜利
        public void checkIfVictory()&#123;
            if(hp&#x3D;&#x3D;0)&#123;
                Hero.battleWin();
                 
                &#x2F;&#x2F;静态内部类不能直接访问外部类的对象属性
                System.out.println(name + &quot; win this game&quot;);
            &#125;
        &#125;
    &#125;
     
    public static void main(String[] args) &#123;
        &#x2F;&#x2F;实例化静态内部类
        Hero.EnemyCrystal crystal &#x3D; new Hero.EnemyCrystal();
        crystal.checkIfVictory();
    &#125;
  
&#125;</code></pre>
<h3 id="匿名类"><a class="markdownIt-Anchor" href="#匿名类"></a> 匿名类</h3>
<ul>
<li>直接使用一个类的子类的类体创建一个子类对象，该类体被认为是创建该类的类的子类。如：<code>new People() &#123;子类（匿名类）的类体&#125;</code></li>
<li>也可以直接使用接口名和一个类体创建一个匿名对象，此类体被认为是实现了该接口的类。如：<code>new Computable() &#123;匿名类类体&#125;</code></li>
<li>对于抽象方法，本来应该在子类中对其实现后，再实例化。但是<strong>匿名类</strong>是在实际使用这个抽象方法的时候直接对其现场实现，省去了在子类中实现的步骤，因而没有子类的名字，叫做匿名。但是，实际上系统是自动为这个你未曾创建的子类分配了一个名字。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package charactor;
   
public abstract class Hero &#123;
    String name; &#x2F;&#x2F;姓名
             
    public abstract void attack(); &#x2F;&#x2F;抽象方法
      
    public static void main(String[] args) &#123;
          
        ADHero adh&#x3D;new ADHero();
        &#x2F;&#x2F;通过打印adh，可以看到adh这个对象属于ADHero类
        adh.attack();
        System.out.println(adh);
          
        Hero h &#x3D; new Hero()&#123; &#x2F;&#x2F;对抽象类在实例化时直接实现抽象类，省去了在子类中实现的步骤，从而没有类名，故为匿名类。
            &#x2F;&#x2F;当场实现attack方法
            public void attack() &#123;
                System.out.println(&quot;新的进攻手段&quot;);
            &#125;
        &#125;;
        h.attack();
        &#x2F;&#x2F;通过打印h，可以看到h这个对象属于Hero$1这么一个系统自动分配的类名
          
        System.out.println(h);
    &#125;
      
&#125;</code></pre>
<h3 id="本地类"><a class="markdownIt-Anchor" href="#本地类"></a> 本地类</h3>
<ul>
<li>本地类可以看做有名字的匿名类，都是在实际使用的代码块里对抽象方法进行实现，只是本地类还顺手创建了子类的名字。示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package charactor;
   
public abstract class Hero &#123;
    String name; &#x2F;&#x2F;姓名
      
    public abstract void attack();
      
    public static void main(String[] args) &#123;
          
        &#x2F;&#x2F;与匿名类的区别在于，本地类有了自定义的类名
        class SomeHero extends Hero&#123; &#x2F;&#x2F;s使用时创建了Hero的子类SomeHero
            public void attack() &#123;
                System.out.println( name+ &quot; 新的进攻手段&quot;);
            &#125;
        &#125;
         
        SomeHero h  &#x3D;new SomeHero();
        h.name &#x3D;&quot;地卜师&quot;;
        h.attack();
    &#125;
      
&#125;</code></pre>
<h2 id="默认方法-2"><a class="markdownIt-Anchor" href="#默认方法-2"></a> 默认方法</h2>
<ul>
<li>在接口中除了抽象方法，还可以实现具体的方法，这个实现了的方法就是默认方法。默认方法前使用<code>default</code>来修饰。示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package charactor;
 
public interface Mortal &#123;
    public void die(); &#x2F;&#x2F;抽象方法
 
    default public void revive() &#123; &#x2F;&#x2F;默认方法
        System.out.println(&quot;本英雄复活了&quot;);
    &#125;
&#125;</code></pre>
<h1 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h1>
<ol>
<li><code>//</code>方式：其注释内容从//开始到本行末尾。</li>
<li><code>/* */</code>方式：其注释内容从<code>/*</code>开始到<code>*/</code>结束。</li>
<li>文档注释：从<code>/**</code>开始到<code>*/</code>结束。</li>
</ol>
<h2 id="文档注释"><a class="markdownIt-Anchor" href="#文档注释"></a> 文档注释</h2>
<ul>
<li>文档注释借助于javadoc工具实现，它可以由源文件生成一个HTML文档。</li>
<li>在注释中包含<strong>标记</strong>和自由格式的文本(在其中可以使用HTML修饰符)。每个标记以<code>@</code>开始，如<code>@return</code>.</li>
</ul>
<h3 id="类注释"><a class="markdownIt-Anchor" href="#类注释"></a> 类注释</h3>
<ul>
<li>类注释放在<code>import</code>语句之后，类定义之前。</li>
</ul>
<h3 id="方法注释"><a class="markdownIt-Anchor" href="#方法注释"></a> 方法注释</h3>
<ul>
<li>方法注释放在所描述的方法之前。通常会使用标记。</li>
<li><code>@param</code>：用以描述当前方法的参数(parameters),可以占据多行。</li>
<li><code>@return</code>:用以描述当前方法的返回信息，同样可以占据多行。</li>
<li><code>@throws</code>：表示这个方法有可能抛出异常。</li>
</ul>
<h3 id="字段注释"><a class="markdownIt-Anchor" href="#字段注释"></a> 字段注释</h3>
<ul>
<li>对公共字段（通常为静态常量）建立文档。</li>
</ul>
<h3 id="通用注释"><a class="markdownIt-Anchor" href="#通用注释"></a> 通用注释</h3>
<ul>
<li><code>@since</code>：建立一个描述这个特性的版本的文本。</li>
<li><code>@author</code>:描述作者，可以有多个这个标记，每个标记对应一个作者。</li>
<li><code>@version</code>:描述当前版本。</li>
<li><code>@see</code>和<code>@link</code>：可以在之后放指向其它类或方法，以及URL的超链接。</li>
</ul>
<h3 id="包注释"><a class="markdownIt-Anchor" href="#包注释"></a> 包注释</h3>
<ul>
<li>在每个包的目录下创建一个名为package-info.java（包含一个Javadoc文档，在文档后面是一个package语句）或者package.html的文件（使用普通的html即可，javadoc会抽取<code>&lt;body&gt;...&lt;/bode&gt;</code>的部分）.</li>
</ul>
<h3 id="文档注释的抽取"><a class="markdownIt-Anchor" href="#文档注释的抽取"></a> 文档注释的抽取</h3>
<ul>
<li>使用<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fjhh/p/5370642.html">javadoc</a>.</li>
</ul>
<h1 id="异常-断言和日志"><a class="markdownIt-Anchor" href="#异常-断言和日志"></a> 异常、断言和日志</h1>
<h2 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h2>
<ul>
<li>异常就是程序执行过程中出现的不正常现象，如非预期情况，错误的参数，网络故障等。</li>
<li>任何一个程序都可能出现异常，java使用<strong>异常对象</strong>表示打开的文件不存在，内存不够，数组访问超界等非预期情况。</li>
</ul>
<h3 id="异常概念"><a class="markdownIt-Anchor" href="#异常概念"></a> 异常概念</h3>
<ul>
<li><strong>异常处理的任务</strong>：将控制权从产生错误的地方转移到能够处理这种情况的错误处理器。</li>
<li><strong>程序中可能会出现的错误</strong>：
<ul>
<li>用户输入错误；</li>
<li>设备错误；</li>
<li>物理限制（存储空间）；</li>
<li>代码错误。</li>
</ul>
</li>
<li><strong>异常处理过程</strong>： 如果某个方法不能够正常的完成，可以通过<strong>抛出</strong>一个封装了错误信息的异常对象来退出方法。需要退出的方法并不返回任何值，而是<strong>直接退出</strong>（中断处理），之后异常处理机制开始搜索能够处理这种异常的异常处理器。</li>
</ul>
<h3 id="异常分类"><a class="markdownIt-Anchor" href="#异常分类"></a> 异常分类</h3>
<ul>
<li><strong>异常对象</strong>：是派生于Throwable类的类实例。</li>
<li><strong>异常的层次结构</strong>：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201015184846.jpg" alt="" />
<ul>
<li>所有的异常类都是由<strong>Throwable类</strong>继承而来，Throwable类属于java.lang类，不需要import即可使用。</li>
<li><strong>Error</strong>类层次结构：描述了java运行时的系统内部错误和资源耗尽错误，不能人工处理的，一般也不要求处理。</li>
<li><strong>Exception</strong>类层次结构：是设计程序时主要关注的异常。</li>
<li><strong>RuntimeException</strong>:由<strong>编程错误</strong>导致的异常（如果出现RuntimeException异常，一定是程序员的问题），又称运行期异常，一般也不要求处理，只要求提示。具体包含：
<ul>
<li>错误的强制类型转换；</li>
<li>数组访问越界；</li>
<li>访问null指针。</li>
</ul>
</li>
<li><strong>IOException</strong>:包含除RuntimeException的其他异常，例如：
<ul>
<li>试图超越文件末尾继续读取数据；</li>
<li>试图打开一个不存在的文件；</li>
<li>试图根据给定的字符串查找并不存在的Class对象。</li>
</ul>
</li>
</ul>
</li>
<li><strong>非检查型异常与检查型异常</strong>：所有派生于<strong>Error或者RuntimeException类的异常称为非检查型异常</strong>。其余异常为检查型异常。</li>
</ul>
<h3 id="异常处理的第一种方式声明检查型异常"><a class="markdownIt-Anchor" href="#异常处理的第一种方式声明检查型异常"></a> 异常处理的第一种方式：声明检查型异常</h3>
<ul>
<li>在方法首法使用<code>throws</code>关键字声明该方法可能抛出的<strong>检查型异常</strong>：如： <code>public FileInputStream(String name) throws FileNotFoundException</code>。如果会抛出多个异常，可以在首部声明所有的检查型异常类,用逗号分隔，如：<code>public Image loadImage(String s) throws FileNotFoundException, EoFException</code></li>
<li>一个方法必须声明所有可能抛出的<strong>检查型异常</strong>。而非检查型异常是我们无法控制的（Error），或者是我们应该极力在编程时避免的（RuntimeException）。</li>
<li><strong>子类</strong>方法中声明的检查型异常是<strong>父类</strong>方法中的声明的异常相同的，或者是该异常的子类。如果父类没有声明异常，则子类也不可以声明异常。</li>
<li>如果方法中抛出的多个异常都是一个异常的子类，那么只需要声明这写异常的父类异常即可。</li>
<li>声明的检查型异常会抛出给方法的调用者处理，最终交给JVM处理。</li>
<li>调用一个声明了抛出异常的方法，必须处理声明的异常，有以下两种方法：
<ol>
<li>在调用这个方法的方法里继续使用throws声明抛出异常，交给jvm来处理，但是jvm处理异常是通过中断来处理的，在抛出异常对象的语句之后的代码不会再被执行。</li>
<li>在该方法里使用<code>try...catch</code>语句，自己处理该异常。</li>
</ol>
</li>
</ul>
<h3 id="抛出异常"><a class="markdownIt-Anchor" href="#抛出异常"></a> 抛出异常</h3>
<ul>
<li>抛出指定异常的方法：
<ol>
<li>找到一个合适的异常类；</li>
<li>创建这个类的<strong>对象</strong>：如：<code>var e = new EOFException</code></li>
<li>将对象抛出：如<code>throw e</code>。</li>
</ol>
</li>
<li>2、3步可以合并为一步：<code>throw new EOFException</code></li>
<li>每个异常类都带有一个字符串参数的构造器，可以用来描述异常的具体信息。如：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">String gripe &#x3D; &quot;Content-length: &quot; + len +&quot;, Recived: &quot; + n;
throw new EOFException(gripe);</code></pre>
<ul>
<li>throws 出来的RuntimeException或者其子类异常，就可以直接抛出交给jvm内置的异常处理器来处理。</li>
</ul>
<h3 id="创建异常类"><a class="markdownIt-Anchor" href="#创建异常类"></a> 创建异常类</h3>
<ul>
<li>如果标准的异常类不能描述清楚你程序的问题，那么就需要创建自己的异常类。</li>
<li>命名以Exception结尾。</li>
<li>自定义的异常类需要派生于Exception类或者Exception的子类（<strong>所有异常类都是Throwable类的子类</strong>）。并且这个类中应该包含两个构造器：一个默认的构造器（无参数），一个包含<strong>描述异常信息的字符串参数的构造器</strong>。示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class FileFormatException extends IOException &#123;
    public FileFormatException() &#123;&#125; &#x2F;&#x2F;默认的构造器
    public FileFormatException (String gripe) &#123;
        super(gripe);&#x2F;&#x2F;父类构造器中有含这个参数的构造器，直接借用即可
    &#125;
&#125;</code></pre>
<h3 id="异常的第二种处理方法捕获异常"><a class="markdownIt-Anchor" href="#异常的第二种处理方法捕获异常"></a> 异常的第二种处理方法：捕获异常</h3>
<ul>
<li>抛出异常是将发生的异常交给异常处理器取处理。而与之相对的<strong>捕获异常</strong>就是将异常交给用户指定的异常处理器去处理。</li>
<li>在调用可能会产生异常的方法时使用<code>try/catch</code>来捕获异常，来替代直接throws声明异常将异常继续抛出交给jvm来处理。</li>
<li>捕获异常需要使用<code>try/catch</code>语句块，要捕获异常的方法就不再使用<code>throws</code>声明抛出异常。示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public void read(String filename) &#123;
    try &#123;
        &#x2F;&#x2F;放置可能产生异常的代码
        var in &#x3D; new FileInputStream(filename);
        int b;
        while (b &#x3D; in.read() !&#x3D; -1) &#123;
            process input
        &#125;
    &#125;
    catch (IOException exception) &#123; &#x2F;&#x2F;异常类名 异常对象名， 发挥了声明异常中throw new 异常的作用
        exception.printStackTrace(); &#x2F;&#x2F;调用对应异常的处理器方法
    &#125;
&#125;</code></pre>
<ul>
<li><strong>捕获多个异常</strong>：在一个try语句块中可以捕获多个异常类型，并对不同的异常类型做出不同的处理。例如：  <pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;
    &#x2F;&#x2F;code that might throw exceptions
&#125;
catch (FileNotFoundException e) &#123;
    &#x2F;&#x2F;emergency action for missing files
&#125; 
catch (IOException e) &#123; &#x2F;&#x2F;父类异常必须放在子类异常后面，否则子类异常就失去作用了
    &#x2F;&#x2F;emergency action for all other I&#x2F;O problems
&#125;
​&#96;&#96;&#96;java
    * 还可以用一个catch语句捕获多个异常类型，前提是这些异常类型彼此之间不存在子类关系。如：
​&#96;&#96;&#96;java

try &#123;
    &#x2F;&#x2F;code that might throw exceptions
&#125;
catch (FileNotFoundException e | UnknownHostException e) &#123; &#x2F;&#x2F;同时捕获多个异常
    &#x2F;&#x2F;emergency action for missing files or unknown hosts
&#125; 
catch (IOException e) &#123;
    &#x2F;&#x2F;emergency action for I&#x2F;O problems
&#125;</code></pre>
</li>
<li><strong>再次抛出异常</strong>：可以在catch语句中仅记录一个异常（即<em>不对该异常对象做修改</em>），之后再将这个异常重新抛出。此时可以在方法上重新加上<code>throws</code>关键字，指明抛出的异常类型。示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;
    &#x2F;&#x2F;access thr database
&#125;
catch (Exception) &#123;
    logger.log(level, message, e);&#x2F;&#x2F;仅仅是记录该异常的信息
    throw e;
&#125;</code></pre>
<h3 id="finally子句"><a class="markdownIt-Anchor" href="#finally子句"></a> finally子句</h3>
<ul>
<li>代码抛出一个异常时，会停止处理这个方法中的剩余的代码，并退出这个方法。但此时可能会有这个方法以及获得的资源没有清理。而finally子句正是用来清理这这些资源的。</li>
<li><strong>finally不能单独使用，必须和try一起使用</strong>。</li>
<li><strong>无论该方法有没有抛出异常，finally子句中的代码都会在前面代码按照普通流程结束后执行</strong>（没有异常则顺序执行到finally子句，捕获了异常则在catch中处理了异常再执行finall子句，抛出了异常则抛出异常后执行finally子句），示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">var in &#x3D; new FileInputStream;
try &#123;
    &#x2F;&#x2F;code
&#125;
catch (IOException) &#123;
    &#x2F;&#x2F;...
&#125;
finally &#123;
    in.close();
&#125;</code></pre>
<ul>
<li>还可以将两个try嵌套，内层try确保关闭资源，外层try语句确保报告错误。示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">InputStream in &#x3D; ...;
try &#123;
    try &#123;
        &#x2F;&#x2F;code that might throw exception
    &#125;
    finally &#123;
        in.close();
    &#125;
&#125;
catch (IOException) &#123;
    &#x2F;&#x2F;...
&#125;</code></pre>
<h3 id="try-with-resources语句"><a class="markdownIt-Anchor" href="#try-with-resources语句"></a> try-with-Resources语句</h3>
<ul>
<li>try-with-Resources语句是和finally子句实现同样功能的。可以在try后面加上执行完代码后需要关闭的资源，这样构成try-with-Resources语句,无论什么时候退出try语块，都会自动将资源关闭。示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">try (var in &#x3D; new Scanner(new FileInputStream(&quot;&#x2F;usr&#x2F;share&#x2F;dict&#x2F;words&quot;), StandardCharests.UTF_8)) &#123;
    while (in.hasNext()) &#123;
        System.out.println(in.next());
    &#125;
&#125;</code></pre>
<ul>
<li>try-with-Resources语句也可以带上catch子句和finally子句。</li>
</ul>
<h3 id="分析堆栈轨迹元素"><a class="markdownIt-Anchor" href="#分析堆栈轨迹元素"></a> 分析堆栈轨迹元素</h3>
<ul>
<li>堆栈轨迹（stack trace）是程序执行过程中某个特定点上所有挂起的方法调用的一个列表。</li>
<li>可以通过Throwable类或者StackWalker类来显示堆栈轨迹。</li>
</ul>
<h2 id="断言"><a class="markdownIt-Anchor" href="#断言"></a> 断言</h2>
<ul>
<li><strong>断言</strong>：断言机制允许在测试代码时插入一些检查。使用关键字<code>assert</code>来使用断言。一般格式:
<ul>
<li><code>assert condition;</code>:这个语句会计算condition中的条件，如果结果为false，就会抛出一个AssertionError的异常。</li>
<li><code>assert condition:expression;</code>:在前一个语句的基础上增加了expression异常描述消息字符串，这个语句会将这个expression描述传入AssertionError的对象构造器中。</li>
</ul>
</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;断言x是一个非负数。

assert x &gt;&#x3D; 0;
&#x2F;&#x2F;或者
assert x &gt;&#x3D; 0 : x;</code></pre>
<ul>
<li>断言的使用场景：
<ul>
<li>断言失败应该是失败的、不可恢复的错误；</li>
<li>断言检查只是用在开发和测试调试阶段，是程序员用来自我检查的工具。</li>
</ul>
</li>
</ul>
<h2 id="日志"><a class="markdownIt-Anchor" href="#日志"></a> 日志</h2>
<ul>
<li>日志用来记录程序中需要记录的问题。可以用java自带的API（如：java.util.logging）实现，也可以用第三方平台的API实现。</li>
</ul>
<h1 id="并发"><a class="markdownIt-Anchor" href="#并发"></a> 并发</h1>
<h2 id="线程与进程"><a class="markdownIt-Anchor" href="#线程与进程"></a> 线程与进程</h2>
<ul>
<li>每个进程(processor)都拥有自己的一套变量，而线程(thread)之间共享数据。线程比进程更加的轻量级。</li>
<li>线程是在进程内部同时做的事情。</li>
<li>多线程即在同一时间，可以做多件事情。</li>
<li>线程由3部分组成：
<ol>
<li>虚拟的cpu：封装在Java.lang.Thread类中。</li>
<li>cpu所执行的代码：传递给Thread类。</li>
<li>cpu所处理的数据：传递给Thread类。</li>
</ol>
</li>
</ul>
<h2 id="创建多线程"><a class="markdownIt-Anchor" href="#创建多线程"></a> 创建多线程</h2>
<h3 id="继承线程类创建多线程"><a class="markdownIt-Anchor" href="#继承线程类创建多线程"></a> 继承线程类创建多线程</h3>
<ul>
<li>可以通过继承<code>Thread</code>类来实现创建线程，如：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class KillThread extends Thread&#123; &#x2F;&#x2F;KillThread是继承自Thread的子类
     
    private Hero h1;
    private Hero h2;
 
    &#x2F;&#x2F;线程的构造器
    public KillThread(Hero h1, Hero h2)&#123;
        this.h1 &#x3D; h1;
        this.h2 &#x3D; h2;
    &#125;
 
    public void run()&#123; &#x2F;&#x2F;覆盖Thread中的run方法（必须），以实现启动线程后的具体操作。
        while(!h2.isDead())&#123;
            h1.attackHero(h2);
        &#125;
    &#125;
&#125;</code></pre>
<ul>
<li>无论使用什么方法实现线程，线程启动都需要使用Thread类中的<strong>start方法</strong>。线程启动示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">KillThread killThread1 &#x3D; new KillThread(gareen,teemo); &#x2F;&#x2F;新建一个线程
killThread1.start(); &#x2F;&#x2F;启动一个创建的线程
KillThread killThread2 &#x3D; new KillThread(bh,leesin);
killThread2.start();</code></pre>
<h3 id="实现runable接口来创建多线程"><a class="markdownIt-Anchor" href="#实现runable接口来创建多线程"></a> 实现Runable接口来创建多线程</h3>
<ul>
<li>Runable接口中有一个run方法，实现这个接口的时候必须实现run方法（run方法中是这个线程需要做的事）。</li>
<li>实现Runable接口示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
public class Battle implements Runnable&#123; &#x2F;&#x2F;实现Runable接口的类
     
    private Hero h1;
    private Hero h2;
 
    public Battle(Hero h1, Hero h2)&#123;
        this.h1 &#x3D; h1;
        this.h2 &#x3D; h2;
    &#125;
 
    public void run()&#123; &#x2F;&#x2F;实现run方法
        while(!h2.isDead())&#123;
            h1.attackHero(h2);
        &#125;
    &#125;
&#125;</code></pre>
<ul>
<li>无论使用什么方法都需要<strong>实现run方法</strong>。</li>
<li>线程启动示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Battle battle1 &#x3D; new Battle(gareen,teemo); &#x2F;&#x2F;启动的时候，首先创建一个Battle对象，然后再根据该battle对象创建一个线程对象，并启动 
new Thread(battle1).start(); &#x2F;&#x2F;把Battle对象作为Thread对象的构造器的参数来新建一个Thread对象，并直接调用start方法启动这个线程。
 
Battle battle2 &#x3D; new Battle(bh,leesin);
new Thread(battle2).start();</code></pre>
<h3 id="使用匿名类创建多线程"><a class="markdownIt-Anchor" href="#使用匿名类创建多线程"></a> 使用匿名类创建多线程</h3>
<p>。。。</p>
<h2 id="线程的状态"><a class="markdownIt-Anchor" href="#线程的状态"></a> 线程的状态</h2>
<ul>
<li>线程有4个状态：
<ol>
<li><strong>新生态</strong>：线程生成后立即进入新生态，此时该线程已被初始化（分配存储空间，初始化数据）。此时的线程可以使用<code>start()</code>方法调度。</li>
<li><strong>可执行态</strong>：，新生态使用<code>start()</code>方法被调度后，进入可执行态，随时可以被执行，可细分为两种状态：
<ol>
<li>执行状态：已获得cpu，正在执行。</li>
<li>就绪状态：只等待处理器资源。这两个子状态的过渡由执行调度器来控制。</li>
</ol>
</li>
<li><strong>阻塞态</strong>：由于某种原因引起线程暂停执行的状态。</li>
<li><strong>停止态</strong>：线程执行完毕或者另一线程调用<code>stop（）</code>使该线程停止，进入停止态，它表示线程已经退出执行状态，并且不再进入可执行状态。</li>
</ol>
</li>
<li>一个线程被创建后就有了生命周期。线程在创建后到销毁前总处于这四种状态中。</li>
</ul>
<h2 id="线程优先级"><a class="markdownIt-Anchor" href="#线程优先级"></a> 线程优先级</h2>
<ul>
<li>
<p>优先级是线程获得cpu而执行的优先程度。java把优先级划为10级，用1到10整数表示，数值越大，优先级越高。</p>
</li>
<li>
<p>Tread类中定义了三个优先级常量：<code>MIN_PRIORITY</code>,<code>MAX_PRIORITY</code>, <code>NORM_PRIORITY</code>分别对应1，10，5.默认线程优先级是<code>NORM_PRIORITY</code>。</p>
</li>
<li>
<p>Thread类中的<code>setPriority(int a)</code>方法可以修改线程的优先级。</p>
</li>
<li>
<p>java采用<strong>抢占式调度方式</strong>，高优先级线程具有剥夺低优先级线程执行的权利。正在执行的低优先级线程，遇到高优先级线程只能停止，让高优先级线程立即执行。相同优先级的线程采取先来先执行。</p>
</li>
<li>
<p>调用**<code>sleep()</code>**方法能使线程暂时进入“睡眠状态”，让出cpu，使与其具有相同优先级线程或者低优先级的线程有执行的机会。</p>
</li>
<li>
<p>**<code>yield()</code>**方法能让线程放弃cpu，使与其具有相同优先级的线程具有执行的机会。</p>
</li>
</ul>
<h2 id="线程同步"><a class="markdownIt-Anchor" href="#线程同步"></a> 线程同步</h2>
<ul>
<li>多线程同步控制机制：保证同一时刻只有<strong>一个线程访问数据资源</strong>。</li>
<li>Tread类定义控制线程执行的方法：
<ol>
<li><strong><code>start()</code></strong>:用于调用<code>run()</code>方法使线程开始执行，进入可执行态；</li>
<li><strong><code>stop()</code></strong>:立即停止线程执行，其内部状态清零，放弃占用资源，进入停止态；</li>
<li><strong><code>wait()</code></strong>:使线程处于等待状态，进入阻塞态；</li>
<li><strong><code>notify()</code></strong>:使线程脱离阻塞状态,进入可执行态；</li>
<li><strong><code>sleep()</code></strong>:调整线程执行时间，参数指定睡眠时间，睡眠时间内，进入阻塞态；</li>
<li><strong><code>yield</code></strong>:暂停调度线程并将其放在等待队列的末尾，等待下一轮执行。</li>
</ol>
</li>
<li><strong>同步锁</strong>：java使用锁标志（lock flag），对被访问数据进行同步限制（上锁），从而实现对数据的保护。线程必须取得锁标志才能访问被保护（上锁）的资源。</li>
<li>使用<code>synchronized</code>修饰符来为保护资源上锁。但是<code>synchronzied</code>只能用来说明<strong>方法</strong>和<strong>代码段</strong>，不能用来说明类和成员变量。被<code>synchronized</code>修饰的方法或者代码段同一时刻只能被一个线程执行，其他想用的线程必须等待。</li>
<li><code>wait()</code>可使一个线程进入阻塞状态，等待其他线程用<code>notify</code>唤醒。<code>notifyAll()</code>可以唤醒其它所有线程。二者配合实现同步机制。</li>
</ul>
<h1 id="流"><a class="markdownIt-Anchor" href="#流"></a> 流</h1>
<ul>
<li>流(stream)是指在计算机的输入和输出之间运动的数据序列。</li>
<li>流通过java的输入输出系统与物理设备链接。</li>
<li><strong>字节流</strong>：java把处理二进制数据的流称为字节流，字节流每次处理一个字节的数据。字节流的命名以<strong>Stream</strong>结尾。</li>
<li><strong>字符流</strong>：把处理某种格式的特定数据称为字符流，字符流每次处理一个字符的数据。字符流命名以<strong>Reader /Writer</strong>结尾。</li>
<li><strong>节点流</strong>：node stream是指直接从指定的位置（如磁盘文件或内存区域）读或写。</li>
<li><strong>过滤器</strong>：非节点流的流称为过滤器（filters）。过滤器输入流往往是将其它输入流作为它的输入流，经过过滤或处理后再以新的输入流的形式提供给用户；过滤输出流也类似。</li>
</ul>
<h2 id="javaiofile类"><a class="markdownIt-Anchor" href="#javaiofile类"></a> java.io.File类</h2>
<ul>
<li>File类是<strong>文件及文件目录路径名的抽象表示形式</strong>。java可以使用File类对文件和目录进行创建，删除，获取，判断，遍历等操作。</li>
<li>File类是与系统无关的类，任何操作系统都可以使用这个类中的方法和字段（它会自适应各种操作系统）。</li>
</ul>
<h3 id="file类的成员变量"><a class="markdownIt-Anchor" href="#file类的成员变量"></a> File类的成员变量</h3>
<ul>
<li>成员变量（都为静态）：
<ul>
<li><code>static String pathSeparator;</code>路径分隔符：Windows中为分号<code>;</code>,linux系统为冒号<code>:</code>.</li>
<li><code>static String separator</code>:文件名分隔符：Windows中为反斜杠<code>\</code>,linux中为正斜杠<code>/</code>。</li>
<li><code>static char pathSeparetorChar</code>:内容一样的字符表示形式。</li>
<li><code>static char separatorChar</code>：内容一样的字符表示形式。</li>
</ul>
</li>
<li>路径：
<ul>
<li>绝对路径：完整路径，以盘符<code>C:\\</code>开始，如<code>C:\02Permanent\Blog\source\_posts</code></li>
<li>相对路径：相对于当前项目的根目录，可以省略当前项目的根目录。若当前路径<code>C:\02Permanent\Blog\source\_posts\java.md</code>,在当前目录下可以简写为<code>java.md</code>。</li>
<li>路径不区分大小写；</li>
<li>Windows的文件名分隔符原本为<code>\</code>,但是反斜杠又有转义的作用，所以需要使用两个反斜杠<code>\\</code>来表示分隔符。</li>
</ul>
</li>
</ul>
<h3 id="file类的构造方法"><a class="markdownIt-Anchor" href="#file类的构造方法"></a> File类的构造方法</h3>
<ul>
<li>构造方法：
<ul>
<li><code>File(String pathname)</code>:通过将给定路径名字符串转换为抽象路径名来创建一个File对象。
<ul>
<li>参数：路径名称的字符串为构造的参数。
<ul>
<li>既可以是文件结尾，也可以是文件名结尾。</li>
<li>既可以是绝对路径，也可以是相对路径。</li>
<li>路径可以存在的，也可以是不存在的。</li>
</ul>
</li>
</ul>
</li>
<li><code>File(String parent, String child)</code>:根据parent路径名字符串和child路径名字符串创建一个File对象。
<ul>
<li>参数：将路径分为了父路径和子路径两个部分，父路径和子路径都可以单独变化，使用起来很灵活。</li>
<li>示例：<code>File f = new File(&quot;c:\\&quot;, &quot;java.md&quot;);</code>f的结果为<code>c:\java.md</code>。</li>
</ul>
</li>
<li><code>File(File parent, String chile)</code>:根据parent<strong>抽象</strong>路径名和child路径名字符串创建一个File对象。
<ul>
<li>参数：把路径分为了抽象路径和路径名字符串两部分。可以使用File类的方法对parent路径进行操作，再使用该路径创建File对象。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">File parent &#x3D; new File(&quot;c:\\&quot;);
File file &#x3D; new File(parent, &quot;hello.java&quot;);</code></pre>
</li>
<li><code>File(URL url)</code>：暂略</li>
</ul>
</li>
</ul>
<h3 id="file类获取文件信息的方法"><a class="markdownIt-Anchor" href="#file类获取文件信息的方法"></a> File类获取文件信息的方法</h3>
<ul>
<li><code>public String getAbsolutePath()</code>：返回此File的<strong>绝对路径</strong>名字符串；（返回构造File时的传入的路径）</li>
<li><code>public String getPath()</code>:返回此File的路径名字符串（既可以是绝对路径，也可以是相对）</li>
<li><code>public String getName()</code>:返回此File表示的<strong>文件或者目录的名称</strong>（即构造时传入的路径的结尾部分）</li>
<li><code>public String getParent()</code>:返回File对象的父目录名称。</li>
<li><code>public long lenght()</code>:返回此File表示的文件的长度；
<ul>
<li>长度是以字节为单位计算的；</li>
<li>目录是没有大小的，只能得到具体文件的长度大小。</li>
</ul>
</li>
</ul>
<h3 id="file类判断属性或状态的方法"><a class="markdownIt-Anchor" href="#file类判断属性或状态的方法"></a> File类判断属性或状态的方法</h3>
<ul>
<li><code>public boolean exists();</code>:此File对象表示的文件或者目录是否真实存在。如果路径本身就不存在，则直接返回false</li>
<li><code>public boolean isDirectory();</code>此File对象表示的是否为目录。如果路径本身就不存在，则直接返回false</li>
<li><code>public boolean isFile();</code>此File对象表示的是否为文件。如果路径本身就不存在，则直接返回false</li>
<li>还有<code>canWrite(), canRead(), isAbsoulte()</code>等分别表示是否写保护，是否读保护，是否使用绝对路径。</li>
</ul>
<h3 id="file类创建和删除的方法"><a class="markdownIt-Anchor" href="#file类创建和删除的方法"></a> File类创建和删除的方法</h3>
<ul>
<li><code>public boolean createNewFile();</code>:当且仅当具有该名称的<strong>文件</strong>尚不存在的时候，创建一个新的空文件。
<ul>
<li>创建文件的路径和名称在构造方法中给出</li>
<li>文件不存在，创建文件，返回true</li>
<li>文件存在，返回false</li>
<li>如果路径不存在，则会抛出<strong>IOException异常</strong>;所以调用这个方法要么throws异常，要么使用try-catch捕获异常。</li>
<li>只能创建文件，不能创建文件夹（目录）</li>
</ul>
</li>
<li><code>public boolean mkdir();</code>:创建由此File表示的目录（只能创建单级空文件夹）
<ul>
<li>创建文件夹的路径和名称在构造方法中给出</li>
<li>文件夹不存在，创建文件，返回true</li>
<li>文件夹存在，返回false</li>
<li>如果路径不存在，则还是返回false</li>
<li>只能创建文件夹，不能创建文件。</li>
</ul>
</li>
<li><code>public boolean mkdirs();</code>:创建由此File表示的目录（能够创建多级文件夹，如<code>File//111//222//333</code>）
<ul>
<li>创建文件夹的路径和名称在构造方法中给出</li>
<li>文件夹不存在，创建文件，返回true</li>
<li>文件夹存在，返回false</li>
<li>如果路径不存在，则还是返回false</li>
<li>只能创建文件夹，不能创建文件。</li>
</ul>
</li>
<li><code>public boolean delete();</code>删除由此File表示的<strong>文件或目录</strong>
<ul>
<li>文件或者目录删除成功，返回true</li>
<li>文件夹中有内容，不会删除返回false；</li>
<li>构造方法中的路径不存在返回false；</li>
<li>该方法直接在硬盘删除文件或者文件夹，不走回收站。</li>
</ul>
</li>
</ul>
<h3 id="file的目录遍历功能"><a class="markdownIt-Anchor" href="#file的目录遍历功能"></a> File的目录遍历功能</h3>
<ul>
<li><code>public String[] list();</code>:返回一个String数组，表示该File目录中所有的子文件或目录。遍历构造方法中给出的目录，会获取目录中<strong>所有文件/文件夹的名称</strong>，把获取到的多个名称存储到一个String类型的数组。（打印出来就是文件或者文件夹名）</li>
<li><code>public File[] listFiles();</code>:返回一个File数组，表示该File目录中所有的子文件或目录。遍历构造方法中的目录，或获取目录中所有的文件或文件夹，把文件或者文件夹封装为File对象，多个File对象，存储到File数组中。（打印出来的是文件名和它的完整存储路径）</li>
<li>这两种方法遍历的是构造方法中给出的目录，如果给出的目录路径不存在，会抛出空指针异常，如果给出的路径不是一个目录，也会抛出一个空指针异常。</li>
<li>示例：递归打印多级目录</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.File;

public class Recurison &#123;

    public static void main(String[] args) &#123;
        File file &#x3D; new File(&quot;c:&#x2F;&#x2F;...&quot;);
        getAllFile(file);
    &#125;

    public  static void getAllFile(File dir) &#123;
        File[] files &#x3D; dir.listFiles();
        System.out.println(dir);

        for(File f : files) &#123;
            if(f.isDirectory()) &#123;
                getAllFile(f);
            &#125; else &#123;
                System.out.println(f);
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<ul>
<li>示例：遍历目录，只需以.java结尾的文件</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.File;

public class Recurison &#123;

    public static void main(String[] args) &#123;
        getAllFile(file);
    &#125;

    public  static void getAllFile(File dir) &#123;
        File[] files &#x3D; dir.listFiles();
        System.out.println(dir);

        for(File f : files) &#123;
            if(f.isDirectory()) &#123;
                getAllFile(f);
            &#125; else &#123;
                &#x2F;*
                * 三选一
                *&#x2F;
                &#x2F;&#x2F;String name &#x3D; f.getName();
                &#x2F;&#x2F;String path &#x3D; f.getPath();
                String s &#x3D; f.toString();
                
                &#x2F;&#x2F;把字符串转换为小写
                s &#x3D; s.tolowerCase();


                boolean b &#x3D; s.endWith(&quot;.java&quot;);
                if(b) &#123;
                    System.out.println(f);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<h3 id="filefilter和filenamefilter过滤器"><a class="markdownIt-Anchor" href="#filefilter和filenamefilter过滤器"></a> FileFilter和FilenameFilter过滤器</h3>
<ul>
<li>FileFilter是一个接口，用于抽象路径名（File对象）的过滤；</li>
<li>FileFilter内有过滤文件的抽象方法：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">boolean accept (File pathname) &#x2F;&#x2F;测试指定抽象路径名是否应该包含在某个路径名列表中</code></pre>
<pre><code>* File pathname:使用ListFiles方法遍历目录，得到的每一个文件对象；
</code></pre>
<ul>
<li>FilenameFilter也是一个接口，用于过滤文件名称。</li>
<li>FileFilter内过滤的抽象方法：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">boolean accept (File dir, String name) </code></pre>
<pre><code>* File dir:构造方法中传递的被遍历的目录；
* String name：使用ListFiles方法遍历目录，获取的每一个文件/目录的名称
</code></pre>
<ul>
<li>两个过滤器接口是没有实现类的，需要我们自己写实现类，重写过滤器的方法accept，在方法找那个自己定义过滤的规则</li>
<li>示例：遍历目录，过滤掉不是以.java结尾的文件。使用接口实现类。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.File;

public class Recurison &#123;

    public static void main(String[] args) &#123;
        getAllFile(file);
    &#125;

    public  static void getAllFile(File dir) &#123;

        &#x2F;*
        * 1.listFiles方法会对目录中传递的目录进行遍历，获取目录中的每一个文件、文件夹--》封装为File对象
        * 2.listFiles方法会调用参数传递的过滤器的accept方法
        * 3.listFiles方法会把遍历得到的每一个File对象，传递给accept方法的参数pathname
        * 4.accept的返回值为true则将传递进去的File对象存入File数组，为false则不保存。
        *&#x2F;
        File[] files &#x3D; dir.listFiles(new FileFilterimpl());&#x2F;&#x2F;传递过滤器对象,将过滤的规则传递给listFiles方法，最后返回过滤后的数组
        System.out.println(dir);

        for(File f : files) &#123;
            if(f.isDirectory()) &#123;
                getAllFile(f);
            &#125; else &#123;
                    System.out.println(f);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
public class FileFiterImpl implements FileFilter &#123;
    @overide
    public boolean accept (File pathname) &#123;

        if(pathname.isDirectory()) &#123;
            return true; &#x2F;&#x2F;如果是文件夹，则仍存在File数组中。
        &#125;
        return pathname.getName().toLowerCase().endWith(&quot;.java&quot;);
    &#125;
&#125;</code></pre>
<ul>
<li>使用匿名内部类实现过滤器</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.File;

public class Recurison &#123;

    public static void main(String[] args) &#123;
        getAllFile(file);
    &#125;

    public  static void getAllFile(File dir) &#123;

        &#x2F;*
        * 1.listFiles方法会对目录中传递的目录进行遍历，获取目录中的每一个文件、文件夹--》封装为File对象
        * 2.listFiles方法会调用参数传递的过滤器的accept方法
        * 3.listFiles方法会把遍历得到的每一个File对象，传递给accept方法的参数pathname
        * 4.accept的返回值为true则将传递进去的File对象存入File数组，为false则不保存。
        *&#x2F;
        File[] files &#x3D; dir.listFiles(new FileFilterimpl() &#123;
            @override
            public boolean accept(File pathname) &#123;
            return pathname.getName().toLowerCase().endWith(&quot;.java&quot;) || pathname.isDirectory();
            &#125;
        &#125;);&#x2F;&#x2F;传递过滤器对象,将过滤的规则传递给listFiles方法，最后返回过滤后的数组
        System.out.println(dir);

        for(File f : files) &#123;
            if(f.isDirectory()) &#123;
                getAllFile(f);
            &#125; else &#123;
                    System.out.println(f);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<ul>
<li>使用lambda表达式（接口中只有一个方法）</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.File;

public class Recurison &#123;

    public static void main(String[] args) &#123;
        getAllFile(file);
    &#125;

    public  static void getAllFile(File dir) &#123;

        &#x2F;*
        * 1.listFiles方法会对目录中传递的目录进行遍历，获取目录中的每一个文件、文件夹--》封装为File对象
        * 2.listFiles方法会调用参数传递的过滤器的accept方法
        * 3.listFiles方法会把遍历得到的每一个File对象，传递给accept方法的参数pathname
        * 4.accept的返回值为true则将传递进去的File对象存入File数组，为false则不保存。
        *&#x2F;
        File[] files &#x3D; dir.listFiles((File pathname) -&gt; &#123;
            return pathname.getName().toLowerCase().endWith(&quot;.java&quot;) || pathname.isDirectory();
        &#125;) &#x2F;&#x2F;传递过滤器对象,将过滤的规则传递给listFiles方法，最后返回过滤后的数组
        System.out.println(dir);

        for(File f : files) &#123;
            if(f.isDirectory()) &#123;
                getAllFile(f);
            &#125; else &#123;
                    System.out.println(f);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<h2 id="io流概述"><a class="markdownIt-Anchor" href="#io流概述"></a> IO流概述</h2>
<ul>
<li>I(Input)O(Output),流：数据（字符，字节）1个字符 = 2个字节，1个字节 = 8个二进制位。</li>
<li>I输入：把硬盘中的数据读取到内存中。O输出：把内存的数据读到硬盘中。</li>
<li>字节流：以字节为单位，可以输入输出任意文件。</li>
<li>字符流：以字符为单位。</li>
<li>输入流：输入数据。</li>
<li>输出流：输出数据。</li>
<li><strong>一切皆为字节</strong>：一切文件数据都是以二进制数字的形式保存的，就是以一个一个字节的形式来存储的。</li>
</ul>
<h2 id="字节流"><a class="markdownIt-Anchor" href="#字节流"></a> 字节流</h2>
<ul>
<li>所有流都是在<code>java.io</code>包中实现的。</li>
</ul>
<h3 id="字节输出流"><a class="markdownIt-Anchor" href="#字节输出流"></a> 字节输出流</h3>
<ul>
<li>在<code>java.io.OutputStream</code>定义了OutputStream<strong>抽象类</strong>，表示所有输出字节流的超类。</li>
<li>成员方法：
<ul>
<li><code>void close();</code>:关闭此输出流并释放与此流有关的所有系统资源。</li>
<li><code>void flush();</code>:刷新此输出流并强制写出所有缓冲的输出字节。</li>
<li><code>void write(byte[] b);</code>:将b.length个字节从指定的byte数组写入此输入流。每次写入数据都会覆盖文件中的所有的数据。</li>
<li><code>void write(byte[] b, int off, int len);</code>:将指定byte数组中从偏移量off开始的len个字节写入此输出流。</li>
<li><code>void write(int b);</code>:将指定的字节写入此输出流。</li>
</ul>
</li>
</ul>
<h4 id="fileoutstream类"><a class="markdownIt-Anchor" href="#fileoutstream类"></a> FileOutStream类</h4>
<ul>
<li>OutStream类的子类，叫做文件字节输出流，把内存中的数据写入到硬盘的文件中。</li>
<li>构造方法：参数为写入数据的目的地。会有FileNotFoundException异常（是IOException异常的子类）。需要抛出或者捕获。
<ul>
<li><code>FileOutputStream(String name)</code>:创建一个向指定名称的文件中写入数据的输出文件流。</li>
<li><code>FileOutputStream(File file)</code>:创建一个向指定File对象表示的文件中写入数据的文件输出流。</li>
<li><code>FileOutputStream(String name, boolean append);</code>：创建一个向具有指定name的文件中写入数据的的输出文件流。
<ul>
<li>String name：写入数据的目的地；</li>
<li>boolean append：<strong>追加写</strong>的开关。true:追加写，false：关闭追加写。</li>
</ul>
</li>
<li><code>FileOutputStream(File file, boolean append);</code>:</li>
<li>构造方法的作用：
<ul>
<li>创建一个FileOutputStream对象</li>
<li>会根据构造方法中传递的文件/文件路径，创建一个新的空文件</li>
<li>会把FileOutputStream对象指向创建好的文件。</li>
</ul>
</li>
</ul>
</li>
<li>字节输出流的使用步骤：
<ol>
<li><strong>创建</strong>一个FileOutputStream对象，构造方法中传递写入数据的目的地；</li>
<li>调用FilePOutputStream对象中的<strong>write方法</strong>，把数据写入文件中；</li>
<li>释放资源(调用<strong>close方法</strong>），因为流在使用过程中会占用系统资源。</li>
</ol>
</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
public class Test &#123;
    public static void main(String[] args) throws IOException &#123;
    &#x2F;&#x2F; **创建**一个FileOutputStream对象，构造方法中传递写入数据的目的地,在路径不对时会抛出IO异常的子异常（FileNotFoundException）。
    FileOutputStream fos &#x3D; new FileOutputStream(&quot;路径&quot;);
    &#x2F;&#x2F;调用FilePOutputStream对象中的**write方法**，把数据写入文件中；
    fos.write(数据);
    &#x2F;*
    fos.write(&#39;b&#39;);
    byte[] b &#x3D; &#123;&#39;1&#39;,&#39;a&#39;,&#39;-&#39;&#125;;
    fos.write(b);
    fos.write(b, 1,  2);
    *&#x2F;
    &#x2F;&#x2F;释放资源
    fos.close();
    &#125;
&#125;</code></pre>
<ul>
<li>写入字符串：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">byte[] b &#x3D; &quot;hello world&quot;.getBytes();
fos.write(b);</code></pre>
<ul>
<li>换行
<ul>
<li>不同系统的换行符号；
<ul>
<li>Windows：<code>\r\n</code></li>
<li>linux:<code>\n</code></li>
<li>mac:<code>\r</code></li>
</ul>
</li>
<li>示例：</li>
</ul>
  <pre class="line-numbers language-java" data-language="java"><code class="language-java">FileOutputStream fos &#x3D; new FileOutputStream(&quot;a.txt&quot;,true);
        byte[] c &#x3D; &quot;hello&quot;.getBytes();
        for(int i &#x3D; 0; i &lt; 10; i++) &#123;
            fos.write(c);
            fos.write(&quot;\r\n&quot;.getBytes());
        &#125;
        fos.close();</code></pre>
</li>
</ul>
<h3 id="文件存储的原理与文本编辑器"><a class="markdownIt-Anchor" href="#文件存储的原理与文本编辑器"></a> 文件存储的原理与文本编辑器</h3>
<ul>
<li>写到硬盘中的文件是以二进制形式保存的，如果直接以int的形式输入数据，则会转换为二进制形式。如：<code>fos.write(97)</code>,实际写数据的时候会将97转化为二进制数1100001。</li>
<li>任意的文本编辑器（如记事本）在打开文件的时候都会查询编码表，把字节转换为字符表示，如果就是以字节形式输入<code>'a','1'</code>则会按照原样输出。
<ul>
<li>0~127之间的数查询ASCII表；</li>
<li>其他值：查询系统默认码表（如中文系统的GBK编码）。</li>
</ul>
</li>
<li>示例：<code>fos.write(97);</code>将97写入a.txt文件中，最终用记事本打开看见的结果为字符<code>a</code></li>
</ul>
<h3 id="字节输出流-2"><a class="markdownIt-Anchor" href="#字节输出流-2"></a> 字节输出流</h3>
<ul>
<li><code>java.io.InputStream</code>是字节输入流所有类的超类，是抽象类，定义了所有子类共性的方法</li>
<li><code>int read();</code>：从输入流中读取数据的下一个字节，返回值会转换为int类型。读到<strong>文件末尾会返回-1</strong>（因为系统会在每个文件末尾设置一个看不见的结束标记）.如果路径不存在，会有IOExcption异常。每次读取完之后，会自动“指向”后面紧接着的未被读的数据。</li>
<li><code>int read(byte[] b);</code>: 从输入流中读取一定数量的字节，并将其存储在缓冲区数组b中。数组b的长度是每次从文件中读取字节的数目。返回值是从文件中成功读取的字节数,如果一个数据都没有读到，则返回-1.</li>
<li><code>void close();</code>:关闭此输入流并释放与该流关联的所有系统资源。</li>
</ul>
<h4 id="fileinputstream类"><a class="markdownIt-Anchor" href="#fileinputstream类"></a> FileInputStream类</h4>
<ul>
<li>继承了<code>InputStream</code>类。将硬盘文件中的数据，读取到内存中使用。</li>
<li>构造方法：会有FileNotFoundException异常（是IOException异常的子类）。需要抛出或者捕获。
<ul>
<li><code>FileInputStream(String name)</code>:String name是要读取的文件的路径。</li>
<li><code>FileInputStream(File, file)</code>：File file是要读取的文件。</li>
<li>作用：创建一个FileInputStream对象，并将此对象指定构造方法中要读取的文件。</li>
</ul>
</li>
<li>输入字节流的使用步骤：
<ol>
<li>创建一个FileInputStream对象，构造方法中绑定要读取的数据源。</li>
<li>使用FileInputStream对象中的方法read，读取文件。、</li>
<li>释放资源（close方法）</li>
</ol>
</li>
<li>一次读取一个字节的示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.FileInputStream;
import java.io.IOException;

public class InputStreamTest &#123;
    public static void main(String[] args) throws IOException &#123; &#x2F;&#x2F;抛出IOException异常可以同时解决FileNotFound和IoException两个异常
        FileInputStream fis &#x3D; new FileInputStream(&quot;a.txt&quot;);
        int len &#x3D; 0;
        while((len &#x3D; fis.read() )!&#x3D; -1) &#123;
            System.out.print((char)len); &#x2F;&#x2F;要想显示字符信息，需要强制转换为char类型
        &#125;
    &#125;
&#125;</code></pre>
<ul>
<li>一次读取多个字节的示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class InputStreamTest &#123;
    public static void main(String[] args) throws IOException &#123;
        FileInputStream fis &#x3D; new FileInputStream(&quot;a.txt&quot;);
        byte[] b &#x3D; new byte[1000];
        int len &#x3D; fis.read(b);
        System.out.println(len);
        System.out.println(new String(b));&#x2F;&#x2F;利用byte数组作为参数构造String对象可以按照文件中原有的格式输出数据。
        fis.close();
        &#125;
    &#125;</code></pre>
<ul>
<li>文件复制基本操作：
<ol>
<li>创建一个字节输入流对象绑定源数据地址；创建一个字节输出流对象绑定目的数据地址。</li>
<li>read读入字节，使用write写入目的地址。</li>
<li>关闭字节输出流对象，关闭字节输入流对象。</li>
</ol>
</li>
</ul>
<h2 id="字符流"><a class="markdownIt-Anchor" href="#字符流"></a> 字符流</h2>
<ul>
<li>一个中文在GBK中占用2个字节，在utf-8占用3个字节。所以一个字节一个字节的读入文件不能得到正确的中文字符。使用字符流可以一次读取一个字符（中文，英文，符号等），解决了这个问题。</li>
</ul>
<h3 id="javaioreader类"><a class="markdownIt-Anchor" href="#javaioreader类"></a> java.io.Reader类</h3>
<ul>
<li>字符输入流：是<strong>字符输入最顶层的父类</strong>，定义了一些共性的成员方法，是一个抽象类。</li>
<li>成员方法：
<ul>
<li><code>int read();</code>:读取单个字符并返回；</li>
<li><code>int read(char[] cbuf)</code>:一次读取多个字符，将字符读入数组；</li>
<li><code>void close();</code>关闭该字符流并释放与之相关的所有资源。</li>
</ul>
</li>
</ul>
<h4 id="javaiofilereader类"><a class="markdownIt-Anchor" href="#javaiofilereader类"></a> java.io.FileReader类</h4>
<ul>
<li>继承了<code>InputStreamReader</code>和<code>Reader</code>类。</li>
<li>作用：把硬盘文件中的数据以字符的方式读取到内存中。</li>
<li>构造方法：会有FileNotFoundException异常（是IOException异常的子类）。需要抛出或者捕获。
<ul>
<li><code>FileReader(String fileName)</code></li>
<li><code>FileReader(File file)</code></li>
<li>参数：
<ul>
<li>String fileName:文件的<strong>路径</strong>；</li>
<li>File file：一个文件。</li>
</ul>
</li>
<li>作用：
<ul>
<li>创建一个FileReader对象；</li>
<li>会把FileReader对象指向我们要读取的文件。</li>
</ul>
</li>
</ul>
</li>
<li>字符输入流的使用步骤：
<ol>
<li>创建FileReader对象，构造方法中绑定要读取的数据源；</li>
<li>使用FileReader对象中的read()方法读取文件；</li>
<li>释放资源（close）。</li>
</ol>
</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
&#x2F;&#x2F;一个字符读入
import java.io.FileReader;
import java.io.IOException;

public class ReaderTest &#123;
    public static void main(String[] args) throws IOException &#123;
        &#x2F;&#x2F;创建对象
        FileReader fr &#x3D; new FileReader(&quot;a.txt&quot;);
        &#x2F;&#x2F;使用read读取文件
        int len &#x3D; 0;
        while ((len &#x3D; fr.read()) !&#x3D; -1) &#123;
            System.out.print((char)len);
        &#125;
        &#x2F;&#x2F;释放资源
        fr.close();
    &#125;
&#125;

&#x2F;&#x2F;使用字符数组，一次读入多个字符进入数组
import java.io.FileReader;
import java.io.IOException;

public class ReaderTest &#123;
    public static void main(String[] args) throws IOException &#123;

        &#x2F;&#x2F;创建对象
        FileReader fr &#x3D; new FileReader(&quot;a.txt&quot;);
        char[] cs &#x3D; new char[1024];
        int len &#x3D; 0; &#x2F;&#x2F;记录每次读取的有效字符个数
        while ((len &#x3D; fr.read(cs)) !&#x3D; -1) &#123;
            System.out.println(new String(cs, 0,len));&#x2F;&#x2F;把字符数组的一部分转换为字符串
        &#125;
    &#125;
&#125;</code></pre>
<h3 id="javaiowriter类"><a class="markdownIt-Anchor" href="#javaiowriter类"></a> java.io.Writer类</h3>
<ul>
<li>字符输出流：所有字符输出流最顶层的父类，是一个抽象类；</li>
<li>部分成员方法：
<ul>
<li><code>void write(int c);</code>写入单个字符；</li>
<li><code>void write(char[] cbuf);</code>写入字符数组；</li>
<li><code>void write(String str);</code>：写入字符串；</li>
<li><code>void flush()</code>：刷新该流的缓冲；</li>
<li><code>void close()</code>:关闭此流，但要先刷新它。</li>
</ul>
</li>
</ul>
<h3 id="javaiofilewriter类"><a class="markdownIt-Anchor" href="#javaiofilewriter类"></a> java.io.FileWriter类</h3>
<ul>
<li>继承了OutputStream和Writer类，把内存中的字符数据写入文件中。</li>
<li>构造方法：会有FileNotFoundException异常（是IOException异常的子类）。需要抛出或者捕获。
<ul>
<li><code>FileWriter(File file);</code>:根据指定的File对象构造一个FileWriter对象。</li>
<li><code>FileWriter(String filename);</code>:根据指定的文件名构造一个FileWriter对象。</li>
<li>参数：写入数据的目的地
<ul>
<li>String filename：文件的路径</li>
<li>File file：文件</li>
</ul>
</li>
<li>作用：
<ol>
<li>创建一个FileWriter对象</li>
<li>根据构造方法中传递的文件/文件的路径创建文件（该文件不存在的情况下）</li>
<li>会把FileWriter对象指向创建好的文件。</li>
</ol>
</li>
</ul>
</li>
<li>字符输出流的使用步骤：
<ol>
<li>创建FileWriter对象，构造方法中绑定要写入数据的目的地；</li>
<li>使用FileWriter对象中的write()方法，把数据写到<strong>内存数据缓冲区</strong>（字符转换为字节）</li>
<li>使用FileWriter对象中的<strong>flush方法</strong>，把内存中的数据，刷新到文件中。</li>
<li>释放资源（close():会先把内存缓冲区的文件刷新到文件中，再释放资源）</li>
</ol>
</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.FileWriter;
import java.io.IOException;

public class WriterTest &#123;
    public static void main(String[] args) throws IOException &#123;
        FileWriter fileWriter &#x3D; new FileWriter(&quot;a.txt&quot;);

        fileWriter.write(&quot;你好!&quot;);

        fileWriter.flush();

        fileWriter.close()
    &#125;
&#125;</code></pre>
<ul>
<li>续写：使用append开关：
<ul>
<li><code>FileWriter(String fileName, boolean append);</code></li>
<li><code>FileWriter(File file, boolean append);</code></li>
<li>append是续写的开关，为true则<strong>不会创建新的文件覆盖源文件</strong>，为false则创建新的文件覆盖源文件。</li>
</ul>
</li>
<li>换行：使用换行符号
<ul>
<li>windows：<code>\r\n</code></li>
<li>linux:<code>/n</code></li>
<li>mac:<code>/r</code></li>
</ul>
</li>
<li>续写和换行示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.FileWriter;
import java.io.IOException;

public class WriterTest &#123;
    public static void main(String[] args) throws IOException &#123;
        FileWriter fileWriter &#x3D; new FileWriter(&quot;a.txt&quot;,true);

        fileWriter.write(&quot;你好&quot;+ &quot;\r\n&quot;);
        fileWriter.write(&quot;你好&quot;+ &quot;\r\n&quot;);

        fileWriter.flush();

        fileWriter.close();
    &#125;
&#125;</code></pre>
<h2 id="流中的异常处理"><a class="markdownIt-Anchor" href="#流中的异常处理"></a> 流中的异常处理</h2>
<h1 id="网络编程"><a class="markdownIt-Anchor" href="#网络编程"></a> 网络编程</h1>
<ul>
<li>java具有支持Internet和WWW的完整软件包。java.net包支持Internet。</li>
</ul>
<h2 id="网络通信协议"><a class="markdownIt-Anchor" href="#网络通信协议"></a> 网络通信协议</h2>
<ul>
<li>同一个网络中的计算机在进行连接和通信时需要遵守一定的<strong>规则</strong>，这些规则被称为网络通信协议，它对数据的传输格式，速率，步骤等做了统一规定。</li>
<li>TCP/IP协议：传输控制协议/因特网互联协议（Transmission Control Protocol/Internet Protocol）是Internet最基本和广泛的协议，它定义了计算机如何炼乳因特网以及数据在它们之间传输的标准。它包含了一系列协议，并且采用了<strong>4层分层模型</strong>，每一层都呼叫它的下一层所提供的协议来完成自己的需求。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/20180930155137505.jpeg" alt="20180930155137505" />
<ul>
<li>链路层：用于定义物理传输通道，通常是对某些网络连接设备的驱动协议。</li>
<li>网络层：网络层是协议的核心，它主要用于将传输的数据进行分组并将分组后的数据放松到目标计算机或者网络。</li>
<li>运输层：主要用于网络程序之间的通信（可以用TCP协议，也可以使用UDP协议）。</li>
<li>应用层：主要负责应用程序的协议，如HTTP协议，FTP协议。</li>
</ul>
</li>
<li><strong>UDP协议</strong>：用户数据报协议（User Datagram Protocol）。
<ul>
<li>UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。</li>
<li>不能保证数据的完整性.会有丢包现象出现。</li>
<li>消耗资源少，通信效率高，通常用于音频，视频和普通数据等的传输。</li>
<li>数据限制在64kb之类，超出这个范围就不能传输了。</li>
<li><strong>数据报（Datagram）</strong>：网络传输的基本单位。</li>
</ul>
</li>
<li><strong>TCP协议</strong>：传输控制协议（Transmission control Protocol）。
<ul>
<li>TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接受端建立逻辑连接，然后再传输数据。</li>
<li>TCP协议提供了两台计算机之间<strong>可靠无差错</strong>的数据传输。</li>
<li>TCP连接必须明确客户端和服务器端，<strong>由客户端像服务器端发送请求</strong>，每次连接的创建都需要经过<strong>三次握手</strong>：</li>
<li>三次握手：在发送数据的准备阶段，客户端和服务器端之间的三次交互，以保证连接的可靠：
<ul>
<li>第一次握手：客户端向服务器端发出连接<strong>请求</strong>，等待服务器的确认；</li>
<li>第二次握手：服务器端向客户端回送一个<strong>响应</strong>，通知客户端收到了连接请求。</li>
<li>第三次握手：客户端再次向服务器端发送确认信息，确认连接。</li>
</ul>
</li>
<li>传输安全，应用广泛，例如下载文件，浏览网页等。</li>
</ul>
</li>
</ul>
<h2 id="ip地址"><a class="markdownIt-Anchor" href="#ip地址"></a> IP地址</h2>
<ul>
<li><strong>IP地址</strong>：互联网协议地址（Internet Protocol Address），IP地址用来给一个网络中的计算机设备做唯一的编号。</li>
<li>IP地址分类：
<ul>
<li>IPV4:32位的二进制数，通常被分为4个字节（每个自己的表示范围位0～255的十进制整数），表示成<code>a.b.c.d</code>格式，如：<code>192.168.65.100</code>.</li>
<li>IPV6:为了扩大地址空间，通过IPV6来重新定义地址空间，采用128位，每16个字节一组，分为8组16进制数，表示成<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>/</li>
</ul>
</li>
<li>查看本机的IP地址，在控制台输入：<code>ipconfig</code></li>
<li>检查网络是否连通,在控制台输入<code>ping IP地址</code></li>
</ul>
<h2 id="端口号"><a class="markdownIt-Anchor" href="#端口号"></a> 端口号</h2>
<ul>
<li>IP地址唯一标示网络中的设备，端口号唯一标识设备中的进程（应用程序）。</li>
<li>打开网络软件时，操作系统会为该网络软件分配端口号。</li>
<li>端口号：用两个字节表示的整数，范围（0～65535）。
<ul>
<li>1024之前的端口号，已经被系统分配给了已知的网络软件，不能再使用（一台计算机上的端口号是不能够重复的）。</li>
<li>常用端口号：
<ul>
<li>80端口：网络端口。如<code>www.baidu.com:80</code></li>
<li>Mysql默认端口号：3306</li>
<li>Tomcat默认端口号：8080</li>
</ul>
</li>
</ul>
</li>
<li>利用<code>协议+IP地址+端口号</code>可以标识网络中的进程。</li>
</ul>
<h2 id="套接字socket"><a class="markdownIt-Anchor" href="#套接字socket"></a> 套接字（socket）</h2>
<ul>
<li>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。</li>
<li>Socket的英文原义是（电力系统的）“插座”，在网络中用于描述IP地址和端口。在Internet上的主机一般同时提供几种服务，每种服务都绑定到一个端口上。客户软件将插头插到不同编号的插座（ip和端口），就可以得到不同的服务。</li>
<li>如果一个进程要通过网络向另一个进程发送数据，只需简单地写入与socket相关联的输出流。一个进程通过从与socket相关联的输入流读来读取另一个进程所写的数据。</li>
</ul>
<h2 id="客户端服务器模型"><a class="markdownIt-Anchor" href="#客户端服务器模型"></a> 客户端/服务器模型</h2>
<ul>
<li>即Client/Server(客户机/服务器)结构，通过任务合理分配到Client端和Server端，降低了系统通讯开销，可充分利用两端硬件环境优势。</li>
<li>C/S的优点是能充分发挥客户端ＰＣ的处理能力，很多工作可以在客户端处理后再提交给服务器。</li>
</ul>
<h2 id="tcp通信编程"><a class="markdownIt-Anchor" href="#tcp通信编程"></a> TCP通信编程</h2>
<h3 id="javanetsocket类客户端"><a class="markdownIt-Anchor" href="#javanetsocket类客户端"></a> java.net.Socket类：客户端</h3>
<ul>
<li>Socket类实现<strong>客户端</strong>的套接字，套接字是两台计算机之间通信的端点。
<ul>
<li>客户端和网络端进行交互必须使用Socket中提供的网络流，不能使用自己创建的流对象。</li>
<li>当我们创建客户端对象Socket的时候，就会去请求服务器，和服务器经过3次握手建立连接通信。</li>
</ul>
</li>
<li>构造方法：<code>Socket(String host, int port)</code>,创建一个流套接字并将其连接到指定主机的指定端口号；
<ul>
<li>String host：服务器的主机地址/服务器的IP地址</li>
<li>int port：服务器的端口号；</li>
</ul>
</li>
<li><code>OutputStream getOutputStream()</code>:返回此套接字的输出流</li>
<li><code>InputStream getInputStream()</code>:返回此套接字的输入流</li>
<li><code>void close()</code>：关闭此套接字；</li>
</ul>
<h3 id="javanetserversocket类服务器端"><a class="markdownIt-Anchor" href="#javanetserversocket类服务器端"></a> java.net.ServerSocket类：服务器端</h3>
<ul>
<li>ServerSocket类表示服务器端的套接字。</li>
<li>构造方法；<code>ServerSocket(int port)</code>:创建指定端口号的ServerSocket对象；</li>
<li><code>Socket accept()</code>；侦听并接受请求此ServerSocket对象的Socket对象。</li>
<li><code>void close()</code>：关闭此套接字。</li>
</ul>
<h3 id="internet寻址inetaddress类和url类"><a class="markdownIt-Anchor" href="#internet寻址inetaddress类和url类"></a> Internet寻址(InetAddress类和URL类)</h3>
<ul>
<li>InetAddress类提供有关从域名地址查询IP地址的方法，类中没有构造器。TCP/IP面向连接服务类(Socket类和ServerSocket类)。</li>
<li>getAddress() ：返回4个字节的IP地址，是4个整数，有可能是负数，需要进行转换处理，才能正确显示。</li>
<li>getHostName()：返回被查询<strong>主机域名地址</strong>，即生成InetAddress对象时使用的字符串参数。</li>
</ul>
<h2 id="tcp通信程序"><a class="markdownIt-Anchor" href="#tcp通信程序"></a> TCP通信程序</h2>
<h3 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h3>
<ul>
<li>TCP通信能够实现两台计算机之间的数据交互，通信的两端要严格区分为<strong>客户端（client）与服务器端（server）</strong>。</li>
<li>TCP通信步骤：
<ol>
<li>服务器端先启动：不会主动请求客户端；</li>
<li>客户端请求服务器端，建立逻辑连接；</li>
</ol>
</li>
<li>客户端和服务器端的逻辑连接中包含一个IO对象（字节流类型对象），客户端和服务器端使用IO对象进行通信。</li>
<li><strong>多个客户端</strong>可以同时与<strong>一个服务器</strong>进行交互。在服务器端通过<strong>accept方法</strong>来获取发送请求的客户端对象。<strong>服务器端没有IO流</strong>，服务器获取客户端Socket对象，使用每个客户端Socket对象中提供的IO流和客户端进行交互。即服务器端不会新建IO流，而是直接借用客户端的IO流来与客户端交互。</li>
<li>服务器端与客户端交互模型：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/IMG_2180.JPG" alt="IMG_2180" /></li>
</ul>
<h3 id="tcp通信程序实现"><a class="markdownIt-Anchor" href="#tcp通信程序实现"></a> TCP通信程序实现</h3>
<h1 id="集合"><a class="markdownIt-Anchor" href="#集合"></a> 集合</h1>
<h2 id="集合概述"><a class="markdownIt-Anchor" href="#集合概述"></a> 集合概述</h2>
<ul>
<li>集合是java提供的一种容器，可以用来存储多个数据。</li>
<li>集合与数组的区别：
<ul>
<li>集合的长度是可变的；</li>
<li>集合存储的都是<strong>对象</strong>，而且对象的类型可以不一致。</li>
</ul>
</li>
</ul>
<h2 id="单列集合的框架"><a class="markdownIt-Anchor" href="#单列集合的框架"></a> 单列集合的框架</h2>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201204142553.png" alt="" /></p>
<ul>
<li>List集合:有存储顺序，可以存储重复元素，有索引；
<ul>
<li>ArrayList：底层是<strong>数组</strong>实现的，查询快，增删慢；</li>
<li>LinkedList:底层是<strong>链表</strong>实现的，查询慢，增删快。</li>
</ul>
</li>
<li>Set集合：无索引，不可存储重复元素，存取无序。
<ul>
<li>HashSet:底层是<strong>哈希表+红黑树</strong>实现的，无索引，不可以存储重复元素，存取无序。</li>
<li>LinkedList：底层是<strong>哈希表+链表</strong>实现的，无索引，不可以存储重复元素，但可以包装存储<strong>顺序</strong>。</li>
<li>TreeSet:底层是<strong>二叉树</strong>实现，一般用于<strong>排序</strong>。</li>
</ul>
</li>
</ul>
<h2 id="collection接口"><a class="markdownIt-Anchor" href="#collection接口"></a> Collection接口</h2>
<ul>
<li>全称：<code>java.util.Collection</code>,是所有单列集合最顶层的接口，定义了所有单列集合共性的方法。</li>
<li>常利用<strong>多态</strong>创建Collection对象,如：<code>Collection&lt;String&gt; coll = new ArrayList&lt;&gt;();</code>,即上层接口对象指向下层实现类。</li>
<li>直接打印Collection对象，会打印出集合中所有的元素。如：<code>System.out.println(coll);</code>空集会打印一个<code>[]</code>,一般会打印<code>[张三, 李四]</code></li>
<li><code>public boolean add(E e);</code>：把给定的对象添加到当前集合中去,添加成功返回true。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">coll.add(&quot;张三&quot;);</code></pre>
<ul>
<li><code>public boolean remove(E e);</code>:把给定的对象在当前集合中删除，如果要删除的元素存在则返回true。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">coll.remove(&quot;张三&quot;);</code></pre>
<ul>
<li><code>public boolean contains(E e);</code>:判断当前集合中是否包含指定的对象，包含则返回true。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">coll.contains(&quot;张三&quot;);</code></pre>
<ul>
<li><code>public boolean isEmpty();</code>:判断当前集合是否为空，为空则返回true。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">coll.isEmpty();</code></pre>
<ul>
<li><code>public int size();</code>:返回集合中的元素个数</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">int size &#x3D; coll.size();</code></pre>
<ul>
<li><code>public Object[] toArray();</code>:把集合中的元素存储到<strong>数组</strong>中。注意返回值是<strong>Object</strong>类型的数组。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Object[] arr &#x3D; coll.toArray();
for(Object i : arr) &#123;
    System.out.println(i);
&#125;</code></pre>
<ul>
<li><code>public void clear();</code>:清空集合中所有的元素，此时集合变回和刚创建时一样。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">coll.clear();</code></pre>
<h2 id="iterator接口"><a class="markdownIt-Anchor" href="#iterator接口"></a> Iterator接口</h2>
<ul>
<li>迭代：获取Collection集合中元素的通用方法。</li>
<li>全称:<code>java.util.Iterator</code>接口，即实现迭代的迭代器。</li>
<li><code>boolean hasNext()</code>:判断集合中还有没有下一个元素，有则返回true。</li>
<li><code>E next()</code>；取出集合中的下一个元素。</li>
<li>获取Iterator接口的实现类对象方法：
<ul>
<li>实现Collection接口的实现类对象调用<code>iterator()</code>方法，这个方法返回值就是Iterator接口的实现类对象。</li>
<li><code>Iterator&lt;E&gt; iterator();</code>：迭代器的泛型跟随Collection对象的泛型。</li>
</ul>
</li>
<li>迭代器的使用步骤：
<ol>
<li>使用集合中的iterator方法获取迭代器的实现类对象，使用Iterator接口对象来接收（同Collection对象一样利用多态）；</li>
<li>使用Iterator中的hasNext方法来判断是否还有下一个元素</li>
<li>使用Iterator中的next方法取出集合中的下一个元素。</li>
</ol>
</li>
<li>迭代器理解：
<ul>
<li>可以将集合想象为一个表，迭代器中有一个游标指向当前行，开始时这个游标是指向表头的。每取一次下一个元素，这个游标都会移向下一行（即取出了元素这一行）。</li>
<li>如果试图取出没有元素的行的值，会出现NoSuchElementException异常。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Collection&lt;String&gt; coll &#x3D; new ArrayList&lt;&gt;();
coll.add(&quot;张三&quot;);
coll.add(&quot;李四&quot;);
Iterator&lt;String&gt; it &#x3D; coll.iterator(); &#x2F;&#x2F;多态的使用
while(it.hasNext()) &#123;
    System.out.println(it.next());
&#125;</code></pre>
<ul>
<li>增强for循环：又称for-each循环，是jdk1.5以后，java提供的利用迭代器原理的新特性。用来遍历数组或者集合。(只可以用来遍历，不能用来修改集合或者数组)。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">for(Object i : coll) &#123;
    System.out.println(i);
&#125;</code></pre>
<h1 id="java的api"><a class="markdownIt-Anchor" href="#java的api"></a> Java的API</h1>
<hr />
<p>实在是太多了，可以在需要时查看API的<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/15/docs/api/index.html">官方文档</a>或者<a target="_blank" rel="noopener" href="https://tool.oschina.net/apidocs/apidoc?api=jdk-zh">在线中文文档</a></p>
<h2 id="javalangobject"><a class="markdownIt-Anchor" href="#javalangobject"></a> java.lang.Object</h2>
<ul>
<li><code>Class getClass()</code>:返回包含对象信息的类对象。</li>
<li><code>boolean equals(Object otherObject)</code>:比较两个对象是否相等。</li>
<li><code>String toString()</code>:返回表示该对象值的字符串。</li>
</ul>
<h2 id="javalangclass"><a class="markdownIt-Anchor" href="#javalangclass"></a> java.lang.Class</h2>
<ul>
<li><code>String getName()</code>:返回这个类的名字；</li>
<li><code>Class getSuperclass()</code>:以Class对象的的形式返回这个类的超类。</li>
<li><code>public static Class&lt;T&gt; forName(String className) throws ClassNotFoundException</code>:返回与带有给定字符串名的类或接口相关联的 Class 对象。调用此方法等效于：<code>Class.forName(className, true, currentLoader)</code>其中 currentLoader 表示当前类的定义类加载器。
<ul>
<li>例如，以下代码片段返回命名为 java.lang.Thread 的类的运行时 Class 描述符。<code>Class t = Class.forName(&quot;java.lang.Thread&quot;)</code>。参数：className - 所需类的完全限定名。返回：具有指定名的类的 Class 对象。抛出：LinkageError - 如果链接失败;ExceptionInInitializerError - 如果此方法所激发的初始化失败;ClassNotFoundException - 如果无法定位该类。</li>
</ul>
</li>
<li><code>public String toString()</code>:将对象转换为字符串。字符串的表示形式为字符串 “class” 或 “interface” 后面紧跟一个空格，然后是该类的完全限定名，它具有 getName 返回的那种格式。如果此 Class 对象表示一个基本类型，则此方法返回该基本类型的名称。如果该 Class 对象表示 void，则此方法返回 “void”。覆盖：类 Object 中的 toString;返回：表示此 class 对象的字符串。</li>
</ul>
<h2 id="javautilobjects"><a class="markdownIt-Anchor" href="#javautilobjects"></a> java.util.Objects</h2>
<ul>
<li>可以看做是Object类针对多个对象进行处理的类似的类。</li>
<li>判断两对象是否相等的方法：<code>static boolean equals(Object a, Object b)</code>。</li>
<li>提供散列码的方法（hashcode）:
<ul>
<li><code>static int hash(Object...objects)</code>，返回一个散列码，由提供的所有对象的散列码组合得到。</li>
<li><code>static int hashCOde(Object a)</code>如果a为null返回0，否则返回a.hashCode()的结果（即Object类中的hashCode方法增加了对null的处理）</li>
</ul>
</li>
<li>判断对象是否为空并抛出异常的方法：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public static &lt;T&gt; T requireNonNull(T obj,String message) &#123;
    if (obj &#x3D;&#x3D; null) &#123;
        throw new NullPointerException(message);
    &#125;
    return obj;
&#125;</code></pre>
<h2 id="javautillist"><a class="markdownIt-Anchor" href="#javautillist"></a> java.util.List</h2>
<h2 id="math"><a class="markdownIt-Anchor" href="#math"></a> Math</h2>
<h2 id="javatimelocaldate"><a class="markdownIt-Anchor" href="#javatimelocaldate"></a> java.time.LocalDate</h2>
<h2 id="javautilrandom"><a class="markdownIt-Anchor" href="#javautilrandom"></a> java.util.Random</h2>
<ul>
<li><code>Random()</code>返回一个随机数生成器（对应的类的对象）</li>
<li><code>int nextInt(int n)</code>，返回一个0~n-1之间的随机数的方法。</li>
</ul>
<h2 id="javautilarrayliste-泛型数组列表"><a class="markdownIt-Anchor" href="#javautilarrayliste-泛型数组列表"></a> java.util.ArrayList<E> （泛型数组列表）</h2>
<ul>
<li>ArrayList类类似于数组，但是它能在添加或者删除元素时，<strong>自动调整数组的容量</strong>。</li>
<li>ArrayList是有<strong>类型参数</strong>的<strong>泛型类</strong>（所以又被称为<strong>泛型数组列表</strong>），泛型类是可以在使用时再声明具体类型的。使用时为了指明数组保存的元素的类型，可以使用一对尖括号<code>&lt;&gt;</code>来将具体的类名追加到ArrayList后面。如<code>Array&lt;Employee&gt; staff = new ArrayList&lt;Employee&gt;();</code>.在这种方式中可以去掉后一个尖括号中的类型<code>Array&lt;Employee&gt; staff = new ArrayList&lt;&gt;(可以在这里填数组列表的容量,也可以不写。即使写了容量，这个容量仍是可以在使用时动态改变的);</code>,这种使用空的尖括号的方式又被称为<strong>菱形语法</strong>。</li>
<li>使用<code>boolean add(E obj)</code>方法可以将元素<strong>加到数组列表</strong>中，如<code>staff.add(i)</code>.<code>void add(int index, E obj)</code>。可以在数组内部指定位置插入元素，并使后面的元素后移，同时数组长度加一。</li>
<li><code>int size()</code>方法返回数组列表中现在的元素个数。如<code>length = staff.size()</code>.</li>
<li>不能使用普通的<code>[下标]</code>来访问数组列表中的元素。使用<code>get()</code>方法来访问数组列表中第i个元素，如<code>value = staff.get(i)</code>。使用<code>set()</code>方法来对第i个元素进行赋值。如<code>staff.set(i, value)</code>.</li>
<li><code>remove()</code>方法删除指定位置的元素，并将之后的所有元素前移，返回所删除的元素。如<code>staff.remove(i)</code>.</li>
<li><code>void ensureCapacity(int capacity)</code>方法可以给数组分配一个有具体数量的数组空间如：<code>staff.ensure(100)</code>。与直接在创建数组列表时声明大小的效果一样。</li>
<li>遍历：泛型数组列表同样可以用<code>for each</code>循环来遍历每个元素。</li>
</ul>
<h2 id="javautilstacke"><a class="markdownIt-Anchor" href="#javautilstacke"></a> java.util.Stack<E></h2>
<ul>
<li>这是java用于实现栈功能的类。</li>
<li>初始化一个空栈：<code>Stack&lt;Interger&gt; stack1 = new Stack&lt;Interger&gt;();</code>,因为栈也是使用泛型的，所以初始化的时候需要<strong>指定类型</strong>。</li>
<li>判断栈是否为空:<code>stack1.empty()</code>,方法<code>boolean empty()</code></li>
<li>查看栈顶部的元素但不取出：<code>stack1.peek()</code>,方法<code>Object peek()</code>，Object是指返回值的类型是由初始化的时候指定的，具体为哪种并不确定。</li>
<li>进栈：<code>stack1.push(Object element);</code>，方法<code>Object push(Object element)</code></li>
<li>出栈：<code>stack1.pop();</code>,方法<code>Object pop()</code>.</li>
<li>返回某个值在堆栈中的位置从，位置是从1开始的：方法<code>int search(Object element)</code>.</li>
</ul>
<h2 id="javautilarrays"><a class="markdownIt-Anchor" href="#javautilarrays"></a> java.util.Arrays</h2>
<ul>
<li>这是一个主要用来对数组进行处理的类。</li>
<li>判断两个数组是否相等的静态方法：<code>static boolean equals(xxx[] a, xxx[] b)</code>.如果两个数组长度相同且对应位置的元素相等，则返回true，否则返回false。</li>
<li>打印数组:<code>Arrays.toString(数组名)</code>。结果是一个形如&quot;[1, 2, 3, 4]&quot;的字符串。打印多维数组需要调用<code>Arrays.deepToString(数组名)</code>。</li>
<li>拷贝数组<code>数组名1.toArray(数组名2)</code>。将数组1的数组元素拷贝到数组2中去。</li>
<li><code>static void sort(Object[] a)</code>:对数组a中的元素进行排序，要求数组中的元素必须实现了Comparable接口的类，并且元素之间必须是可以比较的。</li>
</ul>
<h2 id="javalanginteger"><a class="markdownIt-Anchor" href="#javalanginteger"></a> java.lang.Integer</h2>
<ul>
<li><code>int intValue()</code>:将该Integer的对象的值作为一个int返回。</li>
<li><code>static String toString(int i)</code>:返回一个String对象，表示指定数值的十进制表示。</li>
<li><code>static String toString(int i, int radix)</code>：返回数值i基于radix参数指定进制的表示。</li>
<li><code>static int parseInt(String s)</code>：将字符串转换为十进制整型返回。</li>
<li>`static int pardeInt(String s, int radix)：将字符串转换为radix进制整型返回。</li>
<li><code>static Integer valueOf(String s)</code>:返回一个Integer对象，用s表示的十进制整数初始化。</li>
<li><code>static Integer valueOf(String s, int radix)</code>：返回一个Integer对象，用s表示的radix进制数初始化。</li>
<li><code>static int compare(int x, int y)</code>:对两个整数进行比较，如果x &lt; y,返回负整数，如果x=y返回0， x &gt; y返回一个正整数。</li>
</ul>
<h2 id="javalangenume"><a class="markdownIt-Anchor" href="#javalangenume"></a> java.lang.Enum<E></h2>
<ul>
<li><code>static Enum valueOf(Class enumClass, String name)</code>：返回给定类中指定名字的枚举常量。</li>
<li><code>String toString()</code>:返回枚举常量名。如<code>Size.SMALL.toString()</code>返回字符串&quot;SMALL&quot;.</li>
<li><code>int ordinal()</code>：返回枚举常量在enum中声明的位置，位置从0开始计数。</li>
<li><code>int compareTO(E other)</code>:如果枚举常量出现在other之前，返回一个负整数；如果this==other，返回0； 其他情况返回一个正整数。</li>
</ul>
<h2 id="javalangcomparablet"><a class="markdownIt-Anchor" href="#javalangcomparablet"></a> java.lang.Comparable<T></h2>
<ul>
<li>这是一个接口。其中要求了<code>int comparable(T other)</code>方法。这个方法要求对象小于other返回一个负整数，相等返回0，大于返回正整数。</li>
</ul>
<h2 id="javalangthrowable异常"><a class="markdownIt-Anchor" href="#javalangthrowable异常"></a> java.lang.Throwable(异常)</h2>
<ul>
<li><code>Thorwable()</code>:构造一个Throwable对象但是没有详细的描述信息</li>
<li><code>Throwable(String message)</code>: 构造一个Throwable对象，带有指定的详细描述信息。</li>
<li><code>String getMessage()</code>:获得Throwable对象的简短描述信息。</li>
<li><code>vois PrintStackTrace()</code>:jvm打印堆栈轨迹（异常的信息），是最全面的异常信息（包括类名，方法名及所在程序的行数等）。</li>
<li><code>String toString();</code>返回此异常的描述消息字符串。</li>
</ul>
<h2 id="javauitlproperties配置文件"><a class="markdownIt-Anchor" href="#javauitlproperties配置文件"></a> java.uitl.Properties(配置文件)</h2>
<ul>
<li>Properties类继承自Hashtable类并且实现了Map接口。该类主要用于<strong>读取Java</strong>的配置文件，不同的编程语言有自己所支持的配置文件，配置文件中很多变量是经常改变的，为了方便用户的配置，能让用户够脱离程序本身去修改相关的变量设置。就像在Java中，其配置文件常为<code>.properties</code>文件，是以键值对的形式进行参数配置的。</li>
<li>层次关系：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201206084813.jpg" alt="" /></li>
<li>字段：<code>protected Properties defaults</code>,一个属性列表，包含属性列表中所有<strong>未找到值</strong>的键的默认值。</li>
<li>构造方法：
<ul>
<li><code>public Properties()</code>:创建一个无默认值的空属性列表。</li>
<li><code>public Properties(Properties defaults)</code>:创建一个带有指定默认值的空属性列表。参数：defaults - 默认值。</li>
</ul>
</li>
<li>方法：
<ul>
<li><code>public String getProperty(String key)</code>:用指定的键在此属性列表中搜索属性。如果在此属性列表中未找到该键，则接着递归检查默认属性列表及其默认值。如果未找到属性，则此方法返回 null。参数：key - 属性键。</li>
<li><code>public String getProperty(String key,String defaultValue)</code>:用指定的键在属性列表中搜索属性。如果在属性列表中未找到该键，则接着递归检查默认属性列表及其默认值。如果未找到属性，则此方法返回<strong>默认值变量</strong>。参数：key - 哈希表defaultValue - 默认值。返回：属性列表中具有指定键值的值。</li>
<li><code>public void load(Reader reader)throws IOException</code>:按简单的面向行的格式从输入字符流中读取属性列表（键和元素对）此方法返回后，指定的<strong>流仍保持打开状态</strong>。参数：reader - 输入字符流(Reader是FileReader的上两级父类）。抛出：IOException - 如果从输入流读取时发生错误。IllegalArgumentException - 如果输入中出现了错误的 Unicode 转义。。</li>
</ul>
</li>
</ul>
<h2 id="javaneturl"><a class="markdownIt-Anchor" href="#javaneturl"></a> java.net.URL</h2>
<ul>
<li>类 URL 代表一个统一资源定位符，它是指向互联网“资源”的指针。资源可以是简单的文件或目录，也可以是对更为复杂的对象的引用，例如对数据库或搜索引擎的查询。<br />
*<code>http://www.socs.uts.edu.au:80/MosaicDocs-old/url-primer.html</code></li>
<li>通常，URL 可分成几个部分。上面的 URL 示例指示使用的<strong>协议</strong>为 http （超文本传输协议）并且该信息驻留在一台名为 <a target="_blank" rel="noopener" href="http://www.socs.uts.edu.au">www.socs.uts.edu.au</a> 的<strong>主机</strong>上。主机上的信息名称为 /MosaicDocs-old/url-primer.html。主机上此名称的准确含义取决于协议和主机。该信息一般存储在文件中，但可以随时生成。该 URL 的这一部分称为<strong>路径</strong>部分。URL 可选择指定一个“<strong>端口</strong>”，它是用于建立到远程主机 TCP 连接的端口号。如果未指定该端口号，则使用协议默认的端口。</li>
<li><code>public String getPath()</code>:获取此 URL 的路径部分。返回：此 URL 的路径部分，如果没有路径，则返回一个空字符串</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/Python/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/Python/index.html" class="post-title-link" itemprop="url">Python</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-05 20:45:19" itemprop="dateCreated datePublished" datetime="2020-09-05T20:45:19+08:00">2020-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-09-26 21:42:19" itemprop="dateModified" datetime="2021-09-26T21:42:19+08:00">2021-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>26k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>24 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="python概述"><a class="markdownIt-Anchor" href="#python概述"></a> python概述</h1>
<ol>
<li>Python是一门解释性语言，无需编译和链接。</li>
<li>Python解释器是可以交互的，因此Python甚至可以用作桌面计算器。</li>
<li>Python是可扩展的，可以为Python的解释器添加内置函数和模块。</li>
<li>本文学习的是Python3.</li>
</ol>
<h2 id="解释器"><a class="markdownIt-Anchor" href="#解释器"></a> 解释器</h2>
<ul>
<li>trackback:程序无法成功地运行时，解释器会提供一个traceback。traceback是一条记录，指出了解释器尝试运行代码时， 在什么地方陷入了困境。</li>
</ul>
<h2 id="python编写规范"><a class="markdownIt-Anchor" href="#python编写规范"></a> Python编写规范</h2>
<p><a target="_blank" rel="noopener" href="https://python.freelycode.com/contribution/detail/47">PEP8编写规范</a></p>
<ul>
<li><strong>python之禅</strong>：Python社区的理念都包含在TimPeters撰写的“Python之禅”中。要获悉这些有关编写优秀Python代码的指导原则，只需在解释器中执行命令<code>import this</code>。</li>
<li><strong>Python改进提案（Python Enhancement Proposal，PEP）</strong>。PEP 8是最古老的PEP之一，它向Python程序员提供了代码格式设置指南。PEP 8的篇幅很长，但大都与复杂的编码结构相关。</li>
<li><strong>缩进</strong>：每级缩进都使用四个空格;
<ul>
<li>如果你混合使用了制表符和空格，可将文件中所有的<strong>制表符转换为空格</strong></li>
</ul>
</li>
<li><strong>空格</strong>：
<ul>
<li>在诸如== 、&gt;= 和&lt;= 等<strong>比较运算符</strong>两边各添加一个空格，例如，<code>if age &lt; 4:</code> 要比<code>if age&lt;4:</code>好。</li>
</ul>
</li>
</ul>
<h2 id="python的注释"><a class="markdownIt-Anchor" href="#python的注释"></a> python的注释</h2>
<ul>
<li>Python中使用<code>#</code>做注释符，即使是在解释器的交互编程中也可以使用<code>#</code>注释符。</li>
</ul>
<h1 id="变量和数据类型结构"><a class="markdownIt-Anchor" href="#变量和数据类型结构"></a> 变量和数据类型(结构)</h1>
<h2 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h2>
<ul>
<li>变量名只能包含<strong>字母、数字和下划线</strong>。变量名可以以字母或下划线打头，但不能以数字打头，例如，可将变量命名为message_1，但不能将其命名为1_message。</li>
<li>变量名不能包含空格，但可使用下划线来分隔其中的单词。例如，变量名greeting_message可行，但变量名greeting message会引发错误。</li>
<li>不要将Python关键字和函数名用作变量名，即不要使用Python保留用于特殊用途的单词，如print。</li>
<li>变量名应既简短又具有描述性。例如，name比n好，student_name比s_n好，name_length比length_of_persons_name好。 慎用小写字母l和大写字母O，因为它们可能被人错看成数字1和0。</li>
<li>就目前而言，应使用小写的Python变量名。在变量名中使用大写字母虽然不会导致错误，但避免使用大写字母是个不错的主意。</li>
</ul>
<h2 id="一数字"><a class="markdownIt-Anchor" href="#一数字"></a> 一：数字</h2>
<ul>
<li>常用的数据类型有int、float，但是Python还有其它很多数据类型。例如复数类型（complex）,这种类型中使用j或者J代表复数部分，如<code>5+2j</code>.</li>
<li>基本运算
<ul>
<li>Python支持基本的<code>+</code>,<code>-</code>,<code>*</code>以及<code>/</code>，<code>%</code>（求模/余）的运算，但是和c语言不同的是，<code>/</code>默认的结果是浮点型。使用<code>//</code>可以做返回值为int型的除法运算（类似c语言的普通除法运算）.</li>
<li>Python还支持<strong>幂方运算</strong><code>**</code>,<code>5**2</code>表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>5</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">5^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">5</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>；</li>
<li>python仍旧使用<code>=</code>为变量赋值，同c语言一样，Python中的变量在使用前必须先进行赋值。（但是在交互式编程中，Python内置了一个变量<code>_</code>,存储最近一个表达式的运算结果，这个变量无需赋值，便可直接使用，事实上，<code>_</code>是一个只读变量，对它赋值是没有意义的。）</li>
<li>python的赋值可以进行多重赋值，例如：<code>a, b = 0, 1</code>相当于<code>a = 0, b = 1</code></li>
<li>在字符串中使用<strong>数值类型时</strong>，需要显式地指出你希望Python将这个整数用作字符串。为此，可调用函数<code>str()</code> ， 它让Python将非字符串值表示为字符串,如：<code>print(&quot;age:&quot;+str(19))</code></li>
</ul>
</li>
</ul>
<h2 id="二字符串"><a class="markdownIt-Anchor" href="#二字符串"></a> 二：字符串</h2>
<ul>
<li>字符串可以用单引号<code>''</code>或者双引号<code>&quot;&quot;</code>表示;
<ul>
<li>灵活地使用单引号和双引号来使字符串中可以<strong>嵌套引号和撇号</strong>，如：
<ul>
<li><code>'I told my friend, &quot;Python is my favorite language!&quot;'</code></li>
<li><code>&quot;The language 'Python' is named after Monty Python, not the snake.&quot;</code></li>
<li><code>&quot;One of Python's strengths is its diverse and supportive community.&quot;</code></li>
</ul>
</li>
</ul>
</li>
<li>引号可以用<code>\</code>来转义。</li>
<li>字符串可以用<code>+</code>连接，如<code>'zhang'+'jie'</code>合为<code>'zhangjie'</code>.</li>
<li>字符串可以用<code>*</code>重复输出。<code>'zj'*3</code>即为<code>'zjzjzj'</code>。</li>
<li>字符串可以被索引，进行类似c语言的取出字符串的中字母的操作。如：<code>word = 'python</code>, <code>word[0] == 'p'</code>;
<ul>
<li><strong>索引可以为负数</strong>，这会从右边开始索引。如：<code>word = 'python'</code>,<code>word[-1] = 'n'</code>(负索引是从-1开始，而不是0)。</li>
</ul>
</li>
<li>字符串可以被切片。如<code>word = 'python'</code>,则<code>word[0:2] = 'py'</code>,包含起始的字符，不包含末尾的字符。切片可以省略，省略左边，默认为从0开始，省略右边，则默认到末尾。如<code>word[:3] = 'pyt'</code>,<code>word[1:] = 'ython'</code>。</li>
<li>字符串<strong>是不可变的</strong>，不可以被修改。如果需要修改，只能创建一个新的字符串，并在创建的过程中，将修改加进去。</li>
<li>制表符<code>\t</code>:添加四个空格，如：<code>print(&quot;\tPython&quot;)</code></li>
<li>换行符<code>\n</code>:换到下一行。</li>
</ul>
<h3 id="字符串对象方法"><a class="markdownIt-Anchor" href="#字符串对象方法"></a> 字符串对象方法</h3>
<ul>
<li><code>title()</code>:以首字母大写的方式显示每个单词，即将每个单词的首字母都改为大写。其中以空格区分单词。</li>
<li><code>upper()</code>:将字符串改为全部大写</li>
<li><code>lower()</code>:将字符串改为全部小写,存储数据时，方法lower() 很有用。很多时候，你无法依靠用户来提供正确的大小写，因此需要将字符串先转换为小写，再存储它们。以后需要显示这些信息时，再将其转换为 最合适的大小写方式。</li>
<li>删除空白的方法：
<ul>
<li><code>rstrip()</code>:删除字符串末尾的空白,只是输出的结果中没有了空白，要想将字符串变量中的空白永久删除，需要将结果重新赋值给字符串变量。</li>
<li><code>lstrip()</code>:删除字符串开头的空白。</li>
<li><code>strip()</code>:同时删除字符串两端的空白。</li>
</ul>
</li>
<li></li>
</ul>
<h2 id="三列表"><a class="markdownIt-Anchor" href="#三列表"></a> 三：列表</h2>
<h3 id="列表的基本性质"><a class="markdownIt-Anchor" href="#列表的基本性质"></a> 列表的基本性质</h3>
<ul>
<li>列表由一系列按<strong>特定顺序排列的元素组成</strong>。你可以创建包含字母表中所有字母、数字0~9或所有家庭成员姓名的列表；也可以将任何东西加入列表中，其中的元素之间可以没有任何关系。鉴于列表通常包含多个元素，给列表指定一个表示复数的名称（如letters 、digits 或names ）是个不错的主意。</li>
<li>用方括号<code>[]</code>来表示列表，并用逗号来分隔其中的元素。</li>
<li>列表类似c语言的数组。但是列表中的元素不需要是同一类型。</li>
<li>列表的赋值：如<code>list1 = [1, 2, 3, 4, 5]</code>， <code>list2 = [1, 'a', 2, 'b', 3,[1, 2,&quot;zhangjie&quot;]]</code>,<code>list3 = []</code>。</li>
<li>访问列表元素：类似数组，通过<strong>索引</strong>来访问列表中的元素。如：<code>list1[0]</code>访问的元素是1。
<ul>
<li>最后一个列表元素可以通过索引-1来访问，如：<code>list1[-1]</code>访问的是5。</li>
<li>用负数索引，是从-1开始从右往左依次索引。</li>
</ul>
</li>
<li>同字符串一样，列表也可以被切片和索引。
<ul>
<li>可以<strong>通过切片来复制一个列表</strong>，如：<code>list2 = list1[:]</code>,如果直接赋值，引用还是同一个列表：<code>list2 = list1</code>，两个列表名其实是一个列表的两个不同名字。</li>
</ul>
</li>
<li>同字符串一样，列表也支持使用<code>+</code>进行连接,使用<code>*</code>进行重复。但是连接和重复的对象都必须是列表，返回的结果也是列表。</li>
<li>与字符串不同的是，列表中的元素是<strong>可以修改</strong>的。可以利用赋值操作对列表中某个元素进行修改。</li>
<li>可以使用append（）方法，在列表后面加元素。(括号中放需要加的元素。)</li>
<li>列表中可以嵌套列表。</li>
<li>使用函数<code>len()</code>，可以得到列表或者字符串的长度。如；<code>len(list1)</code>的结果为5.</li>
<li>可以使用函数<code>enumerate(序列)</code>来同时得到元素的值和索引值。</li>
</ul>
<h3 id="列表中常用的方法"><a class="markdownIt-Anchor" href="#列表中常用的方法"></a> 列表中常用的方法</h3>
<ul>
<li><code>list.append（x）</code>在列表的后面加上一个元素x。</li>
<li><code>list.extend(L)</code>将一个给定列表（L）中的元素全部都加到另一个列表里（list）.</li>
<li><code>list.insert(i, x)</code>在列表的指定元素之前插入元素。其中第一个参数是指定列表中元素的索引，第二个参数是要插入的值。如，<code>list.insert(0, 5)</code>是在整个列表前插入一个5.</li>
<li><code>list.remove(x)</code>删除列表中值为x的第一个元素，如果没有这样的元素，则会返回错误。</li>
<li><code>list.pop([i])</code>类似栈里面的弹出，会删除列表里指定元素并返回它的值。如果<strong>没有指定参数</strong>则默认对列表的最后一个元素进行操作。（另外，参数用方括号[]括起来是表示，这个参数是可以有也可以没有的）。结合<code>append</code>方法和<code>pop</code>方法可以将列表当做一个栈使用。</li>
<li><code>list.clear()</code>删除列表中的所有元素，此时打印列表只剩下一对空的方括号。</li>
<li><code>list.index(x)</code>返回列表中第一个值为x的元素的索引，如果不存在这样的元素，则返回一个错误。</li>
<li><code>list.count(x)</code>返回值x在列表中出现的次数。</li>
<li><code>list.sort()</code>会对列表中的元素进行永久性正向排序（即按字母顺序从小到大）;
<ul>
<li>传递参数<code>reverse=True</code>可以对元素进行永久性反向排序（按字母顺序从大到小），如：<code>list.sort(reverse=True)</code></li>
</ul>
</li>
<li><code>sorted(list)</code>对列表中的元素进行临时正向排序，排序规则与sort方法相同，如：<code>print(sorted(list))</code></li>
<li><code>list.reverse()</code>会对列表中的元素进行逆序排列，不是指按与字母顺序相反的顺序排列列表元素，而只是反转列表元素的排列顺序。</li>
<li><code>list.copy()</code>会返回一个列表的拷贝。</li>
</ul>
<h3 id="列表的应用"><a class="markdownIt-Anchor" href="#列表的应用"></a> 列表的应用</h3>
<ul>
<li>当作栈使用。</li>
<li>当作队列使用。需要引入collections.deque方法。</li>
</ul>
<h3 id="列表解析"><a class="markdownIt-Anchor" href="#列表解析"></a> 列表解析</h3>
<ul>
<li>列表可以由公式推出其中的元素。列表推导式由包含一个表达式的方括号组成，<strong>表达式用于存储要存入列表的结果</strong>，表达式后面跟随一个 for 子句，之后可以有零或多个 for 或 if 子句。结果是一个列表，由表达式依据其后面的 for 和 if 子句上下文计算而来的结果构成。</li>
<li>例如： <code>[(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]</code>,它的结果为<code>[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]</code>。</li>
</ul>
<h3 id="del语句"><a class="markdownIt-Anchor" href="#del语句"></a> del语句</h3>
<ul>
<li>del语句可以<strong>根据索引删除列表中的元素。del语句也可以删除列表中的切片</strong>。例如：<code>del list[1]</code>以及<code>del list[2:4]</code>,<code>del list[:]</code>。</li>
<li>del语句还可以删除整个变量，<code>del list</code>.在del删除整个变量后，再次调用该变量会报错，除非再次这个变量赋值。</li>
</ul>
<h3 id="range函数"><a class="markdownIt-Anchor" href="#range函数"></a> range()函数</h3>
<ul>
<li>range()会生成一个指定长度的链表，例如：`range(10),会生成一个<strong>从0到9</strong>的序列，即参数10是指定生成的链表的长度，默认情况下，这个等差链表是从0开始的。</li>
<li>可以指定range生成的链表的起始和结束，例如：<code>range(5, 10)</code>会生成一个从5到9的链表。</li>
<li>可以指定链表的步长（即公差，可以为负数）。例如：<code>range(0, 10, 3)中的第一个参数是起始的数，结束的数为10（永远不会包含指定的结束数），3为步长</code>,结果为0， 3， 6， 9。可以把步长设置为负数，形成从大到小的链表。例如<code>range(-10, -100, -30)</code>,结果-10，-40，-70。</li>
</ul>
<h2 id="四元组"><a class="markdownIt-Anchor" href="#四元组"></a> 四：元组</h2>
<ul>
<li>元组与列表有很多地方类似的，但是元组是用<strong>圆括号来定义</strong>的。</li>
<li>元组和字符串一样是<strong>不可变</strong>的，一般是通过索引来访问其中的元素值。
<ul>
<li>虽然不能修改元组的元素，但可以给存储元组的变量赋值。如：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">dimensions&#x3D;(1,2)
dimensions&#x3D;(3,4)</code></pre>
</li>
<li>元组中的元素可以是<strong>不同类型</strong>的，但是列表中的元素必须是<strong>同一类型</strong>的。</li>
<li>元组的定义可以省掉括号，但最好带上。</li>
<li>元组的常见形式， <code>t = 12345, 'hello'</code>，<code>t = (1, 3 ,&quot;zhangjie&quot;)</code></li>
</ul>
<h2 id="五集合set"><a class="markdownIt-Anchor" href="#五集合set"></a> 五：集合（set）</h2>
<ul>
<li>集合同数学中的定义一样，是一个无序不重复的集。集合中的元素可以是不同的类型的。如果在给集合定义或者复制时，有重复的元素，并不会报错，但是Python会自动删除集合中重复的元素，最终只留下一个元素。</li>
<li>可以使用花括号<code>&#123;&#125;</code>或者<code>set()</code>函数来创建集合。例如：<code>a = &#123;1, 'hello'&#125;</code>或者<code>a = set('abcdefg')</code>。使用set必须有单引号<code>''</code>或者双引号<code>&quot;&quot;</code>，并且set会把被引号包围的任何东西拆分，并按照随机顺序存入集合中。（定义空集合只能使用set(),而不能使用花括号｛｝）</li>
<li>集合也可类似列表使用推导式来定义其内的元素。</li>
<li>集合中可以使用<code>&amp;并，^交，-, |</code>等数学集合运算。</li>
</ul>
<h2 id="六字典"><a class="markdownIt-Anchor" href="#六字典"></a> 六：字典</h2>
<ul>
<li>字典与列表不同，它是根据事先存好的的关键字来索引具体元素的。就像真实的字典一样,在Python中，字典是一系列<strong>键—值对</strong> 。每个键都与一个值相关联,形如<code>key:value</code>，你可以使用键来访问与之相关联的值。与键相关联的值可以是数字、字符串、列表乃至字典。事实上，可将任何Python对象用作字典中的值。</li>
<li>使用<strong>花括号</strong>来创建字典。例如；<code>dict = &#123;'key1':1, 'key2': 2&#125;</code>。一对空的花括号可以创建一个空的字典。</li>
<li>可以直接给字典<strong>增加关键字和对应的值</strong>:<code>dict['key3'] = 3</code>.要<strong>修改字典中的值</strong>，可依次指定字典名、用方括号括起的键以及与该键相关联的新值。</li>
<li>键—值对是两个相关联的值。指定键时，Python将返回与之相关联的值。键和值之间用<strong>冒号</strong>分隔，而键—值对之间用<strong>逗号</strong>分隔。在字典中，你想存储多少个键—值对都可以。</li>
<li>要获取与键相关联的值，可依次指定字典名和放在方括号内的键,如：<code>print(dict['key1'])</code>。</li>
<li>注意，键—值对的<strong>排列顺序与添加顺序不同</strong>。Python不关心键—值对的添加顺序，而只关心键和值之间的关联关系。</li>
<li>对于字典中不再需要的信息，可使用<strong>del 语句将相应的键—值对彻底删除</strong>。使用del 语句时，必须指定字典名和要删除的键。如：<code>del dict['key1']</code>.</li>
<li>使用关键字<code>in</code>可以确认某个关键字是否在字典中。例如；<code>'key1' in dict</code>,如果’key1’存在的话返回True，否则返回False。（类似的还有<code>'key1' not in dict</code>的写法）、</li>
<li>可以使用方法<code>字典名.items()</code><strong>同时读出字典中的关键字和值</strong>（常用在循环中遍历字典）。</li>
<li>使用方法 <code>字典名.keys()</code>可以返回一个字典中的<strong>全部关键字</strong>。</li>
<li>可使用方法<code>values()</code>，它<strong>返回一个值列表，而不包含任何键</strong>。</li>
<li>遍历循环示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"># 遍历键值对
for key, value in dict.items():
    print(&quot;key &#x3D; &quot; + key)
    print(&quot;value &#x3D; &quot; + value)

# 只遍历键
for key in dict.keys():
    print(&quot;key &#x3D; &quot;  + key)</code></pre>
<ul>
<li>可使用函数<code>sorted()</code>来获得按特定顺序排列(特定顺序是指按字母的大小写顺序等默认的顺序)的键列表的副本,如：<code>for name in sorted(dict.keys()):</code></li>
<li>dic()函数可以从值对列表中创建字典。</li>
<li>通过对包含重复元素的列表调用<code>set()</code>方法 ，可让Python找出列表中<strong>独一无二的元素，并使用这些元素来创建一个集合</strong>。如：<code>for value in set(dict.values()):</code></li>
<li>字典推导式也是同样可以使用的。</li>
<li>我们将较大的字典放在多行中:</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">favorite_languages &#x3D; &#123;
    &#39;jen&#39;: &#39;python&#39;,
    &#39;sarah&#39;: &#39;c&#39;,
    &#39;edward&#39;: &#39;ruby&#39;,
    &#39;phil&#39;: &#39;python&#39;,
    &#125;</code></pre>
<ul>
<li>字典和列表等可以相互嵌套，如：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"># 列表中嵌套字典
alien_0 &#x3D; &#123;&#39;color&#39;: &#39;green&#39;, &#39;points&#39;: 5&#125;
alien_1 &#x3D; &#123;&#39;color&#39;: &#39;yellow&#39;, &#39;points&#39;: 10&#125;
alien_2 &#x3D; &#123;&#39;color&#39;: &#39;red&#39;, &#39;points&#39;: 15&#125;
aliens &#x3D; [alien_0, alien_1, alien_2]

# 在字典中嵌套列表
pizza &#x3D; &#123;
&#39;crust&#39;: &#39;thick&#39;,
&#39;toppings&#39;: [&#39;mushrooms&#39;, &#39;extra cheese&#39;],
&#125;

# 在字典中嵌套字典
users &#x3D; &#123;
&#39;aeinstein&#39;: &#123;
&#39;first&#39;: &#39;albert&#39;,
&#39;last&#39;: &#39;einstein&#39;,
&#39;location&#39;: &#39;princeton&#39;,
&#125;,
&#39;mcurie&#39;: &#123;
&#39;first&#39;: &#39;marie&#39;,
&#39;last&#39;: &#39;curie&#39;,
&#39;location&#39;: &#39;paris&#39;,
&#125;,
&#125;</code></pre>
<h1 id="python的流程控制"><a class="markdownIt-Anchor" href="#python的流程控制"></a> python的流程控制</h1>
<h2 id="if语句"><a class="markdownIt-Anchor" href="#if语句"></a> if语句</h2>
<ul>
<li>类似c语言中的if语句，但是python<strong>省去了条件外面的括号</strong>，而是<strong>用冒号<code>:</code>来表示</strong>（就像c语言不能忘记括号一样，python也不能忘记冒号），<strong>并将<code>else if</code>合成了一个<code>elif</code>关键字</strong>（但是还是有单独的<code>else</code>)。如：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; (int)(input()) #input读取键盘的输入，但是默认读入的类型是字符串型，需要强制转换为数字整型

if x &lt; 0:
        x &#x3D; 0
        print(x)
elif x &#x3D;&#x3D; 0:
        x &#x3D; -1
        print(x)
else:
        x &#x3D; 1
       print(x)</code></pre>
<ul>
<li>python条件语句内部的语句不是用花括号<code>&#123;&#125;</code>来括起来，而是直接<strong>用缩进来表示包含关系</strong>。所以这种带有控制语句的代码最好不直接在解释器中写。</li>
<li><strong>条件测试（布尔表达式）</strong>：每条if 语句的核心都是一个值为True 或False 的表达式，这种表达式被称为条件测试。
<ul>
<li>条件表达式(布尔表达式)的结果要么为True ，要么为False 。</li>
</ul>
</li>
<li>if语句判断列表是否为空：<code>if list:</code>,如果列表是空的，相当于条件为false，如果为非空，则相当于条件为true。</li>
</ul>
<h2 id="for语句"><a class="markdownIt-Anchor" href="#for语句"></a> for语句</h2>
<ul>
<li>与c语言的for循环不同的是，python的for循环没有控制条件，它自动停止的。例如</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">words &#x3D; [&#39;zhang&#39;, &#39;jie&#39;]

for word in words:
  print(word)</code></pre>
<ul>
<li>for循环常用来遍历列表或者字符串等序列，循环会在序列尾部自动结束。而在示例程序中的<code>word</code>变量是定义的列表序列中的单个元素。注意<code>for...in...</code>的格式。</li>
<li>for语句的末尾有一个<strong>冒号</strong>。</li>
<li>循环中的语句依靠<strong>缩进</strong>来识别。</li>
</ul>
<h2 id="while循环"><a class="markdownIt-Anchor" href="#while循环"></a> while循环</h2>
<ul>
<li>for 循环用于针对<strong>集合中的每个元素</strong>，而while 循环不断地运行，直到<strong>指定的条件不满足</strong>为止。示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">current_number &#x3D; 1
while current_number &lt;&#x3D; 5:
    print(current_number)
    current_number +&#x3D; 1</code></pre>
<h2 id="break和continue语句"><a class="markdownIt-Anchor" href="#break和continue语句"></a> break和continue语句</h2>
<ul>
<li>break 语句用于控制程序流程，可使用它来控制哪些代码行将执行，哪些代码行不执行，从而让程序按你的要求执行你要执行的代码。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; for n in range(2, 10):
...     for x in range(2, n):#第一次循环，range（2,2)是没有值的,解释器不会输出任何内容
...         if n % x &#x3D;&#x3D; 0:
...             print(n, &#39;equals&#39;, x, &#39;*&#39;, n&#x2F;&#x2F;x)
...             break
...     else:
...         # loop fell through without finding a factor
...         print(n, &#39;is a prime number&#39;)
...
2 is a prime number
3 is a prime number
4 equals 2 * 2
5 is a prime number
6 equals 2 * 3
7 is a prime number
8 equals 2 * 4
9 equals 3 * 3</code></pre>
<ul>
<li>要<strong>返回到循环开头</strong>，并根据条件测试结果决定是否继续执行循环，可使用continue 语句，它不像break 语句那样不再执行余下的代码并退出整个循环。continue语句与c语言中基本一样，它表示跳过continue语句中后面所有的当前循环的语句（到循环尾），从而直接进入下一次迭代。示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; for num in range(2, 10):
...     if num % 2 &#x3D;&#x3D; 0:
...         print(&quot;Found an even number&quot;, num)
...         continue
...     print(&quot;Found a number&quot;, num)
Found an even number 2
Found a number 3
Found an even number 4
Found a number 5
Found an even number 6
Found a number 7
Found an even number 8
Found a number 9</code></pre>
<h2 id="pass语句"><a class="markdownIt-Anchor" href="#pass语句"></a> pass语句</h2>
<ul>
<li>pass语句就像它的名字一样，读到它时，什么也不做，直接过去就行。</li>
</ul>
<h2 id="条件控制"><a class="markdownIt-Anchor" href="#条件控制"></a> 条件控制</h2>
<h3 id="in-和-not-in"><a class="markdownIt-Anchor" href="#in-和-not-in"></a> in 和 not in</h3>
<ul>
<li>in和not in用来判断某个值是否在某个区间内（如列表）。</li>
<li><strong>检查特定值是否在列表中</strong>:要判断特定的值是否已包含在列表中，可使用<strong>关键字in</strong>,如：<code>if user in users:</code>,也可以判断特定值不再列表中，如：<code>if user not in users:</code></li>
</ul>
<h3 id="is-和-not-is"><a class="markdownIt-Anchor" href="#is-和-not-is"></a> is 和 not is</h3>
<ul>
<li>is和not is用来判断两个比较对象是否相同。</li>
</ul>
<h3 id="大于等于以及判等"><a class="markdownIt-Anchor" href="#大于等于以及判等"></a> 大于等于以及判等</h3>
<ul>
<li>python中支持连续比较，即像普通比较一样可以连续的比较多个值的关系。例如：<code>a &lt; b == c</code>可以判断b是否大于a的同时等于c。</li>
</ul>
<h3 id="逻辑操作符"><a class="markdownIt-Anchor" href="#逻辑操作符"></a> 逻辑操作符</h3>
<ul>
<li>python中的逻辑操作符包括<code>and, not, or</code>。</li>
<li><strong>or</strong>的示例：<code>x or y</code>,如果x为真则返回x，否则返回y。</li>
<li><strong>and</strong>的示例：<code>x and y</code>,如果x的值为假，则不再看y的值，返回（false），如果x的值为真，则返回y的值。（and和or都是从左向右解析，and返回值的条件是遇见假的变量或或者到末尾， 而or返回的条件是遇见真或者到末尾。</li>
<li><strong>not</strong>的示例：<code>not x</code>,not只有True和False两种返回值。如果x为真，则not使其取反，结果为False，反之亦然。</li>
</ul>
<h3 id="序列的比较"><a class="markdownIt-Anchor" href="#序列的比较"></a> 序列的比较</h3>
<ul>
<li>条件比较<code>&gt;, &lt; ,==</code>可以用于比较序列（如列表，字符串，字典）。</li>
<li>比较规则：首先比较前两个元素，如果不同，就决定了比较的结果；如果相同，就比较后两个元素，依此类推，直到所有序列都完成比较。如果两个元素本身就是同样类 型的序列，就递归字典序比较。如果两个序列的所有子项都相等，就认为序列相等。如果一个序列是另一个序列的初始子序列，较短的一个序列就小于另一个。字符 串的字典序按照单字符的 ASCII 顺序。</li>
</ul>
<h1 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h1>
<ul>
<li>函数是带名字的代码块，用于完成具体的工作。</li>
<li>重构：将代码划分为一系列完成具体工作的函数。这样的过程被称为<strong>重构</strong>。重构让代码更清晰、更易于理解、更容易扩展。</li>
<li>函数编写规范：
<ul>
<li>应给函数指定描述性名称，且只在其中使用<strong>小写字母和下划线</strong>;</li>
<li>每个函数都应包含简要地阐述其功能的注释，该注释应紧跟在函数定义后面，并采用文档字符串格式；</li>
<li>给形参指定默认值时以及函数调用中的关键字实参，<strong>等号两边不要有空格</strong>；</li>
<li>如果程序或模块包含多个函数，可使用<strong>两个空行将相邻的函数分开</strong>，这样将更容易知道前一个函数在什么地方结束，下一个函数从什么地方开始。</li>
<li>所有的<strong>import 语句都应放在文件开头</strong>，唯一例外的情形是，在文件开头使用了注释来描述整个程序。</li>
<li>如果形参很多，导致函数定义的长度超过了79字符，可在函数定义中输入左括号后按回车键，并在下一行按两次Tab键，从而将形参列表和只缩进一层的函数体区分开来。如：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def function_name(
      parameter_0, parameter_1, parameter_2,
      parameter_3, parameter_4, parameter_5):
  function body...</code></pre>
</li>
</ul>
<h2 id="函数定义"><a class="markdownIt-Anchor" href="#函数定义"></a> 函数定义</h2>
<ul>
<li>使用<code>def</code>定义函数，<code>def</code>后接函数的名字，以及她的形参列表，最后就像大多数功能语句一样，以<code>:</code>开启函数体。</li>
<li>函数体的书写必须必须<strong>全部相对定义缩进</strong>。示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; def fib(n):    # write Fibonacci series up to n
...     &quot;&quot;&quot;Print a Fibonacci series up to n.&quot;&quot;&quot;
...     a, b &#x3D; 0, 1
...     while a &lt; n:
...         print(a, end&#x3D;&#39; &#39;)
...         a, b &#x3D; b, a+b
...     print()
...
&gt;&gt;&gt; # Now call the function we just defined:
... fib(2000)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597</code></pre>
<ul>
<li>函数第一行处的文本是被称为<strong>文档字符串 （docstring）<strong>的注释，描述了函数是做什么的。文档字符串用</strong>三引号</strong>括<br />
起，Python使用它们来生成有关程序中函数的文档。。</li>
</ul>
<h2 id="函数调用"><a class="markdownIt-Anchor" href="#函数调用"></a> 函数调用</h2>
<ul>
<li>直接输入函数的名字并给他传递实参即可，例如<code>fib(10)</code>,即是对前文函数的调用。</li>
<li>函数名可以直接赋值给其它变量。如</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">f &#x3D; fib

f(10)</code></pre>
<p>与直接<code>fib(10)</code>效果一样。</p>
<h2 id="函数的参数"><a class="markdownIt-Anchor" href="#函数的参数"></a> 函数的参数</h2>
<ul>
<li>鉴于函数定义中可能包含<strong>多个形参</strong>，因此函数调用中也可能包含多个实参。向函数传递实参的方式很多，可使用<strong>位置实参</strong> ，这要求实参的顺序与形参的顺序相同；也可使用<strong>关键字实参</strong> ，其中每个实参都由变量名和值组成；还可使用列表和字典。</li>
<li><strong>位置实参</strong>：要求实参的顺序与形参的顺序相同，如：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def describe_pet(animal_type, pet_name):
    &quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot;
    print(&quot;\nI have a &quot; + animal_type + &quot;.&quot;)
    print(&quot;My &quot; + animal_type + &quot;&#39;s name is &quot; + pet_name.title() + &quot;.&quot;)

describe_pet(&#39;hamster&#39;, &#39;harry&#39;)
describe_pet(&#39;dog&#39;, &#39;willie&#39;)</code></pre>
<ul>
<li><strong>关键字实参</strong>：每个实参都由变量名和值组成；还可使用列表和字典，如：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def describe_pet(animal_type, pet_name):
    &quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot;
    print(&quot;\nI have a &quot; + animal_type + &quot;.&quot;)
    print(&quot;My &quot; + animal_type + &quot;&#39;s name is &quot; + pet_name.title() + &quot;.&quot;)

describe_pet(animal_type&#x3D;&#39;hamster&#39;, pet_name&#x3D;&#39;harry&#39;)</code></pre>
<ul>
<li><strong>形参的默认值</strong>：编写函数时，可给每个形参指定默认值 。在调用函数中给形参提供了实参时，Python将使用指定的实参值；否则，将使用形参的默认值。因此，给形参指定默认值后，可在函数调用中省略相应的实参。使用默认值可简化函数调用，还可清楚地指出函数的典型用法。</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def describe_pet(pet_name, animal_type&#x3D;&#39;dog&#39;):
    &quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot;
    print(&quot;\nI have a &quot; + animal_type + &quot;.&quot;)
    print(&quot;My &quot; + animal_type + &quot;&#39;s name is &quot; + pet_name.title() + &quot;.&quot;)</code></pre>
<ul>
<li>如果传递的参数是列表等复杂类型，<strong>函数中对列表等的修改是永久生效的</strong>（类似传递给该函数的是对该列表的引用）
<ul>
<li>若想要仅仅<strong>传一个副本给函数</strong>，可使用切片的方法。如：<code>function_name(list_name[:])</code>。</li>
</ul>
</li>
<li>传递<strong>任意数量的实参</strong>：在形参的前面加上<code>*</code>可以生成一个元组，将所有接收到的元组都封装到这个元组中，使用参数时便在这个元组中去取。示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def make_pizza(*toppings):
    &quot;&quot;&quot;概述要制作的比萨&quot;&quot;&quot;
    print(&quot;\nMaking a pizza with the following toppings:&quot;)
    for topping in toppings:
      print(&quot;- &quot; + topping)

make_pizza(&#39;pepperoni&#39;)
make_pizza(&#39;mushrooms&#39;, &#39;green peppers&#39;, &#39;extra cheese&#39;)</code></pre>
<ul>
<li>结合使用<strong>位置形参和任意数量的实参</strong>：如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。Python<strong>先匹配位置实参和关键字实参</strong>，再将余下的实参都收集到最后一个形参中。</li>
<li><strong>任意数量的关键字实参</strong>：有时候，需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。在这种情况下，可将函数编写成能够接受任意数量的<strong>键—值对</strong>——调用语句提供了多少就接受多少。
<ul>
<li>使用<code>**</code>能够将接收到的关键字实参封装为一个字典。示例：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def build_profile(first, last, **user_info):
    &quot;&quot;&quot;创建一个字典，其中包含我们知道的有关用户的一切&quot;&quot;&quot;
    profile &#x3D; &#123;&#125;
    profile[&#39;first_name&#39;] &#x3D; first
    profile[&#39;last_name&#39;] &#x3D; last
    for key, value in user_info.items():
      profile[key] &#x3D; value
    return profile

user_profile &#x3D; build_profile(&#39;albert&#39;, &#39;einstein&#39;,
                              location&#x3D;&#39;princeton&#39;,
                              field&#x3D;&#39;physics&#39;)
print(user_profile) </code></pre>
<h2 id="函数的返回值"><a class="markdownIt-Anchor" href="#函数的返回值"></a> 函数的返回值</h2>
<ul>
<li>
<p>在函数中，可使用return 语句将值返回到调用函数的代码行。</p>
</li>
<li>
<p>函数可返回任何类型的值，包括列表和字典等较复杂的数据结构。</p>
</li>
<li>
<p><code>-&gt;</code>常常出现在python函数定义的函数名后面，为函数添加<code>元数据</code>,描述函数的返回类型，从而方便开发人员使用。如：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Class ListNode:
    def _init_(self, x):
        self.val &#x3D; x
        self.next &#x3D; None

Class Solution:
    def reverseList(self, head: ListNode) -&gt; ListNode:
# 表示该函数的返回值类型为ListNode</code></pre>
</li>
</ul>
<h2 id="模块"><a class="markdownIt-Anchor" href="#模块"></a> 模块</h2>
<h3 id="模块的概念"><a class="markdownIt-Anchor" href="#模块的概念"></a> 模块的概念</h3>
<ul>
<li>模块是一个在其中<strong>封装了函数的Python程序</strong>。模块可以比作一整盒拼装玩具，而函数就是其中的一块块积木。</li>
<li>模块是包含了函数的定义的Python文件。<a target="_blank" rel="noopener" href="http://xn--ciq4sf6ja323bty0ax7a40rl63althx06d.py">这个文件的名称是模块名.py</a>。</li>
<li>模块中也可以导入其它模块。</li>
</ul>
<h3 id="模块的导入与调用"><a class="markdownIt-Anchor" href="#模块的导入与调用"></a> 模块的导入与调用</h3>
<ul>
<li><code>import 模块名</code>导入模块名。这种方法导入的模块名，使用名模块内的函数时，必须再加上模块名。即类似<code>模块名.函数名</code>的调用方法。示例：<br />
模块(<a target="_blank" rel="noopener" href="http://fibo.py">fibo.py</a>)内容：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def fib(n):    # write Fibonacci series up to n
    a, b &#x3D; 0, 1
    while b &lt; n:
        print(b, end&#x3D;&#39; &#39;)
        a, b &#x3D; b, a+b
    print()

def fib2(n): # return Fibonacci series up to n
    result &#x3D; []
    a, b &#x3D; 0, 1
    while b &lt; n:
        result.append(b)
        a, b &#x3D; b, a+b
    return result</code></pre>
<p>模块调用：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; import fibo
&gt;&gt;&gt; fibo.fib(1000)
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
&gt;&gt;&gt; fibo.fib2(100)
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
&gt;&gt;&gt; fib &#x3D; fibo.fib #还可以将调用的函数赋给本地定义的变量，以方便频繁调用。
&gt;&gt;&gt; fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377</code></pre>
<ul>
<li><code>from 模块名 import 函数名</code>导入函数,这样不会导入模块名，但是导入的函数可以不依赖模块而直接调用。
<ul>
<li>通过用逗号分隔函数名，可根据需要从模块中导入任意数量的函数：<code>from module_name import function_0, function_1, function_2</code></li>
</ul>
</li>
<li>还可以使用<code>from 模块名 import *</code>来导入模块中所有除了以下划线<code>_</code>开头的定义。示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; from fibo import fib, fib2 #导入
&gt;&gt;&gt; fib(500) #直接调用函数
1 1 2 3 5 8 13 21 34 55 89 144 233 377
&gt;&gt;&gt; from fibo import * #导入模块中所有的定义
&gt;&gt;&gt; fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377</code></pre>
<ul>
<li>使用<code>as</code><strong>给导入的函数指定别名</strong>：如果要导入的函数的名称可能与程序中现有的名称冲突，或者函数的名称太长，可指定简短而独一无二的别名 ——函数的另一个名称，类似于外号。如：<code>from module_name import function_name as fn</code>.</li>
<li>使用<code>as</code>给<strong>模块指定别名</strong>：通过给模块指定简短的别名（如给模块pizza 指定别名p ），让你能够更轻松地调用模块中的函数。如：<code>import module_name as mn</code></li>
<li>最佳的做法是，要么只导入你需要使用的函数，要么导入整个模块并使用句点表示法。这能让代码更清晰，更容易阅读和理解。</li>
</ul>
<h3 id="模块的搜索路径"><a class="markdownIt-Anchor" href="#模块的搜索路径"></a> 模块的搜索路径</h3>
<ul>
<li>在导入一个模块时，解释器会从<strong>当前目录</strong>， <strong>环境变量PYTHONPATH</strong>指定的目录列表以及<strong>Python的默认安装路径中</strong>搜索模块。</li>
<li>解释器的实际搜索路径是由变量<code>sys.path</code>指定的。</li>
</ul>
<h3 id="标准模块"><a class="markdownIt-Anchor" href="#标准模块"></a> 标准模块</h3>
<ul>
<li>Python默认内置了很多标准模块，可以直接调用和配置。</li>
</ul>
<h3 id="dir函数"><a class="markdownIt-Anchor" href="#dir函数"></a> dir（）函数</h3>
<ul>
<li>dir（）函数用来按模块名搜索模块的定义。</li>
</ul>
<h3 id="包模块集"><a class="markdownIt-Anchor" href="#包模块集"></a> 包（模块集）</h3>
<ul>
<li>包是模块的上层，调用包中的模块与调用模块中的函数大体是相同的。可以直接<code>import 包名.模块名.函数名</code>,也可以用<code>from 包名 import 模块名/函数、变量名</code>或者<code>from 包名.模块名 import 子模块名/函数、变量名</code>。当然，类似模块的导入，包也同样有<code>from 包名 import *</code>的导入方式。</li>
<li>同样的，包内也可以引用其他包。</li>
<li>包文件的创建；包文件中必须包含<code>_init_.py</code>文件，这个文件可以让Python把该文件识别为包。它可以为空，也可以包含初始化的一些配置。示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">sound&#x2F;                          Top-level package
      __init__.py               Initialize the sound package
      formats&#x2F;                  Subpackage for file format conversions
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects&#x2F;                  Subpackage for sound effects
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters&#x2F;                  Subpackage for filters
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...</code></pre>
<h1 id="输入和输出"><a class="markdownIt-Anchor" href="#输入和输出"></a> 输入和输出</h1>
<h2 id="格式化输出-print"><a class="markdownIt-Anchor" href="#格式化输出-print"></a> 格式化输出-print()</h2>
<ul>
<li>使用<code>print()</code>函数。print()中有类似c语言的用%以及相应参数限制输出格式的方法。
<ul>
<li>Python 3中的print 是一个函数，因此<strong>括号必不可少</strong>。</li>
<li>每一个<code>print()</code>语句结束后，对内容会自动进行换行。</li>
<li>下面示例演示了如何将较长的print 语句分成多行。单词print 比大多数字典名都短，因此让输出的第一部分紧跟在左括号后面是合理的（见❶）。请选择在合适的地方拆分要打印的内容，并在第一行末尾（见❷）加上一个拼接运算符（+ ）。按回车键进入print 语句的后续各行，并使用Tab键将它们对齐并缩进一级。指定要打印的所有内容后，在print 语句的最后一行末尾加上右括号（见❸）。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">❶ print(&quot;Sarah&#39;s favorite language is &quot; +
❷     favorite_languages[&#39;sarah&#39;].title() +
❸     &quot;.&quot;)</code></pre>
<ul>
<li>使用标准string模块，对字符串进行格式操作；例如<code>字符串.format()</code>方法。</li>
<li>使用Template方法；</li>
<li>使用str（）和repr（）函数。str（）将值转化为适合人阅读的形式，repr将值转化为适合解释器读取的形式。示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; s &#x3D; &#39;Hello, world.&#39;
&gt;&gt;&gt; str(s)
&#39;Hello, world.&#39;
&gt;&gt;&gt; repr(s)
&quot;&#39;Hello, world.&#39;&quot;</code></pre>
<h2 id="格式化输入"><a class="markdownIt-Anchor" href="#格式化输入"></a> 格式化输入</h2>
<h3 id="字符串输入-input"><a class="markdownIt-Anchor" href="#字符串输入-input"></a> 字符串输入-input()</h3>
<ul>
<li>函数input() 让程序暂停运行，等待用户输入一些文本。获取用户输入后，Python将其存储在一个变量中，以方便你使用。</li>
<li>函数input() 接受一个参数：即要向用户显示的提示 或说明，让用户知道该如何做。示例：</li>
<li>使用函数input() 时，Python将用户输入解读为<strong>字符串</strong>。</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">name &#x3D; input(&quot;Please enter your name: &quot;)
print(&quot;Hello, &quot; + name + &quot;!&quot;)</code></pre>
<h3 id="将字符串转换为数字"><a class="markdownIt-Anchor" href="#将字符串转换为数字"></a> 将字符串转换为数字</h3>
<ul>
<li>因为input()函数只能读取进来字符串，所以在需要读取数值的时候，需要对字符串类型进行转换。</li>
<li><code>int()</code>函数可以将符合整数的规定的<strong>字符串转换成int型的</strong></li>
<li><code>float(str)</code>函数将符合浮点型的规定的<strong>字符串转换成float型的</strong></li>
<li><code>str(num)</code>将<strong>整数、浮点型转换成字符串型的</strong></li>
</ul>
<h2 id="文件读写"><a class="markdownIt-Anchor" href="#文件读写"></a> 文件读写</h2>
<h3 id="文件的打开与关闭"><a class="markdownIt-Anchor" href="#文件的打开与关闭"></a> 文件的打开与关闭</h3>
<ul>
<li>要以任何方式使用文件——哪怕仅仅是打印其内容，都得先<strong>打开文件</strong>，这样才能访问它。
<ul>
<li>**函数<code>open()</code>**接受一个参数：要打开的文件的名称。Python在当前执行的文件所在的目录中查找指定的文件。</li>
<li>使用函数<code>open()</code>会<strong>返回文件对象</strong>。open常用的模式是<code>open('filename', 'mode')</code>.
<ul>
<li>第一个参数是一个含有要打开的文件的文件名（或文件路径）的字符串。
<ul>
<li><strong>文件路径</strong>：你将类似pi_digits.txt这样的简单文件名传递给函数open() 时，Python将在<strong>当前执行的文件（即.py程序文件）所在的目录</strong>中查找文件,但仅向open()传递位于当前目录下的文件夹下的文件的名称也不可行。要让Python打开不与程序文件位于同一个目录中的文件，需要提供<strong>文件路径</strong> ，它让Python到系统的特定位置去查找。</li>
<li><strong>相对路径</strong>：如：Linux/OS:<code>with open('text_files/filename.txt') as file_object:</code>,在Windows系统中，在文件路径中使用<strong>反斜杠（<code>\</code>）而不是斜杠（<code>/</code>）</strong>：</li>
<li><strong>绝对路径</strong>：绝对路径通常比相对路径更长，因此将其存储在一个变量中，再将该变量传递给open() 会有所帮助。</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"># Linux&#x2F;OS
file_path &#x3D; &#39;&#x2F;home&#x2F;ehmatthes&#x2F;other_files&#x2F;text_files&#x2F;filename.txt&#39; 
with open(file_path) as file_object:

# Windows
file_path &#x3D; &#39;C:\Users\ehmatthes\other_files\text_files\filename.txt&#39; 
with open(file_path) as file_object:</code></pre>
</li>
<li>第二个参数也是一个字符串，含有描述如何使用该文件的几个字符。
<ul>
<li>mode 为 ‘r’ 时表示只是读取文件；‘w’ 表示只是写入文件（已经存在的同名文件将被删掉）；‘a’ 表示打开文件进行追加，写入到文件中的任何数据将自动添加到末尾。 ‘r+’ 表示打开文件进行读取和写入。</li>
<li>mode 参数是可选的，默认为 ‘r’。示例：<code>f = open('workfile', 'w')</code>。</li>
<li>只用写入的模式(w,a)，如果输入的文件不存在，会在当前目录下<strong>创建该文件</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>文件打开之后需要正常的<strong>关闭</strong>：
<ul>
<li>未妥善地关闭文件可能会导致数据丢失或受损；</li>
<li>可以<code>close()</code>语句来关闭文件。</li>
<li>也可以是用关键字<code>with</code>来关闭文件：关键字with 在不再需要访问文件后将其关闭。如：<code>with open('pi_digits.txt') as file_object:</code></li>
</ul>
</li>
</ul>
<h3 id="读取文件内容"><a class="markdownIt-Anchor" href="#读取文件内容"></a> 读取文件内容</h3>
<ul>
<li><code>文件对象.read(size)</code>方法：该方法读取若干数量的数据并以字符串形式返回其内容，size 是可选的数值，指定字符串长度。如果没有指定 size 或者指定为负数，就会<strong>读取并返回整个文件</strong>。如果到了文件末尾，f.read() 会返回一个空字符串（’’）</li>
<li><strong>逐行读取文件</strong>：要以每次一行的方式检查文件，可对文件对象使用<strong>for 循环</strong>(注意：每行的末尾都有一个看不见的换行符,可以使用<code>rstrip()</code>方法去掉)：<pre class="line-numbers language-python" data-language="python"><code class="language-python">filename &#x3D; &#39;pi_digits.txt&#39; 
with open(filename) as file_object:  
  # 每一次在循环中只读取文件中的一行
  for line in file_object: 
    print(line.rstrip())</code></pre>
</li>
<li><code>文件对象.readline()</code>从文件中读取单独一行，字符串结尾会自动加上一个换行符（ \n ）。如果 f.readline() 返回一个空字符串，那就表示到达了文件末尾。</li>
</ul>
<h3 id="写入文件"><a class="markdownIt-Anchor" href="#写入文件"></a> 写入文件</h3>
<ul>
<li>要将文本写入文件，你在调用open() 时需要提供<strong>另一个实参</strong>（因为默认是r模式），告诉Python你要写入打开的文件。</li>
<li>使用文件对象的方法<code>write()</code><strong>将一个字符串写入文件</strong>;
<ul>
<li>函数write() <strong>不会在你写入的文本末尾添加换行符</strong>，因此如果你写入多行时没有指定换行符，文件看起来可能不是你希望的那样：</li>
<li>要让每个字符串都单独占一行，需要在write() 语句中<strong>包含换行符</strong>,如：<code>file_object.write(&quot;I love programming.\n&quot;)</code></li>
<li>像显示到终端的输出一样，还可以<strong>使用空格、制表符和空行来设置这些输出的格式</strong>。</li>
</ul>
</li>
<li>Python<strong>只能将字符串写入文本文件</strong>。要将数值数据存储到文本文件中，必须先使用函数<code>str()</code> 将其转换为字符串格式。</li>
</ul>
<h1 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h1>
<ul>
<li>Python使用<strong>被称为异常的特殊对象来管理程序执行期间发生的错误</strong>。
<ul>
<li>语法正确的情况下发生的错误为异常错误。</li>
<li>错误信息的最后一行指出发生了什么异常类型。异常也有不同的类型，异常类型做为错误信息的一部分显示出来：如零除错误（ ZeroDivisionError ） ，命名错误（ NameError） 和 类型错误（ TypeError ）等。</li>
</ul>
</li>
<li>每当发生让Python不知所措的错误时，它都会创建一个异常对象。如果你编写了处理该异常的代码，程序将继 续运行；如果你未对异常进行处理，程序将停止，并显示一个traceback(在异常没有被处理的情况下才会有traceback)，其中包含有关异常的报告。</li>
<li>异常是使用<strong>try-except 代码块处理</strong>的。try-except 代码块让Python执行指定的操作，同时告诉Python发生异常时怎么办。使用了try-except 代码块时，<strong>即便出现异常， 程序也将继续运行：显示你编写的友好的错误消息，而不是令用户迷惑的traceback并让程序终止</strong>。</li>
</ul>
<h2 id="语法错误syntaxerror"><a class="markdownIt-Anchor" href="#语法错误syntaxerror"></a> 语法错误（SyntaxError）</h2>
<ul>
<li>语法分析器指出错误行，并且在检测到错误的位置前面显示一个小“箭头”。 错误是由箭头 前面 的标记引起的（或者至少是这么检测的）。</li>
<li>错误会输出文件名和行号，所以如果是从脚本输入的你就知道去哪里检查错误了。</li>
</ul>
<h2 id="异常的处理"><a class="markdownIt-Anchor" href="#异常的处理"></a> 异常的处理</h2>
<ul>
<li>使用<code>try...except</code>语句来处理异常。
<ul>
<li>如果try 代码块中的代码运行起来没有问题，Python将跳过except 代码块；如果try 代码块中的代码导致了 错误，Python将查找这样的except 代码块，并运行其中的代码，即其中指定的错误与引发的错误相同。 可以在except代码块中放入<strong>pass语句，告诉程序捕获到异常后什么都不需要做</strong>。</li>
<li>在出现异常的情况下，如果<strong>try-except 代码块后面还有其他代码，程序将接着运行</strong>，因为已经告诉了Python如何处理这种错误。</li>
<li>如：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">try:
  print(5&#x2F;0) 
except ZeroDivisionError: 
  print(&quot;You can&#39;t divide by zero!&quot;)</code></pre>
<ul>
<li><code>try...except...else</code>代码块：依赖于try 代码块成功执行的代码都应放到else 代码块中：
<ul>
<li>try-except-else 代码块的工作原理大致如下：Python尝试执行try 代码块中的代码；只有可能引发异常的代码才需要放在try 语句中。有时候，<strong>有一些仅在try 代码块成功 执行时才需要运行的代码；这些代码应放在else 代码块中</strong>。except 代码块告诉Python，如果它尝试运行try 代码块中的代码时引发了指定的异常，该怎么办。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">try:
  answer &#x3D; int(first_number) &#x2F; int(second_number) 
except ZeroDivisionError: 
  print(&quot;You can&#39;t divide by 0!&quot;) 
else:
  print(answer)</code></pre>
</li>
<li>（<code>try...finall</code>）可以用来定义清理行为。</li>
</ul>
<h2 id="异常的抛出"><a class="markdownIt-Anchor" href="#异常的抛出"></a> 异常的抛出</h2>
<ul>
<li>使用<code>raise</code>语句可以抛出异常。</li>
</ul>
<h2 id="自定义异常"><a class="markdownIt-Anchor" href="#自定义异常"></a> 自定义异常</h2>
<ul>
<li>用户可以自定义异常类型来创建自己的异常名。</li>
</ul>
<h2 id="预定义清理行为"><a class="markdownIt-Anchor" href="#预定义清理行为"></a> 预定义清理行为、</h2>
<ul>
<li><code>with</code>语句打开文件，使用完毕之后会自动关闭文件。这可以称作一种预定义的清理行为。示例；</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">with open(&quot;myfile.txt&quot;) as f:
    for line in f:
        print(line)</code></pre>
<h1 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h1>
<h2 id="类的定义"><a class="markdownIt-Anchor" href="#类的定义"></a> 类的定义</h2>
<ul>
<li>类与函数一样，在使用前需要先定义。类的定义示例如下：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">class ClassName():
    &lt;statement-1&gt;
    .
    .
    .
    &lt;statement-N&gt;</code></pre>
<ul>
<li><strong>方法</strong>：类中的函数叫做方法。</li>
<li><strong>属性</strong>：可通过实例访问的变量称为属性 。</li>
<li>可将类视为有关如何创建实例的说明。</li>
</ul>
<h2 id="_init_-类构造方法"><a class="markdownIt-Anchor" href="#_init_-类构造方法"></a> <code>_init_()</code>-类构造方法</h2>
<ul>
<li><code>__init__()</code>是一个特殊的方法，每当你根据类创建新实例时，<strong>Python都会自动运行它</strong>。在这个方法的名称中，<strong>开头和末尾各有两个下划线</strong>，这是一种约定，旨在避免Python默认方法与普通方法发生名称冲突。</li>
<li>在<code>_init_()</code>这个方法的定义中，<strong>形参self 必不可少，还必须位于其他形参的前面</strong>。
<ul>
<li>Python调用这个<code>__init__()</code>方法来创建实例时，将<strong>自动传入实参self</strong> 。每个**与类相关联的方法调用都自动传递实参self ，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。**每当我们根据类创建实例时，都只需给除开self的形参提供值。</li>
<li>以self 为前缀的变量都可供类中的所有方法使用，我们还可以通过类的任何实例来访问这些变量。如：<code>self.name = name</code> 获取存储在形参name 中的值，并将其存储到变量name 中，然后<strong>该变量被关联到当前创建的实例</strong>。</li>
</ul>
</li>
<li>类的属性不用单独定义，**在<code>_init()</code>中通过self定义并初始化。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">class Dog():
    &quot;&quot;&quot;一次模拟小狗的简单尝试&quot;&quot;&quot;

    def __init__(self, name, age):
      &quot;&quot;&quot;初始化属性name和age&quot;&quot;&quot;
      self.name &#x3D; name
      self.age &#x3D; age

    def sit(self):
      &quot;&quot;&quot;模拟小狗被命令时蹲下&quot;&quot;&quot;
     print(self.name.title() + &quot; is now sitting.&quot;)

    def roll_over(self):
      &quot;&quot;&quot;模拟小狗被命令时打滚&quot;&quot;&quot;
      print(self.name.title() + &quot; rolled over!&quot;)</code></pre>
<h2 id="类的实例化"><a class="markdownIt-Anchor" href="#类的实例化"></a> 类的实例化</h2>
<ul>
<li>类的实例化就就是<strong>将类看做一个函数进行调用</strong>。例如：<code>x = Myclass()</code>。</li>
<li>我们通常可以认为首字母大写的名称（如Dog）指的是类，而小写的名称（如my_dog ）指的是根据类创建的实例。</li>
<li>属性与方法的调用：使用句点表示法获取实例的属性和调用其方法。如：<code>my_dog.name</code>,<code>my_dog.roll_over()</code>
<ul>
<li><code>__doc__</code> 也是一个有效的属性，返回类的文档字符串</li>
</ul>
</li>
</ul>
<h2 id="类的编码风格"><a class="markdownIt-Anchor" href="#类的编码风格"></a> 类的编码风格</h2>
<ul>
<li>类名应采用<strong>驼峰命名法</strong>，即将<strong>类名中的每个单词的首字母都大写</strong>，而不使用下划线。实例名和模块名都采用<strong>小写格式，并在单词之间加上下划线</strong>。</li>
<li>对于每个类，都应紧跟在类定义后面包含一个<strong>文档字符串</strong>。这种文档字符串简要地描述类的功能，并遵循编写函数的文档字符串时采用的格式约定。每个模块也都应包含一个文 档字符串，对其中的类可用于做什么进行描述。</li>
<li>可使用空行来组织代码，但不要滥用。在类中，可使用<strong>一个空行来分隔方法</strong>；而在模块中，可使用<strong>两个空行来分隔类</strong></li>
<li>需要同时导入标准库中的模块和你编写的模块时，<strong>先编写导入标准库模块的import 语句，再添加一个空行</strong>，然后编写导入你自己编写的模块的import 语句。</li>
</ul>
<h2 id="类的继承"><a class="markdownIt-Anchor" href="#类的继承"></a> 类的继承</h2>
<ul>
<li>编写类时，并非总是要从空白开始。如果你要编写的类是另一个现成类的特殊版本，可使用继承 。一个类继承另一个类时，它将自动获得另一个类的所有属性和方法；原有的类称为父类 ，而新类称为子类 。<strong>子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法</strong>。</li>
<li>创建子类时，<strong>父类必须包含在当前文件中，且位于子类前面</strong>。</li>
<li>定义子类时，必须<strong>在括号内指定父类的名称</strong>。</li>
<li>子类的方法<code>__init__()</code>
<ul>
<li>创建子类的实例时，Python首先需要完成的任务是给父类的所有属性赋值。为此，<strong>子类的方法__init__() 需要父类施以援手</strong>。</li>
<li><code>super()</code> 是一个特殊函数，帮助Python将父类和子类关联起来。使用这个函数让Python调用父类的方法<code>__init__()</code> ，让该子类包含父类的所有属性。</li>
</ul>
</li>
<li>让一个类继承另一个类后，可<strong>添加区分子类和父类所需的新属性和方法</strong>,属性在调用<code>super()</code>函数后之后添加，方法可以在类中任意定义。</li>
<li><strong>重写父类的方法</strong>：
<ul>
<li>对于<strong>父类的方法</strong>，只要它不符合子类模拟的实物的行为，都可对其进行重写。</li>
<li>重写父类的方法只需要在<strong>子类中定义一个同名的方法</strong>，就会自动覆盖掉父类的该方法。</li>
</ul>
</li>
<li><strong>将实例用作属性</strong>：类中属性可以是<strong>引用类型</strong>。如：<code>self.battery = Battery()</code>,其中<code>Battery()</code>是Battery类的构造方法。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"># 父类
class Car():
   &quot;&quot;&quot;一次模拟汽车的简单尝试&quot;&quot;&quot; 
   def __init__(self, make, model, year): 
     self.make &#x3D; make 
     self.model &#x3D; model 
     self.year &#x3D; year 
     self.odometer_reading &#x3D; 0 

   def get_descriptive_name(self): 
     long_name &#x3D; str(self.year) + &#39; &#39; + self.make + &#39; &#39; + self.model
     return long_name.title() 

   def read_odometer(self): 
     print(&quot;This car has &quot; + str(self.odometer_reading) + &quot; miles on it.&quot;) 

   def update_odometer(self, mileage): 
     if mileage &gt;&#x3D; self.odometer_reading: 
       self.odometer_reading &#x3D; mileage else:print(&quot;You can&#39;t roll back an odometer!&quot;) 
       
   def increment_odometer(self, miles): 
     self.odometer_reading +&#x3D; miles  
    
   def gas_gank():
     print(&quot;油箱信息&quot;)
# 子类     
class ElectricCar(Car): 
  &quot;&quot;&quot;电动汽车的独特之处&quot;&quot;&quot; 
   def __init__(self, make, model, year): 
     &quot;&quot;&quot;初始化父类的属性&quot;&quot;&quot; 
      super().__init__(make, model, year) 
      self.battery_size &#x3D; 70 
      
   def describe_battery(self): 
     &quot;&quot;&quot;打印一条描述电瓶容量的消息&quot;&quot;&quot; 
     print(&quot;This car has a &quot; + str(self.battery_size) + &quot;-kWh battery.&quot;)
   
   # 重写父类方法
   def gas_gank():
    print(&quot;电动车没有油箱&quot;)</code></pre>
<h2 id="导入类"><a class="markdownIt-Anchor" href="#导入类"></a> 导入类</h2>
<ul>
<li>类和函数一样都可以<strong>封装在模块中</strong>，进行导入。</li>
<li>在模块文件的首部写<strong>个模块级文档字符串，对该模块的内容做简要的描述</strong>。</li>
<li>从模块中导入类的语法和导入函数一致。</li>
<li>一个模块中可以存储一个或者多个类。</li>
<li>模块示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;一组可用于表示电动汽车的类&quot;&quot;&quot;  
from car import Car

class Battery(): 
    ...... 

class ElectricCar(Car): 
    .......</code></pre>
<h2 id="python标准库"><a class="markdownIt-Anchor" href="#python标准库"></a> Python标准库</h2>
<ul>
<li>Python标准库是一组模块，安装的Python都包含它。</li>
<li>可使用标准库中的任何函数和类，为此，只需在程序开头包含一条简单的import 语句。</li>
<li>注：你还可以从其他地方下载外部模块。</li>
</ul>
<h1 id="json存储数据"><a class="markdownIt-Anchor" href="#json存储数据"></a> JSON存储数据</h1>
<ul>
<li>**JSON（JavaScript Object Notation）**格式最初是为JavaScript开发的，但随后成了一种常见格式，被包括Python在内的众多语言采用。</li>
<li>模块json 让你能够将简单的Python<strong>数据结构转储到文件</strong>中，并在程序再次运行时加载该文件中的数据。</li>
<li>可以使用json在Python程序之间分享数据。</li>
<li>JSON数据格式并非Python专用的，这让你能够将以<strong>JSON格式存储的数据与使用其他编程语言</strong>的人分享。</li>
<li>JSON在Python中是一个<strong>模块</strong>，使用JSON格式时需要先导入json模块。</li>
<li><code>json.dump()</code>:这个函数能够将数据结构转存到文件中。</li>
<li><code>json.load()</code>:将以json方式存储到文件的数据结构读取到内存中去。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import json 
# 如果以前存储了用户名，就加载它 
# 否则，就提示用户输入用户名并存储它 
filename &#x3D; &#39;username.json&#39; 
try:  
  with open(filename) as f_obj:  
    username &#x3D; json.load(f_obj) 
  except FileNotFoundError: 
     username &#x3D; input(&quot;What is your name? &quot;)  
     with open(filename, &#39;w&#39;) as f_obj: 
       json.dump(username, f_obj) 
       print(&quot;We&#39;ll remember you when you come back, &quot; + username + &quot;!&quot;) 
  else:
    print(&quot;Welcome back, &quot; + username + &quot;!&quot;)</code></pre>
<h1 id="python测试"><a class="markdownIt-Anchor" href="#python测试"></a> Python测试</h1>
<ul>
<li>Python标准库中的<strong>模块unittest</strong>提供了代码测试工具。</li>
<li><strong>单元测试</strong>用于核实函数的某个方面没有问题。</li>
<li><strong>测试用例</strong>是一组单元测试，这些单元测试一起核实函数在各种情形下的行为都符合要求。</li>
<li><strong>全覆盖测试用例</strong>包含一整套单元测试，涵盖了各种可能的函数使用方式。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import unittest 
from name_function import get_formatted_name 

class NamesTestCase(unittest.TestCase): 
  &quot;&quot;&quot;测试name_function.py &quot;&quot;&quot; 
  def test_first_last_name(self): 
    &quot;&quot;&quot;能够正确地处理像Janis Joplin这样的姓名吗？&quot;&quot;&quot; 
    formatted_name &#x3D; get_formatted_name(&#39;janis&#39;, &#39;joplin&#39;) 
    self.assertEqual(formatted_name, &#39;Janis Joplin&#39;) 

  def test_first_last_middle_name(self): 
    &quot;&quot;&quot;能够正确地处理像Wolfgang Amadeus Mozart这样的姓名吗？&quot;&quot;&quot; 
     formatted_name &#x3D; get_formatted_name( &#39;wolfgang&#39;, &#39;mozart&#39;, &#39;amadeus&#39;) 
     self.assertEqual(formatted_name, &#39;Wolfgang Amadeus Mozart&#39;) 
     
unittest.main()</code></pre>
<ul>
<li>
<p>可先导入<strong>模块unittest</strong>以及要<strong>测试的函数</strong>;</p>
</li>
<li>
<p>再创建一个<strong>继承unittest.TestCase 的类</strong>，在这个类中编写一系列<strong>方法</strong>对函数行为的不同方面进行测试。</p>
<ul>
<li>你可随便给这个类命名，但最好让它看起来与要测试的函数相关，并包含字样Test。</li>
</ul>
</li>
<li>
<p>在类中用于测试函数不同方面的方法名称<strong>必须以test打头，我们运行该测试程序的时候，所有以test打头的方法都将自动运行</strong>。</p>
</li>
<li>
<p>最后需要<strong>调用<code>unittest.main()</code>方法，用于运行测试程序</strong>。</p>
</li>
<li>
<p><strong>断言</strong>：断言方法用来核实得到的<strong>结果是否与期望的结果一致</strong>。</p>
<ul>
<li>在python中断言的一种实现方式是使用通过<code>unint.TestCase</code>类中的<code>assertEqual()</code>方法,如：<code>self.assertEqual(formatted_name, 'Wolfgang Amadeus Mozart')</code>,前面的参数是测试的结果，后面的参数是预期的结果。</li>
<li><code>assertEqual(a, b)</code>: 核实a == b</li>
<li><code>assertNotEqual(a, b)</code>: 核实a != b</li>
<li><code>assertTrue(x)</code>: 核实x 为True</li>
<li><code>assertFalse(x)</code>: 核实x 为False</li>
<li><code>assertIn(item , list )</code> 核实 item 在 list 中</li>
<li><code>assertNotIn(item , list )</code>: 核实 item 不在 list 中</li>
</ul>
</li>
<li>
<p>和函数的测试相似的，也可以对类进行测试：</p>
<ul>
<li>类的测试就是将原来测试函数中调用函数的地方，修改为调用类中的方法。</li>
<li><strong>使用<code>setUp()</code>方法</strong>将测试类初始化：
<ul>
<li><code>unittest.TestCase</code>类包含方法<code>setUp()</code> ，让我们<strong>只需创建这些对象一次，并在每个测试方法中使用它们</strong>。如果你在TestCase 类中包含了方法<code>setUp()</code> ，<strong>Python将先运行它，再运行各个以test_打头的方法</strong>。这样，在你编写的每个测试方法中都可使用在方法<code>setUp()</code> 中创建的对象了。</li>
</ul>
</li>
<li>类测试示例：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import unittest 
from survey import AnonymousSurvey 

class TestAnonymousSurvey(unittest.TestCase): 
  &quot;&quot;&quot;针对AnonymousSurvey类的测试&quot;&quot;&quot; 
  def setUp(self): 
    &quot;&quot;&quot; 创建一个调查对象和一组答案，供使用的测试方法使用 &quot;&quot;&quot; 
    question &#x3D; &quot;What language did you first learn to speak?&quot; 
    self.my_survey &#x3D; AnonymousSurvey(question) 
    self.responses &#x3D; [&#39;English&#39;, &#39;Spanish&#39;, &#39;Mandarin&#39;] 
    
  def test_store_single_response(self): 
    &quot;&quot;&quot;测试单个答案会被妥善地存储&quot;&quot;&quot; 
    self.my_survey.store_response(self.responses[0]) 
    self.assertIn(self.responses[0], self.my_survey.responses) 
    
  def test_store_three_responses(self): 
    &quot;&quot;&quot;测试三个答案会被妥善地存储&quot;&quot;&quot; 
    for response in self.responses: 
      self.my_survey.store_response(response) 
    for response in self.responses: 
      self.assertIn(response, self.my_survey.responses) 

unittest.main()</code></pre>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">











</code></pre>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/GDB/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/GDB/index.html" class="post-title-link" itemprop="url">GDB</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-04 20:46:47" itemprop="dateCreated datePublished" datetime="2020-09-04T20:46:47+08:00">2020-09-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:41:21" itemprop="dateModified" datetime="2022-09-17T19:41:21+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">杂技术</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>400</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="gdb的安装"><a class="markdownIt-Anchor" href="#gdb的安装"></a> GDB的安装</h1>
<h2 id="快速安装"><a class="markdownIt-Anchor" href="#快速安装"></a> 快速安装</h2>
<ul>
<li>快速安装一般不是最新版本；</li>
<li>直接使用命令：<code>sudo apt-get install gdb</code></li>
</ul>
<h2 id="源码编译安装"><a class="markdownIt-Anchor" href="#源码编译安装"></a> 源码编译安装</h2>
<ul>
<li>安装速度较慢，但可以使用最新版本的gdb。</li>
<li>源码安装的步骤：
<ol>
<li>从<a target="_blank" rel="noopener" href="http://ftp.gnu.org/gnu/gdb/">官网</a>下载<code>.tar.gz</code>格式的源码压缩包。</li>
<li>之后编译安装。</li>
</ol>
</li>
</ul>
<h1 id="gdb的基本使用"><a class="markdownIt-Anchor" href="#gdb的基本使用"></a> GDB的基本使用</h1>
<h2 id="编译为可使用gdb的可执行文件"><a class="markdownIt-Anchor" href="#编译为可使用gdb的可执行文件"></a> 编译为可使用GDB的可执行文件</h2>
<ul>
<li>使用gcc编译源文件时，加上<code>-g</code>选项，可以生成可使用GDB进行调试的可执行文件。</li>
</ul>
<h2 id="gdb的调用"><a class="markdownIt-Anchor" href="#gdb的调用"></a> GDB的调用</h2>
<ul>
<li>GDB调用的基本格式为：<code>gdb &lt;可执行文件名&gt;</code></li>
<li>GDB常用的调试指令</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>b &lt;行号&gt;</td>
<td>在源代码指定的某一行设置断点</td>
</tr>
<tr>
<td>r</td>
<td>执行被调试的程序，其会在第一个断点处停止执行</td>
</tr>
<tr>
<td>c</td>
<td>当程序在某一断点处停止执行后，使用该指令可使程序继续执行，直到遇到下一个断点或者程序结束</td>
</tr>
<tr>
<td>n</td>
<td>令程序一行代码一行代码地执行</td>
</tr>
<tr>
<td>p &lt;变量名&gt;</td>
<td>打印指定变量在程序断点处的值（在程序停下来时使用）</td>
</tr>
<tr>
<td>l</td>
<td>显示程序的源代码，并显示行号</td>
</tr>
<tr>
<td>q</td>
<td>终止调试，退出程序</td>
</tr>
</tbody>
</table>
<hr />
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/gdb/">参考资料</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%BF%AB%E6%8D%B7%E9%94%AE/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%BF%AB%E6%8D%B7%E9%94%AE/index.html" class="post-title-link" itemprop="url">计算机基本快捷键</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-02 11:19:05" itemprop="dateCreated datePublished" datetime="2020-09-02T11:19:05+08:00">2020-09-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-09-26 21:40:35" itemprop="dateModified" datetime="2021-09-26T21:40:35+08:00">2021-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">杂技术</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="windows系统快捷键"><a class="markdownIt-Anchor" href="#windows系统快捷键"></a> Windows系统快捷键</h1>
<ul>
<li>带Windows键</li>
</ul>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>win</td>
<td>开始菜单</td>
<td>按Esc或者再按下win可以退出开始菜单</td>
</tr>
<tr>
<td>win + S</td>
<td>调出搜索</td>
<td></td>
</tr>
<tr>
<td>win + E</td>
<td>调出文件资源管理器</td>
<td>可反复使用打开多个文件资源管理器窗口</td>
</tr>
<tr>
<td>win + R</td>
<td>调出运行命令</td>
<td>常用来打开注册表</td>
</tr>
<tr>
<td>win +T</td>
<td>调出底部任务栏，并在其中切换</td>
<td>多次按下win + T可在底部任务栏中顺序切换，按下Esc可以退出选择</td>
</tr>
<tr>
<td>win +数字</td>
<td>可在底部任务栏中快速切换，排在第几，就对应第几个数字</td>
<td>再次按下可以最小化窗口</td>
</tr>
<tr>
<td>win + U</td>
<td>可以直接打开Windows的系统设置窗口</td>
<td></td>
</tr>
<tr>
<td>win + A</td>
<td>打开通知中心</td>
<td>按Esc可以退出</td>
</tr>
<tr>
<td>win + D</td>
<td>最小化所有窗口</td>
<td>再次按下可以恢复</td>
</tr>
<tr>
<td>win + G</td>
<td>启动Xbox屏幕录制</td>
<td>不会直接录制，而是先进入Xbox的操作界面</td>
</tr>
<tr>
<td>win + Alt + R</td>
<td>等待一下下后直接开始屏幕录制</td>
<td>再次按下，则停止录制并保存到C:\Users\12246\Videos\Captures，可选择录制声音</td>
</tr>
<tr>
<td>win + K</td>
<td>打开无线连接设备</td>
<td>如蓝牙</td>
</tr>
<tr>
<td>win + L</td>
<td>锁定计算机</td>
<td>进入需要密码进入的状态</td>
</tr>
<tr>
<td>win + x</td>
<td>调出系统快捷菜单</td>
<td></td>
</tr>
<tr>
<td>win + 空格</td>
<td>在输入法之间切换</td>
<td></td>
</tr>
<tr>
<td>win + 上方向键</td>
<td>总体上可使当前窗口向上移动分屏，连按几次后进入最大化窗口</td>
<td></td>
</tr>
<tr>
<td>win + 下方向键</td>
<td>总体上可使当前窗口向下移动分屏，连按几次后进入最小化窗口</td>
<td></td>
</tr>
<tr>
<td>win + 左/右方向键</td>
<td>使当前窗口左右分屏或者移动</td>
<td>到达边界后弹向相反的另一方</td>
</tr>
<tr>
<td>win + Tab</td>
<td>进入时间轴任务窗口模式</td>
<td>再按一次或者Esc可以回到正常窗口</td>
</tr>
<tr>
<td>win + Alt + D</td>
<td>打开日历</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>其它</li>
</ul>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl键按住</td>
<td>与鼠标左键配合可以选择不连续的多个文件</td>
<td></td>
</tr>
<tr>
<td>shift键按住</td>
<td>与鼠标左键配合可以选择连续的多个文件</td>
<td></td>
</tr>
<tr>
<td>Ctrl + A</td>
<td>全选</td>
<td></td>
</tr>
<tr>
<td>Ctrl + C</td>
<td>复制选择的项目</td>
<td></td>
</tr>
<tr>
<td>Ctrl + X</td>
<td>剪切选择的项目</td>
<td></td>
</tr>
<tr>
<td>Ctrl + V</td>
<td>粘贴被复制或者剪切的项目</td>
<td></td>
</tr>
<tr>
<td>Ctrl + Z</td>
<td>撤销刚才的操作</td>
<td></td>
</tr>
<tr>
<td>ctrl + Y</td>
<td>重新执行刚才的操作</td>
<td>差不多是反撤销，可以理解为撤销被撤销的操作</td>
</tr>
<tr>
<td>Ctrl + F</td>
<td>查找当前页面的指定字符</td>
<td></td>
</tr>
<tr>
<td>Alt + tab</td>
<td>显示当前所有窗口</td>
<td>按住Alt再按tab可以顺序选中不同的窗口,松手后进入选中的页面</td>
</tr>
<tr>
<td>F11</td>
<td>进入全屏</td>
<td>比普通方法进入全屏更强，可以连上边栏的显示也直接关掉，再次按下可关闭全屏</td>
</tr>
</tbody>
</table>
<h1 id="vscode快捷键"><a class="markdownIt-Anchor" href="#vscode快捷键"></a> vscode快捷键</h1>
<ul>
<li>总控制</li>
</ul>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>CTRL + Shift + P、F1</td>
<td>打开顶部命令控制</td>
<td>ctrl + shift + P 会有失灵的时候</td>
</tr>
<tr>
<td>Ctrl + P</td>
<td>打开快捷控制窗口</td>
<td>这个窗口可以快速查找一些当前文件夹下的文件</td>
</tr>
<tr>
<td>Ctrl + shift + N</td>
<td>创建一个全新的vscode窗口</td>
<td></td>
</tr>
<tr>
<td>Ctrl + shift + W</td>
<td>关闭当前窗口</td>
<td></td>
</tr>
<tr>
<td>Ctrl + ,</td>
<td>打开设置（settings）窗口</td>
<td></td>
</tr>
<tr>
<td>Ctrl + K + Ctrl + S</td>
<td>打开设置快捷键的窗口</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>文本编辑</li>
</ul>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl + X</td>
<td>剪切选中部分</td>
<td>与vim插件有冲突，不能使用</td>
</tr>
<tr>
<td>Ctrl + C</td>
<td>复制选中的部分</td>
<td>与vim插件冲突，不能使用</td>
</tr>
<tr>
<td>Alt + 上下方向键</td>
<td>向上或者向下一行一行的移动当前行</td>
<td></td>
</tr>
<tr>
<td>shift + Alt + 上下方向键</td>
<td>向上或者向下复制当前行的内容</td>
<td></td>
</tr>
<tr>
<td>ctrl + shift + K</td>
<td>删除当前行</td>
<td></td>
</tr>
<tr>
<td>Ctrl + enter</td>
<td>在当前行下面插入一行</td>
<td></td>
</tr>
<tr>
<td>Ctrl + shift +enter</td>
<td>在当前行上面插入一行</td>
<td></td>
</tr>
<tr>
<td>Ctrl + 上下方向键</td>
<td>向上下移动页面一行行地移动页面</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>界面控制</li>
</ul>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl + F4，Ctrl + W</td>
<td>关闭当前编辑页</td>
<td>Ctrl + w不知为何用不了</td>
</tr>
<tr>
<td>ctrl +|拆分当前编辑页面（向右）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ctrl + 数字</td>
<td>进入第几个拆分页面</td>
<td></td>
</tr>
<tr>
<td>ctrl + K +方向键</td>
<td>调整拆分页面的排列方式</td>
<td></td>
</tr>
<tr>
<td>Ctrl + shift + `</td>
<td>打开内置的终端</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>文件控制</li>
</ul>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl + N</td>
<td>创建新的编辑文档</td>
<td>要在特定的位置按下才有用</td>
</tr>
<tr>
<td>Ctrl + O</td>
<td>需要在文件选项下按才会有打开文件资源管理器的效果</td>
<td></td>
</tr>
<tr>
<td>Ctrl + F4</td>
<td>关闭当前的标签页</td>
<td></td>
</tr>
<tr>
<td>Ctrl + tab</td>
<td>在标签页之间切换</td>
<td></td>
</tr>
<tr>
<td>ctrl + +/-</td>
<td>控制窗口和字体的大小</td>
<td></td>
</tr>
<tr>
<td>Ctrl + B</td>
<td>打开侧栏</td>
<td></td>
</tr>
<tr>
<td>Ctrl +shift+ E</td>
<td>打开侧边栏文件管理</td>
<td></td>
</tr>
<tr>
<td>Ctrl + shift + F</td>
<td>打开侧边栏查找</td>
<td></td>
</tr>
<tr>
<td>Ctrl + shift + G</td>
<td>打开侧边栏版本管理</td>
<td></td>
</tr>
<tr>
<td>Ctrl + shift + D</td>
<td>打开侧边栏debug</td>
<td></td>
</tr>
<tr>
<td>Ctrl + shift + X</td>
<td>打开侧边栏扩展</td>
<td></td>
</tr>
<tr>
<td>Ctrl + shift + V</td>
<td>打开Markdown预览</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>调试</li>
</ul>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>F9</td>
<td>设置断点</td>
<td></td>
</tr>
<tr>
<td>F5</td>
<td>开始调试</td>
<td></td>
</tr>
<tr>
<td>Shift +F5</td>
<td>停止调试</td>
<td></td>
</tr>
</tbody>
</table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">蜀ICP备2021022902号-1 </a>
      <img src="/images/beian_icon.png" alt="">
  </div>
  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Zestaken</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">678k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:17</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js" integrity="sha256-4mJNT2bMXxcc1GCJaxBmMPdmah5ji0Ldnd79DKd1hoM=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha256-AjM0J5XIbiB590BrznLEgZGLnOQWrt62s3BEq65Q/I0=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha256-9cmf7tcLdXpKsPi/2AWE93PbZpTp4M4tqzFk+lWomjU=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
