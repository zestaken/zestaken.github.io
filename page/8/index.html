<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.zestaken.top","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":true,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="吾好梦中读书~">
<meta property="og:type" content="website">
<meta property="og:title" content="ZestJourney">
<meta property="og:url" content="http://www.zestaken.top/page/8/index.html">
<meta property="og:site_name" content="ZestJourney">
<meta property="og:description" content="吾好梦中读书~">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zestaken">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://www.zestaken.top/page/8/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/8/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ZestJourney</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ZestJourney</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">乐游记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zestaken</p>
  <div class="site-description" itemprop="description">吾好梦中读书~</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">84</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">60</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/Git/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/Git/index.html" class="post-title-link" itemprop="url">Git</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-30 22:22:38" itemprop="dateCreated datePublished" datetime="2020-08-30T22:22:38+08:00">2020-08-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:41:21" itemprop="dateModified" datetime="2022-09-17T19:41:21+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">杂技术</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="git"><a class="markdownIt-Anchor" href="#git"></a> Git</h1>
<p><a target="_blank" rel="noopener" href="https://git-scm.com/book/en/v2/Getting-Started-First-Time-Git-Setup">官方文档</a></p>
<h2 id="git简介"><a class="markdownIt-Anchor" href="#git简介"></a> Git简介</h2>
<ul>
<li>Git是一个开源的分布式版本控制系统;</li>
<li>所谓分布式，是指每个人的电脑上都有一个版本库（仓库），而每当要与别人合作的时候便把自己的版本库推送到模拟的“中央服务器”上，别人再从这个“中央服务器”中获得该版本库。</li>
</ul>
<h2 id="git安装及配置"><a class="markdownIt-Anchor" href="#git安装及配置"></a> Git安装及配置</h2>
<ul>
<li>在linux上可以通过<code>sudo apt-get git</code>来直接安装;在Windows上需要到<a target="_blank" rel="noopener" href="https://git-scm.com/downloads">Git的官网下载</a>;而在Mac上的安装可以在命令行通过<a target="_blank" rel="noopener" href="https://brew.sh/">homebrew</a>安装，但实际上Mac的Xcode上集成了Git，安装Xcode的时候就已经安装好了Git。</li>
<li><strong>配置用户名和用户邮箱</strong>：  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git config --global user.name &quot;yourname&quot;
git config --global user.email &quot;youremail&quot;</code></pre>
<ul>
<li><code>--config</code>这个参数，代表你这台机器上的所有仓库都使用这个用户名和邮箱。</li>
</ul>
</li>
</ul>
<h2 id="创建版本库仓库"><a class="markdownIt-Anchor" href="#创建版本库仓库"></a> 创建版本库(仓库)</h2>
<ul>
<li>版本库又名仓库，英文名repository，你可以简单理解成一个目录(文件夹），这个目录(目录的路径设置成英文避免出现问题）里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</li>
<li>仓库的初始化：进入当前目录下，打开“Git bash”,在终端输入<code>git init</code>,之后会在当前目录下生成一个<code>.git</code>文件目录，这是Git用来跟踪这个目录的文件，不能随意改动。</li>
<li>在当前目录下创建一个文件之后，需要将这个文件加入Git的暂存区中，此时使用<code>git add &lt;filename&gt;</code>（<code>git add .</code>可以将当前目录下的所有文件加入暂存区）（当修改的文件不在当前目录下，而在更深的文件夹中，则需要使用该文件的相对路径作为<code>git add</code>后面的参数。）</li>
<li>暂存区的文件需要加入Git的版本分支中，才算完成了整个文件的Git版本管理，此时使用<code>git commit -m &quot;本次提交说明&quot;</code></li>
</ul>
<h2 id="时间轴上版本查看"><a class="markdownIt-Anchor" href="#时间轴上版本查看"></a> 时间轴上版本查看</h2>
<h3 id="分支状态查看"><a class="markdownIt-Anchor" href="#分支状态查看"></a> 分支状态查看</h3>
<ul>
<li>使用<code>git stastus</code>查看<strong>当前分支</strong>(如果有除了master分支的其他分支的信息，除非当前在那条分支上，否则是不会显示那条分支的信息的）的状态，例如主分支下有多少分分支，以及暂存区多少文件待提交。</li>
<li>使用<code>git status</code>查看当前分支的状态，例如主分支下有多少分分支，以及暂存区多少文件待提交。</li>
</ul>
<h3 id="查看具体修改内容"><a class="markdownIt-Anchor" href="#查看具体修改内容"></a> 查看具体修改内容</h3>
<ul>
<li>使用<code>git diff &lt;filename&gt;</code>可以查看具体的修改内容。</li>
</ul>
<h3 id="查看commit的历史记录"><a class="markdownIt-Anchor" href="#查看commit的历史记录"></a> 查看commit的历史记录</h3>
<ul>
<li>使用<code>git log</code>可以看到从最近到最远的所有commit记录，每个记录都会有commit的版本号id（一串乱七八糟的数字）,时间，作者以及commit时的描述。（此处就显得commit时一个合适的描述是多么的重要。）</li>
</ul>
<h3 id="版本回退回退commit"><a class="markdownIt-Anchor" href="#版本回退回退commit"></a> 版本回退（回退commit）</h3>
<ul>
<li>Git中用HEAD来表示当前版本，HEAD<sup>来表示上一个版本，HEAD</sup>^来表示上上个版本，而至于像100次提交前的版本，则用HEAD~100来表示。</li>
<li>要回到某一个版本可以使用<code>git reset --hard HEAD^</code>或者<code>git reset --hard &lt;版本号&gt;</code>(版本号不用输完，指数前几位即可，Git会自动去寻找符号这部分版本号的commit)。</li>
</ul>
<h3 id="查看历史命令"><a class="markdownIt-Anchor" href="#查看历史命令"></a> 查看历史命令</h3>
<ul>
<li>使用<code>git reflog</code>可以查看历史命令。</li>
</ul>
<h3 id="撤销工作区的修改"><a class="markdownIt-Anchor" href="#撤销工作区的修改"></a> 撤销工作区的修改</h3>
<ul>
<li>
<p>使用<code>git checkout -- &lt;filename&gt;</code>可以将工作区的某文件恢复至上一次<code>git add</code>或者<code>git commit</code>时的状态。（注意，<code>--</code>和`<filename>之间有一个空格）。</p>
</li>
<li>
<p>总结： <code>git reset</code>是撤销版本库的修改（即.git文件中的版本信息）,<code>git checkout</code>是撤销对工作区文件的修改（即当前电脑上真实的文件，实际原理是从.git文件中的暂存区或者版本库中把以前的版本还原到工作区中。）</p>
</li>
<li>
<p>删除文件</p>
</li>
<li>
<p>工作区文件被删除后，会导致版本库和工作区中的文件不一致。为了使工作区与版本库一致，可以使用<code>gir rm &lt;filename&gt;</code>删除，在<code>git conmmit -m &quot;删除描述&quot;</code>将版本库中的文件也删除。当然，我们也可以用<code>git checkout --&lt;filename&gt;</code>恢复工作区中被误删的文件。</p>
</li>
</ul>
<h2 id="远程仓库"><a class="markdownIt-Anchor" href="#远程仓库"></a> 远程仓库</h2>
<h3 id="使用ssh与远程主机github关联"><a class="markdownIt-Anchor" href="#使用ssh与远程主机github关联"></a> 使用SSH与远程主机（GitHub）关联</h3>
<ul>
<li>前面说到使用Git与多人合作，需要使用一个类似“中央服务器”的东西，我们可以自己创建一个Git服务器来充当这个中央服务器，也可以直接使用GitHub来充当这个东西。</li>
<li>首先得使用SSH将本地机与GitHub关联起来，是两者之间能够安全的传输数据。</li>
</ul>
<h4 id="创建本机的ssh秘钥"><a class="markdownIt-Anchor" href="#创建本机的ssh秘钥"></a> 创建本机的SSH秘钥</h4>
<ul>
<li>首先查看自己用户主目录中有没有一个<code>.ssh</code>的文件（我的电脑是在<code>C:\Users\12246\.ssh</code>）。如果没有则使用<code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code>创建。</li>
<li>在<code>.ssh</code>文件中会有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，其中<code>id_rsa</code>是私钥，<code>id_rsa.pub</code>是公钥。</li>
</ul>
<h4 id="将ssh公钥放入github账号中"><a class="markdownIt-Anchor" href="#将ssh公钥放入github账号中"></a> 将SSH公钥放入GitHub账号中</h4>
<ul>
<li>然后登录GitHub，在设置中找到设置SSH的地方，将本机上的公钥粘贴上去（粘贴的时候可能会出现格式错误，比如我用vim打开id_rsa.pub复制的就不行，而用cat查看复制就可以。）。这样就建立了本地机与GitHub的关联。只有将公钥放在GitHub上的电脑，才可以将文件上传到GitHub上。</li>
</ul>
<h3 id="创建远程仓库"><a class="markdownIt-Anchor" href="#创建远程仓库"></a> 创建远程仓库</h3>
<ul>
<li>首先在GitHub账号中创建一个仓库</li>
<li>之后将本地仓库与GitHub中的远程仓库关联起来。在本地仓库目录下打开Gitbash输入如下指令<code>$ git remote add origin git@github.com:&lt;GitHub上的username》/&lt;GitHub上的远程仓库名&gt;.git</code>,便将当前目录下的本地仓库与远程的仓库关联起来了。在本地机上远程库的名字叫orgin，这是远程仓库的默认叫法，当然也可以叫其它名字，只需再关联远程仓库时将orgin改成其它名字即可。</li>
</ul>
<h3 id="推送到远程仓库"><a class="markdownIt-Anchor" href="#推送到远程仓库"></a> 推送到远程仓库</h3>
<ul>
<li>使用<code>git push -u orgin master</code>，将当前库中的当前分支推送到远程库的master中。（在这个命令中，参数 -u只有在第一次推送这个分支时才需要使用，若不是第一次，只需<code>git push orgin master</code>即可；其中，origin是远程仓库在本地的名字，而master是远程仓库的分支名。）</li>
</ul>
<h3 id="从远程库克隆"><a class="markdownIt-Anchor" href="#从远程库克隆"></a> 从远程库克隆</h3>
<ul>
<li>使用<code>git clone git@github.com:&lt;GitHub上的username》/&lt;GitHub上的远程仓库名&gt;.git</code>可以将远程的仓库克隆到本地（在哪个目录下打开gitbash使用的克隆，最后克隆下来的仓库就在哪个目录）(使用一<code>git clone</code>与使用<code>git pull</code>以及<code>git fetch</code>等一样，当执行命令后叫确认的时候不要直接回车，而应按照它所说的输入yes或者no。)</li>
<li>除了使用<code>git@....</code>格式的地址外，还可以使用普通的http地址，只是传输速度相对较慢。</li>
</ul>
<h2 id="分支管理"><a class="markdownIt-Anchor" href="#分支管理"></a> 分支管理</h2>
<h3 id="创建分支"><a class="markdownIt-Anchor" href="#创建分支"></a> 创建分支</h3>
<ul>
<li>使用<code>git branch &lt;分支名字&gt;</code>可以创建一个分支。</li>
<li>使用<code>git checkout &lt;分支名字&gt;</code>或者<code>git switch &lt;分支名字&gt;</code>可以切换到分支。</li>
<li>使用<code>git checkour -b &lt;分支名字&gt;</code>或者<code>git switch -c &lt;分支名字&gt;</code>可以创建一个分支并切换至那个分支。</li>
</ul>
<h3 id="查看分支"><a class="markdownIt-Anchor" href="#查看分支"></a> 查看分支</h3>
<ul>
<li>使用<code>git branch</code>可以查看所有分支，当前分支前面会有一个<code>*</code>标识。</li>
<li>切换至分支上后，我们所有的提交都是在分支上延伸出去。分支的开始位置是在主分支上申请分支的结点。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200901175215.jpg" alt="" /></li>
</ul>
<h3 id="合并分支"><a class="markdownIt-Anchor" href="#合并分支"></a> 合并分支</h3>
<ul>
<li>假如要把其他分支合并到master分支，首先需要切换回master分支；</li>
<li>使用<code>git merge &lt;需要被合并的分支名字&gt;</code>可以把指定的分支合并到<strong>当前分支</strong>。</li>
</ul>
<h4 id="快速合并"><a class="markdownIt-Anchor" href="#快速合并"></a> 快速合并</h4>
<ul>
<li>当master在创建分支后完全没有修改过，而其他分支内容有所修改，此时的合并直接就是把master指向其他分支的当前提交，过程十分的快速。</li>
</ul>
<h4 id="修改合并"><a class="markdownIt-Anchor" href="#修改合并"></a> 修改合并</h4>
<ul>
<li>当master分支和其他分支都各自有不同的修改时，合并分支操作会把他们各自的修改合并在一起成为新的master分支。</li>
</ul>
<h4 id="解决冲突合并"><a class="markdownIt-Anchor" href="#解决冲突合并"></a> 解决冲突合并</h4>
<ul>
<li>当master分支和其它分支都有修改并且有对同一个地方的不同的修改，此时就需要我们手动解决冲突。当使用<code>git merge &lt;分支名&gt;</code>后，会提示分支无法自动合并，需要我们手动解决。<code>git status</code>可以告诉我们有冲突的文件，此时我们打开有冲突的文件，会发现有<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD</code>以及<code>==========</code>和<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;分支名</code>的标识，我们只需要在有标识的地方把文件改成自己想要的样子，之后再正常add和commit即可。</li>
</ul>
<h3 id="查看分支合并的状况"><a class="markdownIt-Anchor" href="#查看分支合并的状况"></a> 查看分支合并的状况</h3>
<ul>
<li>使用带参数的log可以查看分支合并的情况。<code>git log --graph --pretty=oneline --abbrev-commit</code>.或者直接<code>git log --graph</code>查看分支合并图。</li>
</ul>
<h3 id="删除分支"><a class="markdownIt-Anchor" href="#删除分支"></a> 删除分支</h3>
<ul>
<li>删除分支常在分支被合并到主分支之后；</li>
<li>使用<code>git branch -d &lt;分支名字&gt;</code>来删除指定的分支。</li>
</ul>
<h3 id="隐藏工作区"><a class="markdownIt-Anchor" href="#隐藏工作区"></a> 隐藏工作区</h3>
<ul>
<li>使用<code>git stash</code></li>
</ul>
<h2 id="本地管理远程库"><a class="markdownIt-Anchor" href="#本地管理远程库"></a> 本地管理远程库</h2>
<h3 id="查看远程库的信息"><a class="markdownIt-Anchor" href="#查看远程库的信息"></a> 查看远程库的信息</h3>
<ul>
<li>使用<code>git remote</code>或者<code>git remote -v</code>查看远程库的信息。</li>
</ul>
<h3 id="推送分支"><a class="markdownIt-Anchor" href="#推送分支"></a> 推送分支</h3>
<ul>
<li>使用<code>git push &lt;远程分支在本地的名字&gt; &lt;本地分支名&gt;</code>,可以将本地的指定分支推送到远程分支上。</li>
</ul>
<h3 id="抓取分支"><a class="markdownIt-Anchor" href="#抓取分支"></a> 抓取分支</h3>
<ul>
<li>使用<code>git pull</code>抓取关联的远程分支</li>
</ul>
<h3 id="整理分支线"><a class="markdownIt-Anchor" href="#整理分支线"></a> 整理分支线</h3>
<ul>
<li>使用命令<code>git rebase</code></li>
</ul>
<h2 id="标签管理"><a class="markdownIt-Anchor" href="#标签管理"></a> 标签管理</h2>
<h3 id="创建标签"><a class="markdownIt-Anchor" href="#创建标签"></a> 创建标签</h3>
<ul>
<li>使用<code>git tag &lt;标签名&gt;</code>可以给当前分支的最近提交打上一个标签。</li>
<li>使用<code>git tag</code>查看所有标签；</li>
<li>使用<code>git tag &lt;标签名&gt; &lt;commit id&gt;</code>给具体某个commit打上标签。</li>
<li>使用<code>git show &lt;标签名&gt;</code>查看某个标签的具体信息。</li>
</ul>
<h3 id="远程标签"><a class="markdownIt-Anchor" href="#远程标签"></a> 远程标签</h3>
<ul>
<li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签。</li>
<li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li>
<li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li>
<li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%9B%BE/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%9B%BE/index.html" class="post-title-link" itemprop="url">第七章 图</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-15 00:45:37" itemprop="dateCreated datePublished" datetime="2020-08-15T00:45:37+08:00">2020-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:27:52" itemprop="dateModified" datetime="2022-09-17T19:27:52+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">专业基础</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="图"><a class="markdownIt-Anchor" href="#图"></a> 图</h1>
<p>由于考试压力。。。还有待完善。。。</p>
<h2 id="图的定义"><a class="markdownIt-Anchor" href="#图的定义"></a> 图的定义</h2>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815081734.jpg" alt="" /></p>
<ul>
<li>图由顶点集合和边集合产生</li>
</ul>
<h3 id="有向图和无向图"><a class="markdownIt-Anchor" href="#有向图和无向图"></a> 有向图和无向图</h3>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815081931.jpg" alt="" /></p>
<ul>
<li>有向图的边带有箭头，而无向图的边没有箭头。</li>
<li>无向边用<code>()</code>表示，而有向边用<code>&lt;&gt;</code>表示。</li>
</ul>
<h3 id="图的基本术语"><a class="markdownIt-Anchor" href="#图的基本术语"></a> 图的基本术语</h3>
<ul>
<li><strong>端点和邻接点</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815082218.jpg" alt="" />
<ul>
<li>一条边的两头的顶点为端点，这两个端点互为邻接点。</li>
</ul>
</li>
<li><strong>顶点的度、入度和出度</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815082421.jpg" alt="" />
<ul>
<li>有向图的度又分为出度和入度。</li>
<li>度、顶点数和边数的关系<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815082652.jpg" alt="" />
<ul>
<li>每个顶点的度都代表了一条边，但是又因为每个边两头会有两个顶点，所以把所有顶点的度相加再除以2便是边的数目。</li>
</ul>
</li>
</ul>
</li>
<li><strong>完全图</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815083033.jpg" alt="" />
<ul>
<li>完全无向图：每个顶点都与剩下的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个顶点直接有边相连，总共有n个结点，但是这样算，每条边都被算了两次，所以总边数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n(n-1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>。</li>
<li>完全有向图：因为每两个顶点之间都有两条方向不同的边，所以总边数直接就为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>,无需再除以2。</li>
</ul>
</li>
<li><strong>稠密图和稀疏图</strong>
<ul>
<li>稠密图：接近完全图的图；</li>
<li>稀疏图：含有边数较少的图（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mo>&lt;</mo><mo>&lt;</mo><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e&lt;&lt;n(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>）。</li>
</ul>
</li>
<li><strong>子图</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815084016.jpg" alt="" />
<ul>
<li>类似集合中子集的关系。</li>
</ul>
</li>
<li><strong>路径和路径长度</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815084731.jpg" alt="" />
<ul>
<li>路径上无重复结点的路径为简单路径（开始和结尾可以重复）。</li>
</ul>
</li>
<li><strong>回路和环</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815084909.jpg" alt="" />
<ul>
<li>开始与结尾相同的简单路径为简单回路或简单环。</li>
</ul>
</li>
<li><strong>连通、连通图和连通分量</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815085209.jpg" alt="" />
<ul>
<li>连通图的连通分量为自身；而非连通图的连通分量可能有多个；</li>
<li>非连通图的连通分量是原来图中不相连的几个部分；如果原来连通的部分再被拆开，则不是连通分量。例如：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815085655.jpg" alt="" />
<ul>
<li>图2和图3是图1的连通分量，而图4不是。</li>
</ul>
</li>
</ul>
</li>
<li><strong>强连通图和强连通分量</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815103923.jpg" alt="" />
<ul>
<li>强连通图是针对有向图而言的，任意两个结点之间连通的前提下，还要这两个结点间可以互通。</li>
<li>在非强连通图中找强连通分量的方法：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815104350.jpg" alt="" />
<ul>
<li>先找出一个有向环，在这个环内各个顶点之间是互通的，然后再去增加环外与环上任一顶点互通的顶点，从而这个顶点肯定与环内其余顶点互通，从而构建出了强连通分量。</li>
</ul>
</li>
</ul>
</li>
<li><strong>权和网</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815105816.jpg" alt="" />
<ul>
<li>给边加上权，带权图即为网。</li>
</ul>
</li>
</ul>
<h2 id="图的存储结构"><a class="markdownIt-Anchor" href="#图的存储结构"></a> 图的存储结构</h2>
<p>1.邻接矩阵：</p>
<ul>
<li>特别适合于稠密图的存储。</li>
<li>一个图的邻接矩阵的表示是唯一的。</li>
<li>无向图与有向图均可存储。<br />
2.邻接表：</li>
<li>特别适合稀疏图的存储；</li>
<li>一个图的邻接表表示不唯一。</li>
<li>普通邻接表不能表现边的方向性，所以存储有向图需要使用<strong>逆邻接表</strong>。<br />
3.十字链表
<ul>
<li>储存有向图<br />
4.邻接多重表</li>
</ul>
</li>
<li>存储无向图</li>
</ul>
<h3 id="邻接矩阵"><a class="markdownIt-Anchor" href="#邻接矩阵"></a> 邻接矩阵</h3>
<ul>
<li><strong>邻接矩阵定义</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815105755.jpg" alt="" />
<ul>
<li>通过数组下标与顶点的编号之间的对应关系，来表示两个顶点之间的边。因为矩阵的大小是根据顶点数固定了的，所以当图很稀疏时，即图中的边数较少时，会有很多空间的浪费。</li>
<li>由此可知，无向图的邻接矩阵一定是一个主对角线上的元素全为0的对称矩阵。</li>
<li>示例：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815105816.jpg" alt="" /></li>
</ul>
</li>
<li><strong>邻接矩阵存储类型定义</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815110730.jpg" alt="" />
<ul>
<li>需要设立一个二维数组（邻接矩阵）来存储边的信息，一个一维数组来存储顶点的信息；</li>
<li>顶点的信息中包括顶点的编号和它的数据信息。</li>
<li>实质是一种顺序存储结构。</li>
</ul>
</li>
</ul>
<h3 id="邻接表"><a class="markdownIt-Anchor" href="#邻接表"></a> 邻接表</h3>
<ul>
<li><strong>邻接表的定义</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815111128.jpg" alt="" />
<ul>
<li>通过链表来表示顶点之间边的关系；因为链表的长度是动态的，所以当图较稀疏时，也不会有太多存储空间浪费。</li>
<li>用一个数组来记录每个顶点的信息。</li>
<li>每个顶点对应的单链表只是表示它们是顶点的邻接点，而单链表结点之间并无关系。</li>
<li>示例：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815111437.jpg" alt="" /></li>
</ul>
</li>
<li><strong>邻接表存储类型定义</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815111929.jpg" alt="" />
<ul>
<li>边结点类型即单链表结点的类型；</li>
<li>头结点类型即存储在数组中的顶点类型；</li>
<li>通过在数组中检索到顶点，再由顶点通过顶点类型中定义的指向对应单链表的指针来找到该顶点的边信息。</li>
</ul>
</li>
<li><strong>逆邻接表</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815112323.jpg" alt="" />
<ul>
<li>用于存储有向图；</li>
<li>对于每个顶点的单链表中，存储的是有边指向该顶点的顶点。</li>
</ul>
</li>
</ul>
<h3 id="十字链表"><a class="markdownIt-Anchor" href="#十字链表"></a> 十字链表</h3>
<ul>
<li><strong>十字链表的基本概念</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815124639.jpg" alt="" />
<ul>
<li>在邻接表的基础上，每个顶点结点增加一个指向边结点的指针。即每个顶点结点中既记录了出边的信息，又记录了入边的信息；</li>
<li>每个边结点增加相对的起点和终点信息（起点即指向它的顶点，终点即它指向的顶点）,另外使用指向下一个相同终点或起点的指针（即指向对同一个顶点的入边或者出边）,来为某一个顶点的入边或者出边形成一个相对的单链表。</li>
</ul>
</li>
<li><strong>十字链表的实现模型</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815125018.jpg" alt="" />
<ul>
<li>例如：0顶点的两条入边，2和3在第一列被链起来了；而3的三条出边2，0，1在最后一行被链起来了。</li>
</ul>
</li>
</ul>
<h3 id="邻接多重表"><a class="markdownIt-Anchor" href="#邻接多重表"></a> 邻接多重表</h3>
<ul>
<li><strong>邻接多重表的基本概念</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815131029.jpg" alt="" />
<ul>
<li>与十字链表类似，只不过去掉了方向性（即起点与终点之分）</li>
</ul>
</li>
<li><strong>邻接多重表的实现模型</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815131254.jpg" alt="" />
<ul>
<li>例如：0的两条边，3和1在第一行通过靠0来识别的指针链起来了；1的三条边，0、2和4通过以1为标识来识别的指针在第一列链起来了。</li>
</ul>
</li>
</ul>
<h2 id="图的基本运算邻接表"><a class="markdownIt-Anchor" href="#图的基本运算邻接表"></a> 图的基本运算（邻接表）</h2>
<h3 id="图的创建"><a class="markdownIt-Anchor" href="#图的创建"></a> 图的创建</h3>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815175445.jpg" alt="" /></p>
<ul>
<li>先给邻接表分配空间（AdjGraph）;</li>
<li>再让所有头结点（即储存图顶点的数组adjlist）指向第一条边结点的指针域为空；</li>
<li>遍历邻接矩阵中的所有元素，将存在的边，存入边结点类型中（Arcnode）,之后再将边结点以头插法的方式插入到头结点后面。</li>
<li>有两重循环，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="图的输出"><a class="markdownIt-Anchor" href="#图的输出"></a> 图的输出</h3>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815180314.jpg" alt="" /></p>
<ul>
<li>把邻接表的头结点的编号，相邻结点，边的权重，依次打印即可。</li>
</ul>
<h3 id="图的销毁"><a class="markdownIt-Anchor" href="#图的销毁"></a> 图的销毁</h3>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815180909.jpg" alt="" /></p>
<ul>
<li>依次遍历所有头结点；</li>
<li>在遍历每个头结点时，遍历它身后的边结点链，并逐个释放。</li>
</ul>
<h3 id="邻接表转换为邻接矩阵"><a class="markdownIt-Anchor" href="#邻接表转换为邻接矩阵"></a> 邻接表转换为邻接矩阵</h3>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815181559.jpg" alt="" /></p>
<ul>
<li>进入头结点后的边结点链表，然后将当前扫描的边结点编号作为邻接矩阵的列标（头结点编号作为行标）,并修改当前行标列标下的邻接矩阵元素的权重值。</li>
<li>虽有两重循环，但实际只对所有头结点和边结点访问了一次，所以算法的时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span></span>,n为头结点数，e为边结点数。而把邻接矩阵转化为邻接表的的算法，却对许多没有存在的边也要访问一次，所以时间复杂度要高一些。</li>
</ul>
<h2 id="图的遍历"><a class="markdownIt-Anchor" href="#图的遍历"></a> 图的遍历</h2>
<ul>
<li>图的遍历：从给定的图中的任意一个顶点开始，按照某种方法，沿着图的边访问图中所有的顶点，且每个顶点仅被访问一次。</li>
<li>图的遍历序列：通过图的遍历得到的顶点序列称为图的遍历序列。</li>
<li>图的遍历方法：
<ol>
<li>深度优先遍历（DFS：depth-first search）</li>
<li>广度优先遍历(BFS: breadth-first search)</li>
</ol>
</li>
</ul>
<h3 id="深度优先遍历对无向连通图"><a class="markdownIt-Anchor" href="#深度优先遍历对无向连通图"></a> 深度优先遍历（对无向连通图）</h3>
<ul>
<li>
<p><strong>基本原理</strong><br />
1.首先访问出发点v，并将其标记为已访问过；<br />
2.然后依次从v出发搜索v的每个邻接点w。若w未曾访问过，则以w为新的出发点继续进行深度优先遍历，直至图中所有和<strong>源点v有路径相通的顶点</strong>均已被访问为止。<br />
3.若此时图中仍有未访问的顶点，则另选一个尚未访问的顶点为新的源点重复上述过程，直至图中所有的顶点均已被访问为止。<br />
4.注意：<strong>深度优先遍历尽可能优先往深层次进行搜索。</strong><br />
5.<strong>使用一次深度优先遍历只能访问到初始点所在连通分量中的所有顶点，不可能访问到其它连通分量中的顶点</strong></p>
</li>
<li>
<p><strong>实现过程</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815184154.jpg" alt="" /></p>
<ul>
<li>按照访问一个顶点之后便找它的邻接点来访问的递归思路，可以一直穷尽一条通路；</li>
<li>一条路走完之后，便重新找一个没有被访问过的顶点，继续重复这样的访问；</li>
<li>直到最后所有顶点都已被访问过，便停止访问。</li>
</ul>
</li>
<li>
<p><strong>算法实现</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815183638.jpg" alt="" /></p>
<ul>
<li>设计一个<strong>全局数组</strong>，用它的下标代表顶点的编号，每次一个顶点被访问过之后，就将该数组对应的元素置为1，表示该顶点已经被访问过了；</li>
<li>最后退出递归时，是因为到了通路的最后一个顶点，这个顶点唯一的邻接点已经被访问过了，然后终止循环退出；但是，一旦退出递归，若这条通路上的所有顶点，都不与某个顶点向连通，那个顶点便永远无法访问到,这也是这种算法只能遍历无向连通图的原因。</li>
</ul>
</li>
</ul>
<h3 id="广度优先遍历对无向连通图"><a class="markdownIt-Anchor" href="#广度优先遍历对无向连通图"></a> 广度优先遍历（对无向连通图）</h3>
<ul>
<li>
<p><strong>基本原理</strong><br />
1.首先访问出发点v<br />
2.接着依次访问v的所有邻接点w1、w2…wt<br />
3.然后依次访问w1、w2…wt邻接的所有未曾访问过的顶点。<br />
4.以此类推，直至图中所有和源点v有路径相通的顶点都已访问到为止。此时从v开始的搜索过程结束。<br />
5.注意：广度优先遍历按层次优先搜索最近的结点，一层一层往外搜索。深度优先是不断深挖每一个被访问了的顶点的邻接点，广度优先是先将当前顶点的所有邻接点访问完。<br />
6. <strong>同深度优先遍历一样，由于每次访问的都是与当前顶点有一定关系的顶点，所以只能适用于遍历无向连通图</strong></p>
</li>
<li>
<p><strong>实现过程</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815191255.jpg" alt="" /></p>
<ul>
<li>先访问完当前顶点的所有未被访问过的邻接点；</li>
<li>到最后一个邻接点时，转向其它顶点。</li>
<li>直到所有顶点均已被访问，便停止访问。</li>
</ul>
</li>
<li>
<p><strong>算法实现</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815192349.jpg" alt="" /></p>
<ul>
<li>使用队列来实现广度优先遍历，并未像深度优先算法一样才用递归的方法;</li>
<li>设置一个标记数组（无需全局数组，因为广度优先算法直接使用队列，借用一个循环便可完成，不须递归使用函数）,来确定某个顶点是否已经被访问过了。</li>
<li>将第一个要访问的顶点访问后进队；</li>
<li>之后设置循环将队列元素出队并访问它的未被访问过的邻接点，然后将每个被访问的邻接点被访问后都进队，直到当前出队的元素的所有邻接点均已被访问完，之后再出队一个元素，重复此过程，直到队列为空。由于访问的元素与初始元素都有关系，所以这种算法只能用来遍历无向连通图。</li>
</ul>
</li>
</ul>
<h3 id="非连通图的遍历"><a class="markdownIt-Anchor" href="#非连通图的遍历"></a> 非连通图的遍历</h3>
<ul>
<li>可以通过多次调用DFS或者BFS算法，来访问多个连通分量。</li>
</ul>
<h4 id="深度优先遍历"><a class="markdownIt-Anchor" href="#深度优先遍历"></a> 深度优先遍历</h4>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815194234.jpg" alt="" /></p>
<ul>
<li>其中<code>DFS</code>算法是前面遍历无向连通图的深度优先算法；</li>
</ul>
<h4 id="广度优先遍历"><a class="markdownIt-Anchor" href="#广度优先遍历"></a> 广度优先遍历</h4>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815194402.jpg" alt="" /></p>
<ul>
<li>其中<code>BFS</code>算法是前面遍历无向连通图的广度优先算法。</li>
<li>此处的标记数组visted是全局数组。</li>
</ul>
<h4 id="利用遍历来判断无向图是否连通"><a class="markdownIt-Anchor" href="#利用遍历来判断无向图是否连通"></a> 利用遍历来判断无向图是否连通</h4>
<ul>
<li><strong>基本思路</strong>
<ul>
<li>使用某种遍历算法遍历该邻接表；</li>
<li>若一次遍历后，标记数组visited的所有元素均为1，即所有元素都已被遍历过了，则该图是连通图，反之，则不是。</li>
</ul>
</li>
<li><strong>算法实现</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815194938.jpg" alt="" />
<ul>
<li>在调用依次遍历算法后，在遍历标记数组，看是否有元素为0.</li>
</ul>
</li>
</ul>
<h3 id="深度优先遍历的应用"><a class="markdownIt-Anchor" href="#深度优先遍历的应用"></a> 深度优先遍历的应用</h3>
<h4 id="判断某两个顶点之间是否存在简单路径深度优先"><a class="markdownIt-Anchor" href="#判断某两个顶点之间是否存在简单路径深度优先"></a> 判断某两个顶点之间是否存在简单路径（深度优先）</h4>
<ul>
<li>
<p><strong>基本思路</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815213644.jpg" alt="" /></p>
</li>
<li>
<p><strong>算法实现</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815214032.jpg" alt="" /></p>
</li>
</ul>
<h4 id="输出某两个顶点之间的一条简单路径深度优先"><a class="markdownIt-Anchor" href="#输出某两个顶点之间的一条简单路径深度优先"></a> 输出某两个顶点之间的一条简单路径(深度优先)</h4>
<ul>
<li>
<p><strong>基本思路</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815214256.jpg" alt="" /></p>
</li>
<li>
<p><strong>算法实现</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815214557.jpg" alt="" /></p>
</li>
</ul>
<h4 id="输出某两个顶点之间的全部简单路径深度优先"><a class="markdownIt-Anchor" href="#输出某两个顶点之间的全部简单路径深度优先"></a> ？？输出某两个顶点之间的全部简单路径（深度优先）</h4>
<ul>
<li>
<p><strong>基本思路</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815214910.jpg" alt="" /></p>
</li>
<li>
<p><strong>算法实现</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815215424.jpg" alt="" /></p>
</li>
</ul>
<h4 id="输出某个顶点的全部回路"><a class="markdownIt-Anchor" href="#输出某个顶点的全部回路"></a> ??输出某个顶点的全部回路</h4>
<ul>
<li>
<p><strong>基本思路</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815215915.jpg" alt="" /></p>
</li>
<li>
<p><strong>具体算法</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815220035.jpg" alt="" /></p>
</li>
</ul>
<h3 id="广度优先遍历的应用"><a class="markdownIt-Anchor" href="#广度优先遍历的应用"></a> 广度优先遍历的应用</h3>
<h4 id="求不带权无向连通图某两顶点之间的一条最短路径"><a class="markdownIt-Anchor" href="#求不带权无向连通图某两顶点之间的一条最短路径"></a> 求不带权无向连通图某两顶点之间的一条最短路径</h4>
<ul>
<li><strong>算法实现</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815221045.jpg" alt="" />
<ul>
<li>为什么这样找就是最短的？</li>
</ul>
</li>
</ul>
<h2 id="生成树和最小生成树"><a class="markdownIt-Anchor" href="#生成树和最小生成树"></a> 生成树和最小生成树</h2>
<h3 id="生成树的定义"><a class="markdownIt-Anchor" href="#生成树的定义"></a> 生成树的定义</h3>
<ul>
<li><strong>连通图的生成树</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200816082837.jpg" alt="" />
<ul>
<li>连通图的最小生成树含有全部n个顶点，和对应的n-1条边。</li>
</ul>
</li>
<li><strong>带权连通图的最小生成树</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200816083255.jpg" alt="" />
<ul>
<li>最小生成树是针对于带权连通图而言的；</li>
<li>所有边权值之和最小的生成树称为该带权连通图的最小生成树。</li>
</ul>
</li>
<li><strong>遍历方法产生生成树</strong>
<ul>
<li>深度优先生成树：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200816083559.jpg" alt="" /></li>
<li>广度优先生成树：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200816083708.jpg" alt="" /></li>
<li><strong>一个连通图的生成树不一定是唯一的</strong></li>
</ul>
</li>
<li><strong>非连通图的生成森林</strong>
<ul>
<li>多次调用遍历过程。每个连通分量中的顶点集和走过的边一起构成一棵生成树。</li>
<li>所有连通分量的生成树组成非连通图的<strong>生成森林</strong>。</li>
</ul>
</li>
</ul>
<h3 id="最小生成树的构造算法邻接矩阵存储"><a class="markdownIt-Anchor" href="#最小生成树的构造算法邻接矩阵存储"></a> 最小生成树的构造算法（邻接矩阵存储）</h3>
<h4 id="普里姆prim算法"><a class="markdownIt-Anchor" href="#普里姆prim算法"></a> 普里姆（Prim）算法</h4>
<ul>
<li><strong>基本思想</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200816084857.jpg" alt="" />
<ul>
<li>在一个集合中存储已经被访问过的顶点，然后每次在与这些被访问过的顶点相连的边中选一条权值最小的边，然后将该边的另一个未被访问的顶点加入集合中，重复这个步骤，直到所有的顶点都被加入了这个集合。</li>
</ul>
</li>
<li><strong>过程示例</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200816085251.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200816085325.jpg" alt="" /></li>
<li><strong>具体算法</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200816085705.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200816095434.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200816095547.jpg" alt="" />
<ul>
<li>INF 即无穷大的意思，它经常取32767或者65535这样不可能会取到的值，权重为INF表示，这两个顶点不直接相连。</li>
<li>设置两个数组，lowcost存储与已访问过的顶点相连的边的权重,比如lowcost[j]表示j到已访问结点的边的权重。而closest存储已访问过的顶点的下标。</li>
<li>第一步，给两个数组赋初值，lowcost的初值就是与初始顶点与剩余顶点的所有边的权重（到自己的权重为0，到邻接的顶点的权重为实际权重，到不相邻的顶点的权重为INF）,closest的初值便为便为初始顶点。</li>
<li>之后，比较lowcost中元素的大小，找到最小的权重对应的顶点，记录它的编号到k中，**将lowcost[k]设为0，表示编号为k的顶点已经访问过了。</li>
<li>找到k顶点后，将与k元素相连的边的权重与lowcost中储存的边的权重比较，若较小，则存入lowcost中，同时将对应位置的closest设置为k;例如：若lowcost[j]&lt;g.edges[k][j],则将closest[j]设为k,因为closest与lowcost是一一对应的，lowcost和closest的下标都对应未被访问过的顶点（已经被访问过的顶点会由于lowcost[j]而被跳过）,而lowcost的值对应的是与已访问顶点之间权重较小的边的权重，closest的值对应的就是这条边另一头已经被访问过的顶点。</li>
<li>找k的循环循环n-1次，则将整个图的所有元素都被访问了。</li>
<li>每次找到一个k顶点，则将对应的边和顶点输出。（边就是closest[k]到k,顶点就是closest[k]和k)。</li>
</ul>
</li>
<li><strong>时间复杂度</strong>
<ul>
<li>该算法中有两重循环，外重循环n-1次，内重n+n次。所以算法的时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</li>
</ul>
</li>
<li><strong>Prim算法的特点</strong>
<ul>
<li>适合于稠密图求最小生成树，因为每两个顶点间，不管是否存在边，都会被检查，所以如果图很稀疏，那么无用的检查就会很多。</li>
</ul>
</li>
</ul>
<h4 id="克鲁斯卡尔kruskal算法"><a class="markdownIt-Anchor" href="#克鲁斯卡尔kruskal算法"></a> 克鲁斯卡尔（Kruskal）算法</h4>
<ul>
<li><strong>基本思想</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200816103616.jpg" alt="" />
<ul>
<li>Prim算法是以顶点为中心，依次寻找相邻的权值最小的边；而Kruskal算法是一边为中心，逐次选取权值较小的边，最后包含n-1条边便组成了最小生成树。</li>
<li>不过需要注意的是，一旦选取的边生成的回路，便要舍弃这条边。</li>
</ul>
</li>
<li><strong>算法实现</strong>
<ul>
<li>存放边的结构：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200816113957.jpg" alt="" /></li>
<li>具体算法：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200816114726.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200816114934.jpg" alt="" /><br />
* 设置一个标识数组vset来确定一条边的两个顶点是否已经被连接为一个连通分量（一个集合中）,来防止选取的边是生成树形成回路。<br />
* 用一个边数组存储所有的边，并将数组中的边按照权值递增排序。<br />
* 依次选取边数组中的边（因为事先已经排好序了）,利用标识数组vest确定这条边的两个顶点不在一个连通分量中，则输出该边，并将该边的两个顶点对应的表示数组值，改为相同（都为边的起始顶点值），之后选取下一条边；否则，跳过该边，选取下一条边；<br />
* 当选取成功了n-1条边时，终止程序。</li>
</ul>
</li>
<li><strong>Krustal算法的特点</strong>
<ul>
<li>因为是根据边来选择，所以适合于边稀疏图</li>
</ul>
</li>
<li><strong>Krustal算法的时间复杂度</strong>
<ul>
<li>该算法的时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>e</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(elog_2e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span></span>,其中e为边数。</li>
</ul>
</li>
</ul>
<h2 id="最短路径"><a class="markdownIt-Anchor" href="#最短路径"></a> 最短路径</h2>
<h3 id="最短路径定义"><a class="markdownIt-Anchor" href="#最短路径定义"></a> 最短路径定义</h3>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200817233805.jpg" alt="" /></p>
<ul>
<li>对带权有向图而言，路径为从此顶点到目的顶点，而路径长度则为这条路径上所有边的权值之和。</li>
</ul>
<h3 id="单源最短路径问题-狄克斯特拉dijkstra算法"><a class="markdownIt-Anchor" href="#单源最短路径问题-狄克斯特拉dijkstra算法"></a> 单源最短路径问题-狄克斯特拉（Dijkstra）算法</h3>
<ul>
<li>
<p><strong>问题描述</strong></p>
<ul>
<li>给定一个<strong>带权有向图</strong>G与源点v，求从v到G中其他顶点的最短路径（限定各边上的<strong>权值大于或者等于0</strong>）。</li>
</ul>
</li>
<li>
<p><strong>基本原理</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200818212756.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819192549.jpg" alt="" /></p>
<ul>
<li>一步步求出每个顶点与源点的最短距离，每次求最短路径都是基于已经求出最短路径的顶点而求更远顶点的最短路径。</li>
</ul>
</li>
<li>
<p><strong>基本过程</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200818214447.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200818214607.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200818214753.jpg" alt="" /></p>
<ul>
<li>将顶点分为两个集合，一个是已经计算过最短路径的，一个没有；</li>
<li>每次从未被计算过的集合中寻找距离已被计算过的集合最短的顶点，加入该集合中。</li>
<li>最后直到所有顶点都已被计算过最短路径。</li>
</ul>
</li>
<li>
<p><strong>具体算法</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200818220136.jpg" alt="" /></p>
</li>
</ul>
<h3 id="多源最短路径问题-floyed算法"><a class="markdownIt-Anchor" href="#多源最短路径问题-floyed算法"></a> 多源最短路径问题-Floyed算法</h3>
<ul>
<li><strong>问题描述</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819192155.jpg" alt="" /></li>
<li><strong>基本原理</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819192337.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819192801.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819192903.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819193108.jpg" alt="" /></li>
<li><strong>基本过程</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819194244.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819194303.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819194415.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819194512.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819194656.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819194743.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819194928.jpg" alt="" /></li>
<li><strong>具体算法</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819195159.jpg" alt="" /></li>
</ul>
<h2 id="拓扑排序有向图"><a class="markdownIt-Anchor" href="#拓扑排序有向图"></a> 拓扑排序（有向图）</h2>
<h3 id="拓扑排序概念"><a class="markdownIt-Anchor" href="#拓扑排序概念"></a> 拓扑排序概念</h3>
<p>I</p>
<ul>
<li><strong>拓扑序列与拓扑排序</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819200318.jpg" alt="" /></li>
</ul>
<h3 id="拓扑排序操作"><a class="markdownIt-Anchor" href="#拓扑排序操作"></a> 拓扑排序操作</h3>
<ul>
<li><strong>基本过程</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819200530.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819200744.jpg" alt="" /></li>
<li><strong>具体算法</strong>
<ul>
<li><strong>顶点类型</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819200922.jpg" alt="" /></li>
<li><strong>算法</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819211309.jpg" alt="" /></li>
</ul>
</li>
</ul>
<h2 id="aoe网与关键路径"><a class="markdownIt-Anchor" href="#aoe网与关键路径"></a> AOE网与关键路径</h2>
<h3 id="aoe网"><a class="markdownIt-Anchor" href="#aoe网"></a> AOE网</h3>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200820225224.jpg" alt="" /></p>
<h3 id="关键路径"><a class="markdownIt-Anchor" href="#关键路径"></a> 关键路径</h3>
<h4 id="关键路径定义"><a class="markdownIt-Anchor" href="#关键路径定义"></a> 关键路径定义</h4>
<pre><code>![](https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200820225342.jpg)
</code></pre>
<h4 id="求解关键路径"><a class="markdownIt-Anchor" href="#求解关键路径"></a> 求解关键路径</h4>
<ul>
<li><strong>事件的最早开始时间和最迟开始时间</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200820225920.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200820230947.jpg" alt="" /></li>
<li><strong>活动的最早开始时间和最迟开始时间</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200820231244.jpg" alt="" /></li>
<li><strong>求关键活动</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200820231404.jpg" alt="" /></li>
<li><strong>示例</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200820231640.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200820231813.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200820231922.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200820232022.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200820232312.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200820232421.jpg" alt="" /></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/index.html" class="post-title-link" itemprop="url">第六章 树和二叉树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-10 10:05:37" itemprop="dateCreated datePublished" datetime="2020-08-10T10:05:37+08:00">2020-08-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:27:52" itemprop="dateModified" datetime="2022-09-17T19:27:52+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">专业基础</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="树和二叉树"><a class="markdownIt-Anchor" href="#树和二叉树"></a> 树和二叉树</h1>
<h2 id="树"><a class="markdownIt-Anchor" href="#树"></a> 树</h2>
<h3 id="树的定义"><a class="markdownIt-Anchor" href="#树的定义"></a> 树的定义</h3>
<ul>
<li>形式化定义：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810104420.jpg" alt="" /></li>
<li>递归定义：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810104558.jpg" alt="" /></li>
</ul>
<h4 id="树的逻辑表示"><a class="markdownIt-Anchor" href="#树的逻辑表示"></a> 树的逻辑表示</h4>
<ul>
<li>树形表示法：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810104658.jpg" alt="" /></li>
<li>文氏图表示法：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810104800.jpg" alt="" /></li>
<li>凹入表示法：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810104848.jpg" alt="" /></li>
<li>括号表示法：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810104956.jpg" alt="" /></li>
</ul>
<h4 id="树的基本术语"><a class="markdownIt-Anchor" href="#树的基本术语"></a> 树的基本术语</h4>
<ul>
<li><strong>结点的度与树的度</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810105105.jpg" alt="" />
<ul>
<li>结点的度指的是子树的个数；</li>
<li>树的度是<strong>各结点度的最大值</strong></li>
<li><strong>m次数或者m叉树</strong>，其中的m均指的是树的度。（<strong>二叉树是被重新定义过的，它的度小于或者等于2</strong>）</li>
</ul>
</li>
<li><strong>分支结点与叶结点</strong>：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810105401.jpg" alt="" /></li>
<li><strong>路径与路径长度</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810105502.jpg" alt="" />
<ul>
<li>路径是指<strong>两结点间的结点（包含自身）</strong>;</li>
<li>路径长度是指<strong>两结点路径上的分支数目，不是结点的个数</strong>。</li>
</ul>
</li>
<li><strong>孩子结点、双亲结点和兄弟结点</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810105732.jpg" alt="" /></li>
<li><strong>子孙结点和祖先结点</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810105902.jpg" alt="" />
<ul>
<li>子孙结点与孩子结点的区别：子孙结点可以跨很多辈，而孩子结点只是比双亲低一辈；</li>
<li>祖先结点与双亲结点的区别：祖先结点可以跨很多辈。</li>
</ul>
</li>
<li><strong>结点的层次与树的高度（深度）：</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810110201.jpg" alt="" />
<ul>
<li>与结点的度和树的度的关系类似，最大的结点的度为树的度；最大的结点的层次为树的高度（深度）。</li>
</ul>
</li>
<li><strong>有序树与无序树</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810110434.jpg" alt="" /></li>
<li><strong>森林：</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810110535.jpg" alt="" />
<ul>
<li>森林相当于树的上级；</li>
<li>一棵树也同时也是森林。</li>
</ul>
</li>
</ul>
<h3 id="树的性质"><a class="markdownIt-Anchor" href="#树的性质"></a> 树的性质</h3>
<ol>
<li><strong>树中的总结点数等于所有结点的度数之和加1</strong>。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810110918.jpg" alt="" />
<ul>
<li>每个结点的度都表示它的子结点的个数，所以每个结点的度加起来可以表示结点的个数；</li>
<li>但是根结点没有双亲结点，所以没有将根节点加进去，所以得在所有度之和的基础上加一表示根结点。</li>
</ul>
</li>
<li><strong>每层的最大结点数</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810111645.jpg" alt="" />
<ul>
<li>相当于是从根结点递归推下来的：第1层只有一个，第二层最多有m个，第三层最多有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>∗</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">m * m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>个，第四层最多有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>m</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">m^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>个…</li>
</ul>
</li>
<li><strong>一棵树最多的结点数</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810112031.jpg" alt="" />
<ul>
<li>在每层最多结点数的条件下累加起来（等比数列求和）</li>
</ul>
</li>
<li><strong>一颗树的最小高度</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810112321.jpg" alt="" />
<ul>
<li>在一棵树结点数最多的情况下反解出最下高度。</li>
</ul>
</li>
</ol>
<h3 id="树的基本运算"><a class="markdownIt-Anchor" href="#树的基本运算"></a> 树的基本运算</h3>
<h4 id="树的基本操作"><a class="markdownIt-Anchor" href="#树的基本操作"></a> 树的基本操作</h4>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810121713.jpg" alt="" /></p>
<h4 id="树的基本运算-2"><a class="markdownIt-Anchor" href="#树的基本运算-2"></a> 树的基本运算</h4>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810121819.jpg" alt="" /></p>
<h5 id="树的遍历"><a class="markdownIt-Anchor" href="#树的遍历"></a> 树的遍历</h5>
<ol>
<li>先根遍历：若树不空，先访问根结点，然后依次先跟遍历各颗子树（递归描述）</li>
<li>后根遍历：若树不空，先依次后根遍历各颗子树，然后访问根结点；</li>
<li>层次遍历：若树不空，则自上而下，自左至右访问树中的每个结点。</li>
</ol>
<h6 id="树的先根遍历"><a class="markdownIt-Anchor" href="#树的先根遍历"></a> 树的先根遍历</h6>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810122430.jpg" alt="" /></p>
<ul>
<li>根与结点始终是相对的。最开始先到A,此时B,C,D看做三颗子树，A过后到B,此时B又做根，E,F做子树，E,F依次访问完了，才又回到A的角度，遍历A的第二颗子树C，依次递归下去。</li>
</ul>
<h6 id="树的后根遍历"><a class="markdownIt-Anchor" href="#树的后根遍历"></a> 树的后根遍历</h6>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810122913.jpg" alt="" /></p>
<ul>
<li>先找到第一个叶子结点，先从左往右访问它的兄弟结点，这个子树的兄弟结点都访问完了再回到双亲，双亲又访问它的兄弟结点，若它的兄弟结点下面还有结点，则将该结点以及它以下的结点看做一颗子树的整体，进入这颗子树后，又是从第一个叶子结点开始，层层回溯。直到最后回到根结点。</li>
</ul>
<h6 id="树的层次遍历"><a class="markdownIt-Anchor" href="#树的层次遍历"></a> 树的层次遍历</h6>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810123313.jpg" alt="" /></p>
<ul>
<li>遵从从上至下，从左至右的顺序依次遍历即可。</li>
</ul>
<h2 id="二叉树"><a class="markdownIt-Anchor" href="#二叉树"></a> 二叉树</h2>
<h3 id="二叉树的定义"><a class="markdownIt-Anchor" href="#二叉树的定义"></a> 二叉树的定义</h3>
<ul>
<li>
<p><strong>递归定义</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810123739.jpg" alt="" /></p>
</li>
<li>
<p><strong>二叉树的五种基本形态</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810124011.jpg" alt="" /></p>
<ul>
<li>空树和单独一个根结点都可以看做二叉树；</li>
<li>二叉树不须每个结点的度都为2，甚至是只要结点最大的度不超过2即可。这是二叉树与二次树的区别，二次树必须至少有一个度为2的结点（即二次树的度为2，二叉树的度小于或者等于2）</li>
</ul>
</li>
<li>
<p><strong>特殊的二叉树</strong></p>
<ol>
<li><strong>满二叉树</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810124630.jpg" alt="" /></li>
</ol>
<ul>
<li>性质：高度为h的满二叉树恰有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^h - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个结点（由树最多结点数的性质推导）</li>
</ul>
<ol start="2">
<li><strong>完全二叉树</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810125026.jpg" alt="" />
<ul>
<li>完全二叉树包含了满二叉树。</li>
<li>完全二叉树最下层的叶子结点一定先集中在左边。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="二叉树的性质"><a class="markdownIt-Anchor" href="#二叉树的性质"></a> 二叉树的性质</h3>
<ol>
<li><strong>非空二叉树的叶结点数</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810154759.jpg" alt="" />
<ul>
<li>利用度的总数与结点总数的关系推得。</li>
</ul>
</li>
<li><strong>非空二叉树每一层上最多的结点数</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810155328.jpg" alt="" /></li>
<li><strong>非空二叉树最多的结点数</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810155418.jpg" alt="" /></li>
<li><strong>完全二叉树的性质</strong>
<ol>
<li>度数为0的结点数为0或1：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810155628.jpg" alt="" />
<ul>
<li>最后一行如果没有满，就必须从左至右排列叶子结点，上一层同时有两个结点都只有一个分支的情况是不可能发生的。</li>
</ul>
</li>
<li>根据编号判断分支结点和叶子结点<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810160129.jpg" alt="" /></li>
<li><strong>双亲的编号与孩子的编号之间的关系</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810160345.jpg" alt="" /></li>
</ol>
</li>
</ol>
<h3 id="二叉树的存储结构"><a class="markdownIt-Anchor" href="#二叉树的存储结构"></a> 二叉树的存储结构</h3>
<ol>
<li>顺序存储结构</li>
<li>链式存储结构</li>
</ol>
<h4 id="二叉树的顺序存储结构"><a class="markdownIt-Anchor" href="#二叉树的顺序存储结构"></a> 二叉树的顺序存储结构</h4>
<ul>
<li><strong>完全二叉树的顺序存储结构</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810160851.jpg" alt="" />
<ul>
<li>利用双亲与孩子结点编号之间的关系，确定每个结点在数组中的下标，并且根据这种关系来用数组恢复二叉树的逻辑关系。</li>
</ul>
</li>
<li><strong>非完全二叉树的顺序存储结构</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810161304.jpg" alt="" />
<ul>
<li>用空结点将非完全二叉树补全为完全二叉树，之后再依次标号，好使用完全二叉树双亲与孩子结点编号直接的关系表达二叉树的逻辑结构。</li>
</ul>
</li>
<li>**二叉树顺序存储结构的特点：
<ol>
<li>十分适合用来存储完全二叉树；</li>
<li>对于一般的二叉树，特别是单分支结点较多的二叉树来说，可能会使很多空结点未被利用，造成存储空间的大量浪费。</li>
<li>二叉树的顺序存储结构中，找一个结点的双亲和孩子结点十分容易，只需根据下标换算即可。</li>
</ol>
</li>
</ul>
<h4 id="二叉树的链式存储结构"><a class="markdownIt-Anchor" href="#二叉树的链式存储结构"></a> 二叉树的链式存储结构</h4>
<ul>
<li><strong>结点的类型定义：</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810162118.jpg" alt="" />
<ul>
<li>链式存储是利用递归思想来表现二叉树的逻辑结构。</li>
</ul>
</li>
<li><strong>链式存储结构的表现：</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810162232.jpg" alt="" /></li>
<li><strong>链式存储结构的空指针域</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810162232.jpg" alt="" />
<ul>
<li>总指针域数（结点数的两倍）减去分支数（结点度数之和）</li>
</ul>
</li>
<li><strong>二叉树链式存储结构的特点</strong>
<ol>
<li>除了会有一些空指针域的浪费，二叉链较顺序存储结构更为节省空间；</li>
<li>在二叉链中，找一个结点的孩子容易（根据自己的指针域找即可）,但是找双亲就很麻烦。（可以设计指回去的指针噻。）</li>
</ol>
</li>
</ul>
<h3 id="二叉树链式的基本运算"><a class="markdownIt-Anchor" href="#二叉树链式的基本运算"></a> 二叉树（链式）的基本运算</h3>
<h4 id="二叉树的基本操作"><a class="markdownIt-Anchor" href="#二叉树的基本操作"></a> 二叉树的基本操作</h4>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810163035.jpg" alt="" /></p>
<h4 id="二叉树的遍历运算"><a class="markdownIt-Anchor" href="#二叉树的遍历运算"></a> 二叉树的遍历运算</h4>
<ul>
<li>遍历只允许每个结点仅被访问一次。</li>
<li>不管采用哪种方法遍历，在有选择的地方都是从左至右的。</li>
</ul>
<h5 id="先序遍历"><a class="markdownIt-Anchor" href="#先序遍历"></a> 先序遍历</h5>
<ul>
<li>
<p><strong>基本原理</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810172342.jpg" alt="" /></p>
<ul>
<li>每到一个结点都看作是最简单的三个结点的二叉树，贯彻递归的思想。</li>
</ul>
</li>
<li>
<p><strong>先序遍历的递归算法</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810172658.jpg" alt="" /></p>
<ul>
<li>所有遍历的前提都是树不空，所以遍历之前要判断树是否为空，这也是递归结束的条件。</li>
</ul>
</li>
<li>
<p><strong>先序遍历的非递归算法1</strong></p>
<ul>
<li>基本原理：出栈访问法<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810173151.jpg" alt="" />
<ul>
<li>利用栈的特性。从根结点进栈后，将其出栈，出栈接受访问的同时将它的右左孩子进栈，之后再依序将左孩子出栈，并将其的右左孩子进栈，一层嵌一层，从而实现了类似递归的效应。</li>
</ul>
</li>
<li>具体算法：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810173631.jpg" alt="" /><br />
* 注意，一切操作之前还是要先判断二叉树是否为空。<br />
* 进栈的顺序是先右孩子，后左孩子，出栈时才能实现先左后右。<br />
* 遍历结束的条件是栈为空。</li>
</ul>
</li>
<li>
<p><strong>先序遍历的非递归算法2</strong></p>
<ul>
<li>基本原理：进栈访问法<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810174539.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810174652.jpg" alt="" />
<ul>
<li>注意：算法有瑕疵，在进栈的循环完之后在进入出栈的步骤前，应该增加一步取栈顶元素指针的步骤，每次出栈的是栈顶元素，不应都用一个指针来混淆。</li>
<li>进栈时访问了根结点，将根结点进栈，然后转向左子树，将左子树进栈访问，然后再将当前结点视为相对根结点转向其左子树依次进行下去，直到左子树被穷尽，之后出栈栈顶元素（最后进来的左结点）,转向其右子树。</li>
</ul>
</li>
<li>具体算法：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810180154.jpg" alt="" />
<ul>
<li>虽说遍历的结束条件是栈为空或者p为NULL,但是实际上遍历结束时，定是栈既为空p也为NULL,但是未遍历结束到达循环底部，单独栈为空时p必不为NULL,p为NULL时栈必不为空；之所以将条件设置为或者是因为刚要进入遍历循环前，栈为空，但是p不为NULL,这样设置既能保证进入循环又能保证控制循环的结束。（改为do while循环便可减少条件但仍能进入循环）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="中序遍历"><a class="markdownIt-Anchor" href="#中序遍历"></a> 中序遍历</h5>
<ul>
<li>
<p><strong>基本原理</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810194032.jpg" alt="" /></p>
<ul>
<li>左中右的顺序。先找到最左边的元素，访问它的左结点，此时定为空，然后访问自身，再转向右结点，之后回到这颗左子树对应的根结点，递归下去。</li>
</ul>
</li>
<li>
<p><strong>中序遍历的递归算法</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810194514.jpg" alt="" /></p>
</li>
<li>
<p><strong>中序遍历的非递归算法</strong></p>
<ul>
<li>基本原理：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810194847.jpg" alt="" />
<ul>
<li>源自先序遍历的进栈访问法，只是将访问的时间改变成了出栈时。</li>
</ul>
</li>
<li>具体算法：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810195228.jpg" alt="" /></li>
</ul>
</li>
</ul>
<h5 id="后序遍历"><a class="markdownIt-Anchor" href="#后序遍历"></a> 后序遍历</h5>
<ul>
<li>
<p><strong>基本原理</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810195426.jpg" alt="" /></p>
<ul>
<li>左右后的顺序。先序，中序和后序的区别在于根结点在何时被访问，二先左后右的顺序是始终没有改变过的。</li>
<li>同中序遍历类似，先找到最左边的元素，访问它的左结点，此时定为空，然后转向右结点并访问，之后回到该左边的元素，访问它，然后回到这颗左子树对应的根结点，依次递归下去。</li>
</ul>
</li>
<li>
<p><strong>后序遍历的递归算法</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810195907.jpg" alt="" /></p>
</li>
<li>
<p><strong>后序遍历的非递归算法</strong></p>
<ul>
<li>基本原理<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810200500.jpg" alt="" />
<ul>
<li>源自中序遍历的非递归算）,但是由于根结点必须最后访问，但是从左结点到右结点必须经过根结点，但第一次经过根结点时又不能访问它，所以需要设计一个标识来判读此时的指针指向的结点能不能被访问。</li>
</ul>
</li>
<li>具体算法：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810201255.jpg" alt="" />
<ul>
<li>由于第一次经过根结点时不能直接访问，但根据中序遍历的算法每次都是进入访问栈顶元素的循环中，直接访问栈顶元素，所以使用一个r指针和flag标识，当此时根结点有右孩子时，跳过访问它的步骤，而转向它的右孩子，并将flag标识设为false表明此时已经不是在处理栈顶元素了，需要退出处理栈顶元素的循环。</li>
<li>在退出处理栈顶元素的循环后，将此时指针指向的右孩子结点进栈，变为新的栈顶元素，再进入处理栈顶元素的循环中，将其出栈访问，并且将r标识指向它，表明它已经被处理过了，之后继续在处理栈顶元素的循环中运行，此时根节点由于有了r指针说明它的右孩子已经被处理过了，所以能够顺利地出栈访问。</li>
<li>依次递归进行下去，层层出栈逐渐处理回上层结点。</li>
<li>这个两个标识设计得确实秒啊！！！</li>
<li>怪不得老师在先序遍历的第二种非递归算法和中序遍历的非递归算法中要单独注释处理栈顶元素的循环，原来是为这里做准备！</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="层次遍历"><a class="markdownIt-Anchor" href="#层次遍历"></a> 层次遍历</h5>
<ul>
<li>
<p>层次遍历：对于一颗二叉树，从根结点开始，按从上到下，从左至右的顺序访问每一个结点。</p>
</li>
<li>
<p><strong>基本原理：</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810222139.jpg" alt="" /></p>
<ul>
<li>利用队列先进先出的特性遍历二叉树。根结点进队，然后出队，出队时依次将它的左右孩子进队，然后左右孩子出队，同时又将它们的孩子进队，依次递归下去。</li>
</ul>
</li>
<li>
<p><strong>算法实现</strong></p>
<ul>
<li>结点定义：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810222604.jpg" alt="" />
<ul>
<li>采用环形队列</li>
</ul>
</li>
<li>具体算法：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810222604.jpg" alt="" />
<ul>
<li>队空时说明二叉树已经遍历完了。因为此时遍历倒数第二层结点时储存在队列中的的叶子结点已经全部出队了。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="线索二叉树"><a class="markdownIt-Anchor" href="#线索二叉树"></a> 线索二叉树</h3>
<h4 id="线索二叉树的定义"><a class="markdownIt-Anchor" href="#线索二叉树的定义"></a> 线索二叉树的定义</h4>
<ul>
<li>在二叉树的链式存储结构的基础上，修改空链域为指向结点的前驱和后继结点的地址。这样指向该二叉树中的前驱和后继的指针，称为<strong>线索</strong>。（这里的前驱和后继是相对于遍历的先后顺序来说的）</li>
<li>创建线索的过程称为<strong>线索化</strong></li>
<li>生成的线索二叉树与采用的<strong>遍历方法</strong>有关，据此，线索二叉树分为三种：1. 先序线索二叉树；2.中序线索二叉树；3.后序线索二叉树。</li>
</ul>
<h5 id="线索二叉树的基本原理"><a class="markdownIt-Anchor" href="#线索二叉树的基本原理"></a> 线索二叉树的基本原理</h5>
<ul>
<li><strong>结点的设计</strong>
<ul>
<li>设计原理：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200811000127.jpg" alt="" />
<ul>
<li>每个结点都只有两个指针域，这两个指针域是指向自己的孩子结点还是指向自己的前驱和后继结点，则需要设置标志来判断。</li>
</ul>
</li>
<li>结点类型定义：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200811000415.jpg" alt="" /></li>
</ul>
</li>
<li>线索二叉树的基本模型<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200811000712.jpg" alt="" />
<ul>
<li>先要根据具体的遍历方法，找到每个结点的前驱和后继；</li>
<li>左指针域指向左孩子结点或者前驱结点，此处根据中序遍历规则，最左边最下面的结点没有前驱结点，最右边最下面的结点没有后继结点，所以设置了一个额外的头结点来做这种没有前驱或者后继的结点的“前驱和后继”。</li>
</ul>
</li>
</ul>
<h5 id="线索化二叉树"><a class="markdownIt-Anchor" href="#线索化二叉树"></a> 线索化二叉树</h5>
<ul>
<li>
<p><strong>线索化的过程</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200811001337.jpg" alt="" /></p>
<ul>
<li>依照某种遍历方法遍历该二叉树，在遍历的过程中，检查每个结点的指针域是否为空，并根据具体的情况，将这些空指针域指向各自的前驱或者后继结点。</li>
</ul>
</li>
<li>
<p><strong>建立中序线索二叉树的算法</strong></p>
<ul>
<li>基本原理<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200811001810.jpg" alt="" />
<ul>
<li>在中序遍历该二叉树的同时设立两个指针，分别指向互为前驱和后继的两个结点，其中有一个一直指向当前结点，另一个指向它的前驱结点。</li>
</ul>
</li>
<li>具体算法：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200811003232.jpg" alt="" />
<ul>
<li>线索化二叉树的函数有两个，一个负责修改二叉树中各个结点的指针域（Thread）,一个负责创建头结点等开始启动工作和修改最后一个结点的指针域等收尾工作。</li>
<li>先将头结点创建好，并将其后继结点设为头结点并修改标识符（如果这是一个空树，则将头结点的左孩子指针域指向头结点，示意这是空树）</li>
<li>头结点的左孩子结点设为二叉树的根结点，pre指针指向头结点，将二叉树的根结点指针传入Thread函数；</li>
<li>在Thread函数中，应用中序遍历的递归算法，只不过把中间访问根结点的步骤改为检查当前结点的指针域并修改的步骤；</li>
<li>结束Thread函数后，该二叉树除了最后一个结点的后继线索未设置好之外，其余结点的线索均已设置好；</li>
<li>最后结束Thread函数，再次进入CreateThread函数中时，只需再将最后一个结点的线索修改好即可。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="遍历线索化二叉树"><a class="markdownIt-Anchor" href="#遍历线索化二叉树"></a> 遍历线索化二叉树</h5>
<ul>
<li>
<p>基本原理<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814105518.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814105614.jpg" alt="" /></p>
<ul>
<li>找到开始结点（采用不同的线索化方式而有不同，开始结点不是头结点，而是整个遍历过程中要第一个访问的结点）。</li>
<li>在遍历过程中要由线索指向的结点才接受访问。</li>
<li>最后遍历的指针指向了头结点时，则说明整颗树已经遍历完成了。</li>
</ul>
</li>
<li>
<p>具体算法：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814110007.jpg" alt="" /></p>
<ul>
<li>如果是线索就直接访问它，如果不是线索就转向它而不访问。</li>
</ul>
</li>
</ul>
<h3 id="二叉树的构造"><a class="markdownIt-Anchor" href="#二叉树的构造"></a> 二叉树的构造</h3>
<ul>
<li>
<p><strong>二叉树序列性质：</strong></p>
<ul>
<li>同一颗二叉树，具有唯一的先序序列，中序序列和后序序列。但不同二叉树可能具有相同的先序序列、中序序列和后序序列。
<ul>
<li>示例：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814160437.jpg" alt="" /></li>
</ul>
</li>
<li>通过一颗二叉树的先序、中序和后序序列可以<strong>唯一</strong>确定该二叉树。（同时有三种序列）</li>
<li>仅有先序、中序和后序中的<strong>一种</strong>，无法唯一构造该二叉树。</li>
<li><strong>任何n个不同结点的二叉树，都可有它的中序序列和先序序列唯一地确定。（或者中序序列和后序序列）。即必须有中序序列。</strong></li>
</ul>
</li>
<li>
<p><strong>由先序序列和中序序列构造二叉树</strong></p>
<ul>
<li>基本原理：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814161524.jpg" alt="" />
<ul>
<li>通过递归的思想理解，把两种序列都看作根结点、左子树和右子树三个部分。然后同一个结点对应在两个序列的相同部分（比如说都是在根结点部分）的不同位置。</li>
</ul>
</li>
<li>示例：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814161924.jpg" alt="" /></li>
<li>具体算法：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814163249.jpg" alt="" />
<ul>
<li>先确定是否为空树（**这是确定最后递归结束的重要条件），再确定在这两种序列中的左子树，右子树和根结点的三个部分。</li>
<li>采用分而治之的递归思想，在每一个左右子树部分执行同样的的操作，递归下去，直到序列走尽。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>由后序和中序序列构造二叉树</strong></p>
<ul>
<li>基本原理：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814163402.jpg" alt="" />
<ul>
<li>通过根结点确定序列左子树、右子树和根结点的三个部分是关键。（<strong>之所以只用先序和后序序列不能构造二叉树，就是因为这两个的根结点都位于开头或者结尾，无法通过根结点划分序列为三个部分，而单独中序序列由无法确定根结点的位置</strong>）</li>
</ul>
</li>
<li>示例：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814163844.jpg" alt="" />
<ul>
<li>每次放入二叉树的结点的都是相对的根结点。</li>
</ul>
</li>
<li>具体算法：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814164152.jpg" alt="" />
<ul>
<li>整体是先构造根结点再构造左子树和右子树，是<strong>先序遍历</strong>的思路。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="树-森林和二叉树的关系"><a class="markdownIt-Anchor" href="#树-森林和二叉树的关系"></a> 树、森林和二叉树的关系</h3>
<h4 id="树的存储结构"><a class="markdownIt-Anchor" href="#树的存储结构"></a> 树的存储结构</h4>
<h5 id="树的双亲存储结构"><a class="markdownIt-Anchor" href="#树的双亲存储结构"></a> 树的双亲存储结构</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814164629.jpg" alt="" /></p>
<ul>
<li>使用顺序存储结构来存储树的结点。</li>
<li>在每一个结点的数据元素之外，再加上一个记录它的双亲元素的位置的元素。（即新增一个元素存储该结点双亲的下标）。</li>
</ul>
<h5 id="树的孩子链存储结构"><a class="markdownIt-Anchor" href="#树的孩子链存储结构"></a> 树的孩子链存储结构</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814165603.jpg" alt="" /></p>
<ul>
<li>每个结点都用一个指针指向，让后每一个结点内不仅包含自身的数据，还要再设置一个指针类型的数组来记录它的孩子结点的指针。</li>
<li>空指针域会很多。</li>
</ul>
<h5 id="树的孩子兄弟链存储结构"><a class="markdownIt-Anchor" href="#树的孩子兄弟链存储结构"></a> 树的孩子兄弟链存储结构</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814170017.jpg" alt="" /></p>
<ul>
<li>每个结点只设置两个指针域，一个指向孩子结点（或者孩子结点构成的链）,一个指向兄弟结点。</li>
<li>结束的结点应该两个指针域均为空。</li>
</ul>
<h4 id="二叉树与树-森林之间的转换"><a class="markdownIt-Anchor" href="#二叉树与树-森林之间的转换"></a> 二叉树与树、森林之间的转换</h4>
<h5 id="树-森林转化为二叉树"><a class="markdownIt-Anchor" href="#树-森林转化为二叉树"></a> 树、森林转化为二叉树</h5>
<ul>
<li>一棵树转化为二叉树<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814170017.jpg" alt="" />
<ul>
<li>实现步骤：
<ol>
<li>将树的根节点直接作为二叉树的根节点</li>
<li>将树的根节点的<strong>第一个子节点作为根节点的左儿子，若该子节点存在兄弟节点，则将该子节点的第一个兄弟节点（方向从左往右）作为该子节点的右儿子</strong></li>
<li>将树中的剩余节点按照上一步的方式，依序添加到二叉树中，直到树中所有的节点都在二叉树中.</li>
</ol>
</li>
<li>总的来说：每个点的左儿子是它的第一个儿子，右儿子是它从左往右数的第一个兄弟。</li>
</ul>
</li>
<li>多棵树（森林）转化为二叉树<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814171103.jpg" alt="" />
<ul>
<li>法一：
<ol>
<li>把森林的每一棵树转成二叉树
<ol>
<li>以某一棵树作为起始树，下一棵树的根结点作为右孩子连接到上一颗树的根结点。直到处理完最后一棵树。</li>
</ol>
</li>
</ol>
</li>
<li>法二：
<ol>
<li>新增一个结点，把这个结点作为总的根结点，然后将所有树组成一个新的树；</li>
<li>按照处理一颗树的方式，把这棵树转化为二叉树；</li>
<li>最后删除新增的结点。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h5 id="二叉树还原为森林-树"><a class="markdownIt-Anchor" href="#二叉树还原为森林-树"></a> 二叉树还原为森林、树</h5>
<ul>
<li>将一棵二叉树还原为一棵树<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814172402.jpg" alt="" />
<ul>
<li>实现步骤：
<ol>
<li>加线。如果某个结点存在左孩子，则将左孩子的右结点，其右结点的右孩子…也就是一直深入到没有右孩子，将这些结点与父结点连线。</li>
<li>去线。删除所有结点与其右孩子的连线。</li>
<li>调整结构，让原本某结点的右孩子与该结点处于一个水平线，则他们成为了兄弟。</li>
</ol>
</li>
</ul>
</li>
<li>将一棵二叉树还原为多棵树（森林）<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814172632.jpg" alt="" />
<ul>
<li>实现步骤：
<ol>
<li>将所有结点的右孩子与其的连线切断，从而还原出很多二叉树；</li>
<li>将还原出的二叉树再进一步还原为普通树。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="哈夫曼树"><a class="markdownIt-Anchor" href="#哈夫曼树"></a> 哈夫曼树</h3>
<h4 id="哈夫曼树的定义"><a class="markdownIt-Anchor" href="#哈夫曼树的定义"></a> 哈夫曼树的定义</h4>
<ul>
<li><strong>带权路径长度</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814230259.jpg" alt="" />
<ul>
<li>根结点到各个<strong>叶结点</strong>的路径长度与权值的乘积之和。</li>
</ul>
</li>
<li><strong>哈夫曼树</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814230625.jpg" alt="" />
<ul>
<li>哈夫曼树是在叶结点权值相同情况下构造出的带权路径长度最小的二叉树。</li>
<li>哈夫曼树首先是二叉树；</li>
<li>哈夫曼树又称为最优树。</li>
</ul>
</li>
<li><strong>哈夫曼树的特点</strong>
<ol>
<li>没有度为1的结点.</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub><mo>+</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><msub><mi>n</mi><mn>2</mn></msub><mo>=</mo><mn>2</mn><msub><mi>n</mi><mn>0</mn></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n=n_0+n_1+n_2=2n_0-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
</ol>
</li>
</ul>
<h4 id="构造哈夫曼树-"><a class="markdownIt-Anchor" href="#构造哈夫曼树-"></a> 构造哈夫曼树-&gt;???</h4>
<ul>
<li><strong>基本原理</strong>
<ul>
<li>权值越大的叶结点越靠近根结点，反之，权值越小的叶结点越远离根结点。</li>
</ul>
</li>
<li><strong>构造哈夫曼树的过程</strong><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814232041.jpg" alt="" /></li>
<li><strong>构造哈夫曼树的算法</strong>
<ul>
<li>结点结构<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814232545.jpg" alt="" /></li>
<li>具体算法：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814233947.jpg" alt="" />
<ul>
<li>关键在于每次剔除已经有了双亲结点的结点。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="哈夫曼编码"><a class="markdownIt-Anchor" href="#哈夫曼编码"></a> 哈夫曼编码 =》？？？</h4>
<ul>
<li>
<p>定义<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814235953.jpg" alt="" /></p>
<ul>
<li>哈夫曼编码是二进制的01代码</li>
<li>特点：权值越大的字符编码越短，反之越长。</li>
<li>哈夫曼编码是针对叶结点而言的。=》在一组字符中，不可能出现一个字符的哈夫曼编码是另一个字符哈夫曼编码的前缀。</li>
<li>哈夫曼编码又称前缀编码。</li>
</ul>
</li>
<li>
<p>哈夫曼编码的生成算法</p>
<ul>
<li>哈夫曼编码的存储结构<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815004956.jpg" alt="" /></li>
<li>具体算法：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815005526.jpg" alt="" /></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/index.html" class="post-title-link" itemprop="url">第五章 数组与广义表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-09 10:53:37" itemprop="dateCreated datePublished" datetime="2020-08-09T10:53:37+08:00">2020-08-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:27:52" itemprop="dateModified" datetime="2022-09-17T19:27:52+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">专业基础</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="数组与广义表"><a class="markdownIt-Anchor" href="#数组与广义表"></a> 数组与广义表</h1>
<h2 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h2>
<h3 id="数组的定义"><a class="markdownIt-Anchor" href="#数组的定义"></a> 数组的定义</h3>
<ul>
<li>
<p>数组的逻辑结构</p>
<ul>
<li>一维数组：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809155005.jpg" alt="" /></li>
<li>多维数组：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809155216.jpg" alt="" /></li>
</ul>
</li>
<li>
<p>数组的抽象数据类型：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809155800.jpg" alt="" /></p>
</li>
<li>
<p>数组的基本操作：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809155900.jpg" alt="" /></p>
<ul>
<li>数组运算的关键在于找到对应元素的下标。</li>
</ul>
</li>
</ul>
<h3 id="数组的存储结构"><a class="markdownIt-Anchor" href="#数组的存储结构"></a> 数组的存储结构</h3>
<ul>
<li>顺序存储结构：数组中的所有元素存储在一块地址连续的内存单元中,使用的是顺序存储结构。（不要把数组与顺序存储结构搞混，顺序存储结构是单指与链式存储结构相对的地址连续的内存单元存储法，只是在c语言中，顺序存储结构由数组来表现）</li>
<li>数组类型的性质
<ul>
<li>数据元素的数目固定；</li>
<li>所有数据元素具有相同的数据类型；</li>
<li>每个数据元素都有一个（组）唯一的下标；</li>
<li>数组是一种<strong>随机存储结构</strong>，数组中的元素可以随机存取。（随机存取即直接用下标存取矩阵中的元素）</li>
</ul>
</li>
</ul>
<h4 id="一维数组"><a class="markdownIt-Anchor" href="#一维数组"></a> 一维数组：</h4>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809160821.jpg" alt="" /></p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mi mathvariant="normal">与</mi><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_i与a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">与</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之间有i-1个元素，占领了（i-1）*k个存储单元。</li>
</ul>
<h4 id="多维数组"><a class="markdownIt-Anchor" href="#多维数组"></a> 多维数组</h4>
<ul>
<li>行优先存储：以行序为主序的存储</li>
<li>列优先存储：以列序为主序的存储</li>
<li>分为这两种存储方式的原因是：虽然在我们的理解中多维数组就像矩阵一样，但实际在计算机中它是连续存储（就像一排排完的）,所以区分行列的优先度就显得很重要。</li>
</ul>
<h5 id="行优先存储"><a class="markdownIt-Anchor" href="#行优先存储"></a> 行优先存储</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809161853.jpg" alt="" /></p>
<ul>
<li>计算每一个元素前面的元素个数时，先计算前面有多少行，再计算本行前面有多少个元素。</li>
</ul>
<h6 id="三维数组的行优先存储"><a class="markdownIt-Anchor" href="#三维数组的行优先存储"></a> 三维数组的行优先存储</h6>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809163051.jpg" alt="" /></p>
<ul>
<li>三个下标之间的关系可以类比二维数组行优先存储理解：二维数组的a[i][j]中，i是行数，j是列数，在计算机中存储时，相当与每一行看做一个整体（一维数组）然后依标号的顺序存储，一行中包含很多列。三维数组的a[i][j][k]中，i是页数，j是行数，k是列数，在计算机存储中，相当于将一页看做一个整体（二维数组），然后根据标号的顺序存储，一页中包含很多行和列，单独看一页中的存储顺序便相当于又是按照二维数组的存储方式来存储的。</li>
<li>计算公式的理解：先计算前面有多少页<code>i -1</code>,每一页的总元素个数为行列最大数相乘；再计算本页前面有多少行<code>j -1</code>每行的元素个数即为最大的列数，最后计算本行前面有多少列<code>k - 1</code>。</li>
</ul>
<h6 id="n维数组的行优先存储"><a class="markdownIt-Anchor" href="#n维数组的行优先存储"></a> n维数组的行优先存储</h6>
<ul>
<li>第一个元素为a[1][1][1]算：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809164751.jpg" alt="" /></li>
<li>第一个元素不为a[1][1][1]算：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809165211.jpg" alt="" /></li>
</ul>
<h5 id="列优先存储"><a class="markdownIt-Anchor" href="#列优先存储"></a> 列优先存储</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809165539.jpg" alt="" /></p>
<ul>
<li>所有计算公式都与行优先存储的公式结构相同，顺序相反。即行优先存储从第一个下标<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">i_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>算到第n个下标<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>i</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">i_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,而列优先存储的公式都是从第n个下标算到第1个下标。</li>
</ul>
<h3 id="特殊矩阵的压缩存储"><a class="markdownIt-Anchor" href="#特殊矩阵的压缩存储"></a> 特殊矩阵的压缩存储</h3>
<ul>
<li>特殊矩阵的主要形式
<ol>
<li>对称矩阵</li>
<li>上三角矩阵/下三角矩阵</li>
<li>对角矩阵（带状矩阵）</li>
</ol>
</li>
<li>特殊矩阵的共性：都是方阵，行数和列数相同。</li>
<li>特殊矩阵压缩存储后，由于它矩阵元素分布的规律，仍然<strong>具有随机存取</strong>的特性。</li>
</ul>
<h4 id="对称矩阵的压缩存储"><a class="markdownIt-Anchor" href="#对称矩阵的压缩存储"></a> 对称矩阵的压缩存储</h4>
<ul>
<li>
<p>对称矩阵定义<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809170742.jpg" alt="" /></p>
<ul>
<li>a[i][j] == a[j][i]</li>
</ul>
</li>
<li>
<p>对称矩阵的压缩存储</p>
<ul>
<li>基本思想：
<ul>
<li>利用其关于主对角线对称的特性，只存储下三角和主对角线上的元素，以节省空间。</li>
<li>下三角和主对角线上的元素的特征是，行标大于或等于列标（i &gt;= j）。</li>
<li>用一维数组存储对称矩阵。</li>
</ul>
</li>
<li>压缩前后的对应关系<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809172226.jpg" alt="" />
<ul>
<li>原矩阵有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>个元素，而压缩后储存在一维数组中的只有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n(n+1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>个元素。但是原矩阵中的所有元素都可以在这个一维数组中找到。</li>
<li>原矩阵第i行储存了i个元素在一维数组中，所以第i行第j列元素前有（1 + 2 + 3 + …+i-1）+ j-1个元素。这个个数，也对应着在一维数组中该元素的下标（若非c语言，要在个数后加1）。</li>
<li>若要找到上三角的元素，则根据对称性，只需要将行列的下标对换，代入一维数组的下标计算公式即可。</li>
<li>存储位置计算公式：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809173413.jpg" alt="" /></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="三角矩阵的压缩存储"><a class="markdownIt-Anchor" href="#三角矩阵的压缩存储"></a> 三角矩阵的压缩存储</h4>
<ul>
<li>上三角矩阵
<ul>
<li>基本思想
<ul>
<li>与对称矩阵类似，只是未存储的部分全部为0，需要一维数组在最后留一个位置来储存这个常数。</li>
</ul>
</li>
<li>压缩前后的对应关系：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809173945.jpg" alt="" />
<ul>
<li>原矩阵第i行存入一维数组的元素个数为n-i+1个元素。</li>
</ul>
</li>
</ul>
</li>
<li>下三角矩阵：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809174220.jpg" alt="" /></li>
<li>按列优先存储压缩三角矩阵：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809174446.jpg" alt="" />
<ul>
<li>将计算公式的行列对换即可；</li>
<li>注意：一维数组的<strong>初始下标是从0还是1</strong>开始。</li>
</ul>
</li>
</ul>
<h4 id="对角矩阵的压缩存储"><a class="markdownIt-Anchor" href="#对角矩阵的压缩存储"></a> 对角矩阵的压缩存储：</h4>
<ul>
<li>三对角矩阵的定义：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809174817.jpg" alt="" /></li>
<li>压缩的基本思想：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809180021.jpg" alt="" />
<ul>
<li>每个元素前有多少个元素是按照每行三个元素计算：3（i-1），之后再减去第一行少的一个元素，加上本行前有多少个:j-i+1</li>
</ul>
</li>
<li>压缩前后的对应关系<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809175328.jpg" alt="" />
<ul>
<li>每个元素前有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2(i-1)+j-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个元素。</li>
</ul>
</li>
</ul>
<h3 id="稀疏矩阵"><a class="markdownIt-Anchor" href="#稀疏矩阵"></a> 稀疏矩阵</h3>
<ul>
<li>稀疏矩阵的定义：一个阶数较大的矩阵中的非零元素个数相对于总元素个数十分小时，称该矩阵为稀疏矩阵。</li>
<li>稀疏矩阵的压缩存储：
<ol>
<li>三元组表示法：仍然使用线性表，即顺序存储结构存储；</li>
<li>十字链表表示法：使用链表表示。</li>
</ol>
</li>
<li>稀疏矩阵与特殊矩阵不同，它的非零元素分布并没有规律，所以稀疏矩阵压缩后就<strong>丧失了随机存取</strong>的特性。</li>
</ul>
<h4 id="稀疏矩阵的三元组表示"><a class="markdownIt-Anchor" href="#稀疏矩阵的三元组表示"></a> 稀疏矩阵的三元组表示</h4>
<h5 id="三元组定义"><a class="markdownIt-Anchor" href="#三元组定义"></a> 三元组定义</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809181332.jpg" alt="" /></p>
<ul>
<li>其中i，j存储的是该元素在稀疏矩阵中的行标和下标（与普通矩阵不同的是，它的行标和下标是从0开始算的）,而a[i][j]存储的是该元素具体的值。</li>
</ul>
<h4 id="三元组线性表的顺序结构存储及算法"><a class="markdownIt-Anchor" href="#三元组线性表的顺序结构存储及算法"></a> 三元组线性表的顺序结构存储及算法</h4>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809181930.jpg" alt="" /></p>
<h5 id="创建三元组"><a class="markdownIt-Anchor" href="#创建三元组"></a> 创建三元组</h5>
<ul>
<li>基本原理<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809182315.jpg" alt="" /></li>
<li>算法实现：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809182537.jpg" alt="" />
<ul>
<li>将非零元素按行序扫描到的顺序存储进顺序表中，即可实现三元组中的元素是按行序为主序排列。</li>
</ul>
</li>
</ul>
<h5 id="三元组的元素赋值"><a class="markdownIt-Anchor" href="#三元组的元素赋值"></a> 三元组的元素赋值</h5>
<ul>
<li>分为两种情况：
<ul>
<li>只是修改非零元素的值</li>
<li>增加一个非零元素，即将原来矩阵中的0元素改为非零元素。</li>
</ul>
</li>
<li>算法实现:<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809183912.jpg" alt="" />  <pre class="line-numbers language-c" data-language="c"><code class="language-c">bool Value(TSMatrix *t, ElemType  e, int i, int j) &#x2F;&#x2F;三元组的赋值
&#123;
int k &#x3D; 0;
if(i &gt; t.Rows || j &gt; t.Cols)
    return false; &#x2F;&#x2F;坐标不合理  

while(k &lt; t.Terms &amp;&amp; i &gt; t.elem[k].row)  &#x2F;&#x2F;先查找行
    k++;

while(k &lt; t.Terms &amp;&amp; i &#x3D;&#x3D; t.elem[k].row &amp;&amp; j &gt; t.elem[k].col) &#x2F;&#x2F;查列
    k++;

    if(i &#x3D;&#x3D; t.elem[k].row &amp;&amp; j &#x3D;&#x3D; t.elem[k].col) &#x2F;&#x2F;判断条件，如果存在这样的一个元素
        t.elem[k].val&#x3D;e; &#x2F;&#x2F;那么把这个元素赋值给它


    else &#x2F;&#x2F;如果不存在的话,此时的k在列标比预期列标大得最少的元素位置上
    &#123;
    for(int k1 &#x3D; t.Terms-1; k &lt; k1; k1--) &#x2F;&#x2F;先进行移位操作
    &#123;
        t.elem[k1+1].row&#x3D;t.elem[k1].row; &#x2F;&#x2F;行
        t.elem[k1+1].col&#x3D;t.elem[k1].col; &#x2F;&#x2F;列
        t.elem[k1+1].val&#x3D;t.elem[k1].val; &#x2F;&#x2F;值
    &#125;
        t.elem[k].row&#x3D;i; &#x2F;&#x2F;行
        t.elem[k].col&#x3D;j; &#x2F;&#x2F;列
        t.elem[k].val&#x3D;e; &#x2F;&#x2F;值
        t.Terms++; &#x2F;&#x2F;个数加1
    &#125;
    return true;
&#125;</code></pre>
<ul>
<li>前面的算法有严重错误，后面的算法来做参考</li>
<li>若能找到对应的非零元素，则直接修改；</li>
<li>若不能找到对应的非零元素，则将k此时位置及以后的元素后移一位，将新元素值赋给k此时所在的位置。</li>
</ul>
</li>
</ul>
<h5 id="取出指定位置元素的值"><a class="markdownIt-Anchor" href="#取出指定位置元素的值"></a> 取出指定位置元素的值</h5>
<ul>
<li>基本原理:在三元组中查找该位置，若能查到，则将该位置的元素值取出，若不能查到，则该位置的元素值应为0。不能直接根据位置取出元素（随机存取），还需经过查找的过程。（类比数组与链表的区别，数组可以直接拿出某一位置的元素值，而链表必须逐次查找）</li>
<li>算法实现：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809190222.jpg" alt="" />
<ul>
<li>注意：算法有误，查找时的条件应为<code>i &gt; t.data[k].row ;j &gt; t.data[k].col</code></li>
<li>没有找到该位置只是对应着该位置元素为0，不是出错了。</li>
</ul>
</li>
</ul>
<h5 id="输出三元组"><a class="markdownIt-Anchor" href="#输出三元组"></a> 输出三元组</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809190609.jpg" alt="" /></p>
<ul>
<li>只是输出三元组，不是输出一个矩阵，不用管零元素。</li>
</ul>
<h5 id="矩阵转置"><a class="markdownIt-Anchor" href="#矩阵转置"></a> 矩阵转置</h5>
<ul>
<li>
<p>矩阵转置的定义<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809190842.jpg" alt="" /></p>
</li>
<li>
<p>直接转置的非高效算法<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809191544.jpg" alt="" /></p>
<ul>
<li>按照列从1到n依次查找，每一个列数都需要将整个三元组扫描一遍，设列数为n,非零元素个数为t,时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nt)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>
<p>更加高效的算法：</p>
<ul>
<li>基本原理：
<ul>
<li>通过记录每个列标号的个数，来确定在新三元组中该列标号的元素出现的位置，然后直接将元素值填入该位置即可。</li>
<li>设置两个数组，分别记录某列标号出现的次数，以及该列标号在新三元组中第一次出现的位置。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809200538.jpg" alt="" />
<ul>
<li>此处列标号是从0开始算起。在第二个公式中，1 &lt;= col &lt;= t.n</li>
<li>position的计算就是将上一个列标号第一次出现的位置加上该列标号的数目。</li>
</ul>
</li>
</ul>
</li>
<li>算法实现：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809201328.jpg" alt="" />
<ul>
<li>第一步先将矩阵的总行数与列数逆置；</li>
<li>之后通过遍历原三元组，确定每列的非零元的个数，通过<code>++bum[t.data[k].col]</code>来实现对每一列非零元个数的计数，着实秒啊！</li>
<li>第三步，利用num数组，计算出position数组的值；</li>
<li>最后遍历原三元数组，通过每个元素的列标号col来确认它在新三元组中的位置；</li>
<li>值得点赞的是，在每个列标号col对应的元素存入新三元组之后,通过<code>++position[col]</code>的操作，来确定下一个第col列非零元素的位置。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="稀疏矩阵的十字链表表示"><a class="markdownIt-Anchor" href="#稀疏矩阵的十字链表表示"></a> 稀疏矩阵的十字链表表示</h4>
<ul>
<li>
<p>基本原理：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810091754.jpg" alt="" /></p>
<ul>
<li>每个非零元素对应一个结点，该结点中储存该元素的行标和列标以及元素值，另外还设有两个分别向右和向下的指针域。</li>
<li>每行的所有结点链起来，再设置一个头结点，构成一个带头结点的单链表；</li>
<li>每列的所有结点链起来，在设置一个列结点，构成一个带头结点的单链表；</li>
<li>将所有行的头结点用一个数组储存起来，将所有列的头结点用一个数组储存起来；</li>
</ul>
</li>
<li>
<p>结点的定义</p>
  <pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct OLNode&#123;
int i,j;&#x2F;&#x2F;元素的行标和列标
int data;&#x2F;&#x2F;元素的值
struct OLNode * right,*down;&#x2F;&#x2F;两个指针域
&#125;OLNode, *Olink;</code></pre>
</li>
<li>
<p>十字链表的定义</p>
  <pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct
&#123;
OLink *rhead, *chead; &#x2F;&#x2F;存储行和列链表头指针的两个数组
int mu, nu, tu;  &#x2F;&#x2F;矩阵的行数,列数和非零元的个数
&#125;CrossList;</code></pre>
</li>
<li>
<p>十字链表的初始化</p>
</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">CrossList CreateMatrix_OL(CrossList M)
&#123;
    int m, n, t; &#x2F;&#x2F;储存矩阵的行数和列数，以及非零元素个数
    int i, j, e;
    OLNode *p, *q;

    printf(&quot;输入矩阵的行数、列数和非0元素个数：&quot;);
    scanf(&quot;%d%d%d&quot;, &amp;m, &amp;n, &amp;t);
    M.mu &#x3D; m;
    M.nu &#x3D; n;
    M.tu &#x3D; t;

    if (!(M.rhead &#x3D; (OLink*)malloc((m + 1) * sizeof(OLink))) || !(M.chead &#x3D; (OLink*)malloc((n + 1) * sizeof(OLink)))) &#x2F;&#x2F;为头结点分配两个顺序储存空间（数组）
    &#123;
        printf(&quot;初始化矩阵失败&quot;);
        exit(0);
    &#125;

    for (i &#x3D; 1; i &lt;&#x3D; m; i++)
    &#123;
        M.rhead[i] &#x3D; NULL;
    &#125; &#x2F;&#x2F;初始化所有行的头结点

    for (j &#x3D; 1; j &lt;&#x3D; n; j++)
    &#123;
        M.chead[j] &#x3D; NULL;
    &#125; &#x2F;&#x2F;初始化所有列的头结点

    for (scanf(&quot;%d%d%d&quot;, &amp;i, &amp;j, &amp;e); 0 !&#x3D; i; scanf(&quot;%d%d%d&quot;, &amp;i, &amp;j, &amp;e)) &#123;
        if (!(p &#x3D; (OLNode*)malloc(sizeof(OLNode))))
        &#123;
            printf(&quot;初始化结点失败&quot;);
            exit(0);
        &#125;
        p-&gt;i &#x3D; i;
        p-&gt;j &#x3D; j;
        p-&gt;e &#x3D; e;

        &#x2F;&#x2F;链接到行的指定位置
        if (NULL &#x3D;&#x3D; M.rhead[i] || M.rhead[i]-&gt;j &gt; j)
        &#123;
            p-&gt;right &#x3D; M.rhead[i];
            M.rhead[i] &#x3D; p;
        &#125; &#x2F;&#x2F;若原来那一行里第一个数据结点的列标就比新结点大或者没有数据结点，则头插法插入
        else
        &#123;
            for (q &#x3D; M.rhead[i]; (q-&gt;right) &amp;&amp; q-&gt;right-&gt;j &lt; j; q &#x3D; q-&gt;right);
            p-&gt;right &#x3D; q-&gt;right;
            q-&gt;right &#x3D; p;
        &#125; &#x2F;&#x2F;若第一个数据结点比新结点的列标小，则向后找比新结点列标大的，若没有就到最后一个结点，然后插入该结点后面

        &#x2F;&#x2F;链接到列的指定位置
        if (NULL &#x3D;&#x3D; M.chead[j] || M.chead[j]-&gt;i &gt; i)
        &#123;
            p-&gt;down &#x3D; M.chead[j];
            M.chead[j] &#x3D; p;
        &#125;
        else
        &#123;
            for (q &#x3D; M.chead[j]; (q-&gt;down) &amp;&amp; q-&gt;down-&gt;i &lt; i; q &#x3D; q-&gt;down);
            p-&gt;down &#x3D; q-&gt;down;
            q-&gt;down &#x3D; p;
        &#125;
    &#125;
    return M;
&#125;</code></pre>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%B2/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%B2/index.html" class="post-title-link" itemprop="url">第四章 串</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-03 10:53:37" itemprop="dateCreated datePublished" datetime="2020-08-03T10:53:37+08:00">2020-08-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:27:52" itemprop="dateModified" datetime="2022-09-17T19:27:52+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">专业基础</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第四章-串"><a class="markdownIt-Anchor" href="#第四章-串"></a> 第四章 串</h1>
<h2 id="串的定义"><a class="markdownIt-Anchor" href="#串的定义"></a> 串的定义</h2>
<ul>
<li>
<p>串：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200803105608.jpg" alt="" /></p>
<ul>
<li>串也是一种线性表</li>
</ul>
</li>
<li>
<p>串相等：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200803105722.jpg" alt="" /></p>
<ul>
<li>长度相等且对应位置相等。</li>
<li>所有的空串相等。</li>
</ul>
</li>
<li>
<p>子串：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200803105846.jpg" alt="" /></p>
<ul>
<li>类似子集的定义。</li>
</ul>
</li>
<li>
<p>基本运算：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200803110231.jpg" alt="" /></p>
</li>
</ul>
<h2 id="串的存储结构"><a class="markdownIt-Anchor" href="#串的存储结构"></a> 串的存储结构</h2>
<ol>
<li>顺序串：用顺序存储结构（数组）存储，且为存储结构为定长。</li>
<li>堆串：用顺序存储结构存储，但存储结构的长度是根据串的长度来动态分配的。</li>
<li>块链串：用链式存储结构来存储。</li>
</ol>
<h3 id="串的顺序存储结构顺序串"><a class="markdownIt-Anchor" href="#串的顺序存储结构顺序串"></a> 串的顺序存储结构（顺序串）</h3>
<h4 id="串的顺序存储结构的定义"><a class="markdownIt-Anchor" href="#串的顺序存储结构的定义"></a> 串的顺序存储结构的定义</h4>
<ul>
<li>两种类型：
<ul>
<li>紧缩格式</li>
<li>非紧缩格式<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200803110825.jpg" alt="" /></li>
</ul>
</li>
<li>结点定义（下面讨论的都是非紧缩）<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200803111043.jpg" alt="" /></li>
</ul>
<h4 id="串的顺序存储结构的基本运算"><a class="markdownIt-Anchor" href="#串的顺序存储结构的基本运算"></a> 串的顺序存储结构的基本运算</h4>
<h5 id="顺序串的插入"><a class="markdownIt-Anchor" href="#顺序串的插入"></a> 顺序串的插入</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200803112812.jpg" alt="" /></p>
<ul>
<li>先判断插入位置是否合理</li>
<li>之后判断能否完全插入一个串
<ol>
<li>若两个串合起来的长度<code>s-&gt;len +t.len</code>也小于s的最大长度，则可以完全插入</li>
</ol>
<ul>
<li>第一步先将原串pos位置及以后的字符向后平移(即复制到后面的位置上去）；</li>
<li>然后将要插入的串依次赋值到pos位置及它之后空出来的位置上；</li>
<li>最后修改整个串的长度，即两串的长度相加。</li>
</ul>
<ol start="2">
<li>若插入后只能保存t串的字符(二串相加的总长度大于最大长度，但pos位置后留的位置比t串的长度长)</li>
</ol>
<ul>
<li>第一步还是先将s串自pos位开始的字符向后平移，但要给t串留出足够空间，即s串能移多少算多少；</li>
<li>第二步将t串复制进来；</li>
<li>最后串的长度就是s的最大长度。</li>
</ul>
<ol start="3">
<li>若插入之后只能保存t串的部分字符（即pos后的位置在不移s串元素过去的情况下，仍然比t串短）
<ul>
<li>直接将t串复制到pos位置及以后，到最大长度为止，能复制多少算多少。</li>
<li>最后串的长度就是最大长度。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h5 id="顺序串的删除"><a class="markdownIt-Anchor" href="#顺序串的删除"></a> 顺序串的删除</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200803112812.jpg" alt="" /></p>
<ul>
<li>先判断删除位置和个数是否合理：pos位置既不能超出边界，在加上要删除的位数之后也不能超出边界<code>pos &gt; (s-&gt;len - k)</code></li>
<li>先找到待删除区域外的第一个元素，然后依次向前复制，直达到达串的边界。</li>
<li>最后修改串的长度。</li>
</ul>
<h5 id="顺序串的比较"><a class="markdownIt-Anchor" href="#顺序串的比较"></a> 顺序串的比较</h5>
<ul>
<li>比较规则：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200804175856.jpg" alt="" />
<ul>
<li>先不管长短，先比较共同区域内元素的大小；</li>
<li>若共同区域内的元素全都相同，再比较串的长短。（即可能会出现较短的串是较大串的情况）</li>
</ul>
</li>
<li>具体算法：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200804180356.jpg" alt="" />
<ul>
<li>先找出共同长度（即较短串的长度）;</li>
<li>之后在共同长度内比较；</li>
<li>若共同长度内字符全部一致，则再比较长度。</li>
</ul>
</li>
</ul>
<h3 id="堆串"><a class="markdownIt-Anchor" href="#堆串"></a> 堆串</h3>
<h4 id="堆串的定义"><a class="markdownIt-Anchor" href="#堆串的定义"></a> 堆串的定义</h4>
<ul>
<li>为每个串动态分配空间（这个存储空间的实质是一个数组）储存该字符串的信息，然后设置一个指向该串的指针作为串名。每次对字符串进行增删操作就直接分配新的存储空间，释放原来的空间，修改空间的长度。看<a href="#%E5%A0%86%E4%B8%B2%E7%9A%84%E6%8F%92%E5%85%A5">堆串的插入</a>能够更好理解堆串的本质。</li>
<li>与普通的顺序串相比，堆串每次存储字符串的空间是定量(根据字符串实际的长度）再分配的,而不是直接提前规定好存储字符串的空间的长度（即数组的MaxSize）。</li>
<li>堆的定义<pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct
&#123;
  char* ch; &#x2F;&#x2F;指示串的起始地址，即为串分配一个空间，指向这个空间的指针为ch
  int len; &#x2F;&#x2F;指示串的长度
&#125;HString;</code></pre>
<ul>
<li>一个堆即一个堆串的一个基本单元</li>
</ul>
</li>
</ul>
<h4 id="堆串的基本操作"><a class="markdownIt-Anchor" href="#堆串的基本操作"></a> 堆串的基本操作</h4>
<h5 id="堆串赋值"><a class="markdownIt-Anchor" href="#堆串赋值"></a> 堆串赋值</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200808224454.jpg" alt="" /></p>
<ul>
<li>先要判断串是否<strong>不为空</strong>，如果是的话，就释放原来的空间，等待重新分配。</li>
<li>之后将要赋值进来的字符数组的长度计数出来，以便可以分配对应长度的空间。</li>
<li>分配一个长度相同的空间，然后用<code>ch</code>指针指向它;</li>
<li>如果要赋值进来的的字符数组是空的，则将<code>ch</code>指针置为NULL。</li>
</ul>
<h5 id="堆串的插入"><a class="markdownIt-Anchor" href="#堆串的插入"></a> 堆串的插入</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200808231126.jpg" alt="" /></p>
<ul>
<li>先分配一个长度为二串相加的存储空间；</li>
<li>插入操作：
<ol>
<li>将原串pos位置之前的字符复制到新的存储空间里;</li>
<li>在新存储空间的pos位置开始（包含pos位置）,将带插入的串复制进去；</li>
<li>在之后将原串的剩余部分复制进去。</li>
</ol>
<ul>
<li>注意：临界点的判断条件，例如复制待插入的串是从pos位置开始的，即原来的pos位置被新的字符占领了，原来处于pos位置的字符相对的向后移。</li>
</ul>
</li>
<li>最后修改表示长度的len变量；释放原串的存储空间，将指示串位置的ch指针指向新分配的空间。</li>
<li>该基本思想还可以用来实现两串的连接。</li>
</ul>
<h5 id="堆串的复制"><a class="markdownIt-Anchor" href="#堆串的复制"></a> 堆串的复制</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200808232839.jpg" alt="" /></p>
<ul>
<li>分配新空间，顺序复制字符，修改长度变量即可。</li>
</ul>
<h5 id="堆串的判空"><a class="markdownIt-Anchor" href="#堆串的判空"></a> 堆串的判空</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200808233020.jpg" alt="" /></p>
<ul>
<li>判断长度是否为0来判读堆串是否为空；</li>
</ul>
<h5 id="堆串的比较"><a class="markdownIt-Anchor" href="#堆串的比较"></a> 堆串的比较</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200808233855.jpg" alt="" /></p>
<ul>
<li>先逐字符比较，若仍未出结果再比较长度。</li>
</ul>
<h5 id="堆串的清空"><a class="markdownIt-Anchor" href="#堆串的清空"></a> 堆串的清空</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200808234131.jpg" alt="" /></p>
<ul>
<li>先释放堆串的空间，再将指针置为NULL，长度设为0；</li>
</ul>
<h5 id="求堆串的子串"><a class="markdownIt-Anchor" href="#求堆串的子串"></a> 求堆串的子串</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200808234936.jpg" alt="" /></p>
<ul>
<li>先要判断求的子串的长度和位置是否合理；</li>
<li>之后再将子串复制进一个新的堆串中。</li>
</ul>
<h5 id="堆串的子串定位"><a class="markdownIt-Anchor" href="#堆串的子串定位"></a> 堆串的子串定位</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809000140.jpg" alt="" /></p>
<ul>
<li>先从两个字符串的第一个字符开始比较，若字符相等，则依次比较二者的下一个字符；</li>
<li>若字符不相等，则将原串的下标<strong>回溯</strong>到第一个字符的下一位，子串的下标归为0继续在比较。即相当于对应原串的每一个字符都可以生成一个子串，每个字符对应的子串都要与目标子串比较，直到找到目标子串。</li>
<li>比较结束的条件是目标子串已遍历完,最后返回子串第一个字符的位置（即当前下标位置i减去子串的长度j或者t.len）。</li>
</ul>
<h3 id="块链串"><a class="markdownIt-Anchor" href="#块链串"></a> 块链串</h3>
<ul>
<li>块链串即使用链表储存字符串，每一个结点存储一部分字符(类似一句话是整个字符串，而一个结点相当于一个单词)。然后使用next指针连接结点，串成一个大的字符串。</li>
<li>块链串结点定义：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809001808.jpg" alt="" />
<ul>
<li>一个结点中包含一个数据域（char类型的数组）和一个指针域（指向下一结点）。</li>
<li>设置一个储存块链串信息的结构，其中包含该串头结点，尾结点，和长度的信息。</li>
<li>块链串没有设置空的头结点。</li>
</ul>
</li>
</ul>
<h2 id="串的模式匹配"><a class="markdownIt-Anchor" href="#串的模式匹配"></a> 串的模式匹配</h2>
<ul>
<li>在一个串中找到它的子串的位置称为串的模式匹配</li>
</ul>
<h3 id="brute-force蛮牛匹配算法"><a class="markdownIt-Anchor" href="#brute-force蛮牛匹配算法"></a> Brute-Force(蛮牛)匹配算法</h3>
<ul>
<li>
<p>简称为BF算法，又名简单匹配算法。</p>
</li>
<li>
<p>基本思想：穷举<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809003107.jpg" alt="" /></p>
</li>
<li>
<p>算法实现：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809003450.jpg" alt="" /></p>
<ul>
<li>先从两个字符串的第一个字符(若pos不为0,则原串从pos位置开始比较）开始比较，若字符相等，则依次比较二者的下一个字符；</li>
<li>若字符不相等，则将原串的下标<strong>回溯</strong><code>i = i - j + 1</code>到第一个字符的下一位，子串的下标归为0继续在比较。即相当于对应原串的每一个字符都可以生成一个子串，每个字符对应的子串都要与目标子串比较，直到找到目标子串。</li>
<li>比较结束的条件是目标子串已遍历完,最后返回子串第一个字符的位置（即当前下标位置i减去子串的长度j或者t.len）。</li>
</ul>
</li>
<li>
<p>算法分析：</p>
<ul>
<li>最好情况下的时间复杂度（即原串的第一个字符就可以找到子串）😮(m),其中m为子串的问题规模。</li>
<li>最坏情况下的时间复杂度：O(n x m) ,其中n为原串的问题规模。</li>
<li>平均的时间复杂度：O(n x m)。</li>
</ul>
</li>
</ul>
<h3 id="kmp匹配算法"><a class="markdownIt-Anchor" href="#kmp匹配算法"></a> KMP匹配算法</h3>
<ul>
<li>
<p>KMP是三个提出该算法的人的名字的首字母缩写。KMP算法相对于BF算法，主要消除了原串指针的回溯。</p>
</li>
<li>
<p>算法的思想：（i,j均采用数组的下标表示法）</p>
<ol>
<li>若子串没有重复的字符，则当扫描到j位因为字符不相等而退出一轮扫描的时候，说明原串第i位(扫描结束时，j == i)之前的字符与子串第j位之前的字符相等，又因为子串中没有相同的字符，所以子串的的首位字符与原串的前i位字符不相等，所以直接省去子串首字符与原串前i位字符相比较的步骤，跳到与原串第i位开始的字符相比较。这个过程中，<strong>j又回溯</strong>到了子串首字符，而<strong>i没有回溯</strong>直接继续向前推进。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809094650.jpg" alt="" /></li>
<li>若子串中有重复的字符，则若继续按照没有重复字符的方法，在原串第i位前可能与子串首字符相等的字符就会直接失去比较机会，而实际上它们是有可能与子串匹配的。故此我们先记录下子串中不同字符位置前的字符相等情况（通过创建next数组）,将每一次比较终止第j位前的字符分为三种类型：
<ol>
<li>若j位前的字符无重复情况，则j回溯为到首字符,跳到与原串第i位后的字符继续比较（同整个子串无重复字符的情况类似）;</li>
<li>若第j位前的字符前缀与后缀相同（即像：abcab,或者aa,或者aba等）,则j回溯到前缀后的第一位字符，该字符与原串的第i位字符继续比较。因为前缀等于后缀，而原串与子串的这一部分字符相等，所以前缀与原串第i位前的相同长度的部分字符相等，所以可以直接跳过前缀与其的比较，直接进行前缀后的第一个字符与原串的第i个字符的比较。</li>
<li>若第j位前的字符中有相等的情况，但是没有出现前后缀相等的情况（即像：abcdae）,此时j回溯到子串的首字符，然后继续与原串第i位字符开始比较。因为既然子串第j位前字符没有前缀与后缀相等的情况，又有原串的第i位字符前的的字符与子串相同长的字符相等，故与字符开头的部分字符不相等，所以可以直接跳过。例如：子串为abcdaef,原串为abcdaegabcdaef,第一次比较在子串的f位置，原串的g位置停下，若担心漏掉第二次a出现的情况，子串的首字符a与原串的第二个字符a开始比较，肯定是不能匹配成功的。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>next值的求法：</p>
<ul>
<li>
<p>思想：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809102612.jpg" alt="" /></p>
<ul>
<li>next取值的三种情况，其中其它情况对应着字符无重复，和字符没有形成相等的前后缀的情况。</li>
<li>next[j] = -1说明，子串的第j位之前没有任何用于加速匹配的信息（因为此时才开始扫描子串的首字符）,下一趟应从子串的开头j++ =&gt; j=0开始匹配。</li>
<li>next[j]的值取决于前缀的长度，因为在有前缀的情况下，next[j]代表前缀后第一个字符的下标。</li>
<li>示例：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809111243.jpg" alt="" /></li>
</ul>
</li>
<li>
<p>求next的算法：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809104129.jpg" alt="" /></p>
<ul>
<li>j的值一直在增加（中间会有停顿，但不会回缩），而k的值则再-1，0,和其它数之间循环；</li>
<li>每遇到一个没有与前面的字符重复的字符，k都会回退到-1。</li>
<li>要想理解这个算法只有用一个字符串来走来试试（如aabaacd）,词穷了，实在难以用语言描述。。。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>KMP算法实现：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809111243.jpg" alt="" /></p>
<ul>
<li>先挨个字符比较，直到遇到不同的字符终止。之后j根据next修改，i不变，再继续比较。</li>
<li>最后返回匹配到的子串的首字符的下标<code>i - t.len</code>,因为最后一次比较后i还再加了一次，所以直接减去子串的长度即为首字符的下标。</li>
</ul>
</li>
<li>
<p>KMP算法分析：</p>
<ul>
<li>平均时间复杂度：求next数组的时间复杂度为O(m),后面的匹配中时间复杂度为O(n)，所以总的平均时间复杂度O(n+m)。</li>
</ul>
</li>
<li>
<p>KMP算法的改进</p>
<ul>
<li>在计算出next值得同时，如果该位字符与它的next值指向的另一位字符相等，则该位的字符的nextval就指向另一位字符的nextval，如果不等，则该位字符的nextval值就是原来的next值。</li>
<li>解决的问题：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809113921.jpg" alt="" /></li>
<li>求nextval的算法<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809114109.jpg" alt="" />
<ul>
<li>在原来的基础上增加了将nextval的值修改为与其next指向的相等的字符的nextval值。</li>
</ul>
</li>
<li>KMP算法的改进实现：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809114507.jpg" alt="" />
<ul>
<li>除了将next改为了nextval没有任何区别。</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Linux/Make%E5%8F%8AMakefile/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Linux/Make%E5%8F%8AMakefile/index.html" class="post-title-link" itemprop="url">Make及Makefile</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-31 22:28:31" itemprop="dateCreated datePublished" datetime="2020-07-31T22:28:31+08:00">2020-07-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:27:52" itemprop="dateModified" datetime="2022-09-17T19:27:52+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="make及makefile"><a class="markdownIt-Anchor" href="#make及makefile"></a> Make及Makefile</h1>
<h2 id="make"><a class="markdownIt-Anchor" href="#make"></a> Make</h2>
<ul>
<li>代码变成可执行文件，叫做编译（compile）；先编译这个，还是先编译那个（即编译的安排），叫做构建（build）。</li>
<li>Make是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上 ，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。</li>
<li>Make这个词，英语的意思是&quot;制作&quot;。Make命令直接用了这个意思，就是要做出某个文件。make是一个根据指定的Shell命令进行构建的工具。</li>
<li>make命令执行的规则，都写在一个叫做Makefile的文件中，Make命令依赖这个文件进行构建。Makefile文件也可以写为makefile， 或者用命令行参数(<code>make -f &lt;指定的文件名&gt;</code>或者<code>make --file=&lt;指定的文件名&gt;</code>)指定为其他文件名。</li>
</ul>
<h2 id="makefile"><a class="markdownIt-Anchor" href="#makefile"></a> Makefile</h2>
<h3 id="makefile的基本概念"><a class="markdownIt-Anchor" href="#makefile的基本概念"></a> Makefile的基本概念</h3>
<h4 id="makefile是什么"><a class="markdownIt-Anchor" href="#makefile是什么"></a> Makefile是什么？</h4>
<ul>
<li>Makefile 可以简单的认为是一个工程文件的<strong>编译规则</strong>，描述了整个工程的编译和链接等规则。其中包含了那些文件需要编译，那些文件不需要编译，那些文件需要先编译，那些文件需要后编译，那些文件需要重建等等。编译整个工程需要涉及到的，在 Makefile 中都可以进行描述。换句话说，Makefile 可以使得我们的项目工程的<strong>编译变得自动化</strong>，不需要每次都手动输入一堆源文件和参数。</li>
<li>编写Makefile的作用：
<ol>
<li>简化输入的编译命令：在 Makefile 中，制定相应的规则和对应的链接顺序。这样只需要执行 make 命令，工程就会自动编译。每次想要编译工程的时候就执行 make ，省略掉手动编译中的参数选项和命令。</li>
<li>节省编译大工程的时间：Makefile 支持多线程并发操作(就像我们使用的<code>make -j8</code>)，会极大的缩短我们的编译时间，并且当我们修改了源文件之后，编译整个工程的时候，make 命令只会编译我们修改过的文件，没有修改的文件不用重新编译，也极大的解决了我们耗费时间的问题。</li>
</ol>
</li>
</ul>
<h4 id="makefile中的基本规则"><a class="markdownIt-Anchor" href="#makefile中的基本规则"></a> Makefile中的基本规则</h4>
<ul>
<li>
<p>Makefile 描述的是文件编译的相关规则，它的规则主要是两个部分组成，分别是<strong>依赖的关系</strong>和<strong>执行的命令</strong></p>
</li>
<li>
<p>Makefile文件由一系列规则（rules）构成。每条规则的形式如下:</p>
  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&lt;target&gt; : &lt;prerequisites&gt; 
[tab]  &lt;commands&gt;</code></pre>
<ol>
<li>targets：规则的目标，可以是 Object File（一般称它为中间文件），也可以是可执行文件，还可以是一个标签</li>
<li>prerequisites：规则的条件，是我们的依赖文件，要生成 targets 需要的文件或者是目标。可以是多个，也可以是没有；</li>
<li>command：make 需要执行的命令（任意的 shell 命令）。可以有多条命令，每一条命令占一行。</li>
<li>注意：<strong>我们的目标和依赖文件之间要使用<em>冒号</em>分隔开，命令的开始一定要使用<em>Tab</em>键</strong></li>
</ol>
</li>
<li>
<p>Makefile文件规则概要：</p>
<ol>
<li>显式规则：<br />
显式规则说明了，如何生成一个或多的的<strong>目标文件</strong>。这是由 Makefile 的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。</li>
<li>隐晦规则<br />
由于我们的 make 命名有<strong>自动推导</strong>的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写 Makefile，这是由 make 命令所支持的。</li>
<li>变量的定义<br />
在 Makefile 中我们要定义一系列的变量，变量一般都是字符串，这个有点像C语言中的<strong>宏</strong>，当 Makefile 被执行时，其中的变量都会被扩展到相应的引用位置上。</li>
<li>文件指示<br />
其包括了三个部分，一个是在一个 Makefile 中<strong>引用</strong>另一个 Makefile，就像C语言中的 include 一样；另一个是指根据某些情况指定 Makefile 中的<strong>有效部分</strong>，就像C语言中的预编译 #if 一样；还有就是定义一个多行的命令。</li>
<li>注释<br />
Makefile 中<strong>只有行注释</strong>，和 UNIX 的 Shell 脚本一样，其注释是<strong>用“#”字符</strong>，这个就像 C/C++ 中的“//”一样。如果你要在你的 Makefile 中使用“#”字符，可以用反斜框进行转义，如：<code>\#</code>。</li>
</ol>
</li>
</ul>
<h4 id="makefile的基本工作流程"><a class="markdownIt-Anchor" href="#makefile的基本工作流程"></a> Makefile的基本工作流程</h4>
<ul>
<li>当我们在执行 make 条命令的时候，make 就会去<strong>当前文件</strong>下找要执行的编译规则，也就是 Makefile 文件。我们编写 Makefile 的时可以使用的文件的名称&quot;GNUmakefile&quot; 、“makefile” 、“Makefile” ，make 执行时回去寻找 Makefile 文件，找文件的顺序也是这样的。我们推荐使用<strong>Makefile</strong>（一般在工程中都这么写，大写的会比较的规范）。如果文件不存在，make 就会给我们报错，提示：<br />
<code>make：*** 没有明确目标并且找不到 makefile。停止</code></li>
<li>工作流程简介：</li>
</ul>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">main:main.o test1.o test2.o
  gcc main.o test1.o test2.o -o main
main.o:main.c test.h
  gcc -c main.c -o main.o
test1.o:test1.c test.h
  gcc -c test1.c -o test1.o
test2.o:test2.c test.h
  gcc -c test2.c -o test2.o</code></pre>
<ul>
<li><strong>工作流程</strong>：当在 shell 提示符下输入 make 命令以后。 make 读取当前目录下的 Makefile 文件，并将 Makefile 文件中的<strong>第一个目标作为其执行的“终极目标”</strong>，开始处理第一个规则（终极目标所在的规则）。在我们的例子中，第一个规则就是目标 “main” 所在的规则。规则描述了 “main” 的<strong>依赖关系</strong>，并定义了<strong>链接 “.o” 文件生成目标 “main” 的命令</strong>；make 在执行这个规则所定义的命令之前，<strong>首先处理目标 “main” 的所有的依赖文件</strong>（例子中的那些 “.o” 文件）的更新规则（以这些 “.o” 文件为目标的规则）。</li>
<li>对这些 “.o” 文件为目标的<strong>规则处理</strong>有下列三种情况：
<ul>
<li>目标 “.o” 文件<strong>不存在</strong>，使用其描述规则创建它；</li>
<li>目标 “.o” 文件存在，目标 “.o” 文件所<strong>依赖</strong>的 “.c” 源文件 “.h” 文件中的任何一个比目标 “.o” 文件“更新”（在上一次 make 之后被修改）。则根据规则重新编译生成它；</li>
<li>目标 “.o” 文件存在，目标 “.o” 文件比它的任何一个依赖文件（&quot;.c&quot; 源文件、&quot;.h&quot; 文件）“更新”（它的依赖文件在上一次 make 之后<strong>没有被修改</strong>），则什么也不做。</li>
</ul>
</li>
<li>我们执行 make 命令时，<strong>只有修改过的源文件或者是不存在的目标文件</strong>会进行重建，而那些没有改变的文件不用重新编译，这样在很大程度上节省时间，提高编程效率。</li>
<li>具体命令解析
<ol>
<li><code>main: main.o test1.o test2.o</code>:表示最终目标文件是生成main,而main的生成依赖于main.o test1.o test2.o 这三个汇编文件。</li>
<li><code>gcc mian.o test1.o test2.o -o main</code>:指定了生成main所需要执行的shell命令，即将三个依赖的汇编文件链接输出为main。</li>
<li><code>main.o: main.c test.h</code>:表示main.o文件依赖于main.c和test.h文件，为了生成最终文件main，make会先执行能生成main的依赖文件的命令。</li>
<li><code>gcc -c main.c -o main.o</code>:指定了如何通过依赖文件生成main.o的shell命令，即将main.c文件编译汇编为main.o文件（注意：因为gcc会自动找到头文件及所需的链接库，所以汇编时不用加上头文件test.h，但是在<strong>描述依赖关系时还是要将test.h描述进去</strong>）</li>
</ol>
</li>
<li><strong>清除工作过程中的过程文件</strong>:我们在使用的时候会产生中间文件会让整个文件看起来很乱，所以在编写 Makefile 文件的时候会在末尾加上这样的规则语句：</li>
</ul>
  <pre class="line-numbers language-none"><code class="language-none">.PHONY:clean
clean:
rm -rf *.o </code></pre>
<p>其中 “*.o” 是执行过程中产生的中间文件，“test” 是最终生成的执行文件。(具体要删除什么文件，可以自行指定);可以在命令行中指定Makefile中的一个文件作为目标，那么这条make命令就只更新这个指定的目标(如：<code>make clean</code>，如果没有指定目标则make默认更新Makefile中的第一条规则的目标。</p>
<h3 id="makefile中的通配符"><a class="markdownIt-Anchor" href="#makefile中的通配符"></a> Makefile中的通配符</h3>
<ul>
<li>由于Makefile是使用shell命令的，所以shell命令中的通配符在Makefile中也是适用的。</li>
</ul>
<table>
<thead>
<tr>
<th>通配符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>匹配任意个字符,如<code>*.o</code>代表在当前文件夹下所有以<code>.o</code>结尾的文件</td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配一个字符</td>
</tr>
<tr>
<td><code>[]</code></td>
<td>匹配指定的字符，指定的字符放在<code>[]</code>中，如<code>[zhangjie].o</code></td>
</tr>
<tr>
<td><code>~</code></td>
<td>类似于shell中打开目录时的<code>~</code>，后面为空或者接分隔符<code>/</code>或者接路径名或者文件名的时候，代表根目录。如<code>~/bin</code>代表<code>/home/usrname/bin</code>,<code>~zhangjie/bin</code>代表<code>/home/zhangjie/bin</code></td>
</tr>
</tbody>
</table>
<h3 id="makefile变量的定义和使用"><a class="markdownIt-Anchor" href="#makefile变量的定义和使用"></a> Makefile变量的定义和使用</h3>
<h4 id="变量的定义"><a class="markdownIt-Anchor" href="#变量的定义"></a> 变量的定义</h4>
<ul>
<li>变量的定义：
<ul>
<li>变量是用来存储一个值或者使用来进行运算操作，可以用来表示多处出现而内容又可能发生变化的内容。</li>
<li>Makefile中的变量不像c语言中一样,没有数据类型。</li>
<li>变量的名称可以由字母，阿拉伯数字和下划线组成。</li>
<li>变量的定义语句：<code>变量 = 值列表</code>(其中值列表既可以是零项，又可以是一项或者多项),例如：<code>value = 1 2 3</code>,一个变量的定义从<code>=</code>后面的第一个非空白字符开始，包括后面所有的字符，直到注释或者换行之前结束。</li>
</ul>
</li>
<li>变量的调用：
<ul>
<li>调用变量可以使用<code>$(value)</code>,<code>$&#123;value&#125;</code>.</li>
<li>示例：  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">OBJ &#x3D; mian.o test.o 
test: $(OBJ)
  gcc $&#123;OBJ&#125; -o test</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="变量的定义方法"><a class="markdownIt-Anchor" href="#变量的定义方法"></a> 变量的定义方法</h4>
<ul>
<li>简单赋值：<code>:=</code>,编程中常见的变量赋值，只对当前语句有赋值效果,即遇到这种赋值就立即展开。</li>
</ul>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">x :&#x3D; foo
y :&#x3D; $(x)b
x :&#x3D; new
test:
  @echo &quot;y &#x3D;&gt; $(y)&quot;
  @echo &quot;x &#x3D;&gt; $(x)&quot;</code></pre>
<p>结果：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200829225226.jpg" alt="" /></p>
<ul>
<li>递归赋值：<code>=</code>,又叫做迟滞展开，每次使用的变量都是用的最新的定义，所以这种方式甚至能做到等式右边的式子中的变量在之后才被定义,即遇到递归赋值，会在使用整个变量时才将它展开。</li>
</ul>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">x :&#x3D; foo
y &#x3D; $(x)b
x :&#x3D; new
test:
  @echo &quot;y &#x3D;&gt; $(y)&quot;
  @echo &quot;x &#x3D;&gt; $(x)&quot;</code></pre>
<p>结果：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200829230330.jpg" alt="" /></p>
<ul>
<li>
<p>与简单赋值不同的是，递归赋值y中的x使用的是在最后赋给x的new,而不是开始就赋给x的foo(实际上递归赋值相当于最后在使用y变量的时候，才将y的赋值式代入，此时它前面已经又有了对x的新的赋值，所以最后呈现出来的是x最后的赋值,也因此把对x的第二个赋值语句改为简单赋值也是同样的输出)。</p>
</li>
<li>
<p>条件赋值：<code>?=</code>如果当前变量从未被赋值过，则相当于<code>=</code>;但如果当前变量已将被赋值过，则什么也不做，不会再重新赋值。</p>
</li>
</ul>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">x :&#x3D; foo
y :&#x3D; $(x)b
x ?&#x3D; new
test:
  @echo &quot;y &#x3D;&gt; $(y)&quot;
  @echo &quot;x &#x3D;&gt; $(x)&quot;</code></pre>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200830190810.jpg" alt="" /></p>
<ul>
<li>
<p>最后给x的条件赋值实际没有任何效果。</p>
</li>
<li>
<p>追加赋值：<code>+=</code>,追加赋值类似于c语言中的<code>+=</code>,可理解为变量本身再在后面加上<code>+=</code>后面的值，但是不同定义得到的变量它的<code>+=</code>的理解会有不同。比如说，如果变量object使用<code>:=</code>定义的，那么<code>object += foo</code>,与<code>object := $(object) foo</code>,注意最后合成的object的两部分的变量间会自动生成一个空格。</p>
</li>
</ul>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">x :&#x3D; foo
y :&#x3D; $(x)b
x +&#x3D; $(y)
test:
  @echo &quot;y &#x3D;&gt; $(y)&quot;
  @echo &quot;x &#x3D;&gt; $(x)&quot;</code></pre>
<p>结果：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200830192748.jpg" alt="" /></p>
<h4 id="自动化变量"><a class="markdownIt-Anchor" href="#自动化变量"></a> 自动化变量</h4>
<ul>
<li><code>$@</code>:表示规则中的目标</li>
<li><code>$&lt;</code>:表示规则中的第一个条件（即第一个依赖文件）</li>
<li><code>$?</code>:表示规则中所有比目标新的条件，组成一个列表，以空格分隔</li>
<li><code>$^</code>:表示规则中的所有条件(即所有依赖文件)</li>
</ul>
<h3 id="makefile的隐含规则"><a class="markdownIt-Anchor" href="#makefile的隐含规则"></a> Makefile的隐含规则</h3>
<ul>
<li>在Makefile中有内置的隐含规则可以使我们省略对一些规则的命令的编写。</li>
</ul>
<h3 id="makefile的条件判断"><a class="markdownIt-Anchor" href="#makefile的条件判断"></a> Makefile的条件判断</h3>
<ul>
<li>在Makefile编译文件时可能会遇到需要分条件使用不同命令的情况，这时可以使用Makefile的条件编译语句。</li>
<li>常用条件判断的关键字：</li>
</ul>
<table>
<thead>
<tr>
<th>关键字</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>ifeq</td>
<td>判断参数是否相等，相等为true，不相等为false</td>
</tr>
<tr>
<td>ifneq</td>
<td>判断参数是否不相等，不相等为true，相等为false</td>
</tr>
<tr>
<td>ifef</td>
<td>判断是否有值，有值为true，无值为false</td>
</tr>
<tr>
<td>ifnef</td>
<td>判断是否无值，无值为true，有值为false</td>
</tr>
</tbody>
</table>
<h3 id="makefile的伪目标"><a class="markdownIt-Anchor" href="#makefile的伪目标"></a> Makefile的伪目标</h3>
<ul>
<li>伪目标：这个目标没有任何依赖文件，但是有命令，它最终的结果并不会生成任何目标文件，而只是执行该规则下的命令。</li>
<li>伪目标的创建：<code>.PHONY:变量名</code></li>
<li>伪目标的应用：
<ul>
<li>执行一些没有文件产生的命令，如删除</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">.PHONY:clean
clean:
  rm -rf *.o </code></pre>
<ul>
<li>一个make命令产生多可执行文件，提升make的效率。</li>
</ul>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">.PHONY:all
all:test1, test2, test3

test1: test1.o
  gcc $^ -o $@
test2: test2.o
  gcc $^ -o $@
test3: test3.o
  gcc $^ -o $@</code></pre>
<p>*如果只想生成一个test1文件，可以用<code>make test1</code>。</p>
<h3 id="makefile的基础语法"><a class="markdownIt-Anchor" href="#makefile的基础语法"></a> Makefile的基础语法</h3>
<h4 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h4>
<ul>
<li>Makefile类似Python，在每一行后以<code>#</code>来开始注释。</li>
</ul>
<h4 id="回声"><a class="markdownIt-Anchor" href="#回声"></a> 回声</h4>
<ul>
<li>默认情况下，make会打印它执行的命令行，这叫做“回声”。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200830213731.jpg" alt="" /></li>
<li>在每行命令前加上<code>@</code>符号就可以关闭回声，例如经常使用的<code>@echo</code></li>
</ul>
<h4 id="makefile中的函数"><a class="markdownIt-Anchor" href="#makefile中的函数"></a> Makefile中的函数</h4>
<p>Makefile中有许多<a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Functions.html">内置函数</a>可以调用。</p>
<hr />
<p>参考资料：<br />
<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/02/make.html">阮一峰的博客</a><br />
<a target="_blank" rel="noopener" href="http://c.biancheng.net/makefile/">C语言中文网</a><br />
<a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/">GNU make</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/index.html" class="post-title-link" itemprop="url">第三章 栈与队列</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-31 17:25:37" itemprop="dateCreated datePublished" datetime="2020-07-31T17:25:37+08:00">2020-07-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:27:52" itemprop="dateModified" datetime="2022-09-17T19:27:52+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">专业基础</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第三章-限定性线性表-栈与队列"><a class="markdownIt-Anchor" href="#第三章-限定性线性表-栈与队列"></a> 第三章 限定性线性表-栈与队列</h1>
<h2 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h2>
<h3 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h3>
<ul>
<li>栈与队列都是特殊的线性表，是操作受限的线性表，称为限定性线性表。</li>
<li>特点：先进后出（FILO:first in last out）或后进先出（LIFO:last in first out）<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731163004.jpg" alt="" />
<ul>
<li>线性表可以在任意位置插入、删除，而栈只允许在栈顶进行插入或者删除操作，故称为操作受限。</li>
</ul>
</li>
<li>典例：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731163554.jpg" alt="" /></li>
<li>栈的几种基本运算<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731211109.jpg" alt="" /></li>
</ul>
<h3 id="栈的两种存储结构"><a class="markdownIt-Anchor" href="#栈的两种存储结构"></a> 栈的两种存储结构</h3>
<ol>
<li>顺序存储结构：
<ol>
<li>优势：存取时定位很方便</li>
<li>劣势：顺序栈需要一个事先固定的长度，可能会存在空间浪费和不足(栈满）的情况</li>
</ol>
</li>
<li>链式存取结构：
<ol>
<li>优势：栈的长度无限制</li>
<li>劣势：存取定位不方便，且需要每个元素都有一个指针域，增加了内存开销。</li>
</ol>
</li>
<li>总结：当栈的使用过程中元素数量变化范围不可定，有时很大，有时很小，那么使用链栈；反之，如果变化范围在可控范围内，则使用顺序栈。</li>
</ol>
<h3 id="栈的顺序存储结构"><a class="markdownIt-Anchor" href="#栈的顺序存储结构"></a> 栈的顺序存储结构</h3>
<h4 id="栈的顺序存储结构的定义"><a class="markdownIt-Anchor" href="#栈的顺序存储结构的定义"></a> 栈的顺序存储结构的定义</h4>
<ul>
<li>
<p>结点类型：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731211413.jpg" alt="" /></p>
<ul>
<li>用数组存储结点数据；</li>
<li>需要设置一个栈顶指针,但其实top的实际值不是指针，而只是栈顶元素的数组下标，初始值为-1，表示栈空。</li>
</ul>
</li>
<li>
<p>基本原理示意：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731211703.jpg" alt="" /></p>
<ul>
<li>top指针始终指向栈顶元素，且初始值为-1。</li>
</ul>
</li>
<li>
<p>顺序栈四要素：</p>
<ul>
<li>栈空条件：<code>top == -1</code></li>
<li>栈满条件： <code>top == StackSize - 1</code></li>
<li>进栈操作: <code>top++</code>,然后将元素赋给对应数组元素：<code>data[top] = e</code></li>
<li>退栈操作：<code>top--</code>,然后返回对应元素值。</li>
</ul>
</li>
</ul>
<h4 id="栈在顺序栈中实现的基本运算"><a class="markdownIt-Anchor" href="#栈在顺序栈中实现的基本运算"></a> 栈在顺序栈中实现的基本运算</h4>
<h5 id="初始化栈创建"><a class="markdownIt-Anchor" href="#初始化栈创建"></a> 初始化栈（创建）</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731212626.jpg" alt="" /></p>
<ul>
<li><code>top = -1</code>即可创建空栈；</li>
<li>注意栈指针与栈顶“指针”的区别。</li>
</ul>
<h5 id="判断栈是否为空"><a class="markdownIt-Anchor" href="#判断栈是否为空"></a> 判断栈是否为空</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731212955.jpg" alt="" /></p>
<ul>
<li>判空条件<code>top == -1</code></li>
<li>直接返回判等式的真假值即可作为栈是否为空的真假值。</li>
</ul>
<h5 id="进栈"><a class="markdownIt-Anchor" href="#进栈"></a> 进栈</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731213335.jpg" alt="" /></p>
<ul>
<li>先要判断<strong>栈是否已满</strong>;</li>
<li>栈顶指针<code>top++</code>,再放对应元素即可。</li>
</ul>
<h5 id="出栈"><a class="markdownIt-Anchor" href="#出栈"></a> 出栈</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731213626.jpg" alt="" /></p>
<ul>
<li>先要判断<strong>栈是否为空</strong>；</li>
<li>栈顶指针<code>top--</code>即可。</li>
<li>若单纯取栈顶元素，去掉<code>top--</code>即可，但仍要判断栈是否为空。</li>
<li>利用进栈顺序与出栈顺序刚好相反可以用来判断一个字符串是否是对称串。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801110904.jpg" alt="" /></li>
</ul>
<h5 id="两栈共享技术"><a class="markdownIt-Anchor" href="#两栈共享技术"></a> 两栈共享技术</h5>
<ul>
<li>适用于两个相同类型的栈。</li>
<li>目的是节约存储空间，特别是解决一个栈已满，而另一个栈剩余空间还很多的情况。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801111631.jpg" alt="" />
<ul>
<li>用一个数组来储存两个栈，数组的头尾两端分别对应两个栈的栈底，增加元素则是两个top指针在向中间靠拢。</li>
<li>用一个小数组来存储两个栈的栈顶指针。</li>
</ul>
</li>
</ul>
<h6 id="两栈共享的初始化"><a class="markdownIt-Anchor" href="#两栈共享的初始化"></a> 两栈共享的初始化</h6>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">void InitStack（DqStack *S）
&#123;
  S-&gt;top[0] &#x3D; -1;
  S-&gt;top[1] &#x3D; M;&#x2F;&#x2F;数组末端再外面一格，表示该栈为空
&#125;</code></pre>
<ul>
<li>注意靠近末端栈的栈顶指针是反着的。</li>
</ul>
<h6 id="两栈共享的进栈"><a class="markdownIt-Anchor" href="#两栈共享的进栈"></a> 两栈共享的进栈</h6>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">int Push(DqStack *S, StackEkementType x, int i)
&#123;
  if(S-&gt;top[0] + 1 &#x3D;&#x3D; S-&gt;top[1])
    return (FALSE);
  
  switch(i)
  &#123;
    case 0: 
            S-&gt;top[0]++;
            S-&gt;Stack[S-&gt;top[0]] &#x3D; x; 
            break;
    case 1: 
            S-&gt;top[1]--;
            S-&gt;Stack[S-&gt;top[1]] &#x3D; x;
            break;
    default:
            return (FALSE);
  &#125;
  return (TRUE)
&#125;</code></pre>
<ul>
<li>先要判断栈是否已满：<code>S-&gt;top[0] + 1 == S-&gt;top[1]</code>,即两个栈顶指针是否已经抵到一起，即它们之间只相差1。</li>
<li>还需要判断新元素是进入哪个栈；</li>
<li>注意两个栈的栈顶指针向前移动的方式是相反的，一个是加，一个是减。</li>
</ul>
<h6 id="两栈共享的出栈"><a class="markdownIt-Anchor" href="#两栈共享的出栈"></a> 两栈共享的出栈</h6>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801113613.jpg" alt="" /></p>
<ul>
<li>在判断好是哪个栈要出栈的基础上，还要判断该栈是否为空。</li>
<li>出栈只需对应栈顶指针向对应的栈底方向减一位即可。</li>
</ul>
<h3 id="栈的链式存储结构"><a class="markdownIt-Anchor" href="#栈的链式存储结构"></a> 栈的链式存储结构</h3>
<ul>
<li>使用链表存储的栈称为链栈。</li>
<li>基本原理：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801151614.jpg" alt="" />
<ul>
<li>带头结点s.</li>
<li>栈顶为头结点后，栈底为链表链尾。</li>
</ul>
</li>
<li>结点定义：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801151614.jpg" alt="" /></li>
<li>链表4要素：
<ul>
<li>栈空条件：<code>s-&gt;next == NULL</code></li>
<li>栈满条件：链栈是无限的，不会满溢。</li>
<li>进栈操作：头插法。</li>
<li>退栈操作：取出头结点后第一个结点，并释放其空间，并将头结点与下一个结点连接好。</li>
</ul>
</li>
</ul>
<h4 id="链栈的基本运算算法"><a class="markdownIt-Anchor" href="#链栈的基本运算算法"></a> 链栈的基本运算算法</h4>
<h5 id="初始化栈"><a class="markdownIt-Anchor" href="#初始化栈"></a> 初始化栈</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801152247.jpg" alt="" /></p>
<ul>
<li>创建头结点（为其分配空间）,并将其指针域置为NULL。</li>
</ul>
<h5 id="销毁栈"><a class="markdownIt-Anchor" href="#销毁栈"></a> 销毁栈</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801152548.jpg" alt="" /></p>
<ul>
<li>设立两个移动的指针，一个指向当前被释放的结点，一个指向其下一个结点，不断扫描下去。</li>
<li>最后p指针会指向栈底结点，不要忘了将其释放。</li>
</ul>
<h5 id="判断链栈是否为空"><a class="markdownIt-Anchor" href="#判断链栈是否为空"></a> 判断链栈是否为空</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801152848.jpg" alt="" /></p>
<ul>
<li>链栈为空的条件是头结点的指针域为空，即<code>s-&gt;next == NULL</code></li>
</ul>
<h5 id="进栈-2"><a class="markdownIt-Anchor" href="#进栈-2"></a> 进栈</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801153104.jpg" alt="" /></p>
<ul>
<li>每次为新结点分配空间都要判断分配是否成功。</li>
<li>头插法进栈</li>
</ul>
<h5 id="出栈-2"><a class="markdownIt-Anchor" href="#出栈-2"></a> 出栈</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801153346.jpg" alt="" /></p>
<ul>
<li>先要判断栈是否为空<code>p == NULL</code></li>
<li>然后将头结点的指针域设为当前结点的下一个结点即可</li>
<li>若是单纯取出元素，则仅仅去掉改指针，释放空间的一步即可。</li>
</ul>
<h3 id="栈的经典题目"><a class="markdownIt-Anchor" href="#栈的经典题目"></a> 栈的经典题目</h3>
<h4 id="1一种括号配对"><a class="markdownIt-Anchor" href="#1一种括号配对"></a> 1.一种括号配对</h4>
<ul>
<li>基本思路：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801163648.jpg" alt="" />
<ul>
<li>只将左括号进栈，遇到一个右括号则出栈一个左括号与其相匹配；</li>
<li>成功匹配的条件是，栈为空，且所有括号已扫描完。</li>
</ul>
</li>
<li>算法实现：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801164213.jpg" alt="" />
<ul>
<li>先要创建一个空链栈；</li>
<li>最后若一直匹配完了，还要判断栈是否为空来确定是否匹配成功。</li>
</ul>
</li>
</ul>
<h2 id="队列"><a class="markdownIt-Anchor" href="#队列"></a> 队列</h2>
<h3 id="定义-2"><a class="markdownIt-Anchor" href="#定义-2"></a> 定义</h3>
<ul>
<li>队列简称队，是一种运算受限的线性表；</li>
<li>队列只允许在一端进行插入操作，而在另一端进行删除操作。允许插入的一端称为队尾，允许删除的一端称为队头。</li>
<li>特点：先进先出（FIFO：first in first out）,与栈刚好想反。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801164935.jpg" alt="" /></li>
<li>队列的基本运算<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801165142.jpg" alt="" /></li>
</ul>
<h3 id="队列的存储结构"><a class="markdownIt-Anchor" href="#队列的存储结构"></a> 队列的存储结构</h3>
<ol>
<li>链式存储结构</li>
<li>不带头结点但头结点后面设置一个空结点的链队</li>
<li>不带头结点且头结点后直接就是第一个数据结点的链队</li>
<li>顺序存储结构
<ol>
<li>单向顺序队列</li>
<li>环形顺序队列</li>
</ol>
</li>
</ol>
<h3 id="队列的链式存储结构"><a class="markdownIt-Anchor" href="#队列的链式存储结构"></a> 队列的链式存储结构</h3>
<ul>
<li>
<p>带头结点没有空结点的链队<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801223459.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801223632.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801223852.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801224539.jpg" alt="" /></p>
<ul>
<li>设置队头和队尾指针，队头指针始终指向第一个数据结点，队尾指针始终指向最后一个数据结点，队列遵循尾进头出的规则。</li>
<li>设置一个小数组（或者结构）来储存两个指针，其实相当于原来的头结点的升级版。</li>
<li>链队4要素：
<ol>
<li>空队的条件：<code>front == rear &amp;&amp; front == NULL</code></li>
<li>链队是不会出现队满的情况的。</li>
<li>进队操作：将新结点尾插法插入队尾后</li>
<li>出队操作:删除第一个数据结点。</li>
</ol>
</li>
</ul>
</li>
<li>
<p>带头结点有空结点的链队<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801224937.jpg" alt="" /></p>
<ul>
<li>链队4要素
<ol>
<li>队空条件：<code>front == rear</code>,两个指针开始时都指向设置的第一个空结点；</li>
<li>不会出现队满的情况；</li>
<li>进队操作：尾插法；</li>
<li>出队操作：删除第一个非空的数据结点</li>
</ol>
</li>
<li>所以呢？空结点设来有啥用？
<ul>
<li>front指针域永远不用变动，每次不管什么操作，最多改变rear指针，而front指针是永远指向那个空结点的。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>不带头结点只有尾指针的循环链表队列<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802103925.jpg" alt="" /></p>
<ul>
<li>链队4要素
<ol>
<li>队空条件：<code>rear == NULL</code></li>
<li>队满条件：无限。</li>
<li>进队操作：将新结点插入队尾；</li>
<li>出队操作：删除单链表首结点。</li>
</ol>
</li>
<li>初始化：<code>rear = NULL</code></li>
<li>判空：<code>rear == NULL</code></li>
<li>进队：(新结点为p)
<ul>
<li>原队列为空：<code>p-&gt;next = p; rear = p</code></li>
<li>原队列不为空：<code>p-&gt;next = rear-&gt;next; rear-&gt;next =p; rear = p</code></li>
</ul>
</li>
<li>出队：
<ul>
<li>原队中只有一个结点：<code>free(rear); rear = NULL</code></li>
<li>原队中有两个及以上结点：<code>q = rear-&gt;next; rear-&gt;next = q-&gt;next; free(q)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="带头结点设空结点链队的基本运算"><a class="markdownIt-Anchor" href="#带头结点设空结点链队的基本运算"></a> 带头结点设空结点链队的基本运算</h4>
<h5 id="初始化队列"><a class="markdownIt-Anchor" href="#初始化队列"></a> 初始化队列</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802100748.jpg" alt="" /></p>
<ul>
<li>传进来的参数是指向新版头结点的指针；</li>
<li>分配一个空的数据结点的空间，让front 和rear指针都指向它，而把它的next域置为NULL。</li>
</ul>
<h5 id="清空队列"><a class="markdownIt-Anchor" href="#清空队列"></a> 清空队列</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802101350.jpg" alt="" /></p>
<ul>
<li>设置两个移动指针，一个指向当前第一个非空数据结点，另一个指向其下一结点；</li>
<li>每次释放掉第一个非空数据结点，然后顺序移动指针,扫描队列；</li>
<li>结束的条件是当前的第一个非空结点的next域为空，即<code>r != NULL</code>或<code>p-&gt;next != NULL</code></li>
<li>最后释放掉最后一个结点，记得将rear指针域指向空结点。</li>
</ul>
<h5 id="判断队列是否为空"><a class="markdownIt-Anchor" href="#判断队列是否为空"></a> 判断队列是否为空</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802102138.jpg" alt="" /></p>
<ul>
<li>只需判断front 和rear指针是否相等即可，因为front指针永远指向那个空结点。</li>
</ul>
<h5 id="进队"><a class="markdownIt-Anchor" href="#进队"></a> 进队</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802102621.jpg" alt="" /></p>
<ul>
<li>为新结点分配一个空间（记得看分配是否成功;</li>
<li>将新结点接到尾结点后，并移动rear指针。</li>
</ul>
<h5 id="出队"><a class="markdownIt-Anchor" href="#出队"></a> 出队</h5>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802102943.jpg" alt="" /></p>
<ul>
<li>先要判断队列是否为空；</li>
<li>然后设置一个指针指向队头元素，以便读出队头元素的数据，以及将空结点的指针域移到队头元素的下一个结点(若没有下一结点，则自然设为了NULL)</li>
<li>还要注意队头元素是否同时是队尾元素，若是，则需要先将rear指针改为指向空结点,再释放该结点。</li>
</ul>
<h3 id="队列的顺序表存储结构"><a class="markdownIt-Anchor" href="#队列的顺序表存储结构"></a> 队列的顺序表存储结构</h3>
<ul>
<li>顺序队列的两种存储方式
<ol>
<li>
<p>顺序队列（普通的单向队列）:</p>
<ol>
<li>劣势：假溢出问题：当我们认为队列已满不能进队时，其实数组里还有多余的空位置。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802181417.jpg" alt="" /></li>
</ol>
</li>
<li>
<p>循环队列</p>
</li>
</ol>
</li>
</ul>
<h4 id="1单向顺序队"><a class="markdownIt-Anchor" href="#1单向顺序队"></a> 1.单向顺序队</h4>
<h5 id="定义-3"><a class="markdownIt-Anchor" href="#定义-3"></a> 定义</h5>
<ul>
<li>
<p>结点定义<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802163228.jpg" alt="" /></p>
<ul>
<li>用数组存储；</li>
<li>设置指向队头和队尾的“模拟指针”,标明数组的头尾下标，以达到类似指针的指向队头和队尾的效果；</li>
</ul>
</li>
<li>
<p>基本原理：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802163647.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802163835.jpg" alt="" /></p>
<ul>
<li>rear指针始终指向队尾元素，且每次增加一个元素，rear指针加一，数组新的位置用以放新元素；</li>
<li>front指针始终指向队头，且front指向下是始终没有数据元素的；每当元素出队，front则加一前移一位，所以队列与栈不同，用数组表示队列，经常会出现元素在整个数组的中间的情况，前不搭头，后不着尾。</li>
</ul>
</li>
<li>
<p>单向顺序队4要素：</p>
<ol>
<li>队空条件：<code>front == rear</code></li>
<li>队满条件：<code>rear == StackSize - 1</code></li>
<li>进队操作：<code>rear++; data[rear] = e //e 为新加数据元素</code></li>
<li>出队操作：<code>front++;</code></li>
</ol>
</li>
</ul>
<h5 id="单向顺序队的基本运算"><a class="markdownIt-Anchor" href="#单向顺序队的基本运算"></a> 单向顺序队的基本运算</h5>
<h6 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h6>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802164742.jpg" alt="" /></p>
<ul>
<li>整个顺序队其实是一个结构体，这个结构体中含有一个数组和两个充当“指针”的整数（实际是记录下标）</li>
<li>为结构体分配好空间后，再将front和rear都置为-1，表示指向整个队列之前，此时队列为空。</li>
</ul>
<h6 id="销毁队列"><a class="markdownIt-Anchor" href="#销毁队列"></a> 销毁队列</h6>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802165107.jpg" alt="" /></p>
<ul>
<li>不用像链队一样需要将每一个结点空间释放（因为本来就只有一个结点，实际用来储存的是数组）；</li>
<li>只需要将front和rear都置为-1,形式上表示此队列为空即可，数组中实际留有的数据，在下一次使用队列便覆盖了，没有影响。</li>
</ul>
<h6 id="判断栈是否为空-2"><a class="markdownIt-Anchor" href="#判断栈是否为空-2"></a> 判断栈是否为空</h6>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802165537.jpg" alt="" /></p>
<ul>
<li>只需判断front和rear是否相等即可。</li>
</ul>
<h6 id="进队-2"><a class="markdownIt-Anchor" href="#进队-2"></a> 进队</h6>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802165801.jpg" alt="" /></p>
<ul>
<li>注意：先要判断队满与否；</li>
<li>然后rear进一位，将数据赋入对应位置即可。</li>
</ul>
<h6 id="出队-2"><a class="markdownIt-Anchor" href="#出队-2"></a> 出队</h6>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802170017.jpg" alt="" /></p>
<ul>
<li>先要判断队是否为空：<code>q-&gt;front == q-&gt;rear</code></li>
<li>然后将front前移一位（+1）即可。</li>
</ul>
<h4 id="2-环形队列"><a class="markdownIt-Anchor" href="#2-环形队列"></a> 2. 环形队列</h4>
<h5 id="定义-4"><a class="markdownIt-Anchor" href="#定义-4"></a> 定义</h5>
<ul>
<li>基本原理<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802181708.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802182023.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802182141.jpg" alt="" />
<ul>
<li>逻辑上看成一个环形的队列，但实际用来存储的还是一个普通的数组。</li>
<li>利用取余计算结果的循环往复性，在逻辑上实现一个环形；</li>
<li>约定当rear==front的时候队列为空，可以理解为由于不断有元素出队，front不断前移，当front最终于rear相等的时候说明两者之间的元素已经全部出队列了，此时队列为空。</li>
<li>如果不对队满的条件加以限制，则当队列真正满的时候，rear 还是与front相等。所以约定<code>(rear + 1) % StackSize == front</code>时为队满条件，即rear还需再加一位才与front相等，也可以理解为此时由于不断有元素进队，rear在一直向前加，马上就要与front相“撞”,我们牺牲一个位置（即rear在即将与front相撞前指向的位置）来保证与队空条件的区分。</li>
</ul>
</li>
<li>环形队列的4要素；
<ol>
<li>队空条件：<code>front == rear</code></li>
<li>队满条件：<code>(rear + 1) % StackSize == front</code></li>
<li>进队操作：<code>rear = (rear + 1) % StackSize</code>,若不好理解，就直接理解rear最开始小于StackSize的时候，此时取余元素没有效果，就相当于简单的加1。因为取余运算的效果就是不管rear执行过多少次加法来移动，始终都被局限于StackSize的范围内重复“绕圈”。</li>
<li>出队操作：<code>front = (front + 1) % StackSize</code></li>
</ol>
</li>
</ul>
<h5 id="环形队列的基本运算"><a class="markdownIt-Anchor" href="#环形队列的基本运算"></a> 环形队列的基本运算</h5>
<h6 id="初始化-2"><a class="markdownIt-Anchor" href="#初始化-2"></a> 初始化</h6>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802223719.jpg" alt="" /></p>
<ul>
<li>实际只要保证front与rear相等即可，为不为0并不重要。</li>
</ul>
<h6 id="入队"><a class="markdownIt-Anchor" href="#入队"></a> 入队</h6>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802223914.jpg" alt="" /></p>
<ul>
<li>先要判断队列是否已满；</li>
<li>之后再将rear指针前移一位。</li>
</ul>
<h6 id="出队-3"><a class="markdownIt-Anchor" href="#出队-3"></a> 出队</h6>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802224044.jpg" alt="" /></p>
<ul>
<li>先要判断队列是否为空；</li>
<li>之后只要将front指针向前移一位即可。</li>
</ul>
<h5 id="环形队列的简化"><a class="markdownIt-Anchor" href="#环形队列的简化"></a> 环形队列的简化</h5>
<ul>
<li>
<p>根据头指针和队列中的元素个数可以计算出队尾指针，因此可以将队尾指针rear去掉。</p>
</li>
<li>
<p>计算队列中的元素个数和指针的公式：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802224814.jpg" alt="" /></p>
<ul>
<li>公式中的取余运算时咋推出来的？</li>
</ul>
</li>
<li>
<p>结点定义：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802225447.jpg" alt="" /></p>
<ul>
<li>去掉尾指针rear增加元素数量count</li>
</ul>
</li>
<li>
<p>无尾指针环形队列的4要素</p>
<ol>
<li>队空条件：count == 0；</li>
<li>队满条件：count == StackSize;</li>
<li>进队操作：先由count和front求出rear指针，再进行与普通环形队列同样的操作；</li>
<li>出队操作：同普通环形队列。</li>
</ol>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/GCC%E5%9F%BA%E7%A1%80/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/GCC%E5%9F%BA%E7%A1%80/index.html" class="post-title-link" itemprop="url">GCC基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-28 10:01:51" itemprop="dateCreated datePublished" datetime="2020-07-28T10:01:51+08:00">2020-07-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:41:21" itemprop="dateModified" datetime="2022-09-17T19:41:21+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">杂技术</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="gcc基础"><a class="markdownIt-Anchor" href="#gcc基础"></a> GCC基础</h1>
<h2 id="gcc简介"><a class="markdownIt-Anchor" href="#gcc简介"></a> GCC简介</h2>
<ul>
<li>早期 GCC 的全拼为 GNU C Compiler，即 GUN 计划诞生的 C 语言编译器，显然最初 GCC 的定位确实只用于编译 C 语言。但经过这些年不断的迭代，GCC 的功能得到了很大的扩展，它不仅可以用来编译 C 语言程序，还可以处理 C++、Go、Objective -C 等多种编译语言编写的程序。与此同时，由于之前的 GNU C Compiler 已经无法完美诠释 GCC 的含义，所以其英文全称被重新定义为  GNU Compiler Collection，即 GNU 编译器套件。</li>
</ul>
<h2 id="gcc在linux的安装"><a class="markdownIt-Anchor" href="#gcc在linux的安装"></a> GCC在Linux的安装</h2>
<h3 id="查看当前gcc的版本"><a class="markdownIt-Anchor" href="#查看当前gcc的版本"></a> 查看当前GCC的版本</h3>
<ul>
<li>命令：<code>gcc --version</code>或者<code>gcc -v</code><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200728181043.jpg" alt="" /></li>
</ul>
<h3 id="快速安装gcc"><a class="markdownIt-Anchor" href="#快速安装gcc"></a> 快速安装GCC</h3>
<ul>
<li>此处以ubuntu系统的为例</li>
<li>命令:<code>sudo apt-get install gcc</code><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200728181521.jpg" alt="" />
<ul>
<li>因为已经安装了所以没有安装的过程</li>
</ul>
</li>
<li>注：采用此方式安装的 GCC 编译器，版本通常较低。</li>
</ul>
<h3 id="编译安装gcc"><a class="markdownIt-Anchor" href="#编译安装gcc"></a> 编译安装GCC</h3>
<ul>
<li>此方式需要耗费的时间较长（几个小时），但支持安装指定版本的 GCC 编译器，并适用于大多数 Linux 发行版；同时，如果想对已安装的 GCC 编译器进行版本升级，也可以使用此方式。</li>
<li>编译安装 GCC 编译器需要提前到 GCC 官网下载指定版本的 GCC 源码安装包，读者可直接点击<a target="_blank" rel="noopener" href="http://mirror.hust.edu.cn/gnu/gcc/">GCC源码包</a>进行下载。</li>
<li>安装步骤：
<ol>
<li>找到下载好的 gcc-10.2.0.tar.gz 安装包(2020年7月23日更新），将其解压至 /usr/local/ 目录下，命令为：<code>sudo tar -xf gcc-10.1.0.tar.gz -C /usr/local</code><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200728183112.jpg" alt="" /></li>
<li>紧接着执行如下指令，下载安装 GCC 所需要的依赖包（如 gmp、mpfr、mpc 等）:进入/usr/local/gcc-10.2.0目录下 <code>cd /usr/local/gcc-10.2.0</code>，之后执行安装依赖包的命令 <code>./contrib/download_prerequisites</code><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200728183918.jpg" alt="" /></li>
<li>在/usr/local目录下手动创建一个目录，用于存放编译 GCC 源码包生成的文件。执行如下命令：创建目录<code>sudo mkdir gcc-build-10.2.0</code> 之后进入gcc-10.2.0目录下<code>cd gcc-10.2.0</code></li>
<li>通过执行如下指令，可以配置 GCC 支持编译 C 和 C++ 语言:<code>../gcc-10.2.0/configure --enable-checking=release --enable-languages=c,c++ --disable-multilib</code><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200728184348.jpg" alt="" /></li>
<li>在第 4 步创建好 makefile 文件之后，接下来就可以使用 make 命令来编译 GCC 源程序:<code>sudo make</code>(此过程十分耗时，本机使用vmware虚拟机，运行内存4GB，用了8个线程<code>make -j8</code>花了35分钟)</li>
<li>最后在漫长的等待后不要忘了执行如下命令安装 gcc：<code>sudo make install</code>(如果此时直接执行 gcc --version，则 GCC 版本仍会显示之前安装的版本。操作系统重启之后，GCC 版本就会自行更正过来。)</li>
<li>注意：因为/usr/local所在目录本身需要sudo权限才能访问，所以最好在每个命令前加上sudo;如果某个命令执行不成功也可加上sudo再试一下。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200728192642.jpg" alt="" /></li>
</ol>
</li>
</ul>
<h2 id="gcc和g命令的区别"><a class="markdownIt-Anchor" href="#gcc和g命令的区别"></a> gcc和g++命令的区别</h2>
<ul>
<li>实际使用中我们更习惯使用 gcc 指令编译 C 语言程序，用 g++ 指令编译 C++ 代码。需要强调的一点是，这并不是 gcc 和 g++ 的区别，gcc 指令也可以用来编译 C++ 程序，同样 g++ 指令也可以用于编译 C 语言程序。</li>
<li>只要是 GCC 支持编译的程序代码，都可以使用 gcc 命令完成编译。可以这样理解，gcc 是 GCC 编译器的<strong>通用</strong>编译指令，因为根据程序文件的后缀名，gcc 指令可以自行判断出当前程序所用编程语言的类别。（gcc 指令也为用户提供了“<strong>手动指定</strong>代表编译方式”的接口，即使用 -x 选项。例如，gcc -xc xxx 表示以编译 C 语言代码的方式编译 xxx 文件；而 gcc -xc++ xxx 则表示以编译 C++ 代码的方式编译 xxx 文件。）</li>
<li>使用 g++ 指令，则无论目标文件的后缀名是什么，该指令都**一律按照编译 C++**代码的方式编译该文件。</li>
<li>如果想使用 gcc 指令来编译执行 C++ 程序，需要在使用 gcc 指令时，手动为其添加<code>-lstdc++ -shared-libgcc</code>选项，表示 gcc 在编译 C++ 程序时可以链接必要的 C++ 标准库。即g++ 指令就等同于<code>gcc -xc++ -lstdc++ -shared-libgcc</code>指令</li>
</ul>
<h2 id="指定编译标准"><a class="markdownIt-Anchor" href="#指定编译标准"></a> 指定编译标准</h2>
<ul>
<li>命令：<code>gcc/g++ -std=标准 ...</code></li>
<li>GCC支持的标准一览：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200729173010.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200729173106.jpg" alt="" /></li>
</ul>
<h2 id="gcc一步编译cc程序"><a class="markdownIt-Anchor" href="#gcc一步编译cc程序"></a> GCC一步编译c/c++程序</h2>
<ul>
<li>编译命令：<code>gcc xx.c -o &lt;指定生成的文件名&gt;</code>
<ul>
<li>若编译c++ 程序换为g++即可</li>
<li>-o 选项后面接上想要GCC在当前目录下生成的可执行文件的文件名，若去掉-o选项则默认在当前目录下生成一个名为a.out的可执行文件</li>
</ul>
</li>
<li>执行命令：在当前目录下<code>./a.out(文件名)</code>，即只要在终端输入可执行的文件的全路径（绝对或相对均可）就可运行相应可执行文件。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200729180045.jpg" alt="" /></li>
</ul>
<h2 id="gcc分布编译cc程序"><a class="markdownIt-Anchor" href="#gcc分布编译cc程序"></a> GCC分布编译c/c++程序</h2>
<ul>
<li>无论是 C 还是 C++ 程序，其从源代码转变为可执行代码的过程，具体可分为 4 个过程，分别为预处理（Preprocessing）、编译（Compilation）、汇编（Assembly）和链接（Linking）。默认情况下，gcc 指令会一气呵成，直接将源代码历经这 4 个过程转变为可执行代码，且不会保留各个阶段产生的中间文件。</li>
<li>如果想查看这 4 个阶段各自产生的中间文件，最简单直接的方式就是对源代码进行“分步编译”，即控制 GCC 编译器逐步对源代码进行预处理、编译、汇编以及链接操作。</li>
</ul>
<h3 id="预处理"><a class="markdownIt-Anchor" href="#预处理"></a> 预处理</h3>
<ul>
<li>
<p>所谓预处理操作，主要是处理那些源文件和头文件中以 # 开头的命令（比如 #include、#define、#ifdef 等），并删除程序中所有的注释 // 和 /* … */。</p>
</li>
<li>
<p>为 gcc 指令添加 -E 选项，即可控制 GCC 编译器仅对源代码做预处理操作。</p>
<ul>
<li>默认情况下 gcc -E 指令只会将预处理操作的结果输出到屏幕上，并不会自动保存到某个文件。因此该指令往往会和 -o 选项连用，将结果导入到指令的文件中。</li>
<li>Linux 系统中通常用 “.i” 作为 C 语言程序预处理后所得文件的后缀名。</li>
<li>为 gcc 指令再添加一个 -C （大写的C）选项，阻止 GCC 删除源文件和头文件中的注释。</li>
</ul>
</li>
<li>
<p>gcc -E 常用选项</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>选 项</th>
<th>功 能</th>
</tr>
</thead>
<tbody>
<tr>
<td>-D name[=definition]</td>
<td>在处理源文件之前，先定义宏 name。宏 name 必须是在源文件和头文件中都没有被定义过的。将该选项搭配源代码中的#ifdef name命令使用，可以实现条件式编译。如果没有指定一个替换的值（即省略 =definition），该宏被定义为值 1。</td>
</tr>
<tr>
<td>-U name</td>
<td>如果在命令行或 GCC 默认设置中定义过宏 name，则“取消”name 的定义。-D 和 -U 选项会依据在命令行中出现的先后顺序进行处理。</td>
</tr>
<tr>
<td>-include file</td>
<td>如同在源代码中添加 #include “file” 一样。</td>
</tr>
<tr>
<td>-iquote directory</td>
<td>对于以引号（#include “”）导入的头文件中，-iquote 指令可以指定该<strong>头文件的搜索路径</strong>。当 GCC 在源程序所在目录下找不到此头文件时，就会去 -iquote 指令指定的目录中查找。</td>
</tr>
<tr>
<td><code>-isystem dir</code> <code>-idirafter dir</code></td>
<td>都用于指定搜索头文件的目录，适用于以引号 “” 和 &lt;&gt; 导入的头文件。</td>
</tr>
</tbody>
</table>
<ul>
<li>注意：其中，对于指定 #include 搜索路径的几个选项，作用的先后顺序如下：
<ul>
<li>对于用 #include “” 引号形式引入的头文件，首先搜索当前程序文件所在的目录，其次再前往 -iquote 选项指定的目录中查找；</li>
<li>前往 -I 选项指定的目录中搜索；</li>
<li>前往 -isystem 选项指定的目录中搜索；</li>
<li>前往默认的系统路径下搜索；</li>
<li>前往 -idirafter 选项指定的目录中搜索。</li>
</ul>
</li>
</ul>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200730100839.jpg" alt="" /></p>
<h3 id="编译"><a class="markdownIt-Anchor" href="#编译"></a> 编译</h3>
<ul>
<li>编译是整个程序构建的核心部分，也是最复杂的部分之一。所谓编译，简单理解就是将预处理得到的程序代码，经过一系列的词法分析、语法分析、语义分析以及优化，加工为当前机器支持的汇编代码。</li>
<li>通过给 gcc 指令添加 -S（注意是大写）选项，即可令 GCC 编译器仅将指定文件加工至编译阶段，并生成对应的汇编代码文件。</li>
<li>编译操作会<strong>自行新建一个文件名和指定文件相同、后缀名为 .s 的文件</strong>，并将编译的结果保存在该文件中。</li>
<li>如果需要的话，我们还可以为 gcc -S 指令添加 -o 选项，令 GCC 编译器将编译结果保存在我们指定的文件中。</li>
<li>gcc -S 指令操作的文件并非必须是经过预处理后得到的 .i 文件，-S 选项的功能是令 GCC 编译器将指定文件处理至编译阶段结束。这也就意味着，gcc -S 指令可以操作预处理后的 .i 文件，也可以操作源代码文件：
<ul>
<li>如果操作对象为 .i 文件，则 GCC 编译器只需编译此文件；</li>
<li>如果操作对象为 .c 或者 .cpp 源代码文件，则 GCC 编译器会对其进行<strong>预处理和编译</strong>这 2 步操作。</li>
</ul>
</li>
</ul>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200730142545.jpg" alt="" /></p>
<h3 id="汇编"><a class="markdownIt-Anchor" href="#汇编"></a> 汇编</h3>
<ul>
<li>汇编其实就是将汇编代码转换成可以执行的机器指令。大部分汇编语句对应一条机器指令，有的汇编语句对应多条机器指令。相对于编译操作，汇编过程会简单很多，它并没有复杂的语法，也没有语义，也不需要做指令优化，只需要根据汇编语句和机器指令的对照表一一翻译即可。</li>
<li>通过为 gcc 指令添加 -c 选项（注意是小写字母 c），即可让 GCC 编译器将指定文件加工至汇编阶段，并生成相应的目标文件（文件名与指定的文件相同，只是改成了.o后缀）。</li>
<li>和 gcc -S 类似，gcc -c 选项并非只能用于加工 .s 文件。事实上，-c 选项只是令 GCC 编译器<strong>将指定文件加工至汇编阶段，但不执行链接操作</strong>。这也就意味着：
<ul>
<li>如果指定文件为<strong>源程序文件</strong>（例如 demo.c），则 gcc -c 指令会对 demo.c 文件执行预处理、编译以及汇编这 3 步操作；</li>
<li>如果指定文件为刚刚经过<strong>预处理后的文件</strong>（例如 demo.i），则 gcc -c 指令对 demo.i 文件执行编译和汇编这 2 步操作；</li>
<li>如果指定文件为刚刚经过<strong>编译后的文件</strong>（例如 demo.s），则 gcc -c 指令只对 demo.s 文件执行汇编这 1 步操作。</li>
<li>如果文件已经是.o文件,则gcc -c指令不做任何操作。</li>
</ul>
</li>
</ul>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200730143825.jpg" alt="" /></p>
<h3 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h3>
<h4 id="执行默认链接操作"><a class="markdownIt-Anchor" href="#执行默认链接操作"></a> 执行默认链接操作</h4>
<ul>
<li>gcc 会根据所给文件的后缀名 .o，自行判断出此类文件为目标文件，仅需要进行链接操作。</li>
<li>命令：<code>gcc xx.o -o xx</code>,若不指定文件名，则默认输出为a.out<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731090856.jpg" alt="" /></li>
</ul>
<h4 id="手动添加链接库"><a class="markdownIt-Anchor" href="#手动添加链接库"></a> 手动添加链接库</h4>
<h5 id="添加标准链接库目录中的库"><a class="markdownIt-Anchor" href="#添加标准链接库目录中的库"></a> 添加标准链接库目录中的库</h5>
<ul>
<li>链接器把多个二进制的目标文件（object file）链接成一个单独的可执行文件。在链接过程中，它必须把符号（变量名、函数名等一系列标识符）用对应的数据的内存地址（变量地址、函数地址等）替代，以完成程序中多个模块的外部引用。而且，链接器也必须将程序中所用到的所有C标准库函数加入其中。对于链接器而言，链接库不过是一个具有许多目标文件的集合，它们在一个文件中以方便处理。</li>
<li>标准库的大部分函数通常放在文件 libc.a 中（文件名后缀.a代表“achieve”，译为“获取”），或者放在用于共享的动态链接文件 <a target="_blank" rel="noopener" href="http://libc.so">libc.so</a> 中（文件名后缀.so代表“share object”，译为“共享对象”）。这些链接库一般位于 /lib/ 或 /usr/lib/。当使用 GCC 编译和链接程序时，GCC 默认会链接 libc.a 或者 <a target="_blank" rel="noopener" href="http://libc.so">libc.so</a>，但是对于其他的库（例如非标准库、第三方库等），就需要手动添加。</li>
<li>GCC 的-l选项（小写的 L）可以让我们手动添加链接库。基本命令格式：<code>gcc xx.c -lxx</code>,前缀lib和后缀.a是标准的，xx是基本名称，GCC 会在-l选项后<strong>紧跟着</strong>的基本名称的基础上自动添加这些前缀、后缀。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731105555.jpg" alt="" />
<ul>
<li>标准头文件 &lt;math.h&gt; 对应的数学库默认也不会被链接，如果没有手动将它添加进来，就会发生函数未定义错误。</li>
<li>数学库的文件名是 libm.a。前缀lib和后缀.a是标准的，m是基本名称，GCC 会在-l选项后紧跟着的基本名称的基础上自动添加这些前缀、后缀，本例中，基本名称为 m。math.c代码如下：</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;      &#x2F;* printf *&#x2F;
#include &lt;math.h&gt;       &#x2F;* cos *&#x2F;
#define PI 3.14159265
int main ()
&#123;
  double param, result;
  param &#x3D; 60.0;
  result &#x3D; cos ( param * PI &#x2F; 180.0 );
  printf (&quot;The cosine of %f degrees is %f.\n&quot;, param, result );
  return 0;
&#125;</code></pre>
<ul>
<li>又例如Linux的多线程程序：因为pthread的库不是linux系统的库，所以在进行编译的时候要加上-lpthread，否则编译不过。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200714212245.jpg" alt="" /></li>
</ul>
</li>
</ul>
<h5 id="添加其它目录中的库"><a class="markdownIt-Anchor" href="#添加其它目录中的库"></a> 添加其它目录中的库</h5>
<ul>
<li>通常，GCC 会自动在标准库目录中搜索文件，例如 /usr/lib，如果想链接其它目录中的库，就得特别指明。</li>
</ul>
<ol>
<li>法一：把链接库作为一般的目标文件，为 GCC 指定该链接库的完整路径与文件名。
<ul>
<li>例如，如果链接库名为 libm.a，并且位于 /usr/lib 目录，那么下面的命令会让 GCC 编译 main.c，然后将 libm.a 链接到 main.o：<code>gcc main.c -o main.out /usr/lib/libm.a</code></li>
</ul>
</li>
<li>法二：使用-L选项，为 GCC 增加另一个搜索链接库的目录
<ul>
<li><code>gcc main.c -o main.out -L/usr/lib -lm</code> -L后接目录，但还是要有-l选项。另外：可以使用多个-L选项，或者在一个-L选项内使用冒号分割的路径列表。</li>
</ul>
</li>
<li>法三：把包括所需链接库的目录加到环境变量 LIBRARYPATH 中。</li>
</ol>
<h4 id="gcc使用静态链接库和动态链接库"><a class="markdownIt-Anchor" href="#gcc使用静态链接库和动态链接库"></a> GCC使用静态链接库和动态链接库</h4>
<ul>
<li>库文件只是一个统称，代指的是一类压缩包，它们都包含有功能实用的目标文件。虽然库文件用于程序的链接阶段，但编译器提供有 2 种实现链接的方式，分别称为静态链接方式和动态链接方式，其中采用静态链接方式实现链接操作的库文件，称为静态链接库；采用动态链接方式实现链接操作的库文件，称为动态链接库。</li>
<li>GCC 编译器生成可执行文件时，默认情况下会<strong>优先使用动态链接库</strong>实现链接操作，除非当前系统环境中没有程序文件所需要的动态链接库，GCC 编译器才会选择相应的静态链接库。如果两种都没有（或者 GCC 编译器未找到），则链接失败。</li>
<li>在 Linux 发行版中，静态链接库和动态链接库通常存放在 /usr/bin 或者 /bin 目录下。</li>
</ul>
<h5 id="静态链接库"><a class="markdownIt-Anchor" href="#静态链接库"></a> 静态链接库</h5>
<ul>
<li>静态链接库实现链接操作的方式很简单，即程序文件中哪里用到了库文件中的功能模块，GCC 编译器就会将该模板代码<strong>直接复制</strong>到程序文件的适当位置，最终生成可执行文件。</li>
<li>静态链接库的优劣：
<ul>
<li>优势是，生成的可执行文件不再需要任何静态库文件的支持就可以独立运行（可移植性强）。</li>
<li>劣势是，如果程序文件中多次调用库中的同一功能模块，则该模块代码势必就会被复制多次，生成的可执行文件中会包含多段完全相同的代码，造成<strong>代码的冗余</strong>。和使用动态链接库生成的可执行文件相比，静态链接库生成的可执行文件的体积更大。</li>
</ul>
</li>
<li>静态链接库的后缀名：在 Linux 发行版系统中，静态链接库文件的后缀名通常用 .a 表示；在 Windows 系统中，静态链接库文件的后缀名为 .lib。</li>
</ul>
<h5 id="动态链接库"><a class="markdownIt-Anchor" href="#动态链接库"></a> 动态链接库</h5>
<ul>
<li>动态链接库，又称为共享链接库。和静态链接库不同，采用动态链接库实现链接操作时，程序文件中哪里需要库文件的功能模块，GCC 编译器不会直接将该功能模块的代码拷贝到文件中，而是将功能模块的<strong>位置信息</strong>记录到文件中，直接生成可执行文件。显然，这样生成的可执行文件是<strong>无法独立运行</strong>的。采用动态链接库生成的可执行文件运行时，GCC 编译器会将对应的动态链接库一同加载在内存中，由于可执行文件中事先记录了所需功能模块的位置信息，所以<strong>在现有动态链接库的支持下</strong>，也可以成功运行。</li>
<li>动态链接库的优劣：
<ul>
<li>优势是，由于可执行文件中记录的是功能模块的地址，真正的实现代码会在程序运行时被载入内存，这意味着，即便功能模块被<strong>调用多次</strong>，使用的都是同一份实现代码（这也是将动态链接库称为共享链接库的原因）。和使用静态链接库生成的可执行文件相比，动态链接库生成的可执行文件的体积更小，因为其内部不会被复制一堆冗余的代码。</li>
<li>劣势是，此方式生成的可执行文件无法独立运行，必须借助相应的库文件（可移植性差）。</li>
</ul>
</li>
<li>动态链接库的后缀名:在 Linux 发行版系统中，动态链接库的后缀名通常用 .so 表示；在 Windows 系统中，动态链接库的后缀名为 .dll(经常看见.dll文件，搞了半天原来是你）。</li>
</ul>
<h4 id="gcc创建链接库"><a class="markdownIt-Anchor" href="#gcc创建链接库"></a> GCC创建链接库</h4>
<ul>
<li>仅希望别人使用我们实现的功能，但又不想它看到具体实现的源码，就可以使用创建链接库的办法。</li>
</ul>
<h5 id="gcc创建静态链接库"><a class="markdownIt-Anchor" href="#gcc创建静态链接库"></a> GCC创建静态链接库</h5>
<ul>
<li>并非任何一个源文件都可以被加工成静态链接库，其至少需要满足以下 2 个条件：
<ul>
<li>源文件中只提供可以重复使用的代码，例如函数、设计好的类等，<strong>不能包含 main 主函数</strong>；</li>
<li>源文件在实现具备模块功能的同时，还要提供访问它的接口，也就是包含各个功能模块声明部分的<strong>头文件</strong>。</li>
</ul>
</li>
<li>将源文件打包为静态链接库的过程很简单，只需经历以下 2 个步骤:
<ol>
<li>将所有指定的源文件，都编译成相应的目标文件;</li>
<li>然后使用 ar 压缩指令，将生成的目标文件打包成静态链接库，其基本格式如下：<br />
<code>ar rcs 静态链接库名称 目标文件1 目标文件2 ...</code></li>
</ol>
</li>
<li>静态链接库命名规则：<code>libxxx.a</code>
<ul>
<li>Linux 系统下，静态链接库的后缀名为 .a；Windows 系统下，静态链接库的后缀名为 .lib。</li>
<li>其中，xxx 代指我们为该库起的名字，比如 Linux 系统自带的一些静态链接库名称为 libc.a、libgcc.a、libm.a，它们的名称分别为 c、gcc 和 m。</li>
</ul>
</li>
<li>静态链接库的使用很简单，就是在程序的链接阶段，将静态链接库和其他目标文件一起执行链接操作，从而生成可执行文件。<code>gcc -static 目标文件 链接库名</code>,其中，-static 选项强制 GCC 编译器使用静态链接库。</li>
</ul>
<h5 id="gcc创建动态链接库"><a class="markdownIt-Anchor" href="#gcc创建动态链接库"></a> GCC创建动态链接库</h5>
<ul>
<li>
<p>法一：</p>
<ul>
<li>直接使用源文件创建动态链接库，采用 gcc 命令实现的基本格式如下：<code>gcc -fpic -shared 源文件名... -o 动态链接库名</code>,其中，-shared 选项用于生成动态链接库；-fpic（还可写成 -fPIC）选项的功能是，令 GCC 编译器生成动态链接库（多个目标文件的压缩包）时，表示各目标文件中函数、类等功能模块的地址使用相对地址，而非绝对地址。这样，无论将来链接库被加载到内存的什么位置，都可以正常使用。</li>
</ul>
</li>
<li>
<p>法二：</p>
<ul>
<li>先使用 gcc -c 指令将指定源文件编译为目标文件。</li>
<li>注意，为了后续生成动态链接库并能正常使用，将源文件编译为目标文件时，也需要使用 -fpic 选项。</li>
<li>在此基础上，接下来利用上一步生成的目标文件，生成动态链接库：<code>gcc -shared 目标文件名1 目标文件名2 ... 动态链接库名</code></li>
</ul>
</li>
<li>
<p>动态链接库的使用场景就是和项目中其它源文件或目标文件一起参与链接。</p>
<ul>
<li>命令：<code>gcc 源文件名 动态链接库名</code></li>
<li>运行由动态链接库生成的可执行文件时，必须确保程序在运行时可以找到这个动态链接库。常用的解决方案有如下几种：</li>
<li>将链接库文件移动到标准库目录下（例如 /usr/lib、/usr/lib64、/lib、/lib64）；</li>
<li>在终端输入<code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:xxx</code>，其中 xxx 为动态链接库文件的绝对存储路径（此方式仅在当前终端有效，关闭终端后无效）；</li>
<li>修改~/.bashrc 或~/.bash_profile 文件，即在文件最后一行添加<code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:xxx</code>（xxx 为动态库文件的绝对存储路径）。保存之后，执行source .bashrc指令（此方式仅对当前登陆用户有效）。</li>
</ul>
</li>
</ul>
<h2 id="gcc指令一次处理多个文件"><a class="markdownIt-Anchor" href="#gcc指令一次处理多个文件"></a> gcc指令一次处理多个文件</h2>
<ul>
<li>
<p>以下这些操作都可以共用一条 gcc 指令：</p>
<ul>
<li>将多个 C（C++）源文件加工为汇编文件或者目标文件；</li>
<li>将多个 C（C++）源文件或者预处理文件加工为汇编文件或者目标文件；</li>
<li>将多个 C（C++）源文件、预处理文件或者汇编文件加工为目标文件；</li>
<li>同一项目中，不同的源文件、预处理文件、汇编文件以及目标文件，可以使用一条 gcc 指令，最终生成一个可执行文件。</li>
</ul>
</li>
<li>
<p>处理多个文件的三种方法：</p>
<ul>
<li>法一：先单独编译各个源文件，再将它们链接起来。</li>
<li>法二：同时编译多个源文件，再将它们链接起来；</li>
<li>法三：同时直接一步编译多个源文件生成一个可执行文件。</li>
</ul>
</li>
<li>
<p>进入该项目目录，用 *.c 表示所有的源文件，即执行如下指令 <code>gcc *.c -o a.out</code>可同时编译该目录下所有源文件。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/vim/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/vim/index.html" class="post-title-link" itemprop="url">vim</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-16 17:25:37" itemprop="dateCreated datePublished" datetime="2020-07-16T17:25:37+08:00">2020-07-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-09-26 21:39:56" itemprop="dateModified" datetime="2021-09-26T21:39:56+08:00">2021-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">杂技术</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="vim"><a class="markdownIt-Anchor" href="#vim"></a> vim</h1>
<h2 id="vim中的六种基本模式"><a class="markdownIt-Anchor" href="#vim中的六种基本模式"></a> vim中的六种基本模式</h2>
<hr />
<p>几乎所有的编辑器都会有插入和执行命令两种模式，并且大多数的编辑器使用了与Vim截然不同的方式：命令目录（鼠标或者键盘驱动），组合键（通常通过control键（CTRL）和alt键（ALT）组成）或者鼠标输入。Vim和vi一样，仅仅通过键盘来在这些模式之中切换。这就使得Vim可以不用进行菜单或者鼠标操作，并且最小化组合键的操作。对文字录入员或者程序员可以大大增强速度和效率。Vim具有6种基本模式和5种派生模式。</p>
<ol>
<li><strong>普通模式(Normal mode)</strong></li>
</ol>
<ul>
<li>在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是Vim启动后的默认模式。这正好和许多新用户期待的操作方式相反（大多数编辑器默认模式为插入模式）。</li>
<li>Vim强大的编辑能来自于其普通模式命令。普通模式命令往往需要一个操作符结尾。例如普通模式命令dd删除当前行，但是第一个&quot;d&quot;的后面可以跟另外的移动命令来代替第二个d，比如用移动到下一行的&quot;j&quot;键就可以删除当前行和下一行。另外还可以指定命令重复次数，2dd（重复dd两次），和dj的效果是一样的。用户学习了各种各样的文本间移动／跳转的命令和其他的普通模式的编辑命令，并且能够灵活组合使用的话，能够比那些没有模式的编辑器更加高效地进行文本编辑。</li>
<li>在普通模式中，有很多方法可以进入插入模式。比较普通的方式是按a（append／追加）键或者i（insert／插入）键。</li>
</ul>
<ol start="2">
<li><strong>插入模式(Insert mode)</strong></li>
</ol>
<ul>
<li>在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。</li>
<li>在插入模式中，可以按ESC键回到普通模式。</li>
</ul>
<ol start="3">
<li><strong>可视模式(Visual mode)</strong></li>
</ol>
<ul>
<li>这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。Vim的&quot;文本对象&quot;也能和移动命令一样用在这个模式中。</li>
</ul>
<ol start="4">
<li><strong>选择模式(Select mode)</strong></li>
</ol>
<ul>
<li>这个模式和无模式编辑器的行为比较相似（Windows标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim会用这个字符替换选择的高亮文本块，并且自动进入插入模式。</li>
</ul>
<ol start="5">
<li><strong>命令行模式(Command line mode)</strong></li>
</ol>
<ul>
<li>在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（:键），搜索（/和?键）或者过滤命令（!键）。在命令执行之后，Vim返回到命令行模式之前的模式，通常是普通模式。</li>
</ul>
<ol start="6">
<li><strong>Ex模式(Ex mode)</strong></li>
</ol>
<ul>
<li>这和命令行模式比较相似，在使用:visual命令离开Ex模式前，可以一次执行多条命令。</li>
</ul>
<h2 id="vim三种常用模式的切换"><a class="markdownIt-Anchor" href="#vim三种常用模式的切换"></a> vim三种常用模式的切换</h2>
<ul>
<li>vim启动进入普通模式，处于插入模式或命令行模式时只需要按Esc或者Ctrl+[即可进入普通模式。普通模式中按i（插入）或a（附加）键都可以进入插入模式，普通模式中按:进入命令行模式。命令行模式中输入wq回车后保存并退出vim。</li>
</ul>
<h2 id="linux终端下进入vim"><a class="markdownIt-Anchor" href="#linux终端下进入vim"></a> Linux终端下进入vim</h2>
<ul>
<li>使用vim命令进入vim界面
<ul>
<li>vim后面加上你要打开的已存在的文件名或者不存在（则作为新建文件）的文件名。</li>
<li>直接使用vim也可以打开vim编辑器，但是不会打开任何文件。（进入命令行模式后输入:e 文件路径 同样可以打开相应文件。）</li>
</ul>
</li>
</ul>
<h2 id="普通模式下光标移动"><a class="markdownIt-Anchor" href="#普通模式下光标移动"></a> 普通模式下光标移动</h2>
<ul>
<li>常用的移动光标的命令</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>操 作 说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>h</td>
<td>将光标向左移动一格</td>
</tr>
<tr>
<td>l</td>
<td>将光标向右移动一格</td>
</tr>
<tr>
<td>j</td>
<td>将光标向上移动一格</td>
</tr>
<tr>
<td>k</td>
<td>将光标向下移动一格</td>
</tr>
<tr>
<td>W或w</td>
<td>将光标移动到下一个字</td>
</tr>
<tr>
<td>e</td>
<td>将光标移动到本单词的最后一个字符。如果光标所在的位置为本单词的最后一个字符，则跳动到下一个单字的最后一个字符。标点符号如“.”、“,”或“/”等字符都会被当成一个字</td>
</tr>
<tr>
<td>b</td>
<td>将光标移动到单词的第一个字符，如果光标所在位置为本单词的第一个字符，则跳到上一个单词的第一个字符</td>
</tr>
<tr>
<td>0</td>
<td>将光标移动到该行的最前面</td>
</tr>
<tr>
<td>$</td>
<td>将光移动到该行的最后面</td>
</tr>
<tr>
<td>G</td>
<td>将光标移动到最后一行的开头</td>
</tr>
<tr>
<td>{</td>
<td>将光标移动到前面的“{”处。在C语言编程时，如果按两次就会找到函数开头“{”处，如果再次连续按两次还可以找到上一个函数的开头处(若全文没有“{”，则直接将光标移至文本开头</td>
</tr>
<tr>
<td>}</td>
<td>同“{”的使用，将光标移动到后面的“}”（若全文没有“}”，则直接将光标移至全文末尾）</td>
</tr>
<tr>
<td>Ctrl＋b</td>
<td>如果想要翻看文章的前后，可以使用Page Down和Page Up；但当这两个键不能使用时，可以使用Ctrl＋b将光标向前卷一页，相当于Page Up（方向键+shift)</td>
</tr>
<tr>
<td>Ctrl＋f</td>
<td>将光标向后卷一页，相当于Page Down</td>
</tr>
<tr>
<td>Ctrl＋u</td>
<td>将光标向前移半页</td>
</tr>
<tr>
<td>Ctrl＋d</td>
<td>将光标向后移半页</td>
</tr>
<tr>
<td>Ctrl＋e</td>
<td>将光标向下卷一行</td>
</tr>
<tr>
<td>Ctrl＋y</td>
<td>将光标向上卷一行</td>
</tr>
</tbody>
</table>
<h2 id="进入插入模式"><a class="markdownIt-Anchor" href="#进入插入模式"></a> 进入插入模式</h2>
<ul>
<li>在普通模式下使用下面的键将进入插入模式，并可以从相应的位置开始输入。</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>在当前光标处进行编辑（实际插入位置在光标之前）</td>
</tr>
<tr>
<td>I</td>
<td>在行首插入</td>
</tr>
<tr>
<td>A</td>
<td>在行末插入</td>
</tr>
<tr>
<td>a</td>
<td>在光标后插入编辑</td>
</tr>
<tr>
<td>o</td>
<td>在当前行后插入一个新行</td>
</tr>
<tr>
<td>O</td>
<td>在当前行前插入一个新行</td>
</tr>
<tr>
<td>cw</td>
<td>替换从光标所在位置后到一个单词结尾的字符</td>
</tr>
</tbody>
</table>
<h2 id="命令行模式下保存文档"><a class="markdownIt-Anchor" href="#命令行模式下保存文档"></a> 命令行模式下保存文档</h2>
<ul>
<li>从普通模式输入:进入命令行模式，输入w回车，保存文档。输入:w 文件名可以将文档另存为其他文件名或存到其它路径下</li>
</ul>
<h2 id="退出vim"><a class="markdownIt-Anchor" href="#退出vim"></a> 退出vim</h2>
<ul>
<li>命令行模式:</li>
<li>从普通模式输入:进入命令行模式，输入wq回车，保存并退出编辑。</li>
<li>以下为其它几种退出方式：</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:q!</td>
<td>强制退出，不保存</td>
</tr>
<tr>
<td>:q</td>
<td>退出</td>
</tr>
<tr>
<td>:wq!</td>
<td>强制保存并退出</td>
</tr>
<tr>
<td>:w 文件路径</td>
<td>另存为</td>
</tr>
<tr>
<td>:saveas 文件路径</td>
<td>另存为</td>
</tr>
<tr>
<td>:x</td>
<td>保存并退出</td>
</tr>
<tr>
<td>:wq</td>
<td>保存并退出</td>
</tr>
</tbody>
</table>
<ul>
<li>普通模式：<br />
普通模式下输入Shift+zz即可保存退出vim</li>
</ul>
<h2 id="普通模式下删除文本"><a class="markdownIt-Anchor" href="#普通模式下删除文本"></a> 普通模式下删除文本</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>d＋d</td>
<td>连按两次d，可将光标所在的行删除，若是连续删除，可以按住d不放</td>
</tr>
<tr>
<td>d＋w</td>
<td>删除光标所在位置的单词，若是光标在两个字之间，则删除光标后面的一个字符</td>
</tr>
<tr>
<td>n＋d＋d</td>
<td>删除包括光标所在行及向下的n行(n为数字)</td>
</tr>
<tr>
<td>n＋d＋上方向键</td>
<td>删除包括光标所在行及向上的n行</td>
</tr>
<tr>
<td>n＋d＋下方向键</td>
<td>同n＋d＋d命令</td>
</tr>
<tr>
<td>D或者d$</td>
<td>将光标所在行后所有的单词删除</td>
</tr>
<tr>
<td>x</td>
<td>将光标所在位置的字符删除</td>
</tr>
<tr>
<td>X</td>
<td>将光标所在位置前一个字符删除</td>
</tr>
<tr>
<td>n＋x</td>
<td>删除光标所在位置及其后的n个字符</td>
</tr>
<tr>
<td>n＋X</td>
<td>删除光标所在位置及其前的n个字符</td>
</tr>
</tbody>
</table>
<h2 id="vim的重复命令"><a class="markdownIt-Anchor" href="#vim的重复命令"></a> vim的重复命令</h2>
<ul>
<li>在普通模式下.(小数点)表示重复上一次的命令操作</li>
<li>例如：普通模式下输入x，删除第一个字符，输入.(小数点)会再次删除一个字符，除此之外也可以重复dd的删除操作</li>
<li>进入普通模式输入N<command>，N 表示重复后面的次数</li>
<li>在普通模式下，你还可以使用dw或者daw(delete a word)删除一个单词，所以你可以很容易的联想到dnw(n替换为相应数字) 表示删除n个单词</li>
<li>例如：输入10x，删除10个连续字符,输入3dd，将会删除3行文本。</li>
</ul>
<h2 id="普通模式下游标的快速跳转"><a class="markdownIt-Anchor" href="#普通模式下游标的快速跳转"></a> 普通模式下，游标的快速跳转</h2>
<h3 id="行间跳转"><a class="markdownIt-Anchor" href="#行间跳转"></a> 行间跳转</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>nG(n Shift+g)</td>
<td>游标移动到第 n 行(如果默认没有显示行号，请先进入命令模式，输入:set nu以显示行号)</td>
</tr>
<tr>
<td>gg</td>
<td>游标移动到到第一行</td>
</tr>
<tr>
<td>G(Shift+g)</td>
<td>到最后一行</td>
</tr>
</tbody>
</table>
<ul>
<li>小技巧：你在完成依次跳转后，可以使用 Ctrl+o 快速回到上一次(<strong>跳转前</strong>即中途用hjkl移动的不算，只是调回大跳转前的位置)光标所在位置,这个技巧很实用，比如当你在写代码时，忽然想起有个 bug，需要修改，这时候你跳过去改好了，只需要按下 Ctrl+o 就可以回到你之前的位置。</li>
</ul>
<h3 id="行内跳转"><a class="markdownIt-Anchor" href="#行内跳转"></a> 行内跳转</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>w</td>
<td>到下一个单词的开头</td>
</tr>
<tr>
<td>e</td>
<td>到当前单词的结尾</td>
</tr>
<tr>
<td>b</td>
<td>到前一个单词的开头</td>
</tr>
<tr>
<td>ge</td>
<td>到前一个单词的结尾</td>
</tr>
<tr>
<td>0或^</td>
<td>到行头</td>
</tr>
<tr>
<td>$</td>
<td>到行尾</td>
</tr>
<tr>
<td>f&lt;字母&gt;</td>
<td>向后搜索&lt;字母&gt;并跳转到第一个匹配的位置(非常实用)</td>
</tr>
<tr>
<td>F&lt;字母&gt;</td>
<td>向前搜索&lt;字母&gt;并跳转到第一个匹配的位置</td>
</tr>
<tr>
<td>t&lt;字母&gt;</td>
<td>向后搜索&lt;字母&gt;并跳转到第一个匹配位置之前的一个字母(不常用)</td>
</tr>
<tr>
<td>T&lt;字母&gt;</td>
<td>向前搜索&lt;字母&gt;并跳转到第一个匹配位置之后的一个字母(不常用)</td>
</tr>
</tbody>
</table>
<ul>
<li>注意：vim是以一些特殊字符和空格来区分单词的，比如中文的一句话在它眼里就是一个单词。</li>
<li>小技巧：使用~可以将当前光标所在的字母切换大小写，之后光标移动到下一位。</li>
</ul>
<h2 id="复制粘贴和剪切"><a class="markdownIt-Anchor" href="#复制粘贴和剪切"></a> 复制粘贴和剪切</h2>
<h3 id="复制及粘贴文本"><a class="markdownIt-Anchor" href="#复制及粘贴文本"></a> 复制及粘贴文本</h3>
<ul>
<li>普通模式中使用y复制</li>
<li>普通模式中，yy复制游标所在的整行（3yy表示复制3行）</li>
<li>普通模式中，y^ 复制至行首，或y0。不含光标所在处字符。</li>
<li>普通模式中，y$ 复制至行尾。含光标所在处字符。</li>
<li>普通模式中，yw 复制一个单词。</li>
<li>普通模式中，y2w 复制两个单词。</li>
<li>普通模式中，yG 复制至文本末。</li>
<li>普通模式中，y1G 复制至文本开头。</li>
<li>普通模式中使用 p 粘贴</li>
<li>普通模式中，p(小写)代表粘贴至光标后（下）</li>
<li>普通模式中，P(大写)代表粘贴至光标前（上）</li>
</ul>
<h3 id="剪切及粘贴文本"><a class="markdownIt-Anchor" href="#剪切及粘贴文本"></a> 剪切及粘贴文本</h3>
<ul>
<li>其实前面讲的 dd 删除命令就是剪切，你每次 dd 删除文档内容后，便可以使用p来粘贴，也这一点可以让我们实现一个很爽快的功能——交换上下行：</li>
<li>ddp ,就这么简单，即实现了快速交换光标所在行与它下面的行。</li>
</ul>
<h2 id="字符的替换和撤销undo操作"><a class="markdownIt-Anchor" href="#字符的替换和撤销undo操作"></a> 字符的替换和撤销（undo操作）</h2>
<ul>
<li>替换和Undo命令都是针对普通模式下的操作</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>r+&lt;待替换字母&gt;</td>
<td>将游标所在字母替换为指定字母</td>
</tr>
<tr>
<td>R</td>
<td>连续替换，直到按下Esc</td>
</tr>
<tr>
<td>cc</td>
<td>替换整行，即删除游标所在行，并进入插入模式</td>
</tr>
<tr>
<td>cw</td>
<td>替换一个单词，即删除一个单词，并进入插入模式</td>
</tr>
<tr>
<td>C(大写)</td>
<td>替换游标以后至行末</td>
</tr>
<tr>
<td>~</td>
<td>反转游标所在字母大小写</td>
</tr>
<tr>
<td>u{n}</td>
<td>撤销一次或n次操作</td>
</tr>
<tr>
<td>U(大写)</td>
<td>撤销当前行的所有修改</td>
</tr>
<tr>
<td>Ctrl+r</td>
<td>redo，即撤销undo的操作</td>
</tr>
</tbody>
</table>
<h2 id="快速缩进"><a class="markdownIt-Anchor" href="#快速缩进"></a> 快速缩进</h2>
<ul>
<li>普通模式下输入&gt;&gt; 整行将向右缩进（使用，用于格式化代码超爽）</li>
<li>普通模式下输入&lt;&lt; 整行向左回退</li>
<li>注： 普通模式下输入:进入命令行模式下对shiftwidth值进行设置可以控制缩进和回退的字符数</li>
<li>shiftwidth
<ul>
<li>设置的命令：<code>set shiftwidth? //查看当前shiftwidth值</code> ,<code>set shiftwidth=10 //设置新的shiftwidth值</code></li>
</ul>
</li>
</ul>
<h2 id="调整文本的位置"><a class="markdownIt-Anchor" href="#调整文本的位置"></a> 调整文本的位置</h2>
<ul>
<li>命令行模式下输入<code>:ce</code>(center)命令使本行内容居中</li>
<li>命令行模式下输入<code>:ri</code>(right)命令使本行文本靠右</li>
<li>命令行模式下输入<code>:le</code>(left)命令使本行内容靠左</li>
</ul>
<h2 id="快速查找"><a class="markdownIt-Anchor" href="#快速查找"></a> 快速查找</h2>
<ul>
<li>普通模式下输入<code>/</code>然后键入需要查找的字符串 按回车后就会进行查找。 ？ 与/ 功能相同，只不过 ？ 是向上而 / 是向下查找。 进入查找之后，输入n 和 N 可以继续查找。 n是查找下一个内容,N查找上一个内容。(下面的四个功能在vscode上好像用不了)</li>
<li>普通模式下输入<code>\*</code>寻找游标所在处的单词</li>
<li>普通模式下输入<code>\#</code>同上，但 <code>\#</code> 是向前（上）找，<code>\*</code>则是向后（下）找</li>
<li>普通模式下输入<code>g\*</code>同<code>\*</code> ，但部分符合该单词即可</li>
<li>普通模式下输入<code>g\#</code>同<code>\#</code> ，但部分符合该单词即可(以上四个查找n, N 的继续查找命令依然可以用)</li>
</ul>
<h2 id="多文件编辑"><a class="markdownIt-Anchor" href="#多文件编辑"></a> 多文件编辑</h2>
<h3 id="使用vim编辑多个文件"><a class="markdownIt-Anchor" href="#使用vim编辑多个文件"></a> 使用vim编辑多个文件</h3>
<ul>
<li>打开vim时同时打开或创建两个文件</li>
<li>例如：<code>vim 1.txt 2.txt</code></li>
<li>将默认进入1.txt文件的编辑界面</li>
<li>命令行模式下输入 <code>:n</code> 编辑 2.txt 文件，可以加 ! 即 <code>:n!</code>强制切换，之前一个文件的输入没有保存，仅仅切换到另一个文件</li>
<li>命令行模式下输入 <code>:N</code>编辑 1.txt 文件，可以加 ! 即 <code>:N!</code> 强制切换，之前文件内的输入没有保存，仅仅是切换到另一个文件</li>
</ul>
<h3 id="进入vim后打开新文件"><a class="markdownIt-Anchor" href="#进入vim后打开新文件"></a> 进入vim后打开新文件</h3>
<ul>
<li>命令行模式下输入:e 3.txt 打开新文件3.txt</li>
<li>命令行模式下输入:e# 回到前一个文件</li>
<li>命令行模式下输入:ls可以列出以前编辑过的文档</li>
<li>命令行模式下输入:b 2.txt（或者编号）可以直接进入文件2.txt编辑</li>
<li>命令行模式下输入:bd 2.txt（或者编号）可以删除以前编辑过的列表中的文件项目</li>
<li>命令行模式下输入:e! 4.txt，新打开文件4.txt，放弃正在编辑的文件(类似强制转换)</li>
<li>命令行模式下输入:f 显示正在编辑的文件名</li>
<li>命令行模式下输入:f new.txt，改变正在编辑的文件名字为new.txt</li>
</ul>
<h3 id="恢复文件"><a class="markdownIt-Anchor" href="#恢复文件"></a> 恢复文件</h3>
<p>如果因为断电等原因造成文档没有保存，可以采用恢复方式，<code>vim -r</code>进入文档后，输入<code>:ewcover &lt;filename&gt;</code>来恢复</p>
<h2 id="可视模式"><a class="markdownIt-Anchor" href="#可视模式"></a> 可视模式</h2>
<ul>
<li>在普通模式下输入 v（小写），进入字符选择模式，就可以移动光标，光标走过的地方就会选取。再次按下v后就会取消选取。</li>
<li>在普通模式下输入 Shift+v（小写），进入行选择模式，按下V之后就会把整行选取，您可以上下移动光标选更多的行，同样，再按一次 Shift+v 就可以取消选取。</li>
<li>在普通模式下输入 Ctrl+v（小写），这是区域选择模式，可以进行矩形区域选择，再按一次 Ctrl+v 取消选取。</li>
<li>在可视模式下输入 d 删除选取区域内容</li>
<li>在可视模式下输入y复制选取区域内</li>
</ul>
<h2 id="视窗操作"><a class="markdownIt-Anchor" href="#视窗操作"></a> 视窗操作</h2>
<ul>
<li>vim 可以在一个界面里打开多个窗口进行编辑，这些编辑窗口称为 vim 的视窗。</li>
<li>打开方法有很多种，例如可以使用在命令行模式下输入 <code>:new</code> 打开一个新的 vim 视窗，并进入视窗编辑一个新文件（普通模式下输入 <code>Ctrl+w</code> 也可以），除了 :new 命令，下述列举的多种方法也可以在命令模式或普通模式下打开新的视窗：
<ul>
<li>命令行模式下输入<code>:sp 1.txt</code> 打开新的<strong>水平分屏视窗</strong>来编辑1.txt</li>
<li>命令行模式下输入<code>:vsp 2.txt</code> 打开新的<strong>垂直分屏视窗</strong>来编辑2.txt</li>
<li>普通模式下<code>Ctrl+w s</code>将当前窗口分割成两个<strong>水平</strong>的窗口</li>
<li>普通模式下<code>Ctrl+w v</code> 将当前窗口分割成两个<strong>垂直</strong>的窗口</li>
<li>普通模式下<code>Ctrl+w q</code>即 <code>:q</code> 结束分割出来的视窗。如果在新视窗中有输入需要使用强制符！即<code>:q!</code></li>
<li>普通模式下<code>Ctrl+w o</code>打开一个视窗并且<strong>隐藏之前</strong>的所有视窗</li>
<li>普通模式下<code>Ctrl+w j</code> 移至下面视窗</li>
<li>普通模式下<code>Ctrl+w k</code> 移至上面视窗</li>
<li>普通模式下<code>Ctrl+w h</code> 移至左边视窗</li>
<li>普通模式下<code>Ctrl+w l</code> 移至右边视窗</li>
<li>普通模式下<code>Ctrl+w J</code> 将当前视窗移至下面</li>
<li>普通模式下<code>Ctrl+w K</code> 将当前视窗移至上面</li>
<li>普通模式下<code>Ctrl+w H</code> 将当前视窗移至左边</li>
<li>普通模式下<code>Ctrl+w L</code> 将当前视窗移至右边</li>
<li>普通模式下<code>Ctrl+w -</code> 减小视窗的高度</li>
<li>普通模式下<code>Ctrl+w +</code> 增加视窗的高度</li>
</ul>
</li>
</ul>
<h2 id="文档加密"><a class="markdownIt-Anchor" href="#文档加密"></a> 文档加密</h2>
<ul>
<li>命令：<code>vim -x &lt;filename&gt;</code></li>
<li>输入您的密码 确认密码 这样在下一次打开时，vim就会要求你输入密码</li>
</ul>
<h2 id="执行外部shell命令"><a class="markdownIt-Anchor" href="#执行外部shell命令"></a> 执行外部shell命令</h2>
<ul>
<li>在命令行模式中输入!可以执行外部的shell命令
<ul>
<li><code>:!ls</code> 用于显示当前目录的内容</li>
<li><code>:!rm FILENAME</code>用于删除名为 FILENAME 的文件</li>
<li><code>:w FILENAME</code>可将当前 VIM 中正在编辑的文件另存为 FILENAME 文件</li>
</ul>
</li>
</ul>
<h2 id="vim帮助系统"><a class="markdownIt-Anchor" href="#vim帮助系统"></a> vim帮助系统</h2>
<p>vim中的查看帮助</p>
<ul>
<li>普通模式下按<code>F1</code>打开vim自己预设的帮助文档</li>
<li>命令行模式下输入<code>:h shiftwidth</code>打开名为shiftwidth的帮助文件</li>
<li>命令行模式下输入<code>:ver</code> 显示版本及参数</li>
</ul>
<h2 id="vim功能设定"><a class="markdownIt-Anchor" href="#vim功能设定"></a> vim功能设定</h2>
<h3 id="vim的功能设定"><a class="markdownIt-Anchor" href="#vim的功能设定"></a> vim的功能设定</h3>
<ul>
<li>可以在编辑文件的时候进行功能设定，如命令行模式下输入<code>:set nu（显示行数）</code>，设定值退出vim后<strong>不会保存</strong>。要<strong>永久</strong>保存配置需要修改vim配置文件。 vim的配置文件<code>~/.vimrc</code>，可以打开文件进行修改，不过务必小心不要影响vim正常使用</li>
</ul>
<h3 id="获取目前的设定"><a class="markdownIt-Anchor" href="#获取目前的设定"></a> 获取目前的设定</h3>
<ul>
<li>命令行模式下输入<code>:set</code>或者<code>:se</code>显示所有修改过的配置</li>
<li>命令行模式下输入<code>:set all</code> 显示所有的设定值</li>
<li>命令行模式下输入<code>:set option?</code>显示option的设定值</li>
<li>命令行模式下输入<code>:set nooption</code> 取消当前设定值</li>
</ul>
<h3 id="set功能的说明"><a class="markdownIt-Anchor" href="#set功能的说明"></a> set功能的说明</h3>
<ul>
<li>命令行模式下输入<code>:set autoindent(ai)</code>设置自动缩进</li>
<li>命令行模式下输入<code>:set autowrite(aw)</code> 设置自动存档，默认未打开</li>
<li>命令行模式下输入<code>:set background=dark或light</code>，设置背景风格</li>
<li>命令行模式下输入<code>:set backup(bk)</code> 设置自动备份，默认未打开</li>
<li>命令行模式下输入<code>: set cindent(cin)</code> 设置C语言风格缩进</li>
</ul>
<h2 id="vim配置"><a class="markdownIt-Anchor" href="#vim配置"></a> vim配置</h2>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8/index.html" class="post-title-link" itemprop="url">第二章 线性表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-15 17:25:37" itemprop="dateCreated datePublished" datetime="2020-07-15T17:25:37+08:00">2020-07-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:27:52" itemprop="dateModified" datetime="2022-09-17T19:27:52+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">专业基础</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第二章-线性表"><a class="markdownIt-Anchor" href="#第二章-线性表"></a> 第二章 线性表</h1>
<h2 id="线性表的定义"><a class="markdownIt-Anchor" href="#线性表的定义"></a> 线性表的定义</h2>
<ul>
<li>线性表是一个具有<strong>相同特性</strong>的数据元素的有限序列。</li>
<li>特性：
<ul>
<li>相同特性：所有元素属于同一数据类型。</li>
<li>有限：数据元素个数是有限的。</li>
<li>序列：数据元素由逻辑序号唯一确定。一个线性表中可以有<strong>相同值</strong>的元素。</li>
<li>结构：除第一个元素无前驱、最后一个元素无后继外，其余每个元素都有<strong>唯一前驱和唯一后继元素</strong>。</li>
</ul>
</li>
<li>线性表中所含元素的个数叫做线性表的长度。</li>
<li>线性表的逻辑表示：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721183419.jpg" alt="" /></li>
</ul>
<h2 id="线性表的顺序存储结构"><a class="markdownIt-Anchor" href="#线性表的顺序存储结构"></a> 线性表的顺序存储结构</h2>
<h3 id="线性表的顺序存储结构定义"><a class="markdownIt-Anchor" href="#线性表的顺序存储结构定义"></a> 线性表的顺序存储结构定义</h3>
<ul>
<li>把线性表中元素按照顺序存储的方法存储（即存储位置为一篇连续的空间，如数组）</li>
<li>静态存储顺序表
<ul>
<li>定义：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721183915.jpg" alt="" />（意味着last是从0开始的）</li>
<li>特性：
<ul>
<li>随机存取</li>
</ul>
</li>
</ul>
</li>
<li>动态存储顺序表：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721223730.jpg" alt="" />
<ul>
<li>创建动态存储的顺序表：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721223923.jpg" alt="" />
<ul>
<li>关键在于数组的长度是根据具体情况来分配的<code>L-&gt;elem = (ElemType *)malloc(maxSize*sizeof(ElemType))</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="线性表在静态顺序存储结构上的基本运算"><a class="markdownIt-Anchor" href="#线性表在静态顺序存储结构上的基本运算"></a> 线性表在静态顺序存储结构上的基本运算</h3>
<ul>
<li>
<ol>
<li>求某个元素在顺序表中的序号<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721184701.jpg" alt="" /></li>
</ol>
<ul>
<li>因为数组中计数是从0开始，而实际生活中数数是从1开始，所以需要<code>i + 1</code></li>
<li>控制条件为找到数组的最后一个元素<code>i &lt;= L.last</code></li>
</ul>
</li>
<li>
<ol start="2">
<li>求序号为i的数据元素值</li>
</ol>
<ul>
<li>
<p>法一：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721185107.jpg" alt="" /></p>
<ul>
<li>注意控制条件，i过大或者过小都会超出数组边界，故需<code>i &lt; 1 || i &gt; L-&gt;last +1</code></li>
</ul>
</li>
<li>
<p>法二：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721185732.jpg" alt="" /></p>
</li>
<li>
<p>二者的区别在于直接返回元素的值还是通过指针传递元素的值。</p>
</li>
</ul>
</li>
<li>
<ol start="3">
<li>在顺序表的第i个位置<strong>插入</strong>数据元素 (1 &lt;= i &lt;= last + 2)<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721215615.jpg" alt="" /></li>
</ol>
<ul>
<li>控制条件：此时插入位置i的范围要比数组原来的范围增加一，因为数组整体要先增加一个位置，所以有<code>i &lt; 1 || i &gt; L-&gt;last + 2</code>.</li>
<li>关键的元素后移操作：先在数组末尾增加上一个位置，然后从后往前逐次将第i位起的元素后移，<code>for(k = L-&gt;last; k &gt;= i - 1 ; k--) L-&gt;elem[k+1] = L-&gt;elem[k];</code></li>
<li>末尾别忘了<code>last</code>的更改。</li>
<li>算法的时间复杂度：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721220637.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721220653.jpg" alt="" /></li>
</ul>
</li>
<li>
<ol start="4">
<li>顺序表<strong>删除</strong>第i个位置的元素（1 &lt; i &lt; last + 1)<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721221040.jpg" alt="" /></li>
</ol>
<ul>
<li>先将特殊的情况考虑，再做常规处理：i超出数组的范围和顺序表为空的两种情况。<code>i &lt; 1 || i &gt; L-&gt;last + 1</code>和<code>L-&gt;last &lt; 0</code>.(i = 0 不行是因为此处的i代表的是实际生活中的计数，而不是数组从零开始的计数)</li>
<li>关键的元素前移操作：从第i个元素之后的一个元素开始逐渐前移 <code>for(k = i; k &lt;= L-&gt;last; k++) L-&gt;elem[k-1] = L-&gt;elem[k];</code>，控制条件为<code>k &lt;= L -&gt;last</code>的原因是，此时的k作为数组的下标而不是实际生活中的计数，与last的意义相同了，所以不需要再做元素个数与数组下标之间+1 的转换。</li>
<li>算法的时间复杂度：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721222832.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721222948.jpg" alt="" /></li>
</ul>
</li>
</ul>
<h3 id="线性表动态顺序存储结构的算法"><a class="markdownIt-Anchor" href="#线性表动态顺序存储结构的算法"></a> 线性表动态顺序存储结构的算法</h3>
<ul>
<li>二路归并算法
<ul>
<li>将两个非递减顺序表合并为一个有序表，称为二路归并。</li>
<li>基本原理：同时遍历两个顺序表，遍历过程中比较元素的大小并存入有序表中，并根据比较结果调整两个顺序表遍历的速度。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721225112.jpg" alt="" /></li>
<li>注意：两表的同时遍历进行结束之后，还要检查是否有哪个表没有遍历完。</li>
</ul>
</li>
</ul>
<h2 id="线性表的链式存储结构"><a class="markdownIt-Anchor" href="#线性表的链式存储结构"></a> 线性表的链式存储结构</h2>
<h3 id="线性表的链式存储结构的定义"><a class="markdownIt-Anchor" href="#线性表的链式存储结构的定义"></a> 线性表的链式存储结构的定义</h3>
<ul>
<li>链式存储结构即使用链表存储。使用链表时，每个逻辑结点单独存储，为了表示逻辑关系，每个结点里增加一个指针域。</li>
<li>链表的分类：
<ul>
<li>单链表：每个物理结点里增加一个指向<strong>后继结点</strong>的指针域。
<ul>
<li>当访问过一个结点后，只能接着访问它的后继结点，而无法访问它的前驱结点。</li>
</ul>
</li>
<li>循环单链表：将表中尾结点的指针域改为指向表头结点，整个链表形成一个环。
<ul>
<li>从表中任一结点出发均可找到链表中其他结点。</li>
<li>链表中没有空指针域（最后一个结点的空指针域现在指向头结点）</li>
</ul>
</li>
<li>双向链表:  每个物理结点增加一个指向<strong>后继结点</strong>和一个指向<strong>前驱结点</strong>的指针。
<ul>
<li>从任一结点出s发可以快速找到其前驱结点和后继结点。</li>
<li>从任一结点出发可以访问其他任一结点。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="单链表"><a class="markdownIt-Anchor" href="#单链表"></a> 单链表</h3>
<h4 id="结点类型定义"><a class="markdownIt-Anchor" href="#结点类型定义"></a> 结点类型定义</h4>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200722110417.jpg" alt="" /></p>
<ul>
<li>单独创建一个 LinkList类型的目的是区分普通数据结点和头结点。</li>
</ul>
<h4 id="建表"><a class="markdownIt-Anchor" href="#建表"></a> 建表</h4>
<ul>
<li>
<p>头插法建表</p>
<ul>
<li>基本原理：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200722110741.jpg" alt="" />
<ul>
<li>读取是从前往后，但最终形成的链表顺序是原来数据排列方式的从后往前。</li>
<li>最终的表头是一个不含数据的空结点。</li>
</ul>
</li>
<li>算法：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200722111848.jpg" alt="" />
<ul>
<li>每一个结点（包括头结点）都是现场分配的内存。</li>
<li>头结点的指针域始终指向刚插入的结点（开始为NULL除外）。</li>
<li>每次插入操作需将头结点指针域赋给新结点的指针域，然后头结点指针域指向新结点。这样达到断开头结点与旧结点之间的旧链,而形成头结点与新结点之间新链的效果。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>尾插法建表：</p>
<ul>
<li>基本原理：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200722112653.jpg" alt="" />
<ul>
<li>增加一个移动的尾指针，使其一直指向链表的尾结点（开始时指向头结点）</li>
</ul>
</li>
<li>算法：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200722113210.jpg" alt="" />
<ul>
<li>先使用尾指针，使旧尾结点的指针域指向新结点，然后将尾指针指向新结点。</li>
<li>注意：最后要将尾结点的指针域设置为NULL。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="求线性表中第i个位置的数据元素"><a class="markdownIt-Anchor" href="#求线性表中第i个位置的数据元素"></a> 求线性表中第i个位置的数据元素</h4>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723094813.jpg" alt="" /></p>
<ul>
<li>设置一个移动的指针（最开始指向头结点），在计数（从0开始）的同时，移动指针。</li>
<li>在找到第i个元素之前，用循环移动指针。（注意控制条件：计数变量比i小，且不能超出链表元素数目）</li>
</ul>
<h4 id="按元素值查找"><a class="markdownIt-Anchor" href="#按元素值查找"></a> 按元素值查找</h4>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723095356.jpg" alt="" /></p>
<ul>
<li>设置一个移动的指针，从第一个有值域的结点开始查找，每一个元素和所找元素比较，若不相等，则指针向后移。</li>
</ul>
<h4 id="求带头单链表的长度"><a class="markdownIt-Anchor" href="#求带头单链表的长度"></a> 求带头单链表的长度</h4>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723095728.jpg" alt="" /></p>
<ul>
<li>设置一个移动的指针（开始指向头结点），设置一个计数变量(开始设为0表示头结点的序号为0，不算在数据结点的个数中），每移动一次指针，计数变量加一。</li>
<li>结束的控制条件：最后一个结点的指针域为NULL。</li>
</ul>
<h4 id="在链表的第i个位置插入数据元素"><a class="markdownIt-Anchor" href="#在链表的第i个位置插入数据元素"></a> 在链表的第i个位置插入数据元素</h4>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723100430.jpg" alt="" /></p>
<ul>
<li><a href="#%E6%B1%82%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B8%AD%E7%AC%ACi%E4%B8%AA%E4%BD%8D%E7%BD%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0">查找算法</a>和<a href="#%E5%BB%BA%E8%A1%A8">头插法创建链表算法</a>的结合。</li>
</ul>
<h4 id="删除链表的第i个位置的数据元素"><a class="markdownIt-Anchor" href="#删除链表的第i个位置的数据元素"></a> 删除链表的第i个位置的数据元素</h4>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723101022.jpg" alt="" /></p>
<ul>
<li>查找到第i-1个结点，利用它的指向后继结点的指针域（所以结束查找的条件是找到第i-1个元素或者当前结点的指针域为NULL），来删除第i个结点。</li>
<li>使用<code>free()</code>来删除一个结点。</li>
</ul>
<h4 id="合并两个有序链表为一个有序链表"><a class="markdownIt-Anchor" href="#合并两个有序链表为一个有序链表"></a> 合并两个有序链表为一个有序链表</h4>
<ul>
<li>
<p>占用其中一个链表来合并<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723102129.jpg" alt="" /></p>
<ul>
<li>基本原理类似<a href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E7%AE%97%E6%B3%95">二路归并算法</a></li>
<li>设置两个可移动指针，指向原来两个链表的数据元素。</li>
<li>新链表头指针指向原来某个链表的头结点，以此来占用该链表的空间。</li>
</ul>
</li>
<li>
<p>合并为一个全新的链表<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723103937.jpg" alt="" /></p>
<ul>
<li>所不同的是每一次插入都需要重新分配空间，故采用<a href="#%E5%BB%BA%E8%A1%A8">尾插法</a>重新建立一个链表。</li>
<li>最后没有遍历完的结点，需要使用循环来插入新链表中。</li>
<li>注意最后新链表尾结点的指针域要置为NULL。</li>
</ul>
</li>
</ul>
<h3 id="循环单链表"><a class="markdownIt-Anchor" href="#循环单链表"></a> 循环单链表</h3>
<ul>
<li>找到尾结点的条件变为：<code>p-&gt;next = L</code>。</li>
<li>结点类型：同单链表</li>
</ul>
<h4 id="初始化循环单链表"><a class="markdownIt-Anchor" href="#初始化循环单链表"></a> 初始化循环单链表</h4>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723222629.jpg" alt="" /></p>
<ul>
<li>形参为指向头结点指针的指针。</li>
<li>最开始时，头结点即为尾结点，故头结点的指针域指向自己。</li>
</ul>
<h4 id="创建循环单链表"><a class="markdownIt-Anchor" href="#创建循环单链表"></a> 创建循环单链表</h4>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723223045.jpg" alt="" /></p>
<ul>
<li>使用尾插法创建循环链表</li>
<li>最后要将尾结点的指针域设为头结点。</li>
</ul>
<h4 id="循环单链表的合并"><a class="markdownIt-Anchor" href="#循环单链表的合并"></a> 循环单链表的合并</h4>
<ul>
<li>
<p>传入两个循环单链表的头指针<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723223617.jpg" alt="" /></p>
<ul>
<li>找尾结点的循环：<code>while(p-&gt;next != LA) p = p-&gt;next;</code></li>
<li>第一个链表的尾结点的指针域设为第二个链表的第一个数据结点（不是头结点），第二个链表的尾结点的指针域设为第一个链表的头结点。</li>
</ul>
</li>
<li>
<p>传入两个循环单链表的尾指针<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723224057.jpg" alt="" /></p>
<ul>
<li>先找到两个链表的头结点，在修改各自尾结点的指针域。</li>
</ul>
</li>
</ul>
<h3 id="双向链表"><a class="markdownIt-Anchor" href="#双向链表"></a> 双向链表</h3>
<ul>
<li>结点类型定义<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723224256.jpg" alt="" /></li>
</ul>
<h4 id="建立双向链表"><a class="markdownIt-Anchor" href="#建立双向链表"></a> 建立双向链表</h4>
<ul>
<li>
<p>头插法建表<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200725220437.jpg" alt="" /></p>
<ul>
<li>头结点刚创立时前后驱指针域都设为空<code>(*L)-&gt;prior = (*L)-&gt;next = NULL;</code></li>
<li>新插入结点的前驱指针域设为头结点，后驱指针域设为原来头结点后原第一个数据结点。<code>s-&gt;next = (*L)-&gt;next; s-&gt;prior = *L</code></li>
<li>原第一个数据结点的前驱指针需修改为新插入结点<code>(*L)-&gt;next-&gt;prior = s;</code>,头结点的后驱指针域设为新插入结点<code>(*L)-&gt;next = s;</code></li>
<li>头插法的共性是建成的线性表是逆序的；</li>
<li>注意：传入函数的是指向头结点指针的指针，又有-&gt;的优先级高于*，所以需使用（*L）。</li>
</ul>
</li>
<li>
<p>尾插法建表<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200725221517.jpg" alt="" /></p>
<ul>
<li>设立一个可移动的尾指针，始终指向当前的尾结点；</li>
<li>最后注意将尾结点的后驱指针域设为NULL</li>
<li>相较头插法，只需修改两个结点的三个指针域，修改较少。</li>
</ul>
</li>
<li>
<p>建表的变式：逆置双向链表<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200725222226.jpg" alt="" /></p>
<ul>
<li>本质是头插法的运用;</li>
<li>需要新设两个可移动指针来扫描原来的链表。</li>
</ul>
</li>
</ul>
<h4 id="在第i个位置插入数据元素"><a class="markdownIt-Anchor" href="#在第i个位置插入数据元素"></a> 在第i个位置插入数据元素</h4>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200725222900.jpg" alt="" /></p>
<ul>
<li>本质是头插法</li>
<li>查找第i-1个结点即为尾插法</li>
</ul>
<h4 id="删除第i个结点"><a class="markdownIt-Anchor" href="#删除第i个结点"></a> 删除第i个结点</h4>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200725223227.jpg" alt="" /></p>
<ul>
<li>可以找到第i个结点，也可以找第i-1结点；</li>
<li>只需修改两个指针；</li>
</ul>
<h3 id="循环双向链表"><a class="markdownIt-Anchor" href="#循环双向链表"></a> 循环双向链表</h3>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727110328.jpg" alt="" /></p>
<ul>
<li>找到尾结点的条件变为了：<code>L-&gt;next = L</code></li>
<li>判断循环链表是否对称相等的算法<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727110858.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727111123.jpg" alt="" />
<ul>
<li>设置两个可移动指针分别从链表头尾扫描向中间</li>
<li>数据结点数目不同，扫描完是两个扫描指针的相对位置不同。为奇数时，最后两个结点指向同一个数据结点<code>p == q</code>;为偶数时，最后两个扫描指针相邻<code>p-&gt;next == q</code>或者<code>p == q-&gt;prior</code></li>
</ul>
</li>
</ul>
<h2 id="线性表的应用"><a class="markdownIt-Anchor" href="#线性表的应用"></a> 线性表的应用</h2>
<h3 id="一元多项式的运算"><a class="markdownIt-Anchor" href="#一元多项式的运算"></a> 一元多项式的运算</h3>
<ul>
<li>基本原理（一元稀疏多项式的线性表表示）<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727112250.jpg" alt="" /></li>
<li>单链表储存一元多项式的结点定义<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727112636.jpg" alt="" /></li>
<li>创建一元多项式单链表存储的算法<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727153633.jpg" alt="" />
<ul>
<li>尾插法创建</li>
<li>需要申请一个空的头结点</li>
</ul>
</li>
<li>两个一元多项式相加的算法<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727154010.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727154225.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727154452.jpg" alt="" />
<ul>
<li>默认即将要相加的两个一元多项式是按照次数从小到大排好序的。</li>
<li>从头开始遍历，将指数较小的存入新表，两个的指数相等时系数相加后存入新表。</li>
<li>采用头插法创建相加后的新表</li>
</ul>
</li>
</ul>
<h2 id="线性表经典题目"><a class="markdownIt-Anchor" href="#线性表经典题目"></a> 线性表经典题目</h2>
<h3 id="1删除顺序表中值为x的元素"><a class="markdownIt-Anchor" href="#1删除顺序表中值为x的元素"></a> 1.删除顺序表中值为x的元素</h3>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727155451.jpg" alt="" /></p>
<ul>
<li>先找到第一个值为x的元素</li>
<li>之后将其后面值不为x的元素逐个前移</li>
<li>最后修改last的值。因为在移动最后一个元素后，i还加了1，所以<code>L-&gt;last = i-1</code></li>
</ul>
<h3 id="2带头结点单链表就地逆置"><a class="markdownIt-Anchor" href="#2带头结点单链表就地逆置"></a> 2.带头结点单链表就地逆置</h3>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200730101814.jpg" alt="" /></p>
<ul>
<li>将原来链表的头结点分离出来。</li>
<li>遍历原来链表的数据结点，然后用头插法插入分离出来的头结点中，从而实现就地逆置。</li>
</ul>
<h3 id="3以第一个元素为标准将数据元素分为两边"><a class="markdownIt-Anchor" href="#3以第一个元素为标准将数据元素分为两边"></a> 3.以第一个元素为标准将数据元素分为两边</h3>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200730103614.jpg" alt="" /></p>
<ul>
<li>p1为固定指针，始终指向第一个结点，方便其它结点与第一个结点比较大小。</li>
<li>pre、p、q为一套移动指针，其中p指向当前扫描到的与第一个结点比较大小的结点,q指向当前结点的下一个结点，pre指向当前结点的前一个结点。</li>
<li>pre的作用是当需要把当前结点移走时，能够使其它两个结点能够连起来。<code>pre-&gt;next = p-&gt;next</code>。</li>
<li>q的作用一方面是使p能够持续进行扫描，另一方面使在中间结点被移走的情况下协同pre建立边上两个结点的联系。</li>
</ul>
<h3 id="4存放一个二进制数的链表"><a class="markdownIt-Anchor" href="#4存放一个二进制数的链表"></a> 4.存放一个二进制数的链表</h3>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731094419.jpg" alt="" /><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731095000.jpg" alt="" /></p>
<ul>
<li>二进制的加法关键在于找到第一个值为0的位，然后进行01的互换（怪不得计算机要用二进制，确实好操作）</li>
<li>链表实现加法有两种情况，第一种是，不需增加位数，直接01互换即可；第二种是位数需进一位，此时需要增加一个新结点。</li>
<li>q指针的作用是扫描链表;r指针的作用是指向为最后一个值域为1的结点，若没有则指向头结点；temp指针的作用是在需要新增一个结点时，指向原来的第一个数据结点，以便与新增结点建立连接。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Zestaken</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">678k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:17</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js" integrity="sha256-4mJNT2bMXxcc1GCJaxBmMPdmah5ji0Ldnd79DKd1hoM=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha256-AjM0J5XIbiB590BrznLEgZGLnOQWrt62s3BEq65Q/I0=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha256-9cmf7tcLdXpKsPi/2AWE93PbZpTp4M4tqzFk+lWomjU=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
