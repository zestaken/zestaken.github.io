<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.zestaken.top","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":true,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="吾好梦中读书~">
<meta property="og:type" content="website">
<meta property="og:title" content="ZestJourney">
<meta property="og:url" content="http://www.zestaken.top/page/4/index.html">
<meta property="og:site_name" content="ZestJourney">
<meta property="og:description" content="吾好梦中读书~">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zestaken">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://www.zestaken.top/page/4/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ZestJourney</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ZestJourney</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">乐游记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zestaken</p>
  <div class="site-description" itemprop="description">吾好梦中读书~</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">84</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">60</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/Leetcode-%E6%A0%88/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/Leetcode-%E6%A0%88/index.html" class="post-title-link" itemprop="url">Leetcode-栈</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-06 12:49:16" itemprop="dateCreated datePublished" datetime="2021-02-06T12:49:16+08:00">2021-02-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:41:21" itemprop="dateModified" datetime="2022-09-17T19:41:21+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="代码地址"><a class="markdownIt-Anchor" href="#代码地址"></a> 代码地址</h1>
<p><a target="_blank" rel="noopener" href="https://github.com/zestaken/newblog/tree/master/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/Code/src/main/java/stack">github</a></p>
<h1 id="1-删除最外层的括号-1021"><a class="markdownIt-Anchor" href="#1-删除最外层的括号-1021"></a> 1. 删除最外层的括号 1021</h1>
<ul>
<li>题目：</li>
</ul>
<hr />
<p>有效括号字符串为空 (&quot;&quot;)、&quot;(&quot; + A + “)” 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，&quot;&quot;，&quot;()&quot;，&quot;(())()&quot; 和 “(()(()))” 都是有效的括号字符串。</p>
<p>如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。</p>
<p>给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。</p>
<p>对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。</p>
<p></p>
<p>示例 1：</p>
<p>输入：&quot;(()())(())&quot;<br />
输出：&quot;()()()&quot;<br />
解释：<br />
输入字符串为 “(()())(())”，原语化分解得到 “(()())” + “(())”，<br />
删除每个部分中的最外层括号后得到 “()()” + “()” = “()()()”。<br />
示例 2：</p>
<p>输入：&quot;(()())(())(()(()))&quot;<br />
输出：&quot;()()()()(())&quot;<br />
解释：<br />
输入字符串为 “(()())(())(()(()))”，原语化分解得到 “(()())” + “(())” + “(()(()))”，<br />
删除每个部分中的最外层括号后得到 “()()” + “()” + “()(())” = “()()()()(())”。<br />
示例 3：</p>
<p>输入：&quot;()()&quot;<br />
输出：&quot;&quot;<br />
解释：<br />
输入字符串为 “()()”，原语化分解得到 “()” + “()”，<br />
删除每个部分中的最外层括号后得到 “” + “” = “”。</p>
<h2 id="java解法"><a class="markdownIt-Anchor" href="#java解法"></a> java解法</h2>
<ul>
<li>法一：
<ul>
<li>使用一个栈来压入左括号，并将最外层括号设置为<code>*</code>来表示，再设置一个StringBuilder来录入除最外层括号的括号。</li>
<li>每一次栈遇到右括号就弹出，以此来逐个匹配括号，从而判断谁为最外层的括号。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
import java.util.Stack;

public class Solution &#123;
    public String removeOuterParentheses(String S) &#123;
        Stack&lt;Character&gt; stack &#x3D; new Stack&lt;&gt;();
        StringBuilder stringBuilder &#x3D; new StringBuilder();

        &#x2F;&#x2F;遍历字符串
        for(char i : S.toCharArray()) &#123;
            &#x2F;&#x2F;如果栈不为空，则证明不是最外层的左括号，存入stringBulider
            if(i &#x3D;&#x3D; &#39;(&#39; &amp;&amp; !stack.isEmpty()) &#123;
                   stringBuilder.append(i);
                    stack.push(i);
            &#125;else if(i &#x3D;&#x3D; &#39;(&#39; &amp;&amp; stack.isEmpty()) &#123;
                stack.push(&#39;*&#39;);
            &#125; else &#123; &#x2F;&#x2F;如果为右括号，则栈中内容弹出，并根据边界记号来判断是否到边界，如果不是，则将右括号也存入stringBuilder
                char temp1 &#x3D; stack.pop();
                if(temp1 !&#x3D; &#39;*&#39;) &#123;
                    stringBuilder.append(i);
                &#125;
            &#125;
        &#125;
        return String.valueOf(stringBuilder);
    &#125;

    public static void main(String[] args) &#123;
        String s &#x3D; &quot;(()())(()(()))&quot;;
        Solution solution &#x3D; new Solution();
        System.out.println(solution.removeOuterParentheses(s));
    &#125;
&#125;</code></pre>
<ul>
<li>法二：
<ul>
<li>设置一个数字来记录括号的层数，最外层的括号的层数为1，当层数不为1时将括号存入stringBuilder对象中。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public String removeOuterParentheses(String S) &#123;
    StringBuilder stringBuilder &#x3D; new StringBuilder();
    int level &#x3D; 0;
    for(char i : S.toCharArray()) &#123;
        &#x2F;&#x2F;层数按照左括号来记录
        if(i &#x3D;&#x3D; &#39;(&#39;) &#123;
            level++;
        &#125;
        &#x2F;&#x2F;层数大于1时存入，需要放在level减1之前，否则右括号存不进去
        if(level &gt; 1) &#123;
            stringBuilder.append(i);
        &#125;
        &#x2F;&#x2F;当出现右括号时，将当前的层数减一，类似于用栈记录的出栈效果
        if(i &#x3D;&#x3D; &#39;)&#39;)&#123;
            level--;
        &#125;

    &#125;

    return String.valueOf(stringBuilder);
&#125;</code></pre>
<h1 id="2-剑指-offer-09-用两个栈实现队列"><a class="markdownIt-Anchor" href="#2-剑指-offer-09-用两个栈实现队列"></a> 2. 剑指 Offer 09. 用两个栈实现队列</h1>
<ul>
<li>题目：</li>
</ul>
<hr />
<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<p></p>
<p>示例 1：</p>
<p>输入：<br />
[“CQueue”,“appendTail”,“deleteHead”,“deleteHead”]<br />
[[],[3],[],[]]<br />
输出：[null,null,3,-1]<br />
示例 2：</p>
<p>输入：<br />
[“CQueue”,“deleteHead”,“appendTail”,“appendTail”,“deleteHead”,“deleteHead”]<br />
[[],[],[5],[2],[],[]]<br />
输出：[null,-1,null,null,5,2]<br />
提示：</p>
<p>1 &lt;= values &lt;= 10000<br />
最多会对 appendTail、deleteHead 进行 10000 次调用</p>
<ul>
<li>题目解释：</li>
</ul>
<hr />
<p>输入：</p>
<p><code>[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</code><br />
这一行表示每一行代码的操作,其CQueue方法是构造器方法，即是创建队列的操作。</p>
<p><code>[[],[3],[],[]]</code><br />
这个表示每一行代码操作所需要的参数</p>
<h2 id="java解法-2"><a class="markdownIt-Anchor" href="#java解法-2"></a> java解法</h2>
<ol>
<li>法一：
<ol>
<li>设置两个栈，每次添加数据时就向第一个栈中添加数据，每次输出数据时就先将第一个栈中的数据弹出并压入第二个栈中，再依次弹出第二个栈中的数据。</li>
</ol>
</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
package stack;

import java.util.Stack;

public class CQueue &#123;
    Stack&lt;Integer&gt; stack1;
    Stack&lt;Integer&gt; stack2;

    public CQueue()&#123;
        stack1 &#x3D; new Stack&lt;&gt;();
        stack2 &#x3D; new Stack&lt;&gt;();
    &#125;

    public void appendTail(int value) &#123;
        stack1.push(value);
    &#125;

    public int deleteHead()&#123;
        int temp;

        while(!stack1.isEmpty()) &#123;
            temp &#x3D; stack1.pop();
            stack2.push(temp);
        &#125;

        if(stack2.isEmpty()) &#123;
            return -1;
        &#125;

        int value &#x3D; stack2.pop();

        while(!stack2.isEmpty()) &#123;
            temp &#x3D; stack2.pop();
            stack1.push(temp);
        &#125;

        return value;
    &#125;

    public static void main(String[] args) &#123;
        CQueue cQueue &#x3D; new CQueue();

        cQueue.appendTail(1);
        cQueue.appendTail(2);
        cQueue.appendTail(3);

        cQueue.deleteHead();
        Stack&lt;Integer&gt; stack &#x3D; cQueue.stack1;
        while(!stack.isEmpty()) &#123;
            System.out.println(stack.pop());
        &#125;
    &#125;

&#125;</code></pre>
<h1 id="3-1047-删除字符串中的所有相邻重复项"><a class="markdownIt-Anchor" href="#3-1047-删除字符串中的所有相邻重复项"></a> 3. 1047. 删除字符串中的所有相邻重复项</h1>
<ul>
<li>题目：</li>
</ul>
<hr />
<p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p>示例：</p>
<pre class="line-numbers language-none"><code class="language-none">输入：&quot;abbaca&quot;
输出：&quot;ca&quot;
解释：
例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。</code></pre>
<p>提示：<br />
1 &lt;= S.length &lt;= 20000<br />
S 仅由小写英文字母组成。</p>
<h2 id="java解法-3"><a class="markdownIt-Anchor" href="#java解法-3"></a> java解法</h2>
<ul>
<li>法一：
<ul>
<li>设置一个栈，依次将字符串中字符压栈，栈顶内容始终是当前字符的相邻的前一个字符。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;
    public String removeDuplicates(String S) &#123;
        Stack&lt;Character&gt; stack &#x3D; new Stack&lt;&gt;();
        &#x2F;&#x2F;遍历字符串，将字符串删除重复后存入栈中
        for(char i : S.toCharArray()) &#123;
            if(stack.isEmpty()) &#123;
                stack.push(i);
                continue;
            &#125;
            char temp &#x3D; stack.pop();

            &#x2F;&#x2F;如果栈顶的内容与刚读取的字符相同，则弹出栈顶内容，并进行下一次循环；如果相同，则将新字符压入栈
            if(temp &#x3D;&#x3D; i) &#123;
                continue;
            &#125; else &#123;
                stack.push(temp);
                stack.push(i);
            &#125;
        &#125;

        StringBuilder s1 &#x3D; new StringBuilder();

        &#x2F;&#x2F;将栈中内容从头插入新字符串
        while(!stack.isEmpty()) &#123;
            char temp  &#x3D; stack.pop();
            s1.insert(0,temp);
        &#125;
        return s1.toString();
    &#125;

    public static void main(String[] args) &#123;
        String s &#x3D; &quot;abbaca&quot;;

        Solution solution &#x3D; new Solution();

        String s1 &#x3D; solution.removeDuplicates(s);

        System.out.println(s1);
    &#125;
&#125;</code></pre>
<ul>
<li>法二：
<ul>
<li>设置一个存储所有可能的重复情况的集合，然后将字符串与集合中所有内容比较，如果有相同的则替换为空字符串。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public String removeDuplicates(String S) &#123;
    HashSet&lt;String&gt; duplicates &#x3D; new HashSet&lt;&gt;();
    StringBuilder sb &#x3D; new StringBuilder();

    &#x2F;&#x2F;将重复字符串&quot;aa&quot;到&quot;zz&quot;存入集合中，使用哈希集合的原因是这种集合内部不允许内容重复
    for(char i &#x3D; &#39;a&#39;; i &lt;&#x3D; &#39;z&#39;; i++) &#123;
        sb.setLength(0);
        sb.append(i);
        sb.append(i);
        duplicates.add(sb.toString());
    &#125;

    &#x2F;&#x2F;遍历集合，与字符串内容比较，如果字符串中有相同内容则替换为空字符串
    &#x2F;&#x2F;设置一个记录字符串长度的变量，如果两次while循环之后的长度没变，说明字符串中的重复字符串已经被替换完了
    int preLength &#x3D; -1;
    while(preLength !&#x3D; S.length()) &#123;
        preLength &#x3D; S.length();
        for(String d : duplicates) &#123;
            S &#x3D; S.replace(d,&quot;&quot;);
        &#125;
    &#125;
    return S;
&#125;</code></pre>
<h1 id="4-682-棒球比赛"><a class="markdownIt-Anchor" href="#4-682-棒球比赛"></a> 4. 682. 棒球比赛</h1>
<ul>
<li>题目：</li>
</ul>
<hr />
<p>你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。</p>
<p>比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则：</p>
<p>整数 x - 表示本回合新获得分数 x<br />
“+” - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。<br />
“D” - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。<br />
“C” - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。<br />
请你返回记录中所有得分的总和。</p>
<p></p>
<p>示例 1：</p>
<p>输入：ops = [“5”,“2”,“C”,“D”,&quot;+&quot;]<br />
输出：30<br />
解释：<br />
“5” - 记录加 5 ，记录现在是 [5]<br />
“2” - 记录加 2 ，记录现在是 [5, 2]<br />
“C” - 使前一次得分的记录无效并将其移除，记录现在是 [5].<br />
“D” - 记录加 2 * 5 = 10 ，记录现在是 [5, 10].<br />
“+” - 记录加 5 + 10 = 15 ，记录现在是 [5, 10, 15].<br />
所有得分的总和 5 + 10 + 15 = 30<br />
示例 2：</p>
<p>输入：ops = [“5”,&quot;-2&quot;,“4”,“C”,“D”,“9”,&quot;+&quot;,&quot;+&quot;]<br />
输出：27<br />
解释：<br />
“5” - 记录加 5 ，记录现在是 [5]<br />
“-2” - 记录加 -2 ，记录现在是 [5, -2]<br />
“4” - 记录加 4 ，记录现在是 [5, -2, 4]<br />
“C” - 使前一次得分的记录无效并将其移除，记录现在是 [5, -2]<br />
“D” - 记录加 2 * -2 = -4 ，记录现在是 [5, -2, -4]<br />
“9” - 记录加 9 ，记录现在是 [5, -2, -4, 9]<br />
“+” - 记录加 -4 + 9 = 5 ，记录现在是 [5, -2, -4, 9, 5]<br />
“+” - 记录加 9 + 5 = 14 ，记录现在是 [5, -2, -4, 9, 5, 14]<br />
所有得分的总和 5 + -2 + -4 + 9 + 5 + 14 = 27<br />
示例 3：</p>
<p>输入：ops = [“1”]<br />
输出：1</p>
<p>提示：</p>
<p>1 &lt;= ops.length &lt;= 1000<br />
ops[i] 为 “C”、“D”、&quot;+&quot;，或者一个表示整数的字符串。整数范围是 [-3 * 104, 3 * 104]<br />
对于 “+” 操作，题目数据保证记录此操作时前面总是存在两个有效的分数<br />
对于 “C” 和 “D” 操作，题目数据保证记录此操作时前面总是存在一个有效的分数</p>
<h2 id="java解法-4"><a class="markdownIt-Anchor" href="#java解法-4"></a> java解法</h2>
<ul>
<li>法一：
<ul>
<li>依次读出字符串数组中的字符串，如果是特殊字符，则执行该字符对应的操作，如果是数字则转换为整型压入栈中,最后遍历栈计算和。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;
    public int calPoints(String[] ops) &#123;
        Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;();

        for(String op : ops) &#123;
            if(op.equals(&quot;C&quot;)) &#123;
                stack.pop();
            &#125;else if(op.equals(&quot;D&quot;)) &#123;
                stack.push(stack.peek() * 2);
            &#125;else if(op.equals(&quot;+&quot;)) &#123;
                int top &#x3D; stack.pop();
                int newTop &#x3D; top + stack.peek();
                stack.push(top);
                stack.push(newTop);
            &#125;else &#123;
                stack.push(Integer.parseInt(op));
            &#125;
        &#125;

        int sum &#x3D; 0;
        for(int point : stack) &#123;
            sum +&#x3D; point;
        &#125;
        return sum;
    &#125;

    public static void main(String[] args) &#123;
        String[] ops &#x3D; &#123;&quot;5&quot;,&quot;-2&quot;,&quot;4&quot;,&quot;C&quot;,&quot;D&quot;,&quot;9&quot;,&quot;+&quot;,&quot;+&quot;&#125;;
        Solution solution &#x3D; new Solution();
        int points &#x3D; solution.calPoints(ops);
        System.out.println(points);
    &#125;
&#125;</code></pre>
<h1 id="5-用栈实现队列-232"><a class="markdownIt-Anchor" href="#5-用栈实现队列-232"></a> 5. 用栈实现队列 232</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">题目</a></li>
</ul>
<hr />
<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p>
<p>实现 MyQueue 类：</p>
<p>void push(int x) 将元素 x 推到队列的末尾<br />
int pop() 从队列的开头移除并返回元素<br />
int peek() 返回队列开头的元素<br />
boolean empty() 如果队列为空，返回 true ；否则，返回 false</p>
<p>说明：</p>
<p>你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。<br />
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</p>
<p>进阶：</p>
<p>你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。</p>
<pre class="line-numbers language-none"><code class="language-none">示例：

输入：
[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 1, 1, false]

解释：
MyQueue myQueue &#x3D; new MyQueue();
myQueue.push(1); &#x2F;&#x2F; queue is: [1]
myQueue.push(2); &#x2F;&#x2F; queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); &#x2F;&#x2F; return 1
myQueue.pop(); &#x2F;&#x2F; return 1, queue is [2]
myQueue.empty(); &#x2F;&#x2F; return false</code></pre>
<p>提示：</p>
<p>1 &lt;= x &lt;= 9<br />
最多调用 100 次 push、pop、peek 和 empty<br />
假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）</p>
<h2 id="java解法-5"><a class="markdownIt-Anchor" href="#java解法-5"></a> Java解法</h2>
<ul>
<li>法一：用两个栈来实现队列，一个栈负责接收输入，一个栈负责pop和peek。通过在两个栈之间的倒腾，来颠倒元素的顺序，负负得正，变为先入先出
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210720215034.png" alt="" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MyQueue &#123;
    Stack&lt;Integer&gt; in;
    Stack&lt;Integer&gt; out;

    public MyQueue()&#123;
        in &#x3D; new Stack&lt;&gt;();
        out &#x3D; new Stack&lt;&gt;();
    &#125;

    public void push(int x) &#123;
        in.push(x);
    &#125;

    public int pop() &#123;
        while(!in.isEmpty()) &#123;
            int temp &#x3D; in.pop();
            out.push(temp);
        &#125;
        int res &#x3D;  out.pop();
        while(!out.isEmpty()) &#123;
            int temp &#x3D; out.pop();
            in.push(temp);
        &#125;
        return res;
    &#125;

    public int peek() &#123;
        while(!in.isEmpty()) &#123;
            int temp &#x3D; in.pop();
            out.push(temp);
        &#125;
        int res &#x3D; out.peek();
        while(!out.isEmpty()) &#123;
            int temp &#x3D; out.pop();
            in.push(temp);
        &#125;
        return res;
    &#125;

    public boolean empty() &#123;
        return in.isEmpty();
    &#125;
&#125;</code></pre>
<h1 id="6-最小栈-155"><a class="markdownIt-Anchor" href="#6-最小栈-155"></a> 6. 最小栈 155</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-stack/">题目</a></li>
</ul>
<hr />
<p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>push(x) —— 将元素 x 推入栈中。<br />
pop() —— 删除栈顶的元素。<br />
top() —— 获取栈顶元素。<br />
getMin() —— 检索栈中的最小元素。</p>
<pre class="line-numbers language-none"><code class="language-none">示例:

输入：
[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack &#x3D; new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --&gt; 返回 -3.
minStack.pop();
minStack.top();      --&gt; 返回 0.
minStack.getMin();   --&gt; 返回 -2.</code></pre>
<p>提示：</p>
<p>pop、top 和 getMin 操作总是在 非空栈 上调用。</p>
<h2 id="java解法-6"><a class="markdownIt-Anchor" href="#java解法-6"></a> Java解法</h2>
<ul>
<li>法一：使用一个辅助栈，将当前最小的元素压入栈顶，每次pop的时候检查元素是否与辅助栈的栈顶元素相同，如果相同则将辅助栈栈顶元素也弹出。因为栈先进后出的特性，所以当当前最小元素弹出后顶替上来的元素值在栈中一定还存在。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/d58FXH.png" alt="d58FXH" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MinStack155 &#123;
    Stack&lt;Integer&gt; value;
    Stack&lt;Integer&gt; min;

    public MinStack155() &#123;
        value &#x3D; new Stack&lt;&gt;();
        min &#x3D; new Stack&lt;&gt;();
    &#125;

    public void push(int val) &#123;
        &#x2F;&#x2F;若当前值比栈中存的最小值小，则存入最小值栈中
        if(min.isEmpty()) &#123;
            min.push(val);
        &#125;else if(val &lt;&#x3D; min.peek()) &#123; &#x2F;&#x2F;注意与最小值相等也要再压一次，弹出的时候才能持平
            min.push(val);
        &#125;
        value.push(val);
    &#125;

    public int pop() &#123;
        if(value.peek().equals(min.peek())) &#123;
            min.pop();
        &#125;

        return value.pop();
    &#125;

    public int top() &#123;
        return value.peek();
    &#125;

    public int getMin() &#123;
        return min.peek();
    &#125;

&#125;</code></pre>
<h1 id="7-有效的括号-20"><a class="markdownIt-Anchor" href="#7-有效的括号-20"></a> 7. 有效的括号 20</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-parentheses/">题目</a></li>
</ul>
<hr />
<p>给定一个只包括 ‘(’，’)’，’{’，’}’，’[’，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br />
左括号必须以正确的顺序闭合。</p>
<pre class="line-numbers language-none"><code class="language-none">示例 1：

输入：s &#x3D; &quot;()&quot;
输出：true
示例 2：

输入：s &#x3D; &quot;()[]&#123;&#125;&quot;
输出：true
示例 3：

输入：s &#x3D; &quot;(]&quot;
输出：false
示例 4：

输入：s &#x3D; &quot;([)]&quot;
输出：false
示例 5：

输入：s &#x3D; &quot;&#123;[]&#125;&quot;
输出：true</code></pre>
<p>提示：</p>
<p>1 &lt;= s.length &lt;= 104<br />
s 仅由括号 ‘()[]{}’ 组成</p>
<h2 id="java解法-7"><a class="markdownIt-Anchor" href="#java解法-7"></a> Java解法</h2>
<ul>
<li>法一：利用栈的先进先出特性，左括号进栈，遇右括号则出栈匹配
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/XBDlRE.png" alt="XBDlRE" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ValidParentheses20 &#123;

    public boolean isValid(String s) &#123;
        Stack&lt;Character&gt; stack &#x3D; new Stack&lt;&gt;();
        int len &#x3D; s.length();

        if(len % 2 !&#x3D; 0) &#123; &#x2F;&#x2F;括号数为奇数肯定不对
            return false;
        &#125;

        &#x2F;&#x2F;遍历括号，左括号进栈，右括号出栈比对
        int i;
        for(i &#x3D; 0; i &lt; len; i++) &#123;
            char temp &#x3D; s.charAt(i);
            if(temp &#x3D;&#x3D; &#39;(&#39; || temp &#x3D;&#x3D; &#39;[&#39; || temp &#x3D;&#x3D; &#39;&#123;&#39;) &#123;
                stack.push(temp);
            &#125; else &#123;
                char temp2;
                if(!stack.isEmpty()) &#123;
                    temp2 &#x3D; stack.pop();
                &#125; else &#123;
                    return false;
                &#125;
                if(temp2 &#x3D;&#x3D; &#39;(&#39; &amp;&amp; temp &#x3D;&#x3D; &#39;)&#39;) &#123;
                    continue;
                &#125; else if(temp2 &#x3D;&#x3D; &#39;[&#39; &amp;&amp; temp &#x3D;&#x3D; &#39;]&#39;) &#123;
                    continue;
                &#125; else if(temp2 &#x3D;&#x3D; &#39;&#123;&#39; &amp;&amp; temp &#x3D;&#x3D; &#39;&#125;&#39;) &#123;
                    continue;
                &#125; else &#123;
                    return false;
                &#125;
            &#125;
        &#125;

        &#x2F;&#x2F;最终字符串遍历完并且栈空则说明配对成功
        if(stack.isEmpty() || i &#x3D;&#x3D; len - 1) &#123;
            return true;
        &#125; else &#123;
            return false;
        &#125;
    &#125;

&#125;</code></pre>
<h1 id="8-每日温度-739"><a class="markdownIt-Anchor" href="#8-每日温度-739"></a> 8. 每日温度 739</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/daily-temperatures/">题目</a></li>
</ul>
<hr />
<p>请根据每日 气温 列表 temperatures ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<pre class="line-numbers language-none"><code class="language-none">示例 1:

输入: temperatures &#x3D; [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
示例 2:

输入: temperatures &#x3D; [30,40,50,60   ]
输出: [1,1,1,0]
示例 3:

输入: temperatures &#x3D; [30,60,90]
输出: [1,1,0]
 

提示：

1 &lt;&#x3D; temperatures.length &lt;&#x3D; 105
30 &lt;&#x3D; temperatures[i] &lt;&#x3D; 100</code></pre>
<h2 id="java解法-8"><a class="markdownIt-Anchor" href="#java解法-8"></a> Java解法</h2>
<ul>
<li>法一：单调栈的思路：用栈存储温度对应的下标，每遇到温度较高的则出栈存储，温度小的则入栈，保证栈中对应温度呈递减排列
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/l6kYqI.png" alt="l6kYqI" /></li>
<li>与<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-chunks-to-make-sorted/">最多能完成排序的块</a>类似，因为都是根据值的大小来划分位置，所以存值不重要，存位置下标才重要。此外，都利用了在关键结果出现前左右两边的值都是单纯的比关键结果小或者大的单调性。</li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DailyTemperatures739 &#123;

    public int[] dailyTemperatures(int[] temperatures) &#123;
        int len &#x3D; temperatures.length;
        &#x2F;&#x2F;存储下标的栈
        Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;();
        &#x2F;&#x2F;用来存储结果的数组
        int[] days &#x3D; new int[len];

        &#x2F;&#x2F;遍历整个温度数组
        for(int i &#x3D; 0; i &lt; len; i++) &#123;
            &#x2F;&#x2F;当栈为空，或者当前遍历到的温度不大于栈中下标对应的温度，则将对应下标压入栈中
            if(stack.isEmpty() || temperatures[i] &lt;&#x3D; temperatures[stack.peek()]) &#123;
                stack.push(i);
                continue;
            &#125;
            
            &#x2F;&#x2F;当栈不为空，或者当前温度高于栈顶下标对应的温度
            while(!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;
                &#x2F;&#x2F;当遇到比自己温度高的，出栈，将下标相减就是间隔天数
                int index &#x3D; stack.pop();
                days[index] &#x3D; i - index;
            &#125;
            stack.push(i);
        &#125;
        
        &#x2F;&#x2F;最后还留在栈中的就是没有找到之后比自己温度高的，直接赋为0
        while(!stack.isEmpty()) &#123;
            int index &#x3D; stack.pop();
            days[index] &#x3D; 0;
        &#125;

        return days;
    &#125;

&#125;</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Redis/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Redis/index.html" class="post-title-link" itemprop="url">Redis</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-30 11:09:31" itemprop="dateCreated datePublished" datetime="2021-01-30T11:09:31+08:00">2021-01-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-09-26 21:39:41" itemprop="dateModified" datetime="2021-09-26T21:39:41+08:00">2021-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web后端</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="redis概念"><a class="markdownIt-Anchor" href="#redis概念"></a> Redis概念</h1>
<ul>
<li>redis是一款高性能的NOSQL系列的非关系型数据库。
<ul>
<li>Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</li>
<li>Redis支持的键值数据类型：
<ol>
<li>String:字符串类型;</li>
<li>hash:哈希类型;</li>
<li>list：列表类型;</li>
<li>set：集合类型;</li>
<li>sortedset:有序集合类型。</li>
</ol>
</li>
<li>Redis的应用场景：
<ol>
<li>数据缓存（数据查询，短链接，新闻内容，商品内容等）</li>
<li>聊天室的在线好友列表;</li>
<li>任务队列（秒杀，抢购，12306的高并发等）</li>
<li>应用排行榜;</li>
<li>数据过期处理;</li>
<li>分布式集群架构中的session分离</li>
</ol>
</li>
</ul>
</li>
<li>NOSQL:Not Only SQL ,泛指非关系型数据库。
<ul>
<li>为了应对大规模数据的挑战。</li>
</ul>
</li>
<li>关系型数据库：
<ul>
<li>数据之间有关联关系。</li>
<li>数据存储在硬盘的文件中。</li>
<li>数据以表的形式存储。</li>
</ul>
</li>
<li>非关系型数据库，
<ul>
<li>数据之间没有关系;</li>
<li>数据存储在内存中;</li>
<li>存储格式有key:value形式，文档形式，图片形式等。</li>
</ul>
</li>
<li>主流NOSQL产品：
<ul>
<li>键值（key:value)数据库：
<ul>
<li>Tokyo Cabinet/Tyrant， Redis， Voldemort， Oracle BDB</li>
<li>应用场景：内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。</li>
<li>数据模型：Key 指向 Value 的键值对，通常用hashtable来实现</li>
</ul>
</li>
<li>列存储数据库：
<ul>
<li>Cassandra， HBase， Riak</li>
<li>应用场景：分布式的文件系统</li>
<li>数据模型：以列簇式存储，将同一列数据存在一起</li>
</ul>
</li>
<li>文档型数据库：
<ul>
<li>CouchDB， MongoDb</li>
<li>应用场景：Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容）</li>
<li>数据模型：Key-Value对应的键值对，Value为结构化数据</li>
</ul>
</li>
<li>图形(Graph)数据库：
<ul>
<li>Neo4J， InfoGrid， Infinite Graph</li>
<li>应用场景：社交网络，推荐系统等。专注于构建关系图谱</li>
<li>数据模型：图结构。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="redis的安装"><a class="markdownIt-Anchor" href="#redis的安装"></a> Redis的安装</h1>
<ul>
<li>下载：<a target="_blank" rel="noopener" href="https://redis.io">官网</a>,<a target="_blank" rel="noopener" href="https://www.redis.net.cn">中文网</a></li>
<li>为linux系统下载的<code>.tar.gz</code>文件，通过<code>tar -xzf</code>命令解压缩;</li>
<li>进入解压缩文件目录下，执行<code>make</code>编译该文件</li>
<li>二进制文件保存在src目录下：
<ul>
<li><code>src/redis-cli</code>是客户端的启动文件;</li>
<li><code>src/redis-serve</code>是服务端的启动文件。</li>
</ul>
</li>
<li><code>redis.conf</code>是redis的配置文件。</li>
</ul>
<h1 id="redis的数据结构"><a class="markdownIt-Anchor" href="#redis的数据结构"></a> Redis的数据结构</h1>
<ul>
<li>redis存储的都是key:value格式的数据，其中<strong>key都是字符串类型</strong>,而value有五种数据结构。</li>
<li>value的五种数据结构：
<ol>
<li>String:字符串类型, 如：zhangjie</li>
<li>hash:哈希类型,还是键值对，理解为套娃。如：name zhangjie</li>
<li>list：列表类型,理解为双向队列，如：zhangsan lisi wangwu zhangsan</li>
<li>set：集合类型,与list类似，只是<strong>不允许重复元素</strong></li>
<li>sortedset:有序集合类型,在set的基础上，对集合中的元素进行排序。</li>
</ol>
</li>
</ul>
<h1 id="redis的命令操作"><a class="markdownIt-Anchor" href="#redis的命令操作"></a> Redis的命令操作</h1>
<p><a target="_blank" rel="noopener" href="https://www.redis.net.cn/tutorial/3501.html">官方文档</a></p>
<ul>
<li>字符串类型：
<ul>
<li>存储：<code>set key value</code>,如：<code>set username zhangjie</code></li>
<li>获取：<code>get key</code>,如：<code>get username</code></li>
<li>删除：<code>del key</code>,如: <code>del username</code></li>
</ul>
</li>
<li>哈希类型：
<ul>
<li>存储:<code>hset key field value</code>,如：<code>hset usernames username1 zhangjie</code></li>
<li>获取:<code>hget key field</code>,如：<code>hget usernames username1</code></li>
<li>获取所有的field和value：<code>hgetall key</code>,如：<code>hgetall usernames</code></li>
<li>删除：<code>hdel key field</code>,如：<code>hdel usernames username1</code></li>
</ul>
</li>
<li>列表类型：
<ul>
<li>可以添加一个元素到列表的头部或者尾部</li>
<li>存储：
<ul>
<li><code>lpush key value</code>:将元素加入列表左边,如：<code>lpush usernames zhangjie</code></li>
<li><code>rpush key value</code>:将元素加入列表右边</li>
</ul>
</li>
<li>获取：
<ul>
<li><code>lrange key start end</code>:获取指定范围内的元素，如：<code>lrange usernames 0 -1</code>，代表获取列表中的所有元素。</li>
</ul>
</li>
<li>删除：
<ul>
<li><code>lpop key</code>:代表删除列表最左边的元素，并将该元素返回，如:<code>lpop usernames</code></li>
<li><code>rpop key</code>:代表删除列表最右边的元素，并将该元素返回。</li>
</ul>
</li>
</ul>
</li>
<li>集合类型：不允许重复元素
<ul>
<li>存储：<code>sadd key value</code>,如：<code>sadd key a</code>,还可以一次存入多个元素，如：<code>sadd key b c</code></li>
<li>获取：<code>smembers key</code>，获取set集合中的所有元素，但是<strong>不保证和存入的顺序一样</strong>。如：<code>smembers key</code></li>
<li>删除：<code>srem key value</code>,删除集合中的某个元素，如：<code>srem key a</code></li>
</ul>
</li>
<li>有序集合类型：不允许重复元素，且元素有顺序
<ul>
<li>存储：<code>zadd key score value</code>,其中score是value对应的分数，用来作为排序的依据（score小的元素在前），如：<code>zadd key 80 zhangjie</code></li>
<li>获取：
<ul>
<li><code>zrange key start end</code>,获取指定范围内的元素，如：<code>zrange key 0 -1</code>,获取集合中所有的元素。</li>
<li><code>zrange key start end withscores</code>，或获取指定范围内的元素以及对应的socre。</li>
</ul>
</li>
<li>删除：<code>zrem key value</code></li>
</ul>
</li>
<li>通用的命令：
<ul>
<li><code>keys *</code>:获取所有的键（<code>*</code>的位置可以换为正则表达式，获取符合指定规则的键）</li>
<li><code>type key</code>:获取指定键对应的value的类型;</li>
<li><code>del key</code>:删除指定的key value（不止适用于String类型，也适用于所有类型，直接删除指定键）</li>
</ul>
</li>
</ul>
<h1 id="持久化"><a class="markdownIt-Anchor" href="#持久化"></a> 持久化</h1>
<ul>
<li>Redis的持久化：将Redis内存中的文件存储到硬盘文件中去。</li>
<li>Redis持久化的两种机制：
<ul>
<li>RDB：默认方式，不需要配置，默认使用这种方式。
<ul>
<li>在一定的间隔时间中，检测key的变化情况，然后持久化数据。</li>
<li>linux操作系统的关于RDB的配置在<code>redis.conf</code>文件中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-conf" data-language="conf"><code class="language-conf"># after 900 sec(15 min) if at least 1 key changed
save 900 1
# after 300 sec(5 min) if at least 10 key changed
save 300 10
# after 60 sec(1 min) if at least 10000 key changed
save 60 10000</code></pre>
<ul>
<li>AOF：日志记录的方式，可以记录每一条命令的操作。可以在每一条命令操作后，持久化数据
<ul>
<li>编辑<code>redis.conf</code>文件</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-conf" data-language="conf"><code class="language-conf"># no是指AOF方式关闭，yes是打开
appendonly no
# appendfsync always：每一次操作都进行持久化，如果需要启动则取消注释
appendfsync everysec #每隔一秒进行一次持久化操作
# appendfsync no：不进行持久化操作</code></pre>
<h1 id="java客户端-jedis"><a class="markdownIt-Anchor" href="#java客户端-jedis"></a> Java客户端-Jedis</h1>
<ul>
<li>Jedis:一款Java操作Redis数据库的工具</li>
<li>使用步骤：
<ol>
<li>下载并导入相关jar包到工程中：
<ol>
<li><a target="_blank" rel="noopener" href="https://commons.apache.org/proper/commons-pool/download_pool.cgi">common-pool2</a></li>
<li><a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/redis.clients/jedis?__cf_chl_captcha_tk__=d41db408314d60fb331623deabd9a15fe36abc20-1612082289-0-AVlmsRyd0pFMVLysGHAjfOhsUPRBHl6zROFnuHmysV6K7TigdSA1uvSeNmDDWTGalFggBbwRBai91Temzk2O6Jrst1jxpXIFZQib8pQTTtT6QmgsW0hE7HLfbz22RleXBOGwJrTEIHP5OipDQnpaYmvWNWosSJ8HkrWh5MPyB8ypP3Kp9zRONNgpzqY2jeTrRSixucDR7JbxJsCYeu7iRe0z2aC2TCcDS8nYy3XWJbjwVbAu8CedWeWxBWjra0azGe-L1K8uLq7W9SeT-pZbA6d8pbTcj4qsm7WKSZH94RvWgh_UfDzCD9RPOKGrq7taDoO9hM2jk12X7v1jqTkPoTCd8x0Me0tdHsGCSOGtKe_6Fub13BJBQS1xWXIeQT95yjdgRs_eXdUom5d7MIrErcKAuGTJkdGnzJG--LIjrhdKrlvioSKGg4UvToUYkV1Oc1SmjoicGh1vitlE8OT6p5m_Jbu2Bc9zybE7IfgRoBGuPZeZWS3oqJlEKJeM6D6TMWOM09WLhdgZkurzOzKDnwUN1CYnciZFlyoDrvzkHfkVdZl-Z0vhWM42cOWIANBLtpPKOnMFoWfH56jIJGGjrUF7VOee4isrl3_fFwg7zPsDcggPgIlwGrxV-VKXy_6oCQ">Jedis</a></li>
</ol>
</li>
<li>获取数据库连接：</li>
</ol>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Jedis jedis &#x3D; new Jedis(&quot;localhost&quot;,6379);
&#x2F;&#x2F;localhost是主机ip地址，因为是本机，所以直接用localhost
&#x2F;&#x2F;6379是Redis的端口号，Redis服务器启动时会显示端口号，默认是6379
&#x2F;&#x2F;如果空参则默认是localhost和6379参数</code></pre>
<ol start="3">
<li>操作数据库,如：<code>jedis.set(&quot;username&quot;,&quot;zhanjie&quot;);</code>,与命令行操作基本类似</li>
<li>关闭连接：<code>jedis.close();</code></li>
</ol>
<h1 id="jedis连接池"><a class="markdownIt-Anchor" href="#jedis连接池"></a> Jedis连接池</h1>
<ol>
<li>创建Jedis连接池对象：<code>JedisPool jedisPool = new JedisPool();</code></li>
<li>获取Jedis对象：<code>Jedis jedis = jedisPool.getResource();</code></li>
<li>使用Jedis对象：，如：<code>jedis.set(&quot;username&quot;,&quot;zhangjie&quot;);</code></li>
<li>关闭对象，归还到连接池中：<code>jedis.close();</code></li>
</ol>
<ul>
<li>JedisPoolConfig对象，可以作为参数传给JedisPool构造器，配置连接池。如：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">JedisPoolConfig config &#x3D; new JedisPoolConfig();
config.setMaxTotal(50);
config.setMaxIdel(10);

JedisPool jedisPool &#x3D; new JedisPool(config,&quot;localhost&quot;,6379);</code></pre>
<ul>
<li>可以类似JDBC写Jedis连接池的工具类，来简化代码的书写。</li>
<li>注：使用Jedis的连接池还需要额外导入两个包：</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;slf4j-log4j12&lt;&#x2F;artifactId&gt;
    &lt;version&gt;1.7.9&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;slf4j-api&lt;&#x2F;artifactId&gt;
    &lt;version&gt;1.7.22&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/JSON/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/JSON/index.html" class="post-title-link" itemprop="url">JSON</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-25 21:47:27" itemprop="dateCreated datePublished" datetime="2021-01-25T21:47:27+08:00">2021-01-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-09-26 21:38:56" itemprop="dateModified" datetime="2021-09-26T21:38:56+08:00">2021-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web后端</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="json概述"><a class="markdownIt-Anchor" href="#json概述"></a> JSON概述</h1>
<ul>
<li>JSON：JavaScript 对象表示法（JavaScript Object Notation）。</li>
<li>采用完全独立于编程语言的文本格式来存储和表示数据。</li>
<li>JSON是存储和交换文本信息的语法。类似XML。用于数据的传输。</li>
<li>JSON比XML更小、更快，更易解析。</li>
</ul>
<h1 id="json基本规则"><a class="markdownIt-Anchor" href="#json基本规则"></a> JSON基本规则</h1>
<ul>
<li>数据在（名称:值）对中：json数据是由==键值对==构成的。
<ul>
<li><strong>键</strong>：用==引号（单双都行）引起来，也可以不使用引号==；</li>
<li>值的取值类型：
<ol>
<li>数字（整数或者浮点数）,不用加引号</li>
<li>字符串（在双引号中）</li>
<li>逻辑值（true或者false）</li>
<li>数组（在方括号中），如：<code>&#123;&quot;person&quot;:[&#123;name : &quot;zhangsan&quot;&#125;,&#123;name:&quot;lisi&quot;&#125;]&#125;</code></li>
<li>对象（在花括号中），如：<code>&#123;&quot;address&quot;:&#123;&quot;province&quot;:&quot;陕西&quot;,&quot;四川&quot;&#125;&#125;</code></li>
<li>null</li>
</ol>
</li>
<li>数据由逗号分隔：多个键值对<strong>由逗号</strong>分隔；</li>
<li>花括号保存对象：使用{}定义json格式；</li>
<li>方括号保存数组:<code>[]</code></li>
<li>示例：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F;基本定义格式
var person &#x3D; &#123;&quot;name&quot;:&quot;zhangjie&quot;,&quot;age&quot;:19, &quot;gender&quot; : true&#125;;

&#x2F;&#x2F;对象中嵌套数组
var persons &#x3D; &#123;
    &quot;person&quot;:[
        &#123;&quot;name&quot;:&quot;zhangjie&quot;,&quot;age&quot;:23,&quot;gender&quot;:true&#125;,
        &#123;&quot;name&quot;:&quot;lisi&quot;, &quot;age&quot;:24,&quot;gender&quot;:true&#125;,
        &#123;&quot;name&quot;:&quot;wangwu&quot;,&quot;age&quot;:25,&quot;gender&quot;:false&#125;
    ]
&#125;;

&#x2F;&#x2F;数组中嵌套对象
var ps &#x3D; [
        &#123;&quot;name&quot;:&quot;zhangjie&quot;,&quot;age&quot;:23,&quot;gender&quot;:true&#125;,
        &#123;&quot;name&quot;:&quot;lisi&quot;, &quot;age&quot;:24,&quot;gender&quot;:true&#125;,
        &#123;&quot;name&quot;:&quot;wangwu&quot;,&quot;age&quot;:25,&quot;gender&quot;:false&#125;
    ];</code></pre>
<h1 id="获取数据"><a class="markdownIt-Anchor" href="#获取数据"></a> 获取数据</h1>
<ol>
<li><code>json对象.键名；</code></li>
<li><code>json对象[&quot;键名&quot;]</code></li>
<li>遍历json对象：使用for…in循环</li>
</ol>
<ul>
<li>示例：</li>
</ul>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">person.name ;
person[&quot;name&quot;];
for(var key in person) &#123;
    &#x2F;&#x2F;获取到的key是一个字符串
    alert(person[key]);&#x2F;&#x2F;key原本就是字符串，不用引号包裹
&#125;</code></pre>
<h1 id="json数据与javascript对象的相互转化"><a class="markdownIt-Anchor" href="#json数据与javascript对象的相互转化"></a> JSON数据与JavaScript对象的相互转化</h1>
<ul>
<li>JavaScript转换为JSON数据（就是有特殊格式的字符串）：</li>
</ul>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var user &#x3D; &#123;
  name : &quot;zhangjie&quot;,
  age: 20,
  sex: &quot;男&quot;
&#125;;

var json &#x3D; JSON.stringify(user);</code></pre>
<ul>
<li>将JSON数据转换为JavaScript对象：</li>
</ul>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var jsObj &#x3D; JSON.parse(json);</code></pre>
<h1 id="json数据与java对象的相互转换"><a class="markdownIt-Anchor" href="#json数据与java对象的相互转换"></a> JSON数据与java对象的相互转换</h1>
<ul>
<li>JSON的解析器：用于转换json的工具类
<ul>
<li>常见解析器：Jsonlib,Gson,fastJson,jackson</li>
</ul>
</li>
</ul>
<h2 id="java对象转换json"><a class="markdownIt-Anchor" href="#java对象转换json"></a> Java对象转换JSON</h2>
<ul>
<li>此处使用Jackson</li>
<li>使用步骤：
<ol>
<li>导入jackson的相关jar包；</li>
<li>创建jackson的核心类对象：ObjectMapper;</li>
<li>调用ObjectMapper的相关方法进行转换
<ol>
<li><code>writeValue(参数1，obj)</code>:
<ol>
<li>参数1:
<ol>
<li><code>File</code>：将obj对象转换为<strong>JSON字符串</strong>,并保存到指定的<strong>文件</strong>中；</li>
<li><code>Writer</code>:将obj对象转换为JSON字符串，并将json数据填充到<strong>字符输出流</strong>中；</li>
<li><code>OutputStream</code>:将obj对象转换为JSON字符串，并将json数据填充到<strong>字节输出流</strong>中。</li>
</ol>
</li>
<li>writeValueAsString(obj):将对象转为JSON字符串</li>
</ol>
</li>
<li>示例：</li>
</ol>
</li>
</ol>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">ObjectMapper mapper &#x3D; new ObjectMapper();

String json &#x3D; mapper.writeValueAsString(person);

mapper.writeValue(new File(&quot;c:&#x2F;person.txt&quot;));</code></pre>
<ul>
<li>注解：
<ul>
<li><code>@JsonIgnore</code>:排除指定属性，不参与转换。将注解放在对应属性定义位置即可。</li>
<li><code>@JsonFormat</code>:将属性值转换为格式化字符串。
<ul>
<li>如；<code>@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)</code></li>
</ul>
</li>
</ul>
</li>
<li>List集合转换为JSON是数组格式的，在这个数组中存放JSON对象;</li>
<li>Map集合转换为JSON，是一个集合对应一个JSON对象，中间的内容是键值对。</li>
</ul>
<h2 id="json对象转为java对象"><a class="markdownIt-Anchor" href="#json对象转为java对象"></a> JSON对象转为Java对象</h2>
<ul>
<li>此处使用Jackson</li>
<li>使用步骤：
<ol>
<li>导入jackson的相关jar包；</li>
<li>创建jackson的核心类对象：ObjectMapper;</li>
<li>调用ObjectMapper的相关方法进行转换
<ol>
<li><code>readValue(json字符串对象,Class)</code>，如：<code>Person person = mapper.readValue(jsonString,Person.class)</code>.</li>
</ol>
</li>
</ol>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%89%8D%E7%AB%AF/AJAX/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%89%8D%E7%AB%AF/AJAX/index.html" class="post-title-link" itemprop="url">AJAX</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-25 08:02:19" itemprop="dateCreated datePublished" datetime="2021-01-25T08:02:19+08:00">2021-01-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-09-26 21:37:55" itemprop="dateModified" datetime="2021-09-26T21:37:55+08:00">2021-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web前端</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ajax概述"><a class="markdownIt-Anchor" href="#ajax概述"></a> AJAX概述</h1>
<ul>
<li>概念：ASynchronous JavaScript And XML,异步的JavaScript和XML</li>
<li>异步和同步：
<ul>
<li>异步：客户端向服务器端发送请求后，<strong>无需等待服务器端的响应</strong>。在服务器处理请求的过程中，客户端可以进行其他操作。</li>
<li>同步：客户端向服务器端发送请求后，<strong>必须等待服务器端的响应</strong>。在等待的期间，客户端不能做其他操作。</li>
</ul>
</li>
<li>作用：
<ul>
<li>Ajax是一种在无需加载整个网页的情况下，能够<strong>更新部分网页</strong>的技术。</li>
<li>通过在后台与服务器进行的少量数据交换，Ajax可以使网页实现异步更新，即可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用Ajax)如果需要更新内容，必须重载整个页面。</li>
</ul>
</li>
</ul>
<h1 id="ajax的实现方式"><a class="markdownIt-Anchor" href="#ajax的实现方式"></a> AJAX的实现方式</h1>
<ol>
<li>原生的JS实现方式</li>
<li>JQuery实现方式</li>
</ol>
<h2 id="原生的js实现方式"><a class="markdownIt-Anchor" href="#原生的js实现方式"></a> 原生的JS实现方式</h2>
<ol>
<li>定义一个用于异步请求的方法：
<ol>
<li><code>&lt;input type=&quot;button&quot; value=&quot;发送异步请求&quot; onclick=&quot;fun();&quot;&gt;</code></li>
</ol>
</li>
<li>创建发送异步请求的对象：</li>
</ol>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var xmlhttp;
if (window.XMLHttpRequest)
  &#123;&#x2F;&#x2F; code for IE7+, Firefox, Chrome, Opera, Safari
  xmlhttp&#x3D;new XMLHttpRequest();
  &#125;
else
  &#123;&#x2F;&#x2F; code for IE6, IE5
  xmlhttp&#x3D;new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</code></pre>
<ol start="3">
<li>建立连接：
<ol>
<li><code>xmlhttp.open(&quot;GET&quot;,&quot;test1.txt&quot;,true)</code>，参数：
<ol>
<li>请求方式：GET，POST
<ol>
<li>GET方式：请求参数在URL后面拼接，send方法为空参,如：<code>xmlhttp.open(&quot;GET&quot;,&quot;ajaxServlet?username=zhangjie&quot;,true)</code></li>
<li>POST方式：请求参数在send方法中定义，如：<code>xmlhttp.send(&quot;username=zhangjie&quot;)</code></li>
</ol>
</li>
<li>请求的URL:文件在服务器上的位置</li>
<li>同步或者异步请求：true（异步）或者false（同步）</li>
</ol>
</li>
</ol>
</li>
<li>发送请求：
<ol>
<li><code>xmlhttp.send(string)</code>:string参数仅用于POST请求。</li>
</ol>
</li>
<li>接受并处理来在服务器的响应结果：
<ol>
<li>获取方式：<code>xmlhttp.responseText</code>或者<code>xmlhttp.responseXML</code>
<ol>
<li>responseText属性：获得字符串形式的响应数据。</li>
<li>responseXML属性：获得XML形式的响应数据。</li>
</ol>
</li>
<li>获取时间：当XMLHttpTRequest对象的就绪状态(readyState属性)改变时，触发事件onreadystatechange</li>
</ol>
<ul>
<li>onreadystatechange	存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。</li>
<li>readyState:存有XMLHttpRequest 的状态。从 0 到 4 发生变化。
<ul>
<li>0: 请求未初始化</li>
<li>1: 服务器连接已建立</li>
<li>2: 请求已接收</li>
<li>3: 请求处理中</li>
<li>4: 请求已完成，且响应已就绪</li>
</ul>
</li>
<li>status:XMLHttpState对象的状态</li>
<li>200: “OK”</li>
<li>404: 未找到页面</li>
</ul>
<ol start="3">
<li>获取实现：</li>
</ol>
</li>
</ol>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">xmlhttp.onreadystatechange&#x3D;function()
  &#123;
      &#x2F;&#x2F;判断readyState的状态是否为4,判断status响应状态码是否为200
  if (xmlhttp.readyState&#x3D;&#x3D;4 &amp;&amp; xmlhttp.status&#x3D;&#x3D;200)
    &#123;
        &#x2F;&#x2F;获取服务器的响应结果
    document.getElementById(&quot;myDiv&quot;).innerHTML&#x3D;xmlhttp.responseText;
    &#125;
  &#125;</code></pre>
<h2 id="jquery实现方式"><a class="markdownIt-Anchor" href="#jquery实现方式"></a> JQuery实现方式</h2>
<ol>
<li><code>$.ajax()</code>:
<ol>
<li>语法：<code>$.ajax(&#123;键值对&#125;);</code></li>
<li>示例：</li>
</ol>
</li>
</ol>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$.ajax(&#123;
    url:&quot;ajaxServlet&quot;, &#x2F;&#x2F;请求路径
    type:&quot;POST&quot;, &#x2F;&#x2F;请求方式
    data:(&quot;username&quot;:&quot;jack&quot;,&quot;age&quot;:23),
    success:function(data)&#123;
        alert(data+&quot;成功啦&quot;);
    &#125;, &#x2F;&#x2F;响应成功后的回调函数
    error:function() &#123;
        alert(&quot;出错啦&quot;);
    &#125;, &#x2F;&#x2F;表示如果请求响应如果出现错误，会执行的回调函数

    dataType:&quot;text&quot; &#x2F;&#x2F;设置接受到的响应数据格式
&#125;)</code></pre>
<ol start="2">
<li><code>$.get()</code>:发送get请求
<ol>
<li>语法：<code>$.get(url,[data], [callbacke],[type])</code>
<ol>
<li>url:请求路径，必须有;</li>
<li>data:请求参数;</li>
<li>callback:回调函数;</li>
<li>type:响应结果类型。</li>
</ol>
</li>
</ol>
</li>
<li><code>$.post()</code>:发送post请求
<ol>
<li>语法：同get类似。</li>
<li>示例：</li>
</ol>
</li>
</ol>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$.post(&quot;ajaxServlet&quot;,(username:&quot;zhangjie&quot;), function(data)&#123;
    alert(data);
&#125;,&quot;text&quot;);</code></pre>
<ul>
<li><code>serialize()</code>:通过序列化<strong>表单</strong>值，创建URL编码文本字符串。您可以选择一个或多个表单元素（比如input及/或文本框），或者 form 元素本身。序列化的值可在生成 AJAX 请求时用于 URL 查询字符串中(即作为data参数）。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%89%8D%E7%AB%AF/JQuery/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%89%8D%E7%AB%AF/JQuery/index.html" class="post-title-link" itemprop="url">JQuery</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-21 17:35:45" itemprop="dateCreated datePublished" datetime="2021-01-21T17:35:45+08:00">2021-01-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-09-26 21:36:27" itemprop="dateModified" datetime="2021-09-26T21:36:27+08:00">2021-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web前端</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="jquery概念"><a class="markdownIt-Anchor" href="#jquery概念"></a> JQuery概念</h1>
<p><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jquery/index.asp">参考文档</a></p>
<ul>
<li>jQuery是一个快速、简洁的<strong>JavaScript框架</strong>，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化<strong>HTML文档操作、事件处理、动画设计和Ajax交互</strong>。</li>
<li>JavaScript框架：本质上就是一些<strong>js文件</strong>，这些文件中封装了js的原生代码。</li>
</ul>
<h1 id="快速入门"><a class="markdownIt-Anchor" href="#快速入门"></a> 快速入门</h1>
<ol>
<li>下载JQuery
<ol>
<li>版本说明：
<ol>
<li>1.x：兼容ie678,使用最为广泛的，官方只做BUG维护，功能不再新增。因此一般项目来说，使用1.x版本就可以了，最终版本：1.12.4 (2016年5月20日)</li>
<li>2.x：不兼容ie678，很少有人使用，官方只做BUG维护，功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，最终版本：2.2.4 (2016年5月20日)</li>
<li>3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求，一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。目前该版本是官方主要更新维护的版本。最新版本：3.3.1（2018年1月20日）</li>
</ol>
</li>
</ol>
</li>
<li>导入JQuery的js文件：导入.min.js文件。</li>
<li>使用</li>
</ol>
<h1 id="jquery对象和js对象的区别与转换"><a class="markdownIt-Anchor" href="#jquery对象和js对象的区别与转换"></a> JQuery对象和JS对象的区别与转换</h1>
<ul>
<li>JQuery获取元素对象：<code>var $divs = $(&quot;div&quot;);</code>;</li>
<li>JS获取元素对象：<code>var div2 = document.getElementsByTagName(&quot;div&quot;);</code></li>
<li>JQuery对象在操作时更加方便，但是<strong>JQuery对象和JS对象的方法是不通用的</strong>。</li>
<li>JQuery对象和JS对象的互相转换：
<ul>
<li>JS–&gt;JQ：<code>$(JS对象)</code>,如：<code>$(divs).html(&quot;修改html内容&quot;)</code></li>
<li>JQ–&gt;JS：<code>jq对象[索引]</code>或者<code>jq对象.get(索引)</code>,如：<code>$divs[1].innerHTML(&quot;修改HTML内容&quot;)</code>或者<code>$divs.get(0).innerHTML(&quot;修改HTML内容&quot;)</code></li>
</ul>
</li>
</ul>
<h1 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h1>
<ul>
<li>事件绑定：
<ul>
<li>示例：获取b1按钮,绑定单击事件。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(&quot;#b1&quot;).click(function()&#123;
   alert(&quot;click&quot;);
&#125;)</code></pre>
<ul>
<li>入口函数：dom文档加载完成后执行该函数中的代码
<ul>
<li>js写法：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">windows.onload &#x3D; function()&#123;
   alert(&quot;js&quot;);
&#125;</code></pre>
<ul>
<li>jq写法：</li>
</ul>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(function()&#123;
   alert(&quot;jq&quot;);
&#125;)</code></pre>
<ul>
<li>windows.onload与$(function(){})的区别：
<ul>
<li>windows.onload <strong>只能定义一次</strong>,如果定义多次，后边的会将前面的覆盖掉。</li>
<li>$(function(){})<strong>可以定义多次</strong>。</li>
</ul>
</li>
<li>样式控制：css方法
<ul>
<li>用css原本的样式名称：<code>$(&quot;#div1&quot;).css(&quot;background-color&quot;,&quot;red&quot;);</code></li>
<li>用dom的对象名称：<code>$(&quot;#div1&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);</code></li>
</ul>
</li>
</ul>
<h1 id="选择器"><a class="markdownIt-Anchor" href="#选择器"></a> 选择器</h1>
<h2 id="基本选择器"><a class="markdownIt-Anchor" href="#基本选择器"></a> 基本选择器</h2>
<ol>
<li>标签选择器：（元素选择器）
<ol>
<li>语法：<code>$(&quot;html标签名&quot;)</code>,获得所有匹配标签名的元素;</li>
</ol>
</li>
<li>id选择器：
<ol>
<li>语法：<code>$(&quot;#id的属性值&quot;)</code>,获得与指定id属性值匹配的元素;</li>
</ol>
</li>
<li>类选择器：
<ol>
<li>语法：<code>$(&quot;.class的属性值&quot;)</code>,获得与指定的class属性值匹配的元素;</li>
</ol>
</li>
</ol>
<ul>
<li>并集选择器：
<ul>
<li>语法：<code>$(&quot;选择器1,选择器2&quot;)</code>,获取多个选择器选中的所有元素。</li>
</ul>
</li>
</ul>
<h2 id="层级选择器"><a class="markdownIt-Anchor" href="#层级选择器"></a> 层级选择器</h2>
<ol>
<li>后代选择器：
<ol>
<li>语法：<code>$(&quot;选择器1 选择器2)</code>,选择选择器1选择的元素中满足选择器2的所有元素。（多层嵌套的也选择）</li>
</ol>
</li>
<li>子选择器：
<ol>
<li>语法：<code>$(&quot;选择器1 &gt; 选择器2)</code>,选择选择器1选择的元素中满足选择器2的所有子元素。（多层嵌套的不选择)</li>
</ol>
</li>
</ol>
<h2 id="属性选择器"><a class="markdownIt-Anchor" href="#属性选择器"></a> 属性选择器</h2>
<ol>
<li>属性名称选择器：
<ol>
<li>语法：<code>$(&quot;标签名[属性名]&quot;)</code>,该标签下包含指定的属性的元素;</li>
</ol>
</li>
<li>属性选择器：
<ol>
<li>语法:<code>$(&quot;标签名[属性名 = '值']&quot;)</code>,该标签下<strong>包含指定属性且该属性等于指定值</strong>的元素。</li>
<li>语法:<code>$(&quot;标签名[属性名 != '值']&quot;)</code>,该标签下<strong>不包含指定属性获知该属性不等于指定值</strong>的元素。</li>
<li>语法:<code>$(&quot;标签名[属性名 ^= '值']&quot;)</code>,该标签下<strong>包含指定属性且该属性值以指定值开始</strong>的元素。</li>
<li>语法:<code>$(&quot;标签名[属性名 $= '值']&quot;)</code>,该标签下<strong>包含指定属性且该属性值以指定值结尾</strong>的元素。</li>
<li>语法:<code>$(&quot;标签名[属性名 *= '值']&quot;)</code>,该标签下<strong>包含指定属性且该属性值中包含指定的值</strong>的元素。</li>
</ol>
</li>
<li>复合属性选择器：
<ol>
<li>语法：<code>$(&quot;标签名[属性名 = '值'][][]...&quot;)</code>,该标签下，同时满足多个属性限定条件的元素。</li>
</ol>
</li>
</ol>
<h2 id="过滤选择器"><a class="markdownIt-Anchor" href="#过滤选择器"></a> 过滤选择器</h2>
<ol>
<li>首元素选择器：
<ol>
<li>语法：<code>:first</code>,获得选择的元素中的第一个元素，如<code>$(div:first)</code>。</li>
</ol>
</li>
<li>尾元素选择器;
<ol>
<li>语法：<code>:last</code>,获得选择的元素中的最后一个元素。</li>
</ol>
</li>
<li>非元素选择器：
<ol>
<li>语法：<code>：not(selector)</code>,获得选择的与元素中，不包括指定内容的元素。如：<code>$(div:not(.one))</code>，选择div中class不为one的元素。</li>
</ol>
</li>
<li>偶数选择器：
<ol>
<li>语法：<code>：even</code>,获得选择的元素中第偶数个的元素，从0开始计数。如;<code>$(div:even)</code>。</li>
</ol>
</li>
<li>奇数选择器：
<ol>
<li>语法：<code>：odd</code>,获得选择的元素中第奇数个的元素，从0开始计数。</li>
</ol>
</li>
<li>等于索引选择器：
<ol>
<li>语法：<code>:eq(index)</code>,获得选择的元素中第某位的元素。</li>
</ol>
</li>
<li>大于索引选择器：
<ol>
<li>语法：<code>:gt(index)</code>,获得选择的元素中索引大于指定索引的元素。</li>
</ol>
</li>
<li>小于索引选择器：
<ol>
<li>语法：<code>：lt(index)</code>,获得选择的元素中索引小于指定索引的元素。</li>
</ol>
</li>
<li>标题选择器：
<ol>
<li>语法：<code>:header</code>,获得标题元素，没有参数，固定的写法。</li>
</ol>
</li>
</ol>
<h2 id="表单过滤选择器"><a class="markdownIt-Anchor" href="#表单过滤选择器"></a> 表单过滤选择器</h2>
<ol>
<li>可用元素选择器：
<ol>
<li>语法：<code>：enabled</code>,获得可用元素;</li>
</ol>
</li>
<li>不可用元素选择器：
<ol>
<li>语法：<code>：disabled</code>,获得不可用元素;如：<code>$(&quot;input[type = 'text']:disabled&quot;).val(&quot;diabled&quot;)</code>，获取改变表单中不可用<code>&lt;input&gt;</code>元素的值。</li>
</ol>
</li>
<li>选中选择器1：
<ol>
<li>语法：<code>:checked</code>,获得单选/复选框中选中的元素。</li>
</ol>
</li>
<li>选中选择器2:
<ol>
<li>语法：<code>:selected</code>，获得下拉框中选中的元素。如:<code>$(&quot;#job &gt; option :selected&quot;)</code>，获取下拉框选中的元素，若为多个，则相当于存在一个数组中。</li>
</ol>
</li>
</ol>
<h1 id="dom操作"><a class="markdownIt-Anchor" href="#dom操作"></a> DOM操作</h1>
<h2 id="内容操作"><a class="markdownIt-Anchor" href="#内容操作"></a> 内容操作</h2>
<ol>
<li><code>html()</code>:<strong>获取/设置元素的标签体内容</strong>,标签体内容包括该标签中嵌套的标签。</li>
<li><code>text()</code>:获取/设置元素的标签体的<strong>纯文本</strong>内容。</li>
<li><code>val()</code>:获取/设置元素的value属性值。</li>
</ol>
<ul>
<li>注：方法中不传参数，就是获取元素对应内容，方法中传递参数就是修改元素对应的内容。</li>
</ul>
<h2 id="属性操作"><a class="markdownIt-Anchor" href="#属性操作"></a> 属性操作</h2>
<ol>
<li>通用属性操作：
<ol>
<li><code>attr()</code>:获取设置元素的属性,参数只有属性名则获取属性值，如果参数还有属性值则设置属性值。如：<code>$(&quot;#bj&quot;).attr(&quot;name&quot;)</code>和<code>$(&quot;#bj&quot;).attr(&quot;name&quot;,&quot;beijing&quot;)</code></li>
<li>removeAttr()`：删除属性。</li>
<li><code>prop()</code>:获取设置元素的属性;</li>
<li>removeProp()`：删除属性。</li>
</ol>
<ul>
<li>attr和prop的区别：
<ul>
<li>如果操作的是元素的<strong>固有属性</strong>,则建议使用prop;</li>
<li>如果操作的是元素的<strong>自定义属性</strong>,则建议使用attr。</li>
</ul>
</li>
</ul>
</li>
<li>对class属性的操作：
<ol>
<li><code>addClass()</code>:添加class属性值;</li>
<li><code>removeClass()</code>:删除class属性值，如：<code>removeClass(&quot;one&quot;)</code>,删除class=&quot;one&quot;的属性。</li>
<li><code>toggleClass()</code>:切换class属性值;
<ol>
<li>如：<code>toggleClass(&quot;one&quot;)</code>:判断元素对象上存在class=“one”，则将属性值one删除掉;如果元素对象上不存在class=“one”,则添加。</li>
</ol>
</li>
</ol>
</li>
<li>CRUD操作：
<ol>
<li><code>append()</code>:父元素将子元素追加到末尾。
<ol>
<li>对象1.append(对象2):将对象2<strong>添加到对象1元素内部</strong>,并且在末尾。（对象2会移动）</li>
</ol>
</li>
<li><code>prepend()</code>:父元素将子元素追加到开头。
<ol>
<li>对象1.perpend(对象2）：将对象2<strong>添加到对象1元素内部</strong>,并且在开头。</li>
</ol>
</li>
<li><code>appendTo()</code>:
<ol>
<li>对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾。</li>
</ol>
</li>
<li><code>prependTo()</code>:
<ol>
<li>对象1.prepend(对象2):将对象1添加到对象2内部，并且在开头。</li>
</ol>
</li>
<li><code>after()</code>:添加元素到元素后边
<ol>
<li>对象1.after(对象2):将对象2添加到对象1后边，<strong>对象1和对象2是兄弟关系</strong>。</li>
</ol>
</li>
<li><code>before()</code>:添加元素到元素前边
<ol>
<li>对象1.before(对象2):将对象2添加对象1前边，<strong>对象1和对象2是兄弟关系</strong>。</li>
</ol>
</li>
<li><code>insertAfter()</code>:
<ol>
<li>对象1.insertAfter(对象2):将对象1添加到对象2后边，<strong>对象1和对象2是兄弟关系</strong>。</li>
</ol>
</li>
<li><code>insertBefore()</code>:
<ol>
<li>对象1.insertBefore(对象2):将对象1添加到对象2前边，<strong>对象1和对象2是兄弟关系</strong>。</li>
</ol>
</li>
<li><code>remove()</code>：移除元素
<ol>
<li>对象.remove():将对象删除掉;</li>
</ol>
</li>
<li><code>empty()</code>:清空元素的所有后代元素。
<ol>
<li>对象.empty():将对象的后代元素全部清空，但是<strong>保留当前对象以及其属性节点</strong>。</li>
</ol>
</li>
<li><code>clone()</code>:克隆元素并且选中这些克隆。</li>
</ol>
</li>
</ol>
<h1 id="jquery动画"><a class="markdownIt-Anchor" href="#jquery动画"></a> JQuery动画</h1>
<ul>
<li>
<p>默认显示和隐藏方式：</p>
<ol>
<li><code>show([speed], [easing],[fn])</code>:
<ol>
<li>speed:动画的速度。三个预定义的值(slow,normal,fast)或表示动画时长的毫秒数值(如：1000);</li>
<li>easing:用来指定切换效果。默认是swing,可用参数是linear;
<ol>
<li>swing:动画执行时效果是，先慢，中间快，最后又慢。</li>
<li>linear：动画执行是匀速的。</li>
</ol>
</li>
<li>fn:在动画执行结束时执行的函数，每个元素执行一次。</li>
</ol>
</li>
<li><code>hide([speed], [easing],[fn])</code>;</li>
<li><code>toggle([speed], [easing],[fn])</code>:在show和hide之间切换。</li>
</ol>
</li>
<li>
<p>JQuery动画效果是同通过修改元素属性来实现的，如hide()就会设置的其中一个属性就是：<code>style=&quot;display:none&quot;</code></p>
</li>
<li>
<p>滑动显示和隐藏方式：</p>
<ol>
<li><code>slideDown([speed], [easing],[fn])</code></li>
<li><code>slideUp([speed], [easing],[fn])</code></li>
<li><code>slideToggle([speed], [easing],[fn])</code></li>
</ol>
</li>
<li>
<p>淡入淡出显示和隐藏方式：</p>
<ul>
<li><code>fadeIn([speed],[easing],[fn])</code></li>
<li><code>fadeOut([speed],[easing],[fn])</code></li>
<li><code>fadeToggle([speed],[easing],[fn])</code></li>
</ul>
</li>
</ul>
<h1 id="jquery遍历"><a class="markdownIt-Anchor" href="#jquery遍历"></a> JQuery遍历</h1>
<ul>
<li>JS的遍历方式：<code>for(初始化值;循环结束条件;步长)</code>，也适用于JQ</li>
<li>JQ的遍历方式：
<ol>
<li><code>jq对象.each(callback)</code>:callback是一个函数。
<ol>
<li>语法：<code>jq对象.each(function(index,element)[]&#123;&#125;)</code>
<ol>
<li><code>index</code>:就是元素在集合中的索引</li>
<li><code>element</code>：就是集合中每一个元素对象。</li>
<li><code>this</code>:集合中的当前元素对象。</li>
</ol>
</li>
<li>回调函数的返回值：
<ol>
<li><code>false</code>:如果当前的function返回为false，则结束循环。(break)</li>
<li><code>true</code>:如果当前的function返回为true,则结束本次循环，继续下次循环。（continue)</li>
</ol>
</li>
</ol>
</li>
<li><code>$.each(object, callback)</code>,其中callback是回调函数。</li>
<li><code>for...of:jq对象</code>:3.0版本后提供的方式
<ol>
<li>语法：<code>for（元素对象 of 容器对象)</code>.</li>
</ol>
</li>
</ol>
</li>
</ul>
<h1 id="jquery事件绑定"><a class="markdownIt-Anchor" href="#jquery事件绑定"></a> JQuery事件绑定</h1>
<ol>
<li>jquery标准事件绑定方式：<code>jq对象.事件方法（回调函数)</code>
<ol>
<li>如果调用事件方法，不传递回调函数，则会触发浏览器的默认行为。如：
<ol>
<li><code>jq对象.focus()</code>，使对象获得焦点;</li>
<li><code>表单对象.submit()</code>,使表单提交。</li>
</ol>
</li>
</ol>
</li>
<li>on绑定事件/off解除绑定：
<ol>
<li><code>jq对象.on(&quot;事件名称&quot;,回调函数)</code>;</li>
<li><code>jq对象.off(&quot;事件名称&quot;)</code>:
<ol>
<li>如果off方法不传递任何参数，则将组件上的所有事件全部解除。</li>
</ol>
</li>
</ol>
</li>
<li>事件切换：toggle
<ol>
<li><code>jq对象.toggle(fn1,fn2,...)</code>:当单击jq对象对应的组件后，会执行fn1,第二次点击会执行fn2,依次循环往复。</li>
<li>注意：1.9版本后，toggle方法的事件切换功能被删除，jquery Migrate插件（js代码）可以恢复此功能。此js文件需要自行下载。
<ol>
<li><code>&lt;script src=&quot;../js/jquery-migrate-1.0.0.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</code></li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="jquery插件"><a class="markdownIt-Anchor" href="#jquery插件"></a> JQuery插件</h1>
<ol>
<li><code>$.fn.extend(object)</code>:
<ol>
<li>增强通过jquery获取的对象的功能。（即<code>$(&quot;选择器&quot;)</code>的功能)</li>
</ol>
</li>
<li><code>$.extend(object)</code>:
<ol>
<li>增强JQuery对象自身的功能。(即<code>$</code>自身的功能)</li>
</ol>
</li>
</ol>
<ul>
<li>示例：</li>
</ul>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">
$.extend(&#123;
   max:function(a,b) &#123;
      return a &gt;&#x3D; b ? a : b;
   &#125;,
   min:function(a,b) &#123;
      return a &lt;&#x3D; b ? a : b;
   &#125;
&#125;)

$.max(2,3);

$.fn.extend(&#123;
   check:function(a,b) &#123;
      alert(&quot;check&quot;);
   &#125;
&#125;)

$(&quot;btn-check&quot;).check();</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html" class="post-title-link" itemprop="url">设计模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-21 11:21:04" itemprop="dateCreated datePublished" datetime="2021-01-21T11:21:04+08:00">2021-01-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:41:21" itemprop="dateModified" datetime="2022-09-17T19:41:21+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web后端</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="java设计模式简介"><a class="markdownIt-Anchor" href="#java设计模式简介"></a> Java设计模式简介</h1>
<ul>
<li>设计模式（Design pattern）:是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。（23中设计模式别称：GOF23）
<ul>
<li>模式：在某些场景下，针对某类问题的某种通用的解决方案。</li>
<li>场景：项目所在的环境</li>
<li>问题：约束条件，项目目标等</li>
<li>解决方案：通用、可复用的设计，解决约束达到目标。</li>
</ul>
</li>
<li>设计模式的三个分类：
<ul>
<li>创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。
<ul>
<li>五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li>
</ul>
</li>
<li>结构型模式：把类或对象结合在一起形成一个更大的结构。
<ul>
<li>适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li>
</ul>
</li>
<li>行为型模式：类和对象如何交互，及划分责任和算法。
<ul>
<li>策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210121160034.png" alt="" /></li>
</ul>
</li>
</ul>
</li>
<li>7大设计模式原则：</li>
</ul>
<table>
<thead>
<tr>
<th>设计原则</th>
<th>设计原则定义</th>
<th>设计原则详解</th>
</tr>
</thead>
<tbody>
<tr>
<td>开闭原则</td>
<td>开闭原则是指一个软件实体，如类、模块和函数应该对扩展开放,对修改关闭，也就是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。</td>
<td><a target="_blank" rel="noopener" href="https://geek-docs.com/design-pattern/design-principle/open-close-principle.html">开闭原则详解</a></td>
</tr>
<tr>
<td>里氏替换原则</td>
<td>里氏替换原则是关于继承的一个原则，遵循里氏替换原则能够更好地发挥继承的作用，里氏替换原则最早是在1988年，由麻省理工学院的一位姓里的女士（Barbara Liskov）提出来的。子类可以扩展父类的功能，但不能改变父类的功能</td>
<td><a target="_blank" rel="noopener" href="https://geek-docs.com/design-pattern/design-principle/liskov-substitution-principle.html">里氏替换原则详解</a></td>
</tr>
<tr>
<td>迪米特原则</td>
<td>迪米特原则它要求一个对象应该对其他对象有最少的了解，所以迪米特法则又叫做最少知识原则。</td>
<td><a target="_blank" rel="noopener" href="https://geek-docs.com/design-pattern/design-principle/law-of-demeter.html">迪米特原则详解</a></td>
</tr>
<tr>
<td>单一职责原则</td>
<td>单一职责原则(Single Responsibility Principle)是面向对象设计原则的一种。单一职责原则是指不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。</td>
<td><a target="_blank" rel="noopener" href="https://geek-docs.com/design-pattern/design-principle/single-responsibility-principle.html">单一职责原则详解</a></td>
</tr>
<tr>
<td>接口分离原则</td>
<td>接口分离原则指在设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。</td>
<td><a target="_blank" rel="noopener" href="https://geek-docs.com/design-pattern/design-principle/interface-segregation-principle.html">接口分离原则详解</a></td>
</tr>
<tr>
<td>依赖倒置原则</td>
<td>依赖倒置原则指的是高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定)。抽象(稳定)不应该依赖于实现细节(变化)，实现细节应该依赖于抽象(稳定)。即面向接口编程</td>
<td><a target="_blank" rel="noopener" href="https://geek-docs.com/design-pattern/design-principle/dependence-inversion-principle.html">依赖倒置原则</a></td>
</tr>
<tr>
<td>组合/聚合复用原则</td>
<td>组合/聚合复用原则是指尽量使用组合/聚合，不要使用类继承。</td>
<td><a target="_blank" rel="noopener" href="https://geek-docs.com/design-pattern/design-principle/composite-aggregate-reuse-principle.html">组合/聚合复用原则详解</a></td>
</tr>
</tbody>
</table>
<ul>
<li>23种设计模式简述：
<ol>
<li>单例模式：某个类只能有一个实例，提供一个全局的访问点。</li>
<li>工厂方法模式：工厂方法模式是简单工厂模式的进一步抽象和推广，是GoF设计模式的一种。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。</li>
<li>抽象工厂模式：创建相关或依赖对象的家族，而无需明确指定具体类。</li>
<li>建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造。</li>
<li>原型模式：通过复制现有的实例来创建新的实例。</li>
<li>适配器模式：将一个类的方法接口转换成客户希望的另外一个接口。</li>
<li>组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构。</li>
<li>装饰模式：动态的给对象添加新的功能。</li>
<li>代理模式：为其他对象提供一个代理以便控制这个对象的访问。</li>
<li>享元（蝇量）模式：通过共享技术来有效的支持大量细粒度的对象。</li>
<li>外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。</li>
<li>桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化。</li>
<li>模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。</li>
<li>解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。</li>
<li>策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。</li>
<li>状态模式：允许一个对象在其对象内部状态改变时改变它的行为。</li>
<li>观察者模式：对象间的一对多的依赖关系。</li>
<li>备忘录模式：在不破坏封装的前提下，保持对象的内部状态。</li>
<li>中介者模式：用一个中介对象来封装一系列的对象交互。</li>
<li>命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。</li>
<li>访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。</li>
<li>责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。</li>
<li>迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。</li>
</ol>
</li>
</ul>
<h1 id="代理模式"><a class="markdownIt-Anchor" href="#代理模式"></a> 代理模式</h1>
<ul>
<li>代理模式(Proxy Pattern) 是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理。代理模式给某一个对象提供一个代理，并<strong>由代理对象控制对原对象的引用</strong>。代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210121162916.png" alt="" /></li>
<li>三种代理模式：
<ol>
<li>静态代理；</li>
<li>JDK动态代理；</li>
<li>Cglib动态代理。</li>
</ol>
</li>
</ul>
<h2 id="静态代理"><a class="markdownIt-Anchor" href="#静态代理"></a> 静态代理</h2>
<h1 id="工厂设计模式"><a class="markdownIt-Anchor" href="#工厂设计模式"></a> 工厂设计模式</h1>
<ul>
<li>属于创建者模式；</li>
<li>实现了创建者和调用者的分离；</li>
<li>分类：
<ol>
<li>简单工厂模式；</li>
<li>工厂方法模式；</li>
<li>抽象工厂模式；</li>
</ol>
</li>
<li>主要遵循原则：
<ol>
<li>开闭原则；</li>
<li>依赖倒置原则；</li>
<li>迪米特原则；</li>
</ol>
</li>
<li>核心本质：
<ol>
<li>实例化对象不使用new，用工厂方法替代；</li>
<li>将选择实现类，创建对象统一管理和控制，从而将调用者和我们的实现类解耦。</li>
</ol>
</li>
</ul>
<h2 id="简单工厂模式"><a class="markdownIt-Anchor" href="#简单工厂模式"></a> 简单工厂模式</h2>
<ul>
<li>用来生产同一等级结构中的任意产品（对于增加新的产品，需要扩展已有的代码）</li>
<li>虽然不符合开闭原则，但是因为其简单，所以实际中使用得最多。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
&#x2F;&#x2F;车接口
package simpliFactory;


public interface Car &#123;

    void name();
&#125;

&#x2F;&#x2F;benci车实体类
package simpliFactory;

public class BenciCar implements Car &#123;

    @Override
    public void name() &#123;
        System.out.println(&quot;benci&quot;);
    &#125;
&#125;

&#x2F;&#x2F;bmw车实体类
package simpliFactory;

public class BMWCar implements Car &#123;

    @Override
    public void name() &#123;
        System.out.println(&quot;BMW&quot;);
    &#125;
&#125;

&#x2F;&#x2F;车工厂
package simpliFactory;

public class CarFactory &#123;
    public static Car getCar(String name) &#123;
      &#x2F;&#x2F;想要增加新的车型，必须修改这里面的代码
        if(name.equals(&quot;bmw&quot;)) &#123;
            return new BMWCar();
        &#125;else if(name.equals(&quot;benci&quot;)) &#123;
            return new BenciCar();
        &#125;else &#123;
            return null;
        &#125;
    &#125;
&#125;

&#x2F;&#x2F;消费者从车工厂购买车
package simpliFactory;

public class Consumer &#123;
    public static void main(String[] args) &#123;
        Car car1 &#x3D; CarFactory.getCar(&quot;bmw&quot;);
        Car car2 &#x3D; CarFactory.getCar(&quot;benci&quot;);

        car1.name();
        car2.name();
    &#125;
&#125;</code></pre>
<h2 id="工厂方法模式"><a class="markdownIt-Anchor" href="#工厂方法模式"></a> 工厂方法模式</h2>
<ul>
<li>用来生产同一等级结构中的固定产品（支持增加任意产品）</li>
<li>不修改已有类的前提下，通过增加<strong>新的工厂类</strong>来实现扩展。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
&#x2F;&#x2F;车接口
package methodFactory;

public interface Car &#123;

    void name();
&#125;
&#x2F;&#x2F;车工厂接口
package methodFactory;

public interface CarFactory &#123;
     Car getCar();
&#125;
&#x2F;&#x2F;BMW车实体类
package methodFactory;

public class BMWCar implements Car &#123;

    @Override
    public void name() &#123;
        System.out.println(&quot;BMW&quot;);
    &#125;
&#125;
&#x2F;&#x2F;Benci车实体类
package methodFactory;

public class BenciCar implements Car &#123;

    @Override
    public void name() &#123;
        System.out.println(&quot;benci&quot;);
    &#125;
&#125;

&#x2F;&#x2F;BMW车工厂类
package methodFactory;

public class BMWFactory implements CarFactory &#123;
    @Override
    public  Car getCar() &#123;
        return new BMWCar();
    &#125;
&#125;

&#x2F;&#x2F;Benci车工厂类
package methodFactory;

public class BenciFactory implements CarFactory&#123;
    @Override
    public Car getCar() &#123;
        return new BenciCar();
    &#125;
&#125;

&#x2F;&#x2F;消费者从对应的工厂获取对应的车
package methodFactory;

public class Consumer &#123;
    public static void main(String[] args) &#123;
        Car car1 &#x3D; new BMWFactory().getCar();
        Car car2 &#x3D; new BenciFactory().getCar();

        car1.name();
        car2.name();
    &#125;
&#125;</code></pre>
<h2 id="抽象工厂模式"><a class="markdownIt-Anchor" href="#抽象工厂模式"></a> 抽象工厂模式</h2>
<ul>
<li>抽象工厂提供了一个创建一系列相关或相互依赖产品（即一个产品簇）的接口，无需指定它们具体的类。</li>
<li>核心：将一个系列的产品统一到一起创建。增加新系列的产品容易，但是修改产品簇中的产品困难。</li>
<li>示例：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210207173309.jpg" alt="" /></li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;产品簇中产品之一-手机接口
package abstractFactory;

public interface IphoneProduct &#123;

    void call();
&#125;

&#x2F;&#x2F;产品簇中产品之一-路由器接口
package abstractFactory;

public interface IRouterProduct &#123;

    void openWifi();
&#125;


&#x2F;&#x2F;小米系列产品之手机实体类
package abstractFactory;

public class XIaomiPhone  implements IphoneProduct&#123;
    @Override
    public void call() &#123;
        System.out.println(&quot;小米打电话&quot;);
    &#125;
&#125;

&#x2F;&#x2F;小米系列产品之路由器实体类
package abstractFactory;

public class XIaomiRouter implements IRouterProduct &#123;
    @Override
    public void openWifi() &#123;
        System.out.println(&quot;小米路由器连wifi&quot;);
    &#125;
&#125;

&#x2F;&#x2F;华为系列产品之手机实体类
package abstractFactory;

public class HuaweiPhone  implements IphoneProduct&#123;
    @Override
    public void call() &#123;
        System.out.println(&quot;华为打电话&quot;);
    &#125;
&#125;

&#x2F;&#x2F;华为系列产品之路由器实体类
package abstractFactory;

public class HuaweiRouter implements IRouterProduct&#123;
    @Override
    public void openWifi() &#123;
        System.out.println(&quot;华为路由器连wifi&quot;);
    &#125;
&#125;

&#x2F;&#x2F;抽象工厂-用于生产生产不同系列产品的工厂
package abstractFactory;

public interface IProductFactory &#123;

    IphoneProduct producePhone();
    IRouterProduct produceRouter();
&#125;

&#x2F;&#x2F;小米系列产品的生产工厂
package abstractFactory;

public class XiaomiProductFactory implements IProductFactory &#123;
    @Override
    public IphoneProduct producePhone() &#123;
        return new XIaomiPhone();
    &#125;

    @Override
    public IRouterProduct produceRouter() &#123;
        return new XIaomiRouter();
    &#125;
&#125;

&#x2F;&#x2F;华为系列产品的生产工厂
package abstractFactory;

public class HuaweiProductFactory implements IProductFactory &#123;
    @Override
    public IphoneProduct producePhone() &#123;
        return new HuaweiPhone();
    &#125;

    @Override
    public IRouterProduct produceRouter() &#123;
        return new HuaweiRouter();
    &#125;
&#125;


&#x2F;&#x2F;从不同工厂取出不同系列产品
package abstractFactory;

public class Client &#123;

    public static void main(String[] args) &#123;
        IProductFactory xiaomi &#x3D; new XiaomiProductFactory();
        IphoneProduct phone1 &#x3D; xiaomi.producePhone();
        IRouterProduct router1 &#x3D; xiaomi.produceRouter();

        IProductFactory huawei &#x3D; new HuaweiProductFactory();
        IphoneProduct phone2 &#x3D; huawei.producePhone();
        IRouterProduct router2 &#x3D; huawei.produceRouter();

        phone1.call();
        router1.openWifi();

        phone2.call();
        router2.openWifi();
    &#125;
&#125;</code></pre>
<h1 id="代理模式-2"><a class="markdownIt-Anchor" href="#代理模式-2"></a> 代理模式</h1>
<h2 id="静态代理-2"><a class="markdownIt-Anchor" href="#静态代理-2"></a> 静态代理</h2>
<ul>
<li>抽象角色：一般用接口或抽象类来解决，用来统一真实角色和代理角色的核心功能。</li>
<li>真实角色：被代理的角色；</li>
<li>代理角色：代理真实角色，代理真实角色后，一般会增加一些附属功能。</li>
<li>客户：访问代理对象的人。</li>
</ul>
<hr />
<ul>
<li>优点：
<ul>
<li>可以使真实角色的业务简化，不用去关注一些公共的业务；</li>
<li>公共业务交给代理角色，实现了业务的分工；</li>
<li>公共业务发生扩展的时候，方便集中管理，不用去直接修改原有代码，只用增强代理角色的功能。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>一个真实角色就会产生一个代理角色，代码量会翻倍。</li>
</ul>
</li>
<li>代码实现步骤：
<ol>
<li>接口：</li>
</ol>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package staticProxy;

&#x2F;&#x2F;真实角色和代理角色都要实现相同的接口，以确保代理和真实角色的核心功能统一，例如，房东不需要婚介所
public interface Rent &#123;
    void rent();
&#125;</code></pre>
<ol start="2">
<li>真实角色：</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package staticProxy;

&#x2F;&#x2F;房东-真实角色
public class Host implements Rent&#123;
    @Override
    public void rent() &#123;
        System.out.println(&quot;房东出租房屋&quot;);
    &#125;
&#125;</code></pre>
<pre><code>3. 代理角色：
</code></pre>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package staticProxy;

&#x2F;&#x2F;中介-代理角色
public class Proxy implements Rent &#123;

    private Host host;

    public Proxy(Host host)&#123;
        this.host &#x3D; host;
    &#125;

    &#x2F;&#x2F;代理角色除了实现真实角色的功能外，往往还需实现一些附属功能，这正是代理的作用所在。
    @Override
    public void rent() &#123; &#x2F;&#x2F;核心功能rent中添加一些附属功能
        seeHouse();
        host.rent();
        fare();
    &#125;

    public void seeHouse() &#123;
        System.out.println(&quot;中介带客户看房子&quot;);
    &#125;

    public void fare() &#123;
        System.out.println(&quot;中介收取费用&quot;);
    &#125;
&#125;</code></pre>
<pre><code>4. 客户：
</code></pre>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package staticProxy;

public class Client &#123;

    public static void main(String[] args) &#123;
        Host host &#x3D; new Host();
        Proxy proxy &#x3D; new Proxy(host);
        proxy.rent();
    &#125;
&#125;</code></pre>
<h2 id="动态代理"><a class="markdownIt-Anchor" href="#动态代理"></a> 动态代理</h2>
<ul>
<li>动态代理和静态代理发挥的作用相同，只是代理角色生成的方式不同；</li>
<li>动态代理的代理类是动态生成的，不是像静态代理类一样是我们事先写好的；</li>
<li>动态代理的分类：
<ol>
<li>基于接口的动态代理；</li>
<li>基于类的动态代理；</li>
</ol>
</li>
<li>动态代理的实现方式：
<ol>
<li>jdk动态代理–基于接口；</li>
<li>cglib–基于类；</li>
<li>javasist–java字节码实现；</li>
</ol>
</li>
</ul>
<h3 id="jdk动态代理"><a class="markdownIt-Anchor" href="#jdk动态代理"></a> jdk动态代理</h3>
<ul>
<li>jdk的动态代理是通过Proxy类和 InvocationHandler接口实现的；</li>
<li>Proxy类提供生成满足对应接口的代理实例的静态方法；</li>
<li>InvocationHandler是一个接口，每一个动态生成的代理实例都有一个对应的实现了InvocationHandler接口的类。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;统一真实角色和代理角色的接口
public interface Rent &#123;
    void rent();
&#125;

&#x2F;&#x2F;真实角色1
public class Host implements Rent &#123;
    @Override
    public void rent() &#123;
        System.out.println(&quot;房东1出租房子&quot;);
    &#125;
&#125;

&#x2F;&#x2F;真实角色2
public class Host2 implements Rent &#123;
    @Override
    public void rent() &#123;
        System.out.println(&quot;房东2出租房屋&quot;);
    &#125;
&#125;

&#x2F;&#x2F;代理处理类，用于生成实现和真实角色一样接口的代理实例
public class ProxyInvocationHandler implements InvocationHandler &#123;

    &#x2F;&#x2F;需要实现的接口
    private Object target;

    &#x2F;&#x2F;设置对应的接口
    public void setTarget(Object target)&#123;
        this.target &#x3D; target;
    &#125;

    &#x2F;&#x2F;获取代理实例
    public Object getProxy()&#123;
        return Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces(),this);
    &#125;

    &#x2F;&#x2F;实现代理实例的方法
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
        Object result &#x3D; method.invoke(target,args);
        log(method.getName());
        return result;
    &#125;

    &#x2F;&#x2F;添加代理实例的附属方法
    public void log(String methodName) &#123;
        System.out.println(&quot;执行了&quot;+methodName+&quot;方法&quot;);
    &#125;
&#125;

&#x2F;&#x2F;通过代理实现租房
public class Client &#123;
    public static void main(String[] args) &#123;
        Host host1 &#x3D; new Host();
        Host2 host2 &#x3D; new Host2();

        ProxyInvocationHandler pih &#x3D; new ProxyInvocationHandler();&#x2F;&#x2F;生成代理处理对象
        pih.setTarget(host1);&#x2F;&#x2F;设置需要被代理的真实对象
        Rent proxy &#x3D; (Rent)pih.getProxy();&#x2F;&#x2F;生成对应的代理对象
        proxy.rent();

        pih.setTarget(host2);
        Rent proxy2 &#x3D; (Rent) pih.getProxy();
        proxy2.rent();
    &#125;
&#125;</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Listener/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Listener/index.html" class="post-title-link" itemprop="url">Listener</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-21 11:20:42" itemprop="dateCreated datePublished" datetime="2021-01-21T11:20:42+08:00">2021-01-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-09-26 21:39:02" itemprop="dateModified" datetime="2021-09-26T21:39:02+08:00">2021-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web后端</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>719</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="listener概述"><a class="markdownIt-Anchor" href="#listener概述"></a> Listener概述</h1>
<ul>
<li>JavaWeb三大组件之一（Servlet,Filter,Listener)</li>
<li>事件监听机制：
<ul>
<li>事件：一件事情，如：点击。</li>
<li>事件源：事件发生的地方。</li>
<li>监听器：一个对象;</li>
<li>注册监听：将事件，事件源，监听器绑定在一起。当事件源上发生某个事件后，执行监听器的代码。</li>
</ul>
</li>
</ul>
<h1 id="servletcontextlistener"><a class="markdownIt-Anchor" href="#servletcontextlistener"></a> ServletContextListener</h1>
<ul>
<li>ServletContextListener:一个接口，用来监听ServletContext对象的创建和销毁。</li>
<li>接口方法：
<ul>
<li><code>void contextInitalized(ServletContextEvent sce)</code>:ServletContext对象创建后会调用该方法。</li>
<li><code>void contextDestroyed(ServletContextEvent sce)</code>:ServletContext对象被销毁之前会调用该方法。</li>
</ul>
</li>
<li>使用步骤：
<ol>
<li>定义一个类，<strong>实现ServletContextListener接口</strong>;</li>
<li>复习方法;</li>
<li>配置：
<ul>
<li>web.xml:
<ol>
<li>只用配置监听器的类名。<br />
2.可以指定初始化参数<code>&lt;context-param&gt;</code></li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;listener&gt;
    &lt;listener-class&gt;监听器类的完全限定名&lt;&#x2F;listener-class&gt;
&lt;&#x2F;listener&gt;

&lt;context-param&gt;
    &lt;param-name&gt;参数名&lt;&#x2F;param-name&gt;
    &lt;param-value&gt;参数内容&lt;&#x2F;param-value&gt;
&lt;&#x2F;context-param&gt;</code></pre>
<ul>
<li>注解配置：无需写参数。
<ul>
<li><code>@WebListener</code></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Filter/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Filter/index.html" class="post-title-link" itemprop="url">Filter</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-20 21:48:09" itemprop="dateCreated datePublished" datetime="2021-01-20T21:48:09+08:00">2021-01-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-09-26 21:38:27" itemprop="dateModified" datetime="2021-09-26T21:38:27+08:00">2021-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web后端</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="filter概述"><a class="markdownIt-Anchor" href="#filter概述"></a> Filter概述</h1>
<ul>
<li>JavaWeb的三大组件（servlet，Filter，Listener)之一。</li>
<li>web中的过滤器：当访问服务器的资源时，过滤器可以将每次请求拦截下来，完成一些特殊的功能;</li>
<li>作用：
<ul>
<li>一般用于完成<strong>通用的操作</strong>,如：登录验证，统一编码处理，敏感字符过滤。</li>
</ul>
</li>
</ul>
<h1 id="filter快速入门"><a class="markdownIt-Anchor" href="#filter快速入门"></a> Filter快速入门</h1>
<ul>
<li>步骤：
<ol>
<li>定义一个类，实现<strong>接口Filter</strong>,注意这个Filter接口是java.servlet包下的（因为java.util包下也有Filter接口）;</li>
<li>复写方法，（主要起作用的方法是doFilter)</li>
<li>配置拦截路径：
<ol>
<li>在web.xml文件中去配置;</li>
<li>用注解<code>@WebFilter</code>注解，如：<code>@WebFilter(&quot;/demo1&quot;)</code>代表访问/demo1目录下的资源的时候执行拦截。</li>
</ol>
</li>
</ol>
</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import java.io.IOException;

@WebFilter(&quot;&#x2F;*&quot;)
public class FilterDemo1 implements Filter &#123;

    @Override
    public void init(FilterConfig filterConfig) throws ServletException &#123;

    &#125;

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;
        System.out.println(&quot;I&#39;m Filter!&quot;);

        chain.doFilter(request, response);
    &#125;

    @Override
    public void destroy() &#123;
        
    &#125;
&#125;</code></pre>
<h1 id="webxml配置方式"><a class="markdownIt-Anchor" href="#webxml配置方式"></a> web.xml配置方式</h1>
<ul>
<li>配置filter;</li>
<li>配置filter的拦截路径。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;filter&gt;
    &lt;filter-name&gt;过滤器的名字&lt;&#x2F;filter-name&gt;
    &lt;filter-class&gt;过滤器的完全限定类名&lt;&#x2F;filter-class&gt;
&lt;&#x2F;filter&gt;

&lt;filter-mapping&gt;
    &lt;filter-name&gt;过滤器的名字&lt;&#x2F;filter-name&gt;
    &lt;url-pattern&gt;拦截的路径&lt;&#x2F;url-pattern&gt;
&lt;&#x2F;filter-mapping&gt;</code></pre>
<h1 id="过滤器的执行流程和生命周期方法"><a class="markdownIt-Anchor" href="#过滤器的执行流程和生命周期方法"></a> 过滤器的执行流程和生命周期方法</h1>
<ul>
<li>执行流程：
<ol>
<li>执行过滤器，拦截请求，对request对象请求执行增强操作;</li>
<li>放行请求,执行放行后对应的资源;</li>
<li>执行放行后的语句，对response对象响应执行增强操作。</li>
</ol>
</li>
<li>生命周期方法：
<ol>
<li><code>init()</code>:</li>
</ol>
<ul>
<li>在<strong>服务器启动</strong>后，会创建Filter对象，然后调用init方法。</li>
<li>只执行一次，用于<strong>加载资源</strong>。</li>
</ul>
<ol start="2">
<li><code>doFilter()</code>:
<ul>
<li>每一次请求被拦截的资源时，会执行。</li>
<li>会执行多次。</li>
</ul>
</li>
<li><code>destroy()</code>:在<strong>服务器关闭后</strong>,Filter被销毁。
<ol>
<li>如果服务器是正常关闭，则会执行destroy方法;</li>
<li>只执行一次，用于<strong>释放资源</strong>。</li>
</ol>
</li>
</ol>
</li>
</ul>
<h1 id="过滤器配置"><a class="markdownIt-Anchor" href="#过滤器配置"></a> 过滤器配置</h1>
<ul>
<li>过滤器拦截路径配置：
<ol>
<li>具体资源路径：<code>/index.jsp</code>,只有访问index.jsp资源时，过滤器才会被执行;</li>
<li>拦截目录：<code>/user/*</code>,访问/user下的所有资源时，过滤器都会被执行;</li>
<li>后缀名拦截：<code>*.jsp</code>，访问所有后缀名为jsp的资源时，过滤器都会被执行。</li>
<li>拦截所有资源：<code>/*</code>，访问所有资源时，过滤器都会被执行。</li>
</ol>
</li>
<li>拦截方式配置：
<ul>
<li>注解配置：设置dispatcherTypes属性：
<ol>
<li>REQUEST:默认值，浏览器直接请求资源时拦截;</li>
<li>FORWARD：转发访问资源时拦截;</li>
<li>INCLUDE：包含访问资源时拦截;</li>
<li>ERROR：错误跳转资源时拦截;</li>
<li>ASYNC:异步访问资源时拦截。</li>
</ol>
</li>
<li>web.xml配置：设置<code>&lt;dispathcer&gt;&lt;/dispathcer&gt;</code>标签。</li>
<li>示例：
<ul>
<li><code>@WebFilter(value = &quot;/index.jsp&quot;,dispatcherTypes = DispatcherType.REQUEST)</code>：拦截直接访问index.jsp资源的请求;</li>
<li><code>@WebFilter(value = &quot;/index.jsp&quot;,dispatcherTypes = &#123;DispatcherType.REQUEST,DispatcherType.FORWARD&#125;)</code>:拦截直接请求index.jsp或者转发访问index.jsp资源。</li>
<li>web.xml配置：拦截直接请求。</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;filter&gt;
    &lt;filter-name&gt;过滤器的名字&lt;&#x2F;filter-name&gt;
    &lt;filter-class&gt;过滤器的完全限定类名&lt;&#x2F;filter-class&gt;
&lt;&#x2F;filter&gt;

&lt;filter-mapping&gt;
    &lt;filter-name&gt;过滤器的名字&lt;&#x2F;filter-name&gt;
    &lt;url-pattern&gt;拦截的路径&lt;&#x2F;url-pattern&gt;
    &lt;dispatcher&gt;REQUEST&lt;&#x2F;dispatcher&gt;
&lt;&#x2F;filter-mapping&gt;</code></pre>
<h1 id="过滤器链"><a class="markdownIt-Anchor" href="#过滤器链"></a> 过滤器链</h1>
<ul>
<li>过滤器的先后顺序：
<ul>
<li>注解配置：按照**类名的字符串比较规则比较，值小的先执行
<ul>
<li>如： AFilter和BFilter，AFilter先执行;</li>
<li>如：FilterDemo6和FilterDemo17,FilterDemo17先执行。</li>
</ul>
</li>
<li>web.xml配置：<code>&lt;filter-mapping&gt;</code>标签谁定义在上面，谁先执行。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/JSTL/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/JSTL/index.html" class="post-title-link" itemprop="url">JSTL</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-19 17:09:49" itemprop="dateCreated datePublished" datetime="2021-01-19T17:09:49+08:00">2021-01-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-09-26 21:40:51" itemprop="dateModified" datetime="2021-09-26T21:40:51+08:00">2021-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web后端</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="jstl概述"><a class="markdownIt-Anchor" href="#jstl概述"></a> JSTL概述</h1>
<ul>
<li>JSTL:JavaServer Pages Tag Library,JSP标准标签库。</li>
<li>JSTL是由Apache组织提供的开源的免费的JSP标签;</li>
<li>作用：用于简化和替换JSP页面上的<strong>java代码</strong>;</li>
<li>使用步骤：
<ol>
<li>导入JSTL相关的jar包;</li>
<li>引入标签库：taglib指令：<code>&lt;%@ taglib %&gt;</code>
<ul>
<li>一般将JSTL标签库，将前缀设为<code>c</code>。</li>
</ul>
</li>
<li>使用标签。</li>
</ol>
</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt;</code></pre>
<h1 id="常用的jstl标签"><a class="markdownIt-Anchor" href="#常用的jstl标签"></a> 常用的JSTL标签</h1>
<h2 id="if标签"><a class="markdownIt-Anchor" href="#if标签"></a> if标签</h2>
<ul>
<li>if：相当于java代码的if语句</li>
<li>属性：
<ul>
<li>test:必须的属性，接受boolean表达式，相当于原来if语句的条件;
<ul>
<li>如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容;</li>
<li>一般情况下，test属性值会结合EL表达式一起使用,如：</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;c:if test&#x3D;&quot;$&#123;not empty list&#125;&quot;&gt;
    遍历集合;
&lt;&#x2F;c:if&gt;</code></pre>
<ul>
<li>if标签没有else情况，要想实现else情况，则可以再定义一个if标签。</li>
</ul>
<h2 id="choose"><a class="markdownIt-Anchor" href="#choose"></a> choose</h2>
<ul>
<li>choose:相当于java代码的switch语句</li>
<li>使用choose标签声明：相当于switch声明;</li>
<li>使用when标签判断：相当于case;</li>
<li>使用otherwise标签做其他情况的声明：相当于default</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;c:choose&gt;
    &lt;c:when test&#x3D;&quot;$&#123;number &#x3D;&#x3D; 1&#125;&quot;&gt; 1&lt;&#x2F;c:when&gt;
    &lt;c:when test&#x3D;&quot;$&#123;number &#x3D;&#x3D; 2&#125;&quot;&gt; 2&lt;&#x2F;c:when&gt;
    &lt;c:otherwise&gt;默认数字&lt;&#x2F;c:otherwise&gt;
&lt;&#x2F;c:choose&gt;</code></pre>
<h2 id="foreach"><a class="markdownIt-Anchor" href="#foreach"></a> forEach</h2>
<ul>
<li>forEach:相当于java的for语句</li>
<li>作用：
<ol>
<li>完成重复的操作;</li>
<li>遍历容器。</li>
</ol>
</li>
<li>完成重复的操作：相当于<code>for(int i = 0; i &lt; 10; i++)</code>
<ul>
<li>属性：
<ul>
<li>begin:开始值，相当于i = 0;</li>
<li>end:结束值;</li>
<li>var：临时变量，相当于i;</li>
<li>step:步长，为1时相当于++;</li>
<li>varStatus:循环状态对象
<ul>
<li>index属性：容器中的元素的索引，从0开始;</li>
<li>count属性：循环次数，从1开始。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>遍历容器：相当于<code>for(int i ： numbers)</code>
<ul>
<li>属性：
<ul>
<li>items:容器对象;</li>
<li>var:容器中元素的临时变量;</li>
<li>varStatus:循环状态对象
<ul>
<li>index属性：容器中的元素的索引，从0开始;</li>
<li>count属性：循环次数，从1开始。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;c:forEach items&#x3D;“$&#123;list&#125;&quot; var&#x3D;&quot;str&quot; varStatus&#x3D;&quot;s&quot;&gt;
    $&#123;s.index&#125; $&#123;s.count&#125; $&#123;str&#125;&lt;br&gt;
&lt;&#x2F;c:forEach&gt;</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/index.html" class="post-title-link" itemprop="url">EL表达式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-19 12:15:27" itemprop="dateCreated datePublished" datetime="2021-01-19T12:15:27+08:00">2021-01-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-09-26 21:38:24" itemprop="dateModified" datetime="2021-09-26T21:38:24+08:00">2021-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web后端</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="el表达式概述"><a class="markdownIt-Anchor" href="#el表达式概述"></a> EL表达式概述</h1>
<ul>
<li>概念：Expression Language ,表达式语言</li>
<li>作用：替换和简化jsp页面中的代码的编写;</li>
<li>语法：<code>$&#123;表达式&#125;</code>;</li>
<li>jsp默认支持EL表达式：
<ul>
<li>如果要忽略EL表达式：
<ol>
<li>设置jsp中的page指令：<code>isELIgnored = &quot;true&quot;</code>,忽略当前jsp页面中的所有EL表达式;</li>
<li><code>\$&#123;表达式&#125;</code>:忽略当前这个EL表达式。</li>
</ol>
</li>
</ul>
</li>
<li>用法：
<ul>
<li>运算，并在页面上显示运算结果;</li>
<li>获取值。</li>
</ul>
</li>
</ul>
<h1 id="el的运算"><a class="markdownIt-Anchor" href="#el的运算"></a> EL的运算</h1>
<ul>
<li>算术运算符：<code>+ ,-, *, / ,%</code>,其中<code>/</code>可以用<code>div</code>代替，<code>%</code>可以用<code>mod</code>代替。</li>
<li>比较运算符：<code>&gt; &lt; &gt;= == !=</code></li>
<li>逻辑运算符：<code>&amp;&amp;(and), ||(or), !(not)</code></li>
<li>空运算符：<code>empty</code>:
<ul>
<li>功能：用于判断字符串，集合，数组对象是否为null并且长度是否为0;</li>
<li>示例：<code>$&#123;empty list&#125;</code>,返回结果为boolean型。 一般常用<code>$&#123;not empty list&#125;</code>:判断不为null或者长度不为0;</li>
</ul>
</li>
</ul>
<h1 id="el获取值"><a class="markdownIt-Anchor" href="#el获取值"></a> EL获取值</h1>
<ul>
<li>EL表达式只能从<strong>域对象</strong>中获取值;</li>
<li>语法：
<ul>
<li><code>$&#123;域名称.键名&#125;</code>:从指定域中获取指定键的值;</li>
<li><code>$&#123;键名&#125;</code>：表示依次从最小的域中查找是否有该键对应的值，知道找到为止，若没有找到，则返回空字符串。</li>
</ul>
</li>
<li>域名称与域对象的对应关系：
<ol>
<li>pageScope --&gt; pageContext;</li>
<li>requestScopt --&gt; request;</li>
<li>sessionScope --&gt; session;</li>
<li>applicationScope --&gt; application(ServletContext);</li>
</ol>
</li>
<li>示例：
<ul>
<li>在域对象中存储了<code>name 张三</code></li>
<li>获取：<code>$&#123;requestScope.name&#125;</code>将在页面上打印张三。</li>
</ul>
</li>
<li>EL获取对象值：
<ul>
<li><code>$&#123;域名称.键名.属性名&#125;</code>:本质上回去调用对象的getter方法，所以必须有对应的getXxx方法的属性才能调用（甚至只有getXxx的方法，没有实际对应的属性也可以）</li>
<li>对应的对象必须首先以键值对的形式存入对应的域对象中，如:<code>request.setAttribute(&quot;user&quot;,user)</code>,将user对象存入request域中去。</li>
</ul>
</li>
<li>EL获取List集合：
<ul>
<li><code>$&#123;域名称.键名[索引]&#125;</code></li>
</ul>
</li>
<li>EL获取Map集合的值
<ul>
<li><code>$&#123;域名称.键名.key名称&#125;</code></li>
<li><code>$&#123;域名称.键名[&quot;key名称&quot;]&#125;</code></li>
</ul>
</li>
</ul>
<h1 id="el的隐式对象"><a class="markdownIt-Anchor" href="#el的隐式对象"></a> EL的隐式对象</h1>
<ul>
<li>EL中不用创建可以直接使用的对象（类似jsp中的内置对象）。</li>
<li>EL表达式中有11个隐式对象：</li>
<li>pageContext对象：
<ul>
<li>获取其他八个内置对象。</li>
<li>示例：动态获取虚拟目录：<code>$&#123;pageContext.request.contextPath&#125;</code></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">蜀ICP备2021022902号-1 </a>
      <img src="/images/beian_icon.png" alt=""><a href="https://beian.mps.gov.cn/#/query/webSearch?code=51010802032250" rel="noopener" target="_blank">川公网安备51010802032250号 </a>
  </div>
  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Zestaken</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">678k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:17</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js" integrity="sha256-4mJNT2bMXxcc1GCJaxBmMPdmah5ji0Ldnd79DKd1hoM=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha256-AjM0J5XIbiB590BrznLEgZGLnOQWrt62s3BEq65Q/I0=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha256-9cmf7tcLdXpKsPi/2AWE93PbZpTp4M4tqzFk+lWomjU=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
