<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.zestaken.top","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":true,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="吾好梦中读书~">
<meta property="og:type" content="website">
<meta property="og:title" content="ZestJourney">
<meta property="og:url" content="http://www.zestaken.top/page/3/index.html">
<meta property="og:site_name" content="ZestJourney">
<meta property="og:description" content="吾好梦中读书~">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zestaken">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://www.zestaken.top/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ZestJourney</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ZestJourney</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">乐游记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zestaken</p>
  <div class="site-description" itemprop="description">吾好梦中读书~</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">84</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">60</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Linux/Linux%E4%B8%ADman%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Linux/Linux%E4%B8%ADman%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/index.html" class="post-title-link" itemprop="url">Linux中man命令的使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-06 08:02:19" itemprop="dateCreated datePublished" datetime="2021-06-06T08:02:19+08:00">2021-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:30:12" itemprop="dateModified" datetime="2022-09-17T19:30:12+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>814</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="man命令介绍"><a class="markdownIt-Anchor" href="#man命令介绍"></a> man命令介绍</h1>
<ul>
<li>Linux提供了丰富的帮助手册，当你需要查看某个命令的参数时不必到处上网查找，只要<code>man</code>一下即可。</li>
<li>可以使用<code>man man</code>查看man的使用方法。</li>
<li>man命令分为以下几个章节（按真实顺序排列）：
<ol>
<li>标准用户命令（Executable programs or shell commands）</li>
<li>系统调用（System calls）functions provided by the kernel</li>
<li>库调用（Library call）functions within program libraries</li>
<li>特殊文件（设备文件）的访问入口（/dev）Special files (usually found in /dev)</li>
<li>文件格式（配置文件的语法），指定程序的运行特性 File formats and conventions</li>
<li>游戏（Games）</li>
<li>杂项（Miscellaneous）including macro packages and conventions</li>
<li>管理命令 System administration commands</li>
<li>跟kernel有关的文件 Kernel routines</li>
</ol>
</li>
</ul>
<h1 id="man命令的常用参数"><a class="markdownIt-Anchor" href="#man命令的常用参数"></a> man命令的常用参数</h1>
<ul>
<li><code>man -f</code>:与<code>whatis</code>命令功能相同，可以简洁地显示命令的功能，以及它所属的章节。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210606220020.jpg" alt="" /></li>
<li><code>man -k</code>:与<code>apropos</code>命令功能相同，可以在所有命令的manual页面中的Description部分中查找命令后接的关键词，然后对查找到关键词的页面简洁地返回一行描述，以及有该命令完整的名字和所在的页面。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210606220638.png" alt="" /></li>
<li>可以在查命令时，指定对应的章节，如：<code>man 3 sleep</code>只查第三节的sleep：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210606220936.png" alt="" />
<ul>
<li>如果不指定对应的章节如：<code>man sleep</code>，则默认查最小的章节，对sleep来说，就是Sleep（1）</li>
</ul>
</li>
</ul>
<h1 id="man的基本使用方法"><a class="markdownIt-Anchor" href="#man的基本使用方法"></a> man的基本使用方法</h1>
<ul>
<li>翻页：
<ul>
<li>向后翻一屏：space(空格键)</li>
<li>向前翻一屏：b</li>
<li>向后翻一行：Enter(回车键) 或者j</li>
<li>向前翻一行：k</li>
</ul>
</li>
<li>查找：
<ul>
<li><code>/KEYWORD</code>: 向后查找</li>
<li><code>?KEYWORD</code>:  向前查找</li>
<li>在进入查找模式之后：
<ul>
<li>N：前一个</li>
<li>n：下一个</li>
</ul>
</li>
</ul>
</li>
<li>退出：q</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%93%E6%9D%9F%E6%A0%87%E5%BF%97%E5%88%B0Linux%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%93%E6%9D%9F%E6%A0%87%E5%BF%97%E5%88%B0Linux%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/index.html" class="post-title-link" itemprop="url">C语言-从字符串结束标志到Linux进程的内存分配</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-01 16:55:28" itemprop="dateCreated datePublished" datetime="2021-06-01T16:55:28+08:00">2021-06-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:29:23" itemprop="dateModified" datetime="2022-09-17T19:29:23+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">专业基础</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="c语言-从字符串结束标志到linux进程的内存分配"><a class="markdownIt-Anchor" href="#c语言-从字符串结束标志到linux进程的内存分配"></a> C语言-从字符串结束标志到Linux进程的内存分配</h1>
<h2 id="字符串结束标志"><a class="markdownIt-Anchor" href="#字符串结束标志"></a> 字符串结束标志</h2>
<ul>
<li>众所周知（除了本人）C语言中字符串的实质就是一个字符数组，但是字符串这个字符数组有点特殊，它的最后一位一定是<code>'\0'</code>（即空字符）用来标识字符串的结束。</li>
<li>C语言最令人头痛事情之一访问越界，特别是数组访问越界，如果发生了是什么样子？答案马上揭晓。。。</li>
</ul>
<h2 id="错误示范"><a class="markdownIt-Anchor" href="#错误示范"></a> 错误示范</h2>
<ul>
<li>尘封已久的C语言现在被我拿来干了啥可悲的事情呢？</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

&#x2F;&#x2F;整个程序的目的是依次读入16位的数（4个16进制数），然后累加，中途结果超出16位则去掉最高位再在末尾加一，如果读取的数不够4位16进制数，则在末尾补零到4位
int main(int argc, char *argv[]) &#123;
    u_int32_t sum &#x3D; 0;

    char *data &#x3D; argv[1];
    char temp[4];
    int i &#x3D; 0;
    int flag &#x3D; 0;
    while(data[i] !&#x3D; &#39;\0&#39; &amp;&amp; flag &#x3D;&#x3D; 0) &#123;
        for(int j &#x3D; 0; j &lt; 4; j++) &#123;
            if(data[i + j] !&#x3D; &#39;\0&#39;) &#123;
                temp[j] &#x3D; data[i + j];
            &#125; else &#123;
                &#x2F;&#x2F;错误点：如果还差2位才到4位，那么第一次读到&#39;\0&#39;之后的一次循环在干什么呢？那岂不是直接超出数组边界，在访问一个未定义的空间
                    temp[j] &#x3D; &#39;0&#39;;     
                    flag &#x3D; 1;
            &#125;
        &#125;
        if(flag &#x3D;&#x3D; 0) &#123;
            i &#x3D; i  + 4;
        &#125;
        sum +&#x3D; strtol(temp, NULL, 16);
        if(sum &gt; 0xFFFF) &#123;
            sum &#x3D; sum - 0x10000 + 0x0001;
        &#125;
    &#125;
     &#x2F;&#x2F;测试越界后得到的最后四位字符是什么
     printf(&quot;最后四位字符：&quot;);
     for(i &#x3D; 0; i &lt; 4; i++) &#123;
             printf(&quot;%c&quot;,temp[i]);
     &#125; 
     printf(&quot;\n&quot;);
    u_int16_t checksum &#x3D; ~sum;
    printf(&quot;%04x\n&quot;, checksum);
&#125;</code></pre>
<ul>
<li>我这个铁憨憨不仅忘了字符串只有最后一位是<code>'\0'</code>，而且还很自然地实现了越界访问（菜，是一种怎样的忧伤）。</li>
<li>看一看越界后会有什么效果：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/J5zLVA.png" alt="J5zLVA" />
<ul>
<li>所以T和E是两个什么玩意儿？虽然它们很不正常，但是为什么每次越界后得到的都是T和E？越界之后的结果不应该是随机的？</li>
<li>本次测试使用的是MacOS操作系统，clang 11.0.0编译器</li>
</ul>
</li>
</ul>
<h2 id="探索越界之谜"><a class="markdownIt-Anchor" href="#探索越界之谜"></a> 探索越界之谜</h2>
<h3 id="编译器"><a class="markdownIt-Anchor" href="#编译器"></a> 编译器</h3>
<ul>
<li>首先怀疑的是越界之后的结果和不同的编译器有关，因为每次越界的结果都一样。</li>
<li>MacOS虽然明面上使用的是gcc命令编译，但是实质上用的是clang（LLVM clang）。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/jbwrRj.png" alt="jbwrRj" /></li>
<li>对于当前主流桌面操作系统而言，可使用 Visual C++、GCC 以及 LLVM Clang 这三大编译器。
<ul>
<li>Visual C++（简称 MSVC）是由微软开发的，只能用于 Windows 操作系统；</li>
<li>GCC 和 LLVM Clang 除了可用于 Windows 操作系统之外，主要用于 Unix/Linux 操作系统。</li>
</ul>
</li>
<li>给Mac电脑装一个真正的gcc试试：(<code>brew install gcc</code>)<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/Bh7lSd.png" alt="Bh7lSd" />
<ul>
<li>用gcc编译之后再运行：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/h0YSc8.png" alt="h0YSc8" /></li>
<li>结果竟然一模一样！难道不是编译器不同导致的!</li>
</ul>
</li>
</ul>
<h3 id="越界之后的结果查看"><a class="markdownIt-Anchor" href="#越界之后的结果查看"></a> 越界之后的结果查看</h3>
<ul>
<li>之所以怀疑是编译器的问题主要是之前认为编译器会自动识别程序的越界访问，然后用一些固定的字符来提示用户，现在恍然大悟，我怕是想多了。（我的专业课可能上了个寂寞）</li>
<li>打印越界之后的更多信息试一试：</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

&#x2F;&#x2F;整个程序的目的是依次读入16位的数（4个16进制数），然后累加，中途结果超出16位则去掉最高位再在末尾加一，如果读取的数不够4位16进制数，则在末尾补零到4位
int main(int argc, char *argv[]) &#123;
    u_int32_t sum &#x3D; 0;

    char *data &#x3D; argv[1];
    char temp[4];
    int i &#x3D; 0;
    int flag &#x3D; 0;
    while(data[i] !&#x3D; &#39;\0&#39; &amp;&amp; flag &#x3D;&#x3D; 0) &#123;
        for(int j &#x3D; 0; j &lt; 4; j++) &#123;
            if(data[i + j] !&#x3D; &#39;\0&#39;) &#123;
                temp[j] &#x3D; data[i + j];
            &#125; else &#123;
                &#x2F;&#x2F;错误点：如果还差2位才到4位，那么第一次读到&#39;\0&#39;之后的一次循环在干什么呢？那岂不是直接超出数组边界，在访问一个未定义的空间
                &#x2F;**打印越界之后的信息**&#x2F;
		    printf(&quot;%dover%d:%s\n&quot;,i, j,&amp;data[i+j]);
		    printf(&quot;%dvaluei%d:%c\n&quot;,i, j,data[i+j]);
                    temp[j] &#x3D; &#39;0&#39;;     
                    flag &#x3D; 1;
            &#125;
        &#125;
            &#x2F;**打印越界之后的信息**&#x2F;
		    printf(&quot;%dover4:%s\n&quot;, i ,&amp;data[i+4]);
		    printf(&quot;%dvalue4:%c\n&quot;,i, data[i+4]);
		    printf(&quot;%dover5:%s\n&quot;, i, &amp;data[i+5]);
		    printf(&quot;%dvalue5:%c\n&quot;,i, data[i+5]);
		    printf(&quot;%dover6:%s\n&quot;,i,  &amp;data[i+6]);
		    printf(&quot;%dvalue6:%c\n&quot;,i, data[i+6]);
		    printf(&quot;%dover7:%s\n&quot;,i, &amp;data[i+7]);
		    printf(&quot;%dvalue7:%c\n&quot;,i,data[i+7]);

        if(flag &#x3D;&#x3D; 0) &#123;
            i &#x3D; i  + 4;
        &#125;
        sum +&#x3D; strtol(temp, NULL, 16);
        if(sum &gt; 0xFFFF) &#123;
            sum &#x3D; sum - 0x10000 + 0x0001;
        &#125;
    &#125;
     &#x2F;&#x2F;测试越界后得到的最后四位字符是什么
     printf(&quot;最后四位字符：&quot;);
     for(i &#x3D; 0; i &lt; 4; i++) &#123;
             printf(&quot;%c&quot;,temp[i]);
     &#125; 
     printf(&quot;\n&quot;);
    u_int16_t checksum &#x3D; ~sum;
    printf(&quot;%04x\n&quot;, checksum);
&#125;</code></pre>
<ul>
<li>运行结果如图：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/rnHYOO.png" alt="rnHYOO" /></li>
<li>真是拨云见日，在data数组之后存放的是一个字符串<code>TERM_SESSION_ID=w0t0p0:6389D1E3-6A5A-4F0C-9AAB-7BBF04CC0875</code>,每次越界之后读取的就是这个字符串中的内容了，T和E这两个奇怪的东西就是这样来的。</li>
<li>但是还有一个问题，为什么每次运行程序的结果都一样，我的data数组紧邻的为什么就一定是这个奇怪的字符串。</li>
</ul>
<h3 id="linux的全局环境变量"><a class="markdownIt-Anchor" href="#linux的全局环境变量"></a> Linux的全局环境变量</h3>
<ul>
<li>使用<code>printenv</code>或<code>env</code>命令可以查看linux的全局环境变量（mac也适用),部分全局环境变量截图如下：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/BSX2O1.png" alt="BSX2O1" /></li>
<li>全局变量的第一条便是<code>TERM_SESSION_ID=w0t0p0:6389D1E3-6A5A-4F0C-9AAB-7BBF04CC0875</code>，看来我们越界之后极有可能访问到来存储全局环境变量字符串的空间。</li>
<li>感觉有点不放心，在网上看了一种能直接在程序内查看当前进程环境变量的方法：</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

&#x2F;&#x2F;整个程序的目的是依次读入16位的数（4个16进制数），然后累加，中途结果超出16位则去掉最高位再在末尾加一，如果读取的数不够4位16进制数，则在末尾补零到4位
int main(int argc, char *argv[]) &#123;

    &#x2F;&#x2F;。。。
    &#x2F;&#x2F;省略原来的代码
    &#x2F;&#x2F; ...

    &#x2F;&#x2F;查看当前进程的环境变量
    printf(&quot;-------------------------\n&quot;);
    extern char **environ;
    for(int i &#x3D; 0; environ[i]!&#x3D; NULL; i++)&#123;
  	 printf(&quot;%s\n&quot;,environ[i]);
   &#125;
   return 0;
&#125;</code></pre>
<ul>
<li>结果：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/ZNXP0L.png" alt="ZNXP0L" />
<ul>
<li>也出现了<code>TERM_SESSION_ID=w0t0p0:6389D1E3-6A5A-4F0C-9AAB-7BBF04CC0875</code>而且也在第一个。</li>
<li>当前进程的环境变量应该是继承而来的。</li>
</ul>
</li>
</ul>
<h3 id="linux的内存分配"><a class="markdownIt-Anchor" href="#linux的内存分配"></a> Linux的内存分配</h3>
<ul>
<li>通过前面的尝试发现，在我定义的数组之后应该存储的是进程的环境变量。所以，linux中，一个进程的内存究竟是如何组织的？</li>
<li>进程的内存组织：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/h0oHPe.png" alt="h0oHPe" /></li>
<li>如果是按照这种组织，那么我在进程运行时创建的数组应该在堆中，那么才有可能访问到紧邻的静态数据。堆的数据一般是通过malloc分配的。</li>
<li>不太确定这种方式定义的数组是在堆中分配的，将我们的数组用malloc分配试一试。
<ul>
<li>原来：</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">char *data &#x3D; argv[1]</code></pre>
<ul>
<li>使用malloc动态分配：</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">char *data &#x3D; (char *)malloc(sizeof(argv[1]));
data &#x3D; argv[1];</code></pre>
</li>
</ul>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/ZH5ILP.png" alt="ZH5ILP" /></p>
<ul>
<li>结果和原来一模一样，越界之后依然是<code>TERM_SESSION_ID=w0t0p0:6389D1E3-6A5A-4F0C-9AAB-7BBF04CC0875</code>。那么证明了，我创建的字符数组，是存放在堆中的。</li>
<li>哪些数据存放在哪些位置：
<ul>
<li><code>.text</code>（代码)段：程序源代码编译后得到的机器指令放在这个地方。也就是说是它是可执行程序在内存中的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，而不允许写入（修改）操作——它是不可写的。</li>
<li><code>.data</code>:数据段用来存放可执行文件中已初始化全局变量，换句话说就是存放程序已初始化的局部静态分配的变量和全局变量。</li>
<li><code>.bss</code>: 为未初始化的全局变量和局部静态变量预留位置。在内存中的bss段全部置零。</li>
<li><strong>堆（heap）</strong>：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。</li>
<li><strong>栈（stack）</strong>：栈是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</li>
<li><strong>共享库的内存映射区域</strong>：存放一些共享的对象，如动态链接库。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/r2gQFe.png" alt="r2gQFe" /></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%91%BD%E4%BB%A4/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%91%BD%E4%BB%A4/index.html" class="post-title-link" itemprop="url">搜索引擎命令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-25 08:02:19" itemprop="dateCreated datePublished" datetime="2021-05-25T08:02:19+08:00">2021-05-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:41:21" itemprop="dateModified" datetime="2022-09-17T19:41:21+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">杂技术</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="搜索引擎命令"><a class="markdownIt-Anchor" href="#搜索引擎命令"></a> 搜索引擎命令</h1>
<h2 id="双引号"><a class="markdownIt-Anchor" href="#双引号"></a> 双引号</h2>
<ul>
<li>把搜索词放在双引号中，代表完全匹配搜索，也就是说搜索结果返回的页面包含双引号中出现的所有的词，连顺序也必须完全匹配。</li>
<li>bd和Google 都支持这个指令。</li>
<li>例如搜索： “seo方法图片”</li>
</ul>
<h2 id="减号"><a class="markdownIt-Anchor" href="#减号"></a> 减号</h2>
<ul>
<li>减号代表搜索不包含减号后面的词的页面。</li>
<li>使用这个指令时减号前面必须是空格，减号后面没有空格，紧跟着需要排除的词。</li>
<li>Google 和bd都支持这个指令。</li>
<li>例如：搜索 -引擎</li>
<li>返回的则是包含“搜索”这个词，却不包含“引擎”这个词的结果</li>
</ul>
<h2 id="星号"><a class="markdownIt-Anchor" href="#星号"></a> 星号</h2>
<ul>
<li>星号*是常用的通配符，也可以用在搜索中。</li>
<li>百度不支持<code>*</code>号搜索指令。</li>
<li>比如在Google 中搜索：搜索*擎</li>
<li>其中的<code>*</code>号代表任何文字。返回的结果就不仅包含“搜索引擎”，还包含了“搜索收擎”，“搜索巨擎”等内容。</li>
</ul>
<h2 id="inurl"><a class="markdownIt-Anchor" href="#inurl"></a> inurl</h2>
<ul>
<li>指令用于搜索查询词出现在url 中的页面。</li>
<li>bd和Google 都支持inurl 指令。</li>
<li>inurl 指令支持中文和英文。</li>
<li>比如搜索：inurl:搜索引擎优化</li>
<li>返回的结果都是网址url 中包含“搜索引擎优化”的页面。由于关键词出现在url 中对排名有一定影响，使用inurl:搜索可以更准确地找到竞争对手。</li>
</ul>
<h2 id="inanchor"><a class="markdownIt-Anchor" href="#inanchor"></a> inanchor</h2>
<ul>
<li>指令返回的结果是导入链接锚文字中包含搜索词的页面。</li>
<li>百度不支持inanchor。</li>
<li>比如在Google 搜索 ：inanchor:点击这里返回的结果页面本身并不一定包含“点击这里”这四个字，而是指向这些页面的链接锚文字中出现了“点击这里”这四个字。</li>
<li>可以用来找到某个关键词的竞争对手，而且这些竞争对手往往是做过SEO 的。</li>
<li>研究竞争对手页面有哪些外部链接，就可以找到很多链接资源。</li>
</ul>
<h2 id="intitle"><a class="markdownIt-Anchor" href="#intitle"></a> intitle</h2>
<ul>
<li>指令返回的是页面title 中包含关键词的页面。</li>
<li>Google 和bd都支持intitle 指令。</li>
<li>使用intitle 指令找到的文件是更准确的竞争页面。</li>
<li>如果关键词只出现在页面可见文字中，而没有出现在title 中，大部分情况是并没有针对关键词进行优化，所以也不是有力的竞争对手。</li>
</ul>
<h2 id="allintitle"><a class="markdownIt-Anchor" href="#allintitle"></a> allintitle</h2>
<ul>
<li>搜索返回的是页面标题中包含多组关键词的文件。</li>
<li>例如 ：allintitle:SEO 搜索引擎优化</li>
<li>就相当于：intitle:SEO intitle:搜索引擎优化</li>
<li>返回的是标题中中既包含“SEO”，也包含“搜索引擎优化”的页面</li>
</ul>
<h2 id="allinurl"><a class="markdownIt-Anchor" href="#allinurl"></a> allinurl</h2>
<ul>
<li>与allintitle: 类似。</li>
<li>allinurl:SEO 搜索引擎优化</li>
<li>就相当于 ：inurl:SEO inurl:搜索引擎优化</li>
</ul>
<h2 id="filetype"><a class="markdownIt-Anchor" href="#filetype"></a> filetype</h2>
<ul>
<li>用于搜索特定文件格式。</li>
<li>Google 和bd都支持filetype 指令。</li>
<li>比如搜索filetype:pdf SEO</li>
<li>返回的就是包含SEO 这个关键词的所有pdf 文件。</li>
</ul>
<h2 id="site"><a class="markdownIt-Anchor" href="#site"></a> site</h2>
<ul>
<li>是SEO 最熟悉的高级搜索指令，用来搜索某个域名下的所有文件。</li>
<li>注意事项：
<ul>
<li>site:后边跟的冒号必须是英文的“:”，中文的全角冒号“：”无用</li>
<li>网址前不能带“http://”</li>
<li>网址后边不能带斜杠“/”，其实是哪里都不能带“/”</li>
<li>网址中不要用“www”，除非你有特别目的，用“www”会导致错过网站内的内容，因为很多网站的频道是没有“www”的</li>
</ul>
</li>
</ul>
<h2 id="linkdomain"><a class="markdownIt-Anchor" href="#linkdomain"></a> linkdomain</h2>
<ul>
<li>指令只适用于雅虎，返回的是某个域名的反向链接。雅虎的反向链接数据还比较准确，是SEO 人员研究竞争对手外部链接情况的重要工具之一。</li>
<li>比如搜索linkdomain:<a target="_blank" rel="noopener" href="http://cnseotool.com">http://cnseotool.com</a> -site:<a target="_blank" rel="noopener" href="http://cnseotool.xn--com-bk2ek92ajye73gm3id1f4u4a9doda488b2umj0qvm0ecso">http://cnseotool.com得到的就是点石网站的外部链接</a>，因为-site:<a target="_blank" rel="noopener" href="http://cnseotool.com">http://cnseotool.com</a> 已经排除了点石本身的页面，也就是内部链接，剩下的就都是外部链接了。</li>
</ul>
<h2 id="related"><a class="markdownIt-Anchor" href="#related"></a> related</h2>
<ul>
<li>指令只适用于Google，返回的结果是与某个网站有关联的页面。比如搜索related:<a target="_blank" rel="noopener" href="http://cnseotool.com">http://cnseotool.com</a>,我们就可以得到Google 所认为的与点石网站有关联的其他页面。</li>
<li>这种关联到底指的是什么，Google 并没有明确说明，一般认为指的是有共同外部链接的网站。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Linux/Arch/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Linux/Arch/index.html" class="post-title-link" itemprop="url">Arch</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-07 09:37:25" itemprop="dateCreated datePublished" datetime="2021-03-07T09:37:25+08:00">2021-03-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:27:52" itemprop="dateModified" datetime="2022-09-17T19:27:52+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="arch虚拟机安装"><a class="markdownIt-Anchor" href="#arch虚拟机安装"></a> Arch虚拟机安装</h1>
<p><a target="_blank" rel="noopener" href="https://wiki.archlinux.org/index.php/Installation_guide">参考Archwiki</a></p>
<ol>
<li>在<a target="_blank" rel="noopener" href="https://archlinux.org/download/">官网</a>选择一个镜像源下载iso文件。</li>
<li>在VMware安装iso镜像；</li>
<li>启动虚拟机后，经过一会儿的等待，会自动进入命令行界面；</li>
<li>arch安装需要连接网络，检查网络是否畅通，可使用<code>ping</code>命令：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210307094657.png" alt="" /></li>
<li>更新系统时间：<code>timedatectl set-ntp true</code></li>
<li>检查引导模式：<code>ls /sys/firmware/efi/efivars</code>
<ol>
<li>如果显示目录，则是EFI模式；</li>
<li>如果有错，不显示，则是BIOS模式<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210307101020.png" alt="" /></li>
</ol>
</li>
<li>分区：
<ol>
<li>查看目前分区情况:<code>fdisk -l</code><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210307101409.png" alt="" /></li>
<li>创建分区：`fdisk /dev/sda<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210307102000.png" alt="" /></li>
<li>格式化分区：
<ol>
<li>格式化swap分区，并启动：<code>mkswap /dev/sda1</code>,<code>swapon /dev/sda1</code><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210307102440.png" alt="" /></li>
<li>将另外一个大容量的分区，格式化为ETX4格式,并挂载到<code>/mnt</code>目录：<code>mkfs.ext4 /dev/sda2</code>,<code>mount /dev/sda2 /mnt</code></li>
</ol>
</li>
</ol>
</li>
<li>安装软件包：
<ol>
<li>配置镜像源：暂时省略,因为现在在live环境中使用reflector进行镜像的管理，貌似你一连接网络，live系统会自动执行reflector命令来帮你选择镜像源，默认的是根据下载速率进行排序，</li>
<li>安装基本包：<code>pacstrap /mnt base linux linux-firmware</code>，
<ol>
<li>这里要注意的是，上面的命令并不包括所有的基本程序，如网络管理程序、文本编辑器等，如果你想安装这些程序，可以将名字添加到pacstrap后，并用空格隔开。你也可以在Chroot进新系统后使用<code>pacman</code>手动安装软件包或组。</li>
</ol>
</li>
</ol>
</li>
<li>配置系统:
<ol>
<li>生成自动挂载分区的fstab文件:<code>genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</code><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210307105154.png" alt="" /></li>
<li>切换到新系统,Chroot意为Change root，相当于把操纵权交给我们新安装（或已经存在）的Linux系统，执行了这步以后，我们的操作都相当于在磁盘上新装的系统中进行。<code>arch-chroot /mnt</code><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210307105356.png" alt="" /></li>
<li>更改时区，依次执行如下命令设置我们的时区为上海并生成相关文件：<code>ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code>,<code>hwclock --systohc</code></li>
<li>安装一个vim，便于之后的操作：<code>pacman -S vim</code></li>
<li>设置Locale，即语言选项,执行如下命令来编辑/etc/locale.gen文件：<code>vim /etc/locale.gen</code>
<ol>
<li>在文件中找到<code>en_US.UTF-8 UTF-8</code>,<code>zh_CN.UTF-8 UTF-8</code>,<code>zh_HK.UTF-8 UTF-8</code>,<code>zh_TW.UTF-8 UTF-8</code> 这四行，去掉行首的#号，保存并退出。</li>
<li>然后执行：<code>locale-gen</code></li>
<li>打开（不存在时会创建）<code>/etc/locale.conf</code>文件,在文件的第一行加入以下内容：<code>LANG=en_US.UTF-8</code></li>
</ol>
</li>
<li>网络配置：
<ol>
<li>设置主机名：打开/etc/hostname文件,在文件的第一行输入你自己设定的一个myhostname(我的是zestaken)</li>
<li>编辑<code>etc/hosts</code>文件，在文件末添加如下内容：</li>
</ol>
 <pre class="line-numbers language-none"><code class="language-none">127.0.0.1	localhost
::1		    localhost
127.0.1.1	myhostname.localdomain	myhostname</code></pre>
<ol start="3">
<li>安装dhcpcd,dhcpd 是 Internet Systems Consortium DHCP 的服务，它被用作局域网环境中的路由管理。<code>pacman -S dhcpcd</code></li>
<li>启动dhcpcd服务：<code>systemctl enable dhcpcd.service</code></li>
</ol>
</li>
<li>设置ROOT用户密码：
<ol>
<li><code>#</code>代表以Root用户执行命令，``$代表以普通用户执行命令</li>
<li>通过<code>passwd</code>设置ROOT密码，我设置的是<code>1</code>.</li>
</ol>
</li>
<li>安装引导工具Grub2:
<ol>
<li>首先安装os-prober和ntfs-3g这两个包，它可以配合Grub检测已经存在的系统，自动设置启动选项:<code>pacman -S os-prober ntfs-3g</code></li>
<li>如果为BIOS/MBR引导方式:
<ol>
<li>安装grub包：<code>pacman -S grub</code></li>
<li>部署grub：<code>grub-install --target=i386-pc /dev/sdx</code> （将sdx换成你安装的硬盘）注意这里的sdx应该为硬盘（例如/dev/sda），而不是形如/dev/sda1这样的分区。</li>
<li>生成配置文件：<code>grub-mkconfig -o /boot/grub/grub.cfg</code></li>
</ol>
</li>
</ol>
</li>
<li>退出新安装好的系统：<code>exit</code></li>
<li>写在已经挂载好的分区：<code>umount -R /mnt</code></li>
<li>重启:<code>reboot</code></li>
<li>再次打开会有如下页面,输入root，再输入之前设置的密码，显示出命令提示符，恭喜你，你已经成功安装ArchLinux！<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210307113916.png" alt="" /></li>
</ol>
</li>
</ol>
<h1 id="美化arch"><a class="markdownIt-Anchor" href="#美化arch"></a> 美化Arch</h1>
<ul>
<li>安装xorg服务，xorg服务是linux桌面的硬件接口，所有的窗管都是x窗口的实现：<code>pacman -S xorg xterm xorg-xinit</code></li>
<li>安装显示管理器：显示管理器也就是Linux启动之后的启动界面。世界上有很多个显示管理器，这里使用sddm，一个不错的显示管理器。
<ul>
<li>安装：<code>pacman -S sddm</code></li>
<li>设置开机自启动：<code>systemctl enable sddm.service</code></li>
</ul>
</li>
<li>安装KDE（Plasma）桌面：
<ul>
<li><code>pacman -S plasma kde-applications</code></li>
</ul>
</li>
<li>重启之前先创建用户(使用默认设置）：<code>useradd -m username</code></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/SpringMVC/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/SpringMVC/index.html" class="post-title-link" itemprop="url">SpringMVC</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-04 09:35:32" itemprop="dateCreated datePublished" datetime="2021-03-04T09:35:32+08:00">2021-03-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:27:52" itemprop="dateModified" datetime="2022-09-17T19:27:52+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web后端</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>36k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>33 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="springmvc简介"><a class="markdownIt-Anchor" href="#springmvc简介"></a> SpringMVC简介</h1>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#spring-web">官方文档</a></p>
<ul>
<li>SpringMVC是一个web框架，围绕<code>DispatcherServlet</code>设计；</li>
<li>DispacherServelt的作用是将请求分发到不同的处理器。
<ul>
<li>DispatcherServlet是一个实际的Servlet，它继承自HttpServlet类。</li>
</ul>
</li>
<li>SpringMVC和许多其他的MVC框架一样，以请求为驱动，围绕一个中心servlet分派请求及提供其他功能。</li>
<li>传统MVC架构：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210307210022.png" alt="" /></li>
</ul>
<h1 id="springmvc执行原理"><a class="markdownIt-Anchor" href="#springmvc执行原理"></a> SpringMVC执行原理</h1>
<ul>
<li>SpringMVC核心架构：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210307210107.png" alt="" /></li>
</ul>
<h1 id="快速入门"><a class="markdownIt-Anchor" href="#快速入门"></a> 快速入门</h1>
<ol>
<li>建立一个web支持的项目；</li>
<li>配置maven的资源过滤问题：</li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;
                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;
            &lt;&#x2F;includes&gt;
            &lt;filtering&gt;false&lt;&#x2F;filtering&gt;
        &lt;&#x2F;resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;
                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;
            &lt;&#x2F;includes&gt;
            &lt;filtering&gt;false&lt;&#x2F;filtering&gt;
        &lt;&#x2F;resource&gt;
    &lt;&#x2F;resources&gt;
&lt;&#x2F;build&gt;</code></pre>
<ol start="3">
<li>导入相关依赖，主要是<code>spring-webmvc</code></li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;
    &lt;version&gt;5.3.3&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>
<ol start="4">
<li>配置web.xml
<ul>
<li>web.xml的版本要4.0及以上；</li>
<li>在项目结构中，将maven导入的依赖，全部导入到artifacts的依赖中去。</li>
<li>注册DispatchServlet,管理SpringMVC配置文件，设置启动级别为1，映射路径为<code>/</code></li>
</ul>
</li>
</ol>
  <pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
  &lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;
          xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
          xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;
          version&#x3D;&quot;4.0&quot;&gt;

      &lt;!-- 注册servlet --&gt;
      &lt;servlet&gt;
          &lt;servlet-name&gt;SpringMVC&lt;&#x2F;servlet-name&gt;
          &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;、
          &lt;!-- 通过初始化参数指定SpringMVC配置文件的位置，进行关联 --&gt;
          &lt;init-param&gt;
              &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;
              &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;&#x2F;param-value&gt;
          &lt;&#x2F;init-param&gt;
          &lt;!-- 启动顺序，数字越小，启动越早 --&gt;
          &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;
      &lt;&#x2F;servlet&gt;

      &lt;!-- 所有请求都会被springmvc拦截 --&gt;
      &lt;servlet-mapping&gt;
          &lt;servlet-name&gt;SpringMVC&lt;&#x2F;servlet-name&gt;
          &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;
      &lt;&#x2F;servlet-mapping&gt;
  &lt;&#x2F;web-app&gt;</code></pre>
<ol start="5">
<li>配置Springmvc-servlet.xml(web.xml关联的springmvc配置文件，放在resouce目录下)</li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;
       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;
       xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;
       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans
            https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd
            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context
            https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd&quot;&gt;


    &lt;context:annotation-config&#x2F;&gt;
    &lt;!--    自动扫描包，让指定包下的注解生效，由IOC容器统一管理--&gt;
    &lt;context:component-scan base-package&#x3D;&quot;com.zestaken.controller&quot;&#x2F;&gt;
    &lt;!--    让springmvc不处理静态资源，如.css .js .html .mp3 .mp4--&gt;
        &lt;mvc:default-servlet-handler&#x2F;&gt;

    &lt;!--    支持mvc注解驱动--&gt;
        &lt;mvc:annotation-driven&#x2F;&gt;

    &lt;!--    配置视图解析器--&gt;
        &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
            id&#x3D;&quot;internalResourceViewResolver&quot;&gt;
    &lt;!--        前缀--&gt;
            &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot;&#x2F;&gt;
    &lt;!--        后缀--&gt;
            &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt;
        &lt;&#x2F;bean&gt;
&lt;&#x2F;beans&gt;</code></pre>
<ul>
<li>在视图解析器中，将所有的视图都放在**/WEB-INF/**目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。</li>
</ul>
<ol start="6">
<li>创建controller：</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
@RequestMapping(&quot;&#x2F;HelloController&quot;)
public class HelloController &#123;
    
    &#x2F;&#x2F;真实访问地址就是：项目名&#x2F;HelloController&#x2F;hello1
    @RequestMapping(&quot;&#x2F;hello1&quot;)
    public String sayHello(Model model) &#123;
        &#x2F;&#x2F;向模型中添加属性msg与值，可以在jsp页面中取出并渲染
        model.addAttribute(&quot;msg&quot;, &quot;hello, springmvc&quot;);
        &#x2F;&#x2F;返回值代表视图：WEB-INF&#x2F;jsp&#x2F;hello.jsp
        return &quot;hello&quot;;
    &#125;
&#125;</code></pre>
<ul>
<li><code>@Controller</code>是为了让Spring IOC容器自动扫描到；被这个注解的类中的所有方法，如果返回值是String，并且有具体的页面可以操作，那么就会被视图解析器解析。#</li>
<li><code>@ResquestMapping</code>是为了映射请求路径，这里因为类与方法上都有映射，所以访问时应该是<code>HelloController/hello</code>(类上的映射可以不写)</li>
<li>方法中声明的Model类型的参数是为了把Action中的数据带到视图层中；</li>
<li>方法返回的结果是视图的名称hello，加上==配置文件中的前后缀==变成WEB-INF/jsp/hello.jsp</li>
</ul>
<ol start="7">
<li>创建视图层：<pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;
 &lt;html&gt;
 &lt;head&gt;
     &lt;title&gt;Title&lt;&#x2F;title&gt;
 &lt;&#x2F;head&gt;
 &lt;body&gt;
 &lt;h1&gt;$&#123;msg&#125;&lt;&#x2F;h1&gt;
 &lt;&#x2F;body&gt;
 &lt;&#x2F;html&gt;</code></pre>
</li>
<li>启动tomcat，访问/HelloController/hello1。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210307221352.png" alt="" /></li>
</ol>
<h1 id="restful风格"><a class="markdownIt-Anchor" href="#restful风格"></a> Restful风格</h1>
<ul>
<li>Restful风格：一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</li>
<li>REST即Representational State Transfer的缩写，可译为&quot;表现层状态转化”。REST最大的几个特点为：资源、统一接口、URI和无状态。</li>
<li>资源：互联网所有的事物都可以被抽象为资源 。</li>
<li>资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。 <br />
分别对应 添加、 删除、修改、查询。</li>
<li>传统方式操作资源：通过不同的参数来实现不同的效果，方法单一，都是GET或者POST。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;127.0.0.1&#x2F;item&#x2F;queryUser.action?id&#x3D;1   查询,GET 
http:&#x2F;&#x2F;127.0.0.1&#x2F;item&#x2F;saveUser.action             新增,POST 
http:&#x2F;&#x2F;127.0.0.1&#x2F;item&#x2F;updateUser.action          更新,POST 
http:&#x2F;&#x2F;127.0.0.1&#x2F;item&#x2F;deleteUser.action?id&#x3D;1  删除,GET或POST</code></pre>
<ul>
<li>使用RESTful操作资源 :
<ul>
<li>通过不同的请求方法来实现不同的效果。请求的地址一样，但是因为请求的方式不同，实现的功能不同。
<ul>
<li>可以通过 GET、 POST、 PUT、 PATCH、 DELETE 等方式对服务端的资源进行操作。其中，GET 用于查询资源，POST 用于创建资源，PUT 用于更新服务端的资源的全部信息，PATCH 用于更新服务端的资源的部分信息，DELETE 用于删除服务端的资源。</li>
</ul>
</li>
<li>同时隐藏了参数的传递，直接将参数写入到地址中，隐藏了参数名。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">【GET】 &#x2F;users # 查询用户信息列表

【GET】 &#x2F;users&#x2F;1001 # 查看某个用户信息（其中1001就是要用到方法中的参数）

【POST】 &#x2F;users # 新建用户信息

【PUT】 &#x2F;users&#x2F;1001 # 更新用户信息(全部字段)

【PATCH】 &#x2F;users&#x2F;1001 # 更新用户信息(部分字段)

【DELETE】 &#x2F;users&#x2F;1001 # 删除用户信息</code></pre>
<ul>
<li>传统方法实现示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class HelloController &#123;

    @RequestMapping(&quot;&#x2F;hello1&quot;)
    public String sayHello(int a, int b,Model model) &#123;
        int res &#x3D; a + b;
        model.addAttribute(&quot;msg&quot;, &quot;输出结果为：&quot;+res);
        return &quot;hello&quot;;
    &#125;
&#125;</code></pre>
<ul>
<li>请求这个方法的路径：<code>http://localhost:8080/SpringMVC_war_exploded/hello1?a=1&amp;b=2</code></li>
<li>Restful风格实现示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;

@Controller
public class HelloController &#123;

&#x2F;&#x2F;    @RequestMapping(value &#x3D; &quot;&#x2F;hello1&#x2F;&#123;a&#125;&#x2F;&#123;b&#125;&quot;,method &#x3D; RequestMethod.GET)
    @GetMapping(&quot;&#x2F;hello&#x2F;&#123;a&#125;&#x2F;&#123;b&#125;&quot;)
    public String GETHello(@PathVariable int a, @PathVariable int b, Model model) &#123;
        int res &#x3D; a - b;
        model.addAttribute(&quot;msg&quot;, &quot;GET输出结果为：&quot;+res);
        return &quot;hello&quot;;
    &#125;

    @PostMapping(&quot;&#x2F;hello&#x2F;&#123;b&#125;&#x2F;&#123;a&#125;&quot;)
    public String POSTHello(@PathVariable int a, @PathVariable int b, Model model) &#123;
        int res &#x3D; a - b;
        model.addAttribute(&quot;msg&quot;, &quot;POST输出结果为：&quot;+res);
        return &quot;hello&quot;;
    &#125;
&#125;
&#125;</code></pre>
<ul>
<li>将参数的传递放到路径中去：
<ul>
<li>方法的参数必须加上<code>@PathVariable</code>注解</li>
<li>方法的路径中，必须对应方法的参数(名称相同，<code>&#123;a&#125;</code>对应参数<code>int a</code>)，并且用花括号括起来。</li>
</ul>
</li>
<li>限制不同的请求方法，只能使用不同的方法
<ul>
<li>一种方法是给<code>@RequestMapping</code>注解加上method参数</li>
<li>一种方法是使用对应请求方法特有的map注解,如，GEI方法对应的<code>@GETMapping</code>注解。</li>
</ul>
</li>
<li>请求GETHello的请求路径：<code>http://localhost:8080/SpringMVC_war_exploded/hello/1/2</code>
<ul>
<li>路径中的参数必须与参数的类型对应。</li>
<li>请求生效必须采用GET方法。</li>
</ul>
</li>
</ul>
<h1 id="重定向和转发"><a class="markdownIt-Anchor" href="#重定向和转发"></a> 重定向和转发</h1>
<ul>
<li>法一： ModelAndView对象：设置该对象，根据view的名称，和视图解析器跳转到指定的页面。
<ul>
<li>视图解析器配置示例：</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!--    配置视图解析器--&gt;
     &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
         id&#x3D;&quot;internalResourceViewResolver&quot;&gt;
 &lt;!--        前缀--&gt;
         &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot;&#x2F;&gt;
 &lt;!--        后缀--&gt;
         &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt;
     &lt;&#x2F;bean&gt;
 &lt;&#x2F;beans&gt;</code></pre>
<ul>
<li>页面位置：视图解析器的前缀 + viewName + 视图解析器后缀。</li>
<li>高级写法中，ModelAndView对象简化为了Model对象：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">  @RequestMapping(&quot;&#x2F;hello1&quot;)
public String sayHello(int a, int b,Model model) &#123;
    int res &#x3D; a + b;
    model.addAttribute(&quot;msg&quot;, &quot;输出结果为：&quot;+res);
    return &quot;hello&quot;;
&#125;</code></pre>
<ul>
<li>在路径前面加上转发或者重定向的前缀，可以实现转发或者重定向（如果不加，==默认是转发==）：</li>
</ul>
  <pre class="line-numbers language-java" data-language="java"><code class="language-java">      @RequestMapping(&quot;&#x2F;hello1&quot;)
public String sayHello(int a, int b,Model model) &#123;
    int res &#x3D; a + b;
    model.addAttribute(&quot;msg&quot;, &quot;输出结果为：&quot;+res);
    &#x2F;&#x2F;重定向
    return &quot;redirect:hello&quot;;
&#125;</code></pre>
</li>
<li>法二：==不使用视图解析器==，直接使用SpringMvc实现
<ul>
<li>这种情况下，需要将页面的位置具体出来。</li>
</ul>
  <pre class="line-numbers language-java" data-language="java"><code class="language-java">      @RequestMapping(&quot;&#x2F;hello1&quot;)
public String sayHello(int a, int b,Model model) &#123;
    int res &#x3D; a + b;
    model.addAttribute(&quot;msg&quot;, &quot;输出结果为：&quot;+res);
    return &quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;hello.jsp&quot;;
&#125;</code></pre>
<pre><code>  * 默认是转发；
  * 可以在路径前面加前缀，来分别实现转发和重定向。
  * 如：
</code></pre>
  <pre class="line-numbers language-java" data-language="java"><code class="language-java">      @RequestMapping(&quot;&#x2F;hello1&quot;)
public String sayHello(int a, int b,Model model) &#123;
    int res &#x3D; a + b;
    model.addAttribute(&quot;msg&quot;, &quot;输出结果为：&quot;+res);
    &#x2F;&#x2F;转发
     return &quot;forward:&#x2F;WEB-INF&#x2F;jsp&#x2F;hello.jsp&quot;;
&#125;
      @RequestMapping(&quot;&#x2F;hello1&quot;)
public String sayHello(int a, int b,Model model) &#123;
    int res &#x3D; a + b;
    model.addAttribute(&quot;msg&quot;, &quot;输出结果为：&quot;+res);
    &#x2F;&#x2F;重定向(重定向好像不能访问WEB-INF文件夹下的内容)
     return &quot;redirect:&#x2F;index.jsp&quot;;
&#125;</code></pre>
</li>
</ul>
<h1 id="接收请求参数和数据回显"><a class="markdownIt-Anchor" href="#接收请求参数和数据回显"></a> 接收请求参数和数据回显</h1>
<ul>
<li>基本接收参数方式：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
@RequestMapping(&quot;&#x2F;user&quot;)
public class UserController &#123;

    &#x2F;&#x2F;请求示例：localhost:8080&#x2F;user&#x2F;t1 ? name &#x3D; zhangjie
    @GetMapping(&quot;&#x2F;t1&quot;)
    public String test1(String name, Model model) &#123;

        &#x2F;&#x2F;name接收到前端传进来的参数name
        System.out.println(name);

        &#x2F;&#x2F;将要传给前端的结果封装到Model对象中，返回给前端
        model.addAttribute(name);

        &#x2F;&#x2F;视图跳转
        return &quot;test&quot;;
    &#125;
&#125;</code></pre>
<ul>
<li>前端请求的参数必须与函数的形参名相同才行。</li>
<li>可以在需要从前端接收的参数名前加上<code>@RequestParam(&quot;前端传递的参数名&quot;)</code>来限定参数的性质。示例：</li>
</ul>
  <pre class="line-numbers language-java" data-language="java"><code class="language-java">public String test1(@RequestParam(&quot;username&quot;) String name, Model model) 
&#x2F;&#x2F;请求示例：localhost:8080&#x2F;user&#x2F;t1 ? username &#x3D; zhangjie</code></pre>
<ul>
<li>接收前端的参数：前端传递的参数可以==封装为一个对象==：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;实体类
package com.zestaken.pojo;

public class User &#123;
    public void setId(int id) &#123;
        this.id &#x3D; id;
    &#125;

    public void setName(String name) &#123;
        this.name &#x3D; name;
    &#125;

    public int getId() &#123;
        return id;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    private int id;
    private String name;

    @Override
    public String toString() &#123;
        return &quot;User&#123;&quot; +
                &quot;id&#x3D;&quot; + id +
                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;

&#x2F;&#x2F;controller类
@Controller
@RequestMapping(&quot;&#x2F;user&quot;)
public class UserController &#123;

    &#x2F;&#x2F;请求示例：localhost:8080&#x2F;user&#x2F;t1 ? id &#x3D; 1 &amp;&amp; name &#x3D; zhangjie 
    @GetMapping(&quot;&#x2F;t1&quot;)
    public String test1(User user, Model model) &#123;

        &#x2F;&#x2F;name接收到前端传进来的参数user
        System.out.println(user.toString());

        &#x2F;&#x2F;将要传给前端的结果封装到Model对象中，返回给前端
        model.addAttribute(user.toString());

        &#x2F;&#x2F;视图跳转
        return &quot;test&quot;;
    &#125;
&#125;</code></pre>
<ul>
<li>接收前端用户传递的参数，判断参数的名字，==假设参数名字直接在方法的形参中定义了，可以直接使用==</li>
<li>假设方法中定义的形参是一个对象，则将前端传递的参数与对象中的属性名进行匹配，如果名字一致则将参数写到对象的属性中去，如果不一致匹配不到则该对象的该属性值为空。</li>
<li>回显结果到前端：通过ModelAndView对象实现</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.lang.annotation.Annotation;

public class Controller2 implements Controller &#123;
    public ModelAndView test1(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) &#123;
        ModelAndView modelAndView &#x3D; new ModelAndView();
        &#x2F;&#x2F;设置返回给前端的内容
        modelAndView.addObject(&quot;msg&quot;, &quot;controllertest&quot;);
        &#x2F;&#x2F;设置要响应的前端页面
        modelAndView.setViewName(&quot;test&quot;);
        return modelAndView;
    &#125;

    @Override
    public String value() &#123;
        return null;
    &#125;

    @Override
    public Class&lt;? extends Annotation&gt; annotationType() &#123;
        return null;
    &#125;
&#125;</code></pre>
<ul>
<li>需要实现Controller接口；</li>
<li>可以获取请求和响应的参数；</li>
<li>通过ModelAndView对象来设置响应给前端的结果，和具体的的前端页面。</li>
<li>回显结果到前端：通过Model对象来实现。</li>
<li>回显结果到前端：通过ModelMap来实现。</li>
<li>三种回显数据的方法的对比：
<ul>
<li>Model：只有几种方法，只适用于储存数据，是ModelMap的精简版；</li>
<li>ModelMap:继承了LinkedMap,除了实现了自身的一些方法，同样的继承LinkedMap方法和特性。功能更齐全。</li>
<li>ModelAndView:可以在储存数据的同时，进行设置返回的逻辑视图，进行控制展示层的跳转。</li>
</ul>
</li>
</ul>
<h1 id="后台乱码问题"><a class="markdownIt-Anchor" href="#后台乱码问题"></a> 后台乱码问题</h1>
<ul>
<li>在前端编码方式为utf-8的情况下，因为服务端的编码问题导致经由后台代码的中文输出为乱码。</li>
<li>解决方案：使用SpringMVC的乱码过滤器过滤器。</li>
<li>在<code>web.xml</code>中配置SpringMVC的乱码过滤器：</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;filter&gt;
    &lt;filter-name&gt;encoding&lt;&#x2F;filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;
        &lt;param-name&gt;utf-8&gt;&lt;&#x2F;param-name&gt;
    &lt;&#x2F;init-param&gt;
&lt;&#x2F;filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;encoding&lt;&#x2F;filter-name&gt;
    &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;
&lt;&#x2F;filter-mapping&gt;</code></pre>
<h1 id="ssm整合"><a class="markdownIt-Anchor" href="#ssm整合"></a> SSM整合</h1>
<ol>
<li>maven的pom.xml配置，导入相关依赖包</li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;
         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;

    &lt;groupId&gt;com.example&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;ssm&lt;&#x2F;artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;
    &lt;name&gt;ssm&lt;&#x2F;name&gt;
    &lt;packaging&gt;war&lt;&#x2F;packaging&gt;

    &lt;properties&gt;
        &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;
        &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt;
        &lt;junit.version&gt;5.6.2&lt;&#x2F;junit.version&gt;
    &lt;&#x2F;properties&gt;

&lt;!--    依赖：junit，数据库驱动，连接池，servlet，jsp，mybatis，mybatis-spring，spring servlet jsp jstl--&gt;
    &lt;dependencies&gt;
&lt;!--        web包--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;javaee-web-api&lt;&#x2F;artifactId&gt;
            &lt;version&gt;8.0.1&lt;&#x2F;version&gt;
            &lt;scope&gt;provided&lt;&#x2F;scope&gt;
        &lt;&#x2F;dependency&gt;
&lt;!--        junit--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.junit.jupiter&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;junit-jupiter-api&lt;&#x2F;artifactId&gt;
            &lt;version&gt;$&#123;junit.version&#125;&lt;&#x2F;version&gt;
            &lt;scope&gt;test&lt;&#x2F;scope&gt;
        &lt;&#x2F;dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.junit.jupiter&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;junit-jupiter-engine&lt;&#x2F;artifactId&gt;
            &lt;version&gt;$&#123;junit.version&#125;&lt;&#x2F;version&gt;
            &lt;scope&gt;test&lt;&#x2F;scope&gt;
        &lt;&#x2F;dependency&gt;

&lt;!--        mysql数据库驱动包， 数据库连接池c3p0--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;
            &lt;version&gt;8.0.23&lt;&#x2F;version&gt;
        &lt;&#x2F;dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.mchange&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;c3p0&lt;&#x2F;artifactId&gt;
            &lt;version&gt;0.9.5.2&lt;&#x2F;version&gt;
        &lt;&#x2F;dependency&gt;

&lt;!--        servlet jsp--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt;
            &lt;version&gt;2.5&lt;&#x2F;version&gt;
        &lt;&#x2F;dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt;
            &lt;version&gt;2.2&lt;&#x2F;version&gt;
        &lt;&#x2F;dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;jstl&lt;&#x2F;artifactId&gt;
            &lt;version&gt;1.2&lt;&#x2F;version&gt;
        &lt;&#x2F;dependency&gt;

&lt;!--        mybatis mybatis-spring--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;
            &lt;version&gt;3.5.6&lt;&#x2F;version&gt;
        &lt;&#x2F;dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt;
            &lt;version&gt;2.0.6&lt;&#x2F;version&gt;
        &lt;&#x2F;dependency&gt;

&lt;!--        spring依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;
            &lt;version&gt;5.3.3&lt;&#x2F;version&gt;
        &lt;&#x2F;dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;
            &lt;version&gt;5.3.4&lt;&#x2F;version&gt;
        &lt;&#x2F;dependency&gt;
    &lt;&#x2F;dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;
                &lt;artifactId&gt;maven-war-plugin&lt;&#x2F;artifactId&gt;
                &lt;version&gt;3.3.0&lt;&#x2F;version&gt;
            &lt;&#x2F;plugin&gt;
        &lt;&#x2F;plugins&gt;
&lt;!--        配置静态资源导出问题--&gt;
            &lt;resources&gt;
                &lt;resource&gt;
                    &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;
                    &lt;includes&gt;
                        &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;
                        &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;
                    &lt;&#x2F;includes&gt;
                    &lt;filtering&gt;false&lt;&#x2F;filtering&gt;
                &lt;&#x2F;resource&gt;
                &lt;resource&gt;
                    &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;
                    &lt;includes&gt;
                        &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;
                        &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;
                    &lt;&#x2F;includes&gt;
                    &lt;filtering&gt;false&lt;&#x2F;filtering&gt;
                &lt;&#x2F;resource&gt;
            &lt;&#x2F;resources&gt;
    &lt;&#x2F;build&gt;
&lt;&#x2F;project&gt;</code></pre>
<ol start="2">
<li>编写基本目录结构：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210312104652.png" alt="" /></li>
</ol>
<h2 id="一mybaits层编写"><a class="markdownIt-Anchor" href="#一mybaits层编写"></a> 一：mybaits层编写</h2>
<ol>
<li>
<p>连接数据库<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210311225308.png" alt="" /></p>
</li>
<li>
<p>编写mybatis层配置：</p>
<ol>
<li>mybatis-config.xml，并管理</li>
</ol>
</li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;
        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;
&lt;!-- 核心配置文件 --&gt;
&lt;configuration&gt;

&lt;!--    配置数据源的工作交给spring去做--&gt;
&lt;!--    &lt;properties resource&#x3D;&quot;db.properties&quot;&gt;--&gt;
&lt;!--        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;--&gt;
&lt;!--    &lt;&#x2F;properties&gt;--&gt;

&lt;!--    &lt;environments default&#x3D;&quot;development&quot;&gt;--&gt;
&lt;!--        &lt;environment id&#x3D;&quot;development&quot;&gt;--&gt;
&lt;!--            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;--&gt;
&lt;!--            &lt;!&amp;ndash;配置数据源&amp;ndash;&gt;--&gt;
&lt;!--            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;--&gt;
&lt;!--                &lt;!&amp;ndash;注册驱动，同jdbc&amp;ndash;&gt;--&gt;
&lt;!--                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt;--&gt;
&lt;!--                &lt;!&amp;ndash;数据库连接路径&amp;ndash;&gt;--&gt;
&lt;!--                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;--&gt;
&lt;!--                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;--&gt;
&lt;!--                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt;--&gt;
&lt;!--            &lt;&#x2F;dataSource&gt;--&gt;
&lt;!--        &lt;&#x2F;environment&gt;--&gt;
&lt;!--    &lt;&#x2F;environments&gt;--&gt;

&lt;!--    mybatis的配置文件中可以做配置别名等工作--&gt;
&lt;typeAliases&gt;
    &lt;package name&#x3D;&quot;com.zestaken.pojo&quot;&#x2F;&gt;
&lt;&#x2F;typeAliases&gt;
&lt;!--每一个Mapper.xml文件都需要在这个mybatis核心配置文件中注册--&gt;
&lt;mappers&gt;
    &lt;mapper resource&#x3D;&quot;com&#x2F;zestaken&#x2F;dao&#x2F;T_collegeMapper.xml&quot;&#x2F;&gt;
&lt;&#x2F;mappers&gt;
&lt;&#x2F;configuration&gt;</code></pre>
<ol start="3">
<li>编写数据库配置文件：database.properties</li>
</ol>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">jdbc.driver &#x3D; com.mysql.cj.Driver
# 如果使用的是MySQL8.0以上版本，需要加上一个时区配置:serverTimezone&#x3D;Asia&#x2F;Shanghai
jdbc.url &#x3D; jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;youth_study?serverTimezone&#x3D;Asia&#x2F;Shanghai
jdbc.usrname &#x3D; root
jdbc.password &#x3D; root</code></pre>
<ol start="4">
<li>编写实体类pojo：</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.pojo;

import java.sql.Date;

public class T_college &#123;
    private int id;
    private String name;
    private Date gmt_create;
    private Date gmt_modified;

    public int getId() &#123;
        return id;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public Date getGmt_create() &#123;
        return gmt_create;
    &#125;

    public Date getGmt_modified() &#123;
        return gmt_modified;
    &#125;

    public void setId(int id) &#123;
        this.id &#x3D; id;
    &#125;

    public void setName(String name) &#123;
        this.name &#x3D; name;
    &#125;

    public void setGmt_create(Date gmt_create) &#123;
        this.gmt_create &#x3D; gmt_create;
    &#125;

    public void setGmt_modified(Date gmt_modified) &#123;
        this.gmt_modified &#x3D; gmt_modified;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;T_college&#123;&quot; +
                &quot;id&#x3D;&quot; + id +
                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, gmt_create&#x3D;&quot; + gmt_create +
                &quot;, gmt_modified&#x3D;&quot; + gmt_modified +
                &#39;&#125;&#39;;
    &#125;
&#125;</code></pre>
<ul>
<li>属性名与数据库字段名相同；</li>
<li>并编写每个属性的getter和setter方法</li>
<li>编写toString方法</li>
<li><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210312110729.png" alt="" /></li>
<li>类名就是表名配合首字母大写</li>
</ul>
<ol start="5">
<li>编写操作数据库的方法（dao层）接口，命名为pojo实体类加Mapper，如：T_collegeMapper</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.dao;

import com.zestaken.pojo.T_college;
import org.apache.ibatis.annotations.Param;

import java.util.List;

public interface T_collegeMapper &#123;

    &#x2F;&#x2F;    增加一个学院
    int addCollege(T_college college);

    &#x2F;&#x2F;删除一个指定的学院
    int deleteCollege(@Param(&quot;collegeID&quot;) int id);

    &#x2F;&#x2F;更新一个学院的信息
    int updateCollege(T_college college);

    &#x2F;&#x2F;查询一个学院
    T_college queryCollege(@Param(&quot;collegeID&quot;) int id);

    &#x2F;&#x2F;查询全部的学院
    List&lt;T_college&gt; queryAllCollege();
&#125;
</code></pre>
<p>6.编写对应dao层接口的mapper配置文件：T_collegeMapper.xml</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;
        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace&#x3D;&quot;com.zestaken.dao.T_collegeMapper&quot;&gt;

    &lt;insert id&#x3D;&quot;addCollege&quot; parameterType&#x3D;&quot;T_college&quot;&gt;
    insert into youth_study.t_college(id,name)
    value (#&#123;id&#125;,#&#123;name&#125;);
    &lt;&#x2F;insert&gt;

    &lt;delete id&#x3D;&quot;deleteCollege&quot; parameterType&#x3D;&quot;int&quot;&gt;
    delete from youth_study.t_college
    where id &#x3D; #&#123;collegeID&#125;;
    &lt;&#x2F;delete&gt;
    
    &lt;update id&#x3D;&quot;updateCollege&quot; parameterType&#x3D;&quot;T_college&quot;&gt;
    update youth_study.t_college
    set name&#x3D;#&#123;name&#125;
    where id &#x3D; #&#123;id&#125;;
    &lt;&#x2F;update&gt;

    &lt;select id&#x3D;&quot;queryCollege&quot; resultType&#x3D;&quot;T_college&quot;&gt;
    select * form youth_study.t_college
    where id &#x3D; #&#123;collegeID&#125;;
    &lt;&#x2F;select&gt;

    &lt;select id&#x3D;&quot;queryAllCollege&quot; resultType&#x3D;&quot;T_college&quot;&gt;
    select * from youth_study.t_college;
    &lt;&#x2F;select&gt;

&lt;&#x2F;mapper&gt;</code></pre>
<ol start="7">
<li>绑定mapper，在mybatis-config.xml中配置：</li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;mappers&gt;
    &lt;mapper resource&#x3D;&quot;com&#x2F;zestaken&#x2F;dao&#x2F;T_collegeMapper.xml&quot;&#x2F;&gt;
&lt;&#x2F;mappers&gt;</code></pre>
<p>8.编写业务层的接口：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.service;

import com.zestaken.pojo.T_college;

import java.util.List;

public interface T_collegeService &#123;

    &#x2F;&#x2F;    增加一个学院
    int addCollege(T_college college);

    &#x2F;&#x2F;删除一个指定的学院
    int deleteCollege(int id);

    &#x2F;&#x2F;更新一个学院的信息
    int updateCollege(T_college college);

    &#x2F;&#x2F;查询一个学院
    T_college queryCollege(int id);

    &#x2F;&#x2F;查询全部的学院
    List&lt;T_college&gt; queryAllCollege();
&#125;</code></pre>
<p>9.实现业务层的接口:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.service;

import com.zestaken.dao.T_collegeMapper;
import com.zestaken.pojo.T_college;

import java.util.List;

public class T_collegeServiceImpl implements T_collegeService&#123;

    &#x2F;&#x2F;service层调dao层实现功能
    private T_collegeMapper t_collegeMapper;

    &#x2F;&#x2F;方便之后用Spring托管这个对象
    public void setT_collegeMapper(T_collegeMapper t_collegeMapper) &#123;
        this.t_collegeMapper &#x3D; t_collegeMapper;
    &#125;

    @Override
    public int addCollege(T_college college) &#123;
        return t_collegeMapper.addCollege(college);
    &#125;

    @Override
    public int deleteCollege(int id) &#123;
        return t_collegeMapper.deleteCollege(id);
    &#125;

    @Override
    public int updateCollege(T_college college) &#123;
        return t_collegeMapper.updateCollege(college);
    &#125;

    @Override
    public T_college queryCollege(int id) &#123;
        return t_collegeMapper.queryCollege(id);
    &#125;

    @Override
    public List&lt;T_college&gt; queryAllCollege() &#123;
        return t_collegeMapper.queryAllCollege();
    &#125;
&#125;</code></pre>
<h2 id="spring层"><a class="markdownIt-Anchor" href="#spring层"></a> Spring层</h2>
<ul>
<li>要将Spring相关的所有配置文件整合在到一起（本质上写一个spring的配置文件就足够了，分开写只是为了思路更清晰）
<ul>
<li>可以通过用import配置文件的方法实现:<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210313164643.png" alt="" /></li>
<li>也可以利用idea配置实现：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210313164431.png" alt="" /></li>
</ul>
</li>
</ul>
<h3 id="spring整合dao层"><a class="markdownIt-Anchor" href="#spring整合dao层"></a> Spring整合dao层</h3>
<ul>
<li>编写spring-dao.xml配置文件：</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;
       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;
       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans
            https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd
            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context
            https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;

&lt;!--    关联数据库配置文件--&gt;
    &lt;context:property-placeholder location&#x3D;&quot;classpath:database.properties&quot;&#x2F;&gt;

&lt;!--    配置连接池，此处使用c3p0--&gt;
    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
        &lt;property name&#x3D;&quot;driverClass&quot; value&#x3D;&quot;$&#123;jdbc.driver&#125;&quot;&#x2F;&gt;
        &lt;property name&#x3D;&quot;jdbcUrl&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;
        &lt;property name&#x3D;&quot;user&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;
        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&quot;&#x2F;&gt;

    &lt;!--        c3p0配置--&gt;
        &lt;property name&#x3D;&quot;maxPoolSize&quot; value&#x3D;&quot;30&quot;&#x2F;&gt;
        &lt;property name&#x3D;&quot;minPoolSize&quot; value&#x3D;&quot;10&quot;&#x2F;&gt;
        &lt;property name&#x3D;&quot;autoCommitOnClose&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;
        &lt;property name&#x3D;&quot;checkoutTimeout&quot; value&#x3D;&quot;10000&quot;&#x2F;&gt;
        &lt;property name&#x3D;&quot;acquireRetryAttempts&quot; value&#x3D;&quot;2&quot;&#x2F;&gt;
    &lt;&#x2F;bean&gt;

&lt;!--    sqlSessionFactory配置--&gt;
    &lt;bean id&#x3D;&quot;sqlSessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
    &lt;!--        绑定数据源--&gt;
        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;
    &lt;!--        绑定mybatis的配置文件--&gt;
        &lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;classpath:mybatis-config.xml&quot;&#x2F;&gt;
    &lt;&#x2F;bean&gt;

&lt;!--    配置dao接口的扫描包 动态实现Dao接口注入到Spring容器中（不用写接口实现类了）--&gt;
    &lt;bean class&#x3D;&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
        &lt;property name&#x3D;&quot;sqlSessionFactoryBeanName&quot; value&#x3D;&quot;sqlSessionFactory&quot;&#x2F;&gt;
        &lt;property name&#x3D;&quot;basePackage&quot; value&#x3D;&quot;com.zestaken.dao&quot;&#x2F;&gt;
    &lt;&#x2F;bean&gt;
&lt;&#x2F;beans&gt;</code></pre>
<h3 id="spring整合service层"><a class="markdownIt-Anchor" href="#spring整合service层"></a> Spring整合service层</h3>
<ul>
<li>写一个spring-sevice.xml配置文件：</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;
       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;
       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans
            https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd
            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context
            https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;

&lt;!--    扫描service层下的包, 要被扫描的类上面要加上@Compoent（或者更详细的@Service注解）--&gt;
    &lt;context:component-scan base-package&#x3D;&quot;com.zestaken.service&quot;&#x2F;&gt;

&lt;!--    将service层的业务类注入到Spring，可以通过配置，或者注解实现--&gt;
    &lt;bean id&#x3D;&quot;T_collegeServiceImpl&quot; class&#x3D;&quot;com.zestaken.service.T_collegeServiceImpl&quot;&gt;
        &lt;property name&#x3D;&quot;t_collegeMapper&quot; ref&#x3D;&quot;t_collegeMapper&quot;&#x2F;&gt;
    &lt;&#x2F;bean&gt;

&lt;!--声明式事务配置--&gt;
    &lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
&lt;!--        注入数据源--&gt;
        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;
    &lt;&#x2F;bean&gt;
&lt;&#x2F;beans&gt;</code></pre>
<ul>
<li>如果需要aop的配置，也写在这里。</li>
</ul>
<h2 id="springmvc层"><a class="markdownIt-Anchor" href="#springmvc层"></a> SpringMVC层</h2>
<ul>
<li>编写WEB-INF目录下的web.xml配置文件：</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;
         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;
         version&#x3D;&quot;4.0&quot;&gt;

&lt;!--    DispatchServlet配置--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;
&lt;!--            &lt;param-value&gt;classpath:spring-mvc.xml&lt;&#x2F;param-value&gt;--&gt;
&lt;!--            不能只导入Springmvc的配置文件，需要导入所有spring的配置文件，不然有一些bean会找不到--&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt;
        &lt;&#x2F;init-param&gt;
        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;
    &lt;&#x2F;servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;
        &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;
    &lt;&#x2F;servlet-mapping&gt;
    
&lt;!--    乱码过滤配置--&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;encodingFilter&lt;&#x2F;filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;
            &lt;param-value&gt;utf-8&lt;&#x2F;param-value&gt;
        &lt;&#x2F;init-param&gt;
    &lt;&#x2F;filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encodingFilter&lt;&#x2F;filter-name&gt;
        &lt;url-pattern&gt;*&lt;&#x2F;url-pattern&gt;
    &lt;&#x2F;filter-mapping&gt;

&lt;!--    配置session--&gt;
    &lt;session-config&gt;
        &lt;session-timeout&gt;15&lt;&#x2F;session-timeout&gt;
    &lt;&#x2F;session-config&gt;
&lt;&#x2F;web-app&gt;&gt;</code></pre>
<ul>
<li>编写spring-mvc.xml配置文件：</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;
       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
       xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;
       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;
       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans
            https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd
            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context
            https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;comtext&#x2F;spring-context.xsd
            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc
            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd&quot;&gt;

&lt;!--    注解驱动--&gt;
    &lt;mvc:annotation-driven&#x2F;&gt;
&lt;!--    静态资源过滤--&gt;
    &lt;mvc:default-servlet-handler&#x2F;&gt;
&lt;!--    扫描包：controller--&gt;
    &lt;context:component-scan base-package&#x3D;&quot;com.zestaken.controller&quot;&#x2F;&gt;

&lt;!--    视图解析器--&gt;
    &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot;&#x2F;&gt;
        &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt;
    &lt;&#x2F;bean&gt;
&lt;&#x2F;beans&gt;</code></pre>
<h2 id="编写实际项目"><a class="markdownIt-Anchor" href="#编写实际项目"></a> 编写实际项目</h2>
<ul>
<li>编写web.xml(WEB-INF)目录下的：</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;
         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;
         version&#x3D;&quot;4.0&quot;&gt;

&lt;!--    DispatchServlet配置--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;
&lt;!--            &lt;param-value&gt;classpath:spring-mvc.xml&lt;&#x2F;param-value&gt;--&gt;
&lt;!--            不能只导入Springmvc的配置文件，需要导入所有spring的配置文件，不然有一些bean会找不到--&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt;
        &lt;&#x2F;init-param&gt;
        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;
    &lt;&#x2F;servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;
        &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;
    &lt;&#x2F;servlet-mapping&gt;

&lt;!--    &lt;context-param&gt;--&gt;
&lt;!--        &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;--&gt;

&lt;!--        &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt;--&gt;
&lt;!--    &lt;&#x2F;context-param&gt;--&gt;

    
&lt;!--    乱码过滤配置--&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;encodingFilter&lt;&#x2F;filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;
            &lt;param-value&gt;utf-8&lt;&#x2F;param-value&gt;
        &lt;&#x2F;init-param&gt;
    &lt;&#x2F;filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encodingFilter&lt;&#x2F;filter-name&gt;
        &lt;url-pattern&gt;*&lt;&#x2F;url-pattern&gt;
    &lt;&#x2F;filter-mapping&gt;

&lt;!--    配置session--&gt;
    &lt;session-config&gt;
        &lt;session-timeout&gt;15&lt;&#x2F;session-timeout&gt;
    &lt;&#x2F;session-config&gt;

&lt;&#x2F;web-app&gt;</code></pre>
<ul>
<li>编写controller：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.controller;

import com.zestaken.pojo.T_college;
import com.zestaken.service.T_collegeService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

import java.util.List;


@Controller
@RequestMapping(&quot;&#x2F;college&quot;)
public class T_collegeController &#123;

    &#x2F;&#x2F;controller调service层
    @Autowired
    @Qualifier(&quot;T_collegeServiceImpl&quot;)
    private T_collegeService t_collegeService;

    public void setT_collegeService(T_collegeService t_collegeService) &#123;
        this.t_collegeService &#x3D; t_collegeService;
    &#125;

    @RequestMapping(&quot;&#x2F;allCollege&quot;)
    public  String queryAllCollege(Model model) &#123;
        List&lt;T_college&gt; t_colleges &#x3D; t_collegeService.queryAllCollege();
        model.addAttribute(&quot;msg&quot;, t_colleges);
        return &quot;allCollege&quot;;
    &#125;
&#125;</code></pre>
<ul>
<li>编写页面：
<ul>
<li><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210313220441.png" alt="" /></li>
</ul>
</li>
</ul>
<pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%--
  Created by IntelliJ IDEA.
  User: 12246
  Date: 2021&#x2F;3&#x2F;13
  Time: 19:15
  To change this template use File | Settings | File Templates.
--%&gt;
&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;首页&lt;&#x2F;title&gt;
&lt;&#x2F;head&gt;
&lt;body&gt;

&lt;h1&gt;
    &lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;college&#x2F;allCollege&quot;&gt;进入学院展示页面&lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;&#x2F;body&gt;
&lt;&#x2F;html&gt;</code></pre>
<pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%--
  Created by IntelliJ IDEA.
  User: 12246
  Date: 2021&#x2F;3&#x2F;13
  Time: 19:14
  To change this template use File | Settings | File Templates.
--%&gt;
&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;allCollege&lt;&#x2F;title&gt;
&lt;&#x2F;head&gt;
&lt;body&gt;

&lt;h1&gt;$&#123;msg&#125;&lt;&#x2F;h1&gt;
&lt;&#x2F;body&gt;
&lt;&#x2F;html&gt;</code></pre>
<ul>
<li>配置Tomcat，启动项目。</li>
<li>最后总架构：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210313220644.png" alt="" /></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/index.html" class="post-title-link" itemprop="url">C语言-错误处理与信号处理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-02 19:47:46" itemprop="dateCreated datePublished" datetime="2021-03-02T19:47:46+08:00">2021-03-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-09-26 21:33:59" itemprop="dateModified" datetime="2021-09-26T21:33:59+08:00">2021-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">专业基础</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="errnoh错误"><a class="markdownIt-Anchor" href="#errnoh错误"></a> <code>&lt;errno.h&gt;</code>:错误</h1>
<ul>
<li>标准库中的一些函数通过向<code>&lt;erron.h&gt;</code>中声明的<strong>int型errno变量</strong>存储一个错误码（正整数）来表示有错误发生。</li>
<li>如果使用的一个库函数，通过给errno赋值来产生程序运行出错的信号，我们可以在调用这个函数之后，==检查erron的值是否为0==，来判断函数调用过程中是否有错误发生。</li>
<li>使用errno来检测函数调用的错误，需要==在函数调用前将errno置零==。</li>
<li>errno中存储的错误值经常是以下两个宏：
<ul>
<li><strong>EDOM(定义域错误)</strong>：传递给函数的一个参数==超出了定义域==，使用这个宏。</li>
<li><strong>ERANGE(取值范围错误)</strong>：函数的==返回值太大,无法用返回类型==。</li>
</ul>
</li>
<li>与变量errno有关的两个函数（都不属于<code>&lt;errno.h&gt;</code>）:
<ul>
<li><strong>perror</strong>函数：
<ul>
<li>在<code>&lt;stdio.h&gt;</code>中声明，用于显示描述错误的信息；perror函数会==输出到stderr流==。</li>
<li>原型：<code>void perror(const char *s)</code></li>
<li>参数：
<ul>
<li>一个作为部分错误消息的字符串。</li>
</ul>
</li>
<li>返回值：
<ul>
<li>依次显示下列内容：
<ol>
<li>调用perror的参数；</li>
<li>一个分号；</li>
<li>一个空格；</li>
<li>一条出错消息：消息的内容根据errno的值决定；</li>
<li>一个换行符。</li>
</ol>
</li>
<li>示例：<code>perror(&quot;sqrt error&quot;); sqrt error: Numercial argument out of domain</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>strerror</strong>函数：
<ul>
<li>在<code>&lt;string.h&gt;</code>声明，当以错误码为参数调用strerror时，函数会==返回一个指针,它指向一个描述这个错误的字符串==；</li>
<li>原型：<code>char *strerror(int errnum)</code></li>
<li>参数：
<ul>
<li>strerror函数的参数==通常是errno的值==，但以任意整数为参数都能返回一个字符串。</li>
</ul>
</li>
<li>示例：<code>puts(strerror(EDOM))</code></li>
</ul>
</li>
<li>对于同一个错误，perror函数和strerror函数返回的消息的值是相同的。</li>
</ul>
</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">errno &#x3D; 0;

y &#x3D; sqrt(x);
if(errno !&#x3D; 0) &#123;
    perror(&quot;sqrt error&quot;);
    puts(strerror(erron));
&#125;</code></pre>
<h1 id="signalh信号处理"><a class="markdownIt-Anchor" href="#signalh信号处理"></a> <code>&lt;signal.h&gt;</code>：信号处理</h1>
<ul>
<li><code>&lt;signal.h&gt;</code>提供了==处理异常情况（异常情况又称为信号）的工具==。</li>
<li><strong>信号</strong>：当有错误或者外部事件发生时，称为产生了一个信号。很多信号可以在程序执行过程中的任意时刻发生。</li>
<li><strong>信号类型</strong>：
<ul>
<li>==运行时错误==，如（除以0）；</li>
<li>==发生在程序以外的事件==，如：操作系统对正在运行的程序的中断信号。</li>
</ul>
</li>
<li><strong>信号宏</strong>：
<ul>
<li>信号宏：<code>&lt;signal.h&gt;</code>中定义了一系列的宏,==用于表示不同的信号==；</li>
<li>6种信号宏：
<ol>
<li><code>SIGABRT</code>:异常终止；</li>
<li><code>SIGFPE</code>:在算术运算中发生错误；</li>
<li><code>SIGILL</code>:无效指令；</li>
<li><code>SIGINT</code>:中断；</li>
<li><code>SIGSEGV</code>:无效存储访问；</li>
<li><code>SIGTERM</code>:终止请求。</li>
</ol>
</li>
</ul>
</li>
<li><strong>signal</strong>函数：
<ul>
<li>signal是<code>&lt;signal.h&gt;</code>提供的，用来==安装信号处理函数，以便将来给定的信号发生时使用==。</li>
<li>原型：<code>void (*signal(int sig, void (*func)(int)))(int)</code></li>
<li>参数：
<ul>
<li>第一个参数是==特定信号的编码（表示不同信号的宏）==；</li>
<li>第二个参数是==一个指向会在信号发生时处理这一信号的函数的指针==；</li>
</ul>
</li>
<li>返回值：
<ul>
<li>一旦调用信号处理函数返回,==程序会从信号发生点恢复并继续执行==，除了SIGABRT和SIGFPE两种信号。</li>
<li>signal的返回值是一个==指向指定信号的前一个处理函数的指针==。可以用于恢复原来的处理函数。</li>
<li>如果一个signal函数调用失败，==会返回SIG_ERR（一个在<code>&lt;signal.h&gt;</code>中定义的宏）并在errno中存入一个正值。==</li>
</ul>
</li>
</ul>
</li>
<li><strong>信号处理函数</strong>:
<ul>
<li>自定义信号处理函数：
<ul>
<li>每个信号处理函数都必须有一个==int类型的参数==，且返回类型为void。</li>
<li>当一个特定的信号产生并调用相应的信号处理函数时，==信号的编码会作为参数传递给处理函数==。</li>
</ul>
</li>
<li>预定义的信号处理函数：<code>&lt;signal.h&gt;</code>提供了一些预定义的信号处理函数,这些函数==都是用宏表示的==。
<ul>
<li><strong>SIG_DFL</strong>:
<ul>
<li>按==默认==方式处理信号。</li>
<li>调用该函数的结果是由实现定义的，但大多数情况下会导致程序终止。</li>
</ul>
</li>
<li><strong>SIG_IGN</strong>:
<ul>
<li>当指定的信号产生时，==忽略该信号==；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>raise</strong>函数：
<ul>
<li><code>&lt;signal.h&gt;</code>中声明，用来==使程序主动触发信号==。</li>
<li>原型：<code>int raise(int sig)</code></li>
<li>参数：
<ul>
<li>sig参数用于==指定所需信号的编码==；</li>
</ul>
</li>
<li>返回值：
<ul>
<li>raise函数的返回值，代表产生信号是否成功：==成功为0，失败为非0==。</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/index.html" class="post-title-link" itemprop="url">C语言-输入输出</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-01 16:55:28" itemprop="dateCreated datePublished" datetime="2021-03-01T16:55:28+08:00">2021-03-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-09-26 21:33:59" itemprop="dateModified" datetime="2021-09-26T21:33:59+08:00">2021-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">专业基础</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="流"><a class="markdownIt-Anchor" href="#流"></a> 流</h1>
<ul>
<li><strong>流(Stream)</strong>: C语言中，流表示==任意输入的源或任意输出的目的地==。</li>
<li>流经常表示存储在不同介质的==文件==，也经常和==不存储文件的设备(如网络端口，打印机)==关联。</li>
<li><code>&lt;stido.h&gt;</code>中的函数可以处理各种形式的流。</li>
</ul>
<h2 id="文件指针"><a class="markdownIt-Anchor" href="#文件指针"></a> 文件指针</h2>
<ul>
<li><strong>文件指针(file pointer)</strong>：C程序中==对流的访问是通过文件指针来实现的==。</li>
<li><strong>文件指针的类型</strong>：<code>FILE *</code>
<ul>
<li>FILE类型是在<code>&lt;stdio.h&gt;</code>中声明的。</li>
<li>示例:<code>FILE *fp1;</code></li>
</ul>
</li>
</ul>
<h2 id="标准流和重定向"><a class="markdownIt-Anchor" href="#标准流和重定向"></a> 标准流和重定向</h2>
<ul>
<li><code>&lt;stdio.h&gt;</code>提供了3个标准流：
<ol>
<li><code>stdin</code>:标准输入流，默认是键盘。</li>
<li><code>stdout</code>:标准输出流，默认是屏幕。</li>
<li><code>stderr</code>:标准错误，默认是屏幕。</li>
</ol>
</li>
<li><strong>标准流的特性</strong>：
<ul>
<li>这三个标准流==可以直接使用，不需要对其进行声明，也不用打开或者关闭==。</li>
<li>stdin,stdout,stderr是三个==文件指针==。</li>
</ul>
</li>
<li><strong>重定向</strong>：
<ul>
<li>操作系统通过==重定向的操作改变标准流的默认含义==。</li>
<li><strong>输出重定向</strong>：使stdin流表示文件，而不是键盘,通过在命令行中使用<code>&lt;</code>实现，如：<code>demo &lt;in.dat</code>,运行demo程序时从in.dat文件中获取数据。</li>
<li><strong>输出重定向</strong>：使stdout流表示文件，而不是屏幕，通过在命令行中使用<code>&gt;</code>实现，如：<code>demo &gt;out.dat</code>，运行demo程序时输出到out.dat文件中。</li>
</ul>
</li>
</ul>
<h2 id="文本文件和二进制文件"><a class="markdownIt-Anchor" href="#文本文件和二进制文件"></a> 文本文件和二进制文件</h2>
<ul>
<li><code>&lt;stdio.h&gt;</code>支持<strong>文本文件</strong>和<strong>二进制文件</strong>。</li>
<li><strong>文本文件(text file)</strong>：
<ul>
<li>在文本文件中，==字节表示字符==；</li>
<li><strong>文本文件分为若干行</strong>：
<ul>
<li>文本文件的每一行通常==以一两个特殊字符结尾==；</li>
<li>windows系统是以==回车符<code>\x0d</code>和回行符<code>\x0a</code>==结尾；</li>
<li>unix操作系统是以==一个单独的回行符<code>\x0a</code>==结尾。</li>
</ul>
</li>
<li><strong>文本文件末尾可以包含一个特殊的文件末尾标识符</strong>：
<ul>
<li>文件末尾标识==不是必须的，但一旦存在，就标志着文件的结束==。</li>
</ul>
</li>
</ul>
</li>
<li><strong>二进制文件</strong>：
<ul>
<li>在二进制文件中，==字节可以表示很多类型的数据==。</li>
<li>二进制文件==不分行，没有行末标记和文件末尾标记==。</li>
</ul>
</li>
</ul>
<h1 id="文件操作"><a class="markdownIt-Anchor" href="#文件操作"></a> 文件操作</h1>
<ul>
<li><code>&lt;stdio.h&gt;</code>提供了一系列的文件操作，包括打开文件，关闭文件，改变文件的缓冲方式，删除文件以及重命名文件等。</li>
</ul>
<h2 id="打开文件"><a class="markdownIt-Anchor" href="#打开文件"></a> 打开文件</h2>
<ul>
<li><strong><code>fopen()</code>函数</strong>：
<ul>
<li>将文件打开并用作==流==；</li>
<li>原型：<code>FILE *fopen(const char *filename, const char *mode)</code></li>
<li><strong>filename</strong>：要打开文件的文件名（可能包含文件的==路径信息==。）
<ul>
<li>路径：在windows系统中的路径中含有<code>\</code>,会被C语言识别为转移字符，而导致错误。常用<code>\\</code>或者<code>/</code>来替换路径中的<code>\</code>。</li>
</ul>
</li>
<li><strong>mode</strong>:==模式字符串==，用来指定打算对文件执行的操作。对==文本文件和对二进制文件的模式字符串是不一样的==。
<ul>
<li>对<strong>文本文件</strong>的六种模式字符串：
<ol>
<li><code>&quot;r&quot;</code>:打开文件用于读；</li>
<li><code>&quot;w&quot;</code>:打开文件用于写(文件不需要存在)</li>
<li><code>&quot;a&quot;</code>:打开文件用于追加（文件不需要存在）</li>
<li><code>&quot;r+&quot;</code>&quot;:打开文件用于==读和写，从文件头开始==；</li>
<li><code>&quot;w+&quot;</code>:打开文件用于==读和写（如果文件存在就清空）==；</li>
<li><code>&quot;a+&quot;</code>:打开文件用于==读和写（如果文件存在就追加）==。</li>
</ol>
</li>
<li>对<strong>二进制文件</strong>也有六种模式字符串，只需要在文件文件的基础上==加上b==即可。</li>
</ul>
</li>
<li><strong>返回值</strong>：
<ul>
<li>fopen函数的返回值是一个==文件指针==；</li>
<li>当无法代开文件时，会==返回一个空指针==。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="关闭文件"><a class="markdownIt-Anchor" href="#关闭文件"></a> 关闭文件</h2>
<ul>
<li><strong><code>flclose()</code>函数</strong>:
<ul>
<li>关闭不再使用的文件。</li>
<li>原型：<code>int fclose(FILE *stream)</code></li>
<li><strong>参数</strong>：
<ul>
<li>==必须是来自fopen函数或者freopen函数的文件指针==；</li>
</ul>
</li>
<li><strong>返回值</strong>：
<ul>
<li>如果成功关闭的文件，返回==0==；</li>
<li>如果失败，返回==EOF==(EOP是<code>&lt;stdio.h&gt;</code>中定义的宏)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="为打开的流附加文件"><a class="markdownIt-Anchor" href="#为打开的流附加文件"></a> 为打开的流附加文件</h2>
<ul>
<li><strong><code>freopen()</code>函数</strong>：
<ul>
<li>该函数为已经打开的流附加上一个不同的文件。</li>
<li>原型:<code>FILE *freopen(const char *filename, const char *mode, FILE *stream)</code></li>
<li><strong>参数</strong>:
<ul>
<li>前两个参数同fopen一样；</li>
<li>第三个参数是一个文件指针，指向一个已经打开了的流。</li>
</ul>
</li>
<li><strong>返回值</strong>：
<ul>
<li>正常的返回值是它的第三个参数，一个文件指针；</li>
<li>如果无法打开新文件，返回==空指针==。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="从命令行获取文件名"><a class="markdownIt-Anchor" href="#从命令行获取文件名"></a> 从命令行获取文件名</h2>
<ul>
<li>执行程序时，可以通过将==文件名放入命令行的方式为程序提供文件名==。</li>
<li>示例：命令<code>demo demo1.txt demo2.txt</code>，其中demo是程序名，剩下的是文件名。在C语言中<code>argv[1]</code>指向字符串<code>demo1.txt</code>,<code>argv[2]</code>指向字符串<code>demo2.txt</code></li>
</ul>
<h2 id="临时文件"><a class="markdownIt-Anchor" href="#临时文件"></a> 临时文件</h2>
<ul>
<li><strong>临时文件</strong>：==只在程序运行时==存在的文件。</li>
<li><code>&lt;stdio.h&gt;</code>提供了两个函数来处理临时文件。</li>
<li><code>tmpfile()</code>:
<ul>
<li>tmpfile函数用于==创建临时文件==（用wb+模式打开），这个临时文件在==关闭它或者程序终止==时消失。</li>
<li>原型：<code>FILE *tmpfile(void)</code></li>
<li>返回值：
<ul>
<li>如果创建文件成功，会返回==文件指针==；</li>
<li>如果创建失败，返回==空指针==。</li>
</ul>
</li>
<li>特点：
<ul>
<li>无法知道tmpfile创建的临时文件的==文件名==；</li>
<li>无法使用tmpfile创建的文件成为==永久性的==。</li>
</ul>
</li>
</ul>
</li>
<li><code>tmpnam()</code>:
<ul>
<li>tmpname函数为临时文件==产生名字==。</li>
<li>原型：<code>char *tmpnam(char *s);</code></li>
<li>参数：
<ul>
<li>如果参数是一个空指针，tmpnam会==将生成的文件名存储到一个静态字符数组变量中去，并且返回指向这个变量的指针==；</li>
<li>传递给tmpnam的参数应该是一个==字符数组==，tmpnam会将文件名存储到这个字符数组中去，并==返回指向这个数组第一个元素的指针==。</li>
</ul>
</li>
<li>tmpnam函数常与fopen函数配合生成具有名字的临时文件。</li>
</ul>
</li>
</ul>
<h2 id="文件缓冲"><a class="markdownIt-Anchor" href="#文件缓冲"></a> 文件缓冲</h2>
<ul>
<li>使用文件缓冲的原因：向外存写入或者读出数据都是==相对较慢==的操作。</li>
<li><strong>缓冲(buffering)</strong>：将写入流或者输入流中的数据，先写入==缓冲区==，最后再将缓冲区的内容写入实际的设备。</li>
<li><code>&lt;stdio.h&gt;</code>中的缓冲函数，会在缓冲有用时==自动进行缓冲操作==，缓冲是在后台发生的。</li>
<li><strong><code>fflush</code>函数</strong>：
<ul>
<li>调用fflush函数，可以按照我们希望的频率==将缓冲区的内容写到相应设备上去==。</li>
<li>原型：<code>int fflush(FILE *stream)</code></li>
<li>参数：
<ul>
<li>如果传递的是一个==文件指针==，则将与该文件指针相关联的文件的缓冲区内容写到实际设备。</li>
<li>如果传递的是一个==空指针==，则将所有缓冲区内容写到实际设备上去。</li>
</ul>
</li>
<li>返回值；
<ul>
<li>调用成功，==返回0==;</li>
<li>调用失败，==返回EOF==。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>setvbuf</code>函数</strong>:
<ul>
<li>改变缓冲流的方法，并且允许控制缓冲区的大小和位置。</li>
<li>原型：<code>int setvbuf(FILE *stream, char *buf, int mode, size_t size);</code></li>
<li>参数：
<ul>
<li><code>stream</code>:需要改变缓冲方式的流；</li>
<li><code>buf</code>:期望的==缓冲区的地址==；
<ul>
<li>如果实参为空指针，则会==创建一个指定大小的缓冲区==。</li>
</ul>
</li>
<li><code>mode</code>:期望的缓冲类型，只能为==下列三个宏==：
<ol>
<li><code>_IOFBF</code>:==满缓冲==，当缓冲区为空时，从流读入数据；当缓冲区满时，向流写入数据；</li>
<li><code>_IOLBF</code>:==行缓冲==，每次从流读入一行数据或者向流写入一行数据；</li>
<li><code>_IONBF</code>:==无缓冲==，直接从流读入数据或者直接向流写入数据，而没有缓冲区。</li>
</ol>
</li>
<li><code>size</code>:缓冲区内==字节的数量==。</li>
</ul>
</li>
<li>返回值：
<ul>
<li>调用成功，==返回0==；</li>
<li>调用失败，==返回非零值==。</li>
</ul>
</li>
</ul>
</li>
<li><code>setbuf</code>函数：
<ul>
<li>setvbuf的早期版。</li>
</ul>
</li>
</ul>
<h2 id="文件删除与重命名"><a class="markdownIt-Anchor" href="#文件删除与重命名"></a> 文件删除与重命名</h2>
<ul>
<li><strong><code>remove</code>函数</strong>：
<ul>
<li>用于删除文件；</li>
<li>原型：<code>int remove(const char *filename)</code></li>
<li>参数：
<ul>
<li><strong>文件名</strong>；</li>
</ul>
</li>
<li>返回值：
<ul>
<li>成功，0；</li>
<li>失败，非零值。</li>
</ul>
</li>
<li>要删除的文件需要<strong>关闭</strong>。</li>
</ul>
</li>
<li><strong><code>rename</code>函数</strong>：
<ul>
<li>改变文件的名字；</li>
<li>原型：<code>int rename(const char *old, const char *new)</code></li>
<li>参数：
<ul>
<li>old：原来的文件名；</li>
<li>new：新的文件名。</li>
</ul>
</li>
<li>返回值：
<ul>
<li>成功，0；</li>
<li>失败，非零值。</li>
</ul>
</li>
<li>注意：
<ul>
<li>要改名的文件需要<strong>关闭</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80-%E6%8C%87%E9%92%88/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80-%E6%8C%87%E9%92%88/index.html" class="post-title-link" itemprop="url">C语言-指针</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-25 17:05:47" itemprop="dateCreated datePublished" datetime="2021-02-25T17:05:47+08:00">2021-02-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-05-29 17:49:50" itemprop="dateModified" datetime="2021-05-29T17:49:50+08:00">2021-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">专业基础</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="指针的基本概念"><a class="markdownIt-Anchor" href="#指针的基本概念"></a> 指针的基本概念</h1>
<ul>
<li>==指针就是地址，而指针变量就是存储地址的变量==。</li>
<li>指针变量的声明：在普通变量声明的基础上加上<code>*</code>:
<ul>
<li>如指向int类型对象的指针变量：<code>int *p;</code></li>
</ul>
</li>
<li><strong>取地址运算符</strong>：用于获取变量的地址，来给指针变量赋值。
<ul>
<li>示例：</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">int i, *p;
p &#x3D; &amp;i;</code></pre>
</li>
<li><strong>间接寻址运算符</strong>：用于访问指针变量指向的对象的内容。
<ul>
<li>示例：</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">int i, *p;
p &#x3D; &amp;i;
i &#x3D; *p;</code></pre>
<ul>
<li>不要混淆间接寻址运算符和指针变量的声明时的<code>*</code>的功能。</li>
<li><code>*p</code>相当于<code>i</code>的==别名==，对<code>*p</code>执行的任何操作，与直接对<code>i</code>做操作的效果一样。</li>
</ul>
</li>
</ul>
<h1 id="指针与数组"><a class="markdownIt-Anchor" href="#指针与数组"></a> 指针与数组</h1>
<ul>
<li>指针可以指向数组元素:
<ul>
<li>示例：</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">int a[10],*p;
p &#x3D; &amp;a[0];
*p &#x3D; 5;</code></pre>
<ul>
<li>如果==指针指向数组元素，那么对该指针进行算运算==就是有意义的：
<ol>
<li><strong>指针加上整数</strong>：指针加上整数，代表该指针指向更右边数组的元素，如<code>int *p = &amp;a[0]</code>，给p加上2之后，p指向<code>a[2]</code></li>
<li><strong>指针减去整数</strong>：指针减去整数，代表该指针指向更左边数组的元素，如<code>int *p = a[2]</code>，给p减去2之后，p指向<code>a[0]</code></li>
<li><strong>两个指针相减</strong>：两个指针相减，结果为这两个指针指向的数组元素之间间隔的数组元素个数，如<code>int *p = &amp;a[5]; int *q = &amp;a[1]</code>，那么p和q相减的结果就是4。</li>
</ol>
</li>
</ul>
</li>
<li>可以直接<strong>将数组名赋值给指针变量</strong>：
<ul>
<li>如：<code>int a[2] = &#123;0, 1, 2&#125;; int *p = a;</code></li>
<li>实质是p指向该数组的第一个元素<code>a[0]</code></li>
<li>==数组的名字实质上是指向数组第一个元素的指针==</li>
<li>不能给数组名赋值。</li>
</ul>
</li>
<li><strong>数组型形式参数</strong>：
<ul>
<li>在将数组作为形式参数传递给函数的时候，实际传递的是==指向该数组的第一个元素的指针（或者说是数组名）==。</li>
<li>==声明形式参数为指针就相当于声明变量为数组==(但是普通变量不可以这样理解），可以==将数组型形式参数声明为指针==，如：<code>int function(int a[], int n)</code>与<code>int function(int *a, int n)</code>等价。</li>
<li>可以给函数传递==数组的片段==，如：<code>function(&amp;a[6], 10)</code></li>
</ul>
</li>
<li><strong>用指针作为数组名</strong>：
<ul>
<li>可以将指针看做数组名进行==取下标操作==。</li>
<li>编译器将<code>p[i]</code>看做`*(p+i)。</li>
<li>对指针进行取下标操作的前提是:==该指针是指向了一个数组的首元素==。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">int a[10], *p;
p &#x3D; a;
int num &#x3D; p[1];</code></pre>
</li>
<li><strong>指针数组</strong>：
<ul>
<li>元素是指针的数组，如：<code>int *p[10]</code>，声明了一个数组，这个数组存储10个int型指针变量。</li>
</ul>
</li>
<li><strong>指向指针的指针</strong>：
<ul>
<li>示例：</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">char *p1;
char **p2 &#x3D; &amp;p1;</code></pre>
</li>
</ul>
<h2 id="指针和多维数组"><a class="markdownIt-Anchor" href="#指针和多维数组"></a> 指针和多维数组</h2>
<ul>
<li>C语言中的多维数组，可以理解为将每一行的元素依次排列；</li>
<li><strong>将二维数组看做是一维数组</strong>来处理：
<ul>
<li>指针指向二维数组的第一个元素，指针每次加一，都会指向数组的下一个元素，如果到达本行末尾，就指向下一行的第一个元素。</li>
</ul>
</li>
<li><strong>将指针指向某一行的第一个元素</strong>：
<ul>
<li>一般方法：</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">int a[10][10], *p;
&#x2F;&#x2F;指向第二行的第一个元素
p &#x3D; &amp;a[1][0]; </code></pre>
<ul>
<li>简写：根据可以对指针进行去下标操作，利用<code>&amp;a[i][0] = &amp;(*(a[i] + 0))</code></li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">int a[10][10], *p;
&#x2F;&#x2F;指向第三行的第一个元素
p &#x3D; a[2];</code></pre>
</li>
<li><strong>指向一维数组的指针</strong>：
<ul>
<li>对一维数组，我们常用的指针是指向==数组的第一个元素的==；</li>
<li>可以定义==指向一个一维数组的指针==：<code>int (*p)[10]</code>,这是声明了一个指向长度为10的整型数组的指针p；</li>
<li>对于二维数组，可以看做是==一个每个元素都是一维数组的一维数组==；</li>
<li>使用指向数组的指针来==按行遍历二维数组==：</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">int a[10][11], (*p)[10];
&#x2F;&#x2F;省去数组赋值等
&#x2F;&#x2F;按列遍历数组，并将数组第五列的值赋为0
for(p &#x3D; &amp;a[0]; p &lt; &amp;a[10]; p++) &#123;
  (*p)[4];
&#125;</code></pre>
<ul>
<li>在二维数组中，<code>a[i]</code>取的是第i-1行第一个元素的地址，<code>&amp;a[i]</code>取的是第i-1行的地址（第i-1个一维数组的地址）</li>
<li>对于指向数组的指针来说：<code>*p</code>是取出指向的数组，<code>(*p)[i]</code>是取出指向的数组中的第i-1个元素。</li>
</ul>
</li>
<li><strong>用多维数组名作为指针</strong>：
<ul>
<li>二维数组的==数组名是一个指向一维数组的指针==，例如<code>int a[10][10]</code>的数组名<code>a</code>代表的意思是<code>&amp;a[0]</code>。</li>
</ul>
</li>
<li><strong>多维数组的长度</strong>：
<ul>
<li>对于==一维数组在声明时就赋值的情况下，可以省略数组的长度==，如：<code>int a[] = &#123;1, 2&#125;</code></li>
<li>==二维数组在声明时就赋值可以省略第一维的长度==,最后的二维数组的每一维的长度都是每一行的数组的长度是==根据最长的数组的长度来确定==的。如果有一些行的数据不够填满整行，那么C语言==会用空字符<code>\0</code>来填补==。</li>
</ul>
</li>
</ul>
<h1 id="字符串数组"><a class="markdownIt-Anchor" href="#字符串数组"></a> 字符串数组</h1>
<h2 id="二维数组实现字符串数组"><a class="markdownIt-Anchor" href="#二维数组实现字符串数组"></a> 二维数组实现字符串数组</h2>
<ul>
<li><strong>字符串字面量</strong>：
<ul>
<li>字符串是一个==字符数组==；</li>
<li>字符串字面量就是这个数组的数组名，==是一个<code>char *</code>类型的指针==。</li>
<li>字符串字面量是==不能被修改的==</li>
</ul>
</li>
<li>创建一个二维数组，按照每行一个字符串(==一维字符数组==)的方式，将一系列字符串存入一个数组中。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">char planets[][8] &#x3D; &#123; &quot;Mercury&quot;, &quot;Venus&quot;, &quot;Earth&quot;,
					  &quot;Mars&quot;, &quot;Jupiter&quot;, &quot;Saturn&quot;,
					  &quot;Urans&quot;, &quot;Neptune&quot;, &quot;Pluto&quot; &#125;;</code></pre>
<ul>
<li>因为每一行字符串的长度是省略的，所以每一行的长度是系统自动确定的。在二维数组中，每一行的数组的长度是根据最长的数组的长度来确定的。如果有一些行的数据不够填满整行，那么C语言<strong>会用空字符<code>\0</code>来填补，造成了空间浪费</strong>。</li>
<li>可以理解为用这种方式创建的<strong>二维数组都是矩形的</strong>。</li>
</ul>
<h2 id="指针数组实现字符串数组"><a class="markdownIt-Anchor" href="#指针数组实现字符串数组"></a> 指针数组实现字符串数组</h2>
<ul>
<li>要想实现<strong>参差不齐的二维数组</strong>，需要使用<strong>元素为指针的数组</strong>。</li>
<li>建立一个<strong>元素都是指向字符串的指针</strong>的数组，来实现字符串数组。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">char *planets[] &#x3D; &#123; &quot;Mercury&quot;, &quot;Venus&quot;, &quot;Earth&quot;,
					&quot;Mars&quot;, &quot;Jupiter&quot;, &quot;Saturn&quot;,
					&quot;Urans&quot;, &quot;Neptune&quot;, &quot;Pluto&quot;&#125;;</code></pre>
<h2 id="字符串数组的应用命令行参数"><a class="markdownIt-Anchor" href="#字符串数组的应用命令行参数"></a> 字符串数组的应用：命令行参数</h2>
<ul>
<li>运行程序是需要提供一些信息，这些信息从命令行中提供，称为<strong>命令行参数</strong>（C语言中也叫程序参数）。</li>
<li>为了访问命令行参数必须将<strong>main函数定义为含有两个特殊参数的的函数</strong>：
<ul>
<li><code>argc</code>参数：argc是参数计数的参数，为int型，用于记录<strong>命令行参数的数量</strong>。</li>
<li><code>argv</code>参数：argv是<strong>指向命令行参数的指针数组</strong>，这些命令行参数以<strong>字符串</strong>的形式存储。
<ul>
<li>argv是<code>char *argv[]</code>型的，实质就是一个字符串数组。</li>
<li><code>argv[0]</code>指向<strong>程序名</strong>；</li>
<li><code>argv[1]</code>到<code>argv[argc - 1]</code>指向余下的命令行参数。</li>
<li><code>argv[argc]</code>是一个附加元素，这个元素始终是一个<strong>空指针</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define NUM_PLANETS 9

int main(int argc, char* argv[]) &#123;
	char *planets[] &#x3D; &#123; &quot;Mercury&quot;, &quot;Venus&quot;, &quot;Earth&quot;,
						&quot;Mars&quot;, &quot;Jupiter&quot;, &quot;Saturn&quot;,
						&quot;Urans&quot;, &quot;Neptune&quot;, &quot;Pluto&quot; &#125;;
	int i, j;

	for (i &#x3D; 1; i &lt; argc; i++) &#123;
		for (j &#x3D; 0; j &lt; NUM_PLANETS; j++) &#123;
			if (strcmp(argv[i], planets[j]) &#x3D;&#x3D; 0) &#123;
				printf_s(&quot;%s is planet %d\n&quot;, argv[i], j + 1);
				break;
			&#125;
				if (j &#x3D;&#x3D; NUM_PLANETS) &#123;
					printf_s(&quot;%s is not a planet\n&quot;, argv[i]);
				&#125;
		&#125;
	&#125;
	return 0;
&#125;</code></pre>
<h1 id="动态存储分配"><a class="markdownIt-Anchor" href="#动态存储分配"></a> 动态存储分配</h1>
<ul>
<li><strong>动态存储分配</strong>：在程序==运行期间==分配内存单元的能力</li>
<li>内存分配函数所获得的内存块都来自一个称为**堆（heap）**的存储池。</li>
<li><strong>内存分配函数</strong>有三种，都是声明在<code>&lt;stdlib.h&gt;</code>头中的：
<ol>
<li><strong><code>malloc</code>函数</strong>：分配内存块，但是不对内存块进行初始化。（最常用，最高效）
<ul>
<li>原型：<code>void *malloc(size_t size)</code>,malloc函数分配size个字节的内存块，并且返回指向该内存块的指针。</li>
<li>示例：<code>int *a = (n * sizeof(int));</code>,为长度为n的int型数组分配空间。</li>
</ul>
</li>
<li><strong><code>calloc</code>函数</strong>：分配内存块，并且对内存块进行清零。
<ul>
<li>原型：<code>void *calloc(size_t nmemb, size_t size);</code>,calloc函数为nmemb个元素的数组分配内存空间，其中每个元素的长度都是size个字节。</li>
<li>在分配了内存之后，calloc函数会==通过把所有位设置为0的方式进行初始化==。</li>
<li>将nemeb设为1，可以为==任何类型的数据项分配内存==。</li>
<li>示例：<code>int *a = calloc(n, sizeof(int))</code>，为长度为n的int型数组分配空间。</li>
</ul>
</li>
<li><strong><code>realloc</code>函数</strong>：调整先前分配的内存块大小。
<ul>
<li>原型：<code>void *realloc(void *ptr, size_t size);</code>,调用realloc函数时，==ptr必须指向先前通过malloc，calloc或realloc的调用获得的内存块==。size表示内存块的新尺寸。</li>
<li>如果realloc==以空指针作为第一个实际参数，那么它的行为就行malloc函数一样==。</li>
<li>如果realloc==以0作为第二个实际参数，那么它会释放掉内存块==。</li>
</ul>
</li>
</ol>
</li>
<li><strong>内存分配函数的返回值</strong>：
<ul>
<li><strong><code>void *</code></strong>:内存分配函数会返回<code>void *</code>类型的值，该类型的指针是==通用指针==，指向分配的内存。
<ul>
<li>可以将==<code>void *</code>类型的变量赋给任意类型的指针变量。</li>
</ul>
</li>
</ul>
</li>
<li><strong>空指针</strong>：
<ul>
<li>当找不到需要的足够大的内存块时，内存分配函数会返回==空指针==；</li>
<li>空指针是==不指向任何地方的指针==，这是一个用于区别于所有有效指针的特殊值。</li>
<li>测试内存分配函数的返回值是否是空指针，用来==判断内存分配是否成功==。</li>
<li><strong>NULL</strong>宏：空指针用NULL宏来表示。NULL宏在多个头（包括<code>&lt;stido.h&gt;</code>和<code>&lt;stdlib.h&gt;</code>）中都有定义。</li>
</ul>
</li>
<li><strong>释放存储空间</strong>：
<ul>
<li><strong><code>free()</code>函数</strong>：
<ul>
<li>原型：<code>void free(void *ptr)</code></li>
<li>==调用free函数会释放掉ptr指针指向的内存块==</li>
<li>free函数的实际参数必须是==先前由内存分配函数返回的指针==。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="指向函数的指针"><a class="markdownIt-Anchor" href="#指向函数的指针"></a> 指向函数的指针</h1>
<ul>
<li>如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段==存储空间的首地址==称为这个函数的地址,而且==函数名表示的就是这个地址==。</li>
<li><strong>函数指针</strong>；用一个指针变量来存储函数的地址。</li>
<li><strong>函数指针的声明</strong>：
<ul>
<li>声明模板：<code>函数返回值类型 (*函数指针变量名)(函数参数类型列表);</code></li>
<li>示例：<code>int (*p)(int,int);</code></li>
</ul>
</li>
<li><strong>函数指针调用函数</strong>：
<ul>
<li>通过<code>*</code>运算符来取出实际的函数。也可以直接通过函数指针变量名调用；</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">int fun(int x);&#x2F;&#x2F;声明函数
int (*p)(int);&#x2F;&#x2F;声明函数指针
p &#x3D; fun; &#x2F;&#x2F;函数指针指向fun函数
int result &#x3D; (*p)(5);&#x2F;&#x2F;调用函数
&#x2F;&#x2F;或者
int result &#x3D; p(5);</code></pre>
</li>
<li><strong>存储函数指针的指针数组</strong>：
<ul>
<li>可以声明元素为函数指针的数组：<code>void (*funs[10])(int);</code></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Spring/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Spring/index.html" class="post-title-link" itemprop="url">Spring</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-10 08:30:49" itemprop="dateCreated datePublished" datetime="2021-02-10T08:30:49+08:00">2021-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:27:52" itemprop="dateModified" datetime="2022-09-17T19:27:52+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web后端</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>31k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>28 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="spring简介"><a class="markdownIt-Anchor" href="#spring简介"></a> Spring简介</h1>
<ul>
<li>历史：
<ol>
<li>2002年，首次推出Spring框架的雏形：interface21框架</li>
<li>2004年3月24日，基于interface21框架，发布了Spring框架的1.0版本（本次学习使用的是Spring5）</li>
<li>Spring Framework的创始人：Rod Johnson</li>
</ol>
</li>
<li>Spring理念：使现有技术更加容易使用，本身整合了现有的很多技术框架。</li>
<li>SSH:struct2+Spring+Hibernate</li>
<li>SSM:SpringMVC+Spring+Mybatis</li>
<li><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-framework">官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://repo.spring.io/realse/org/springframework/spring">官网下载地址</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework">github地址</a></li>
<li>maven坐标：</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!-- 安装这个包，会自动添加其它依赖的包--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;
    &lt;version&gt;5.3.3&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;

&lt;!-- 和mybatis整合需要的包 --&gt;
&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework&#x2F;spring-webmvc --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;
    &lt;version&gt;5.3.3&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>
<ul>
<li>
<p>Spring优点：</p>
<ol>
<li>是一个开源的免费的框架；</li>
<li>轻量级，非入侵式框架；</li>
<li><strong>控制反转（IOC）</strong></li>
<li><strong>面向切面编程（AOP）</strong></li>
<li>支持事务的处理</li>
<li>支持框架整合</li>
</ol>
</li>
<li>
<p>缺点：配置繁琐</p>
</li>
<li>
<p>Spring的组成：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210210093918.jpg" alt="" /></p>
</li>
<li>
<p>Spring的拓展：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210210094952.jpg" alt="" /></p>
<ul>
<li>SpringBoot：
<ul>
<li>一个快速开发的脚手架；</li>
<li>基于SpringBoot可以快速开发单个的微服务；</li>
<li>约定大于配置</li>
</ul>
</li>
<li>SpringCloud:
<ul>
<li>SpringCloud是基于SpringBoot实现的。</li>
</ul>
</li>
<li>学习SpringBoot的前提是Spring及SpringMVC</li>
</ul>
</li>
</ul>
<h1 id="ioc"><a class="markdownIt-Anchor" href="#ioc"></a> IOC</h1>
<h2 id="ioc原型"><a class="markdownIt-Anchor" href="#ioc原型"></a> IOC原型</h2>
<ul>
<li>普通接口实现：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.service;

import com.zestaken.dao.UserDao;
import com.zestaken.dao.UserDaoImpl;

&#x2F;&#x2F;在service层调用Dao层的方法进行业务操作
public class UserServiceImpl implements UserService&#123;
    &#x2F;&#x2F;直接在编写程序时写好UserDao属性
    private UserDao userDao &#x3D; new UserDaoImpl();

    @Override
    public void getUsers() &#123;
        userDao.getUsers();
    &#125;
&#125;</code></pre>
<ul>
<li>IOC注入思想实现：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.service;

import com.zestaken.dao.UserDao;

public class UserServiceImpl implements UserService&#123;
    &#x2F;&#x2F;编写程序将UserDao对象设置为从外界获取注入的值，而不是直接由程序员设置
    private UserDao userDao;

    &#x2F;&#x2F;注入UserDao的值
    public void setUserDao(UserDao userDao) &#123;
        this.userDao &#x3D; userDao;
    &#125;

    @Override
    public void getUsers() &#123;
        userDao.getUsers();
    &#125;
&#125;</code></pre>
<ul>
<li>用普通的方法实现，每一次新增UserDao接口的实现类，都需要修改UserService实现类的代码。</li>
<li>普通实现方法:程序是<strong>主动创建对象</strong>，控制权在程序员的手上。</li>
<li>IOC思想实现：使用set注入后，程序<strong>不再具有主动性</strong>，而是被动接受传递的对象。</li>
<li>优点：程序员不用再去管理对象的创建了，系统的耦合性大大降低。</li>
</ul>
<h2 id="ioc本质"><a class="markdownIt-Anchor" href="#ioc本质"></a> IOC本质</h2>
<ul>
<li>控制反转（Inversion Of Control），是一种设计思想，DI（Dependency Injection，依赖注入）是实现IOC的一种方式。</li>
<li>未使用IOC思想的面向对象编程中，对象的创建和对象间的依赖关系，完全硬编码在程序中，<strong>对象的创建由程序自己控制</strong>，使用IOC思想后，<strong>对象的创建转移给第三方</strong>，控制反转即<strong>获得依赖对象的方式反转了</strong>。</li>
<li>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式；</li>
<li>在Spring中实现IOC的是<strong>IOC容器</strong>，其<strong>实现方法是DI（依赖注入）</strong>。</li>
</ul>
<h2 id="spring的ioc实现"><a class="markdownIt-Anchor" href="#spring的ioc实现"></a> Spring的IOC实现</h2>
<ol>
<li>书写接口实现类：</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;Dao层实现
package com.zestaken.dao;

public class UserDaoImpl implements UserDao&#123;
    @Override
    public void getUsers() &#123;
        System.out.println(&quot;sql查询&quot;);
    &#125;
&#125;
&#x2F;&#x2F;Service层实现
package com.zestaken.service;

import com.zestaken.dao.UserDao;

public class UserServiceImpl implements UserService&#123;
    private UserDao userDao ;

    &#x2F;&#x2F;注入UserDao的值
    &#x2F;&#x2F;使用Spring管理的类的属性，必须由set方法设定
    public void setUserDao(UserDao userDao) &#123;
        this.userDao &#x3D; userDao;
    &#125;

    @Override
    public void getUsers() &#123;
        userDao.getUsers();
    &#125;
&#125;</code></pre>
<ol start="2">
<li>将实现类用xml的方式交给Spring管理</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;
       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans
        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;

&lt;!--    在Spring中使用bean来创建对象，--&gt;
&lt;!--    id是该类生成的对象名，class是完全限定类名--&gt;
    &lt;bean id&#x3D;&quot;userDaoImpl&quot; class&#x3D;&quot;com.zestaken.dao.UserDaoImpl&quot;&#x2F;&gt;
    &lt;bean id&#x3D;&quot;userServiceImpl&quot; class&#x3D;&quot;com.zestaken.service.UserServiceImpl&quot;&gt;
&lt;!--        name指定需要赋值的属性 ref指定传递的对象--&gt;
        &lt;property name&#x3D;&quot;userDao&quot; ref&#x3D;&quot;userDaoImpl&quot;&#x2F;&gt;
    &lt;&#x2F;bean&gt;

&lt;&#x2F;beans&gt;</code></pre>
<ol start="3">
<li>测试：</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.service;

import org.junit.jupiter.api.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class ServiceTest &#123;
    @Test
    public void userServiceImplTest()&#123;
        &#x2F;&#x2F;获取Spring的上下文对象,参数是配置文件名
        ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        &#x2F;&#x2F;现在所有的对象都交由Spring管理了，要想使用对象，只需要从Spring中取出即可（Spring中这些对象叫做bean）
        UserServiceImpl userServiceImpl &#x3D; (UserServiceImpl) context.getBean(&quot;userServiceImpl&quot;);
        &#x2F;&#x2F;获取出对象之后，即可正常使用
        userServiceImpl.getUsers();
    &#125;
&#125;</code></pre>
<ul>
<li>控制：传统的程序的对象是由程序本身控制创建的，使用Spring的对象是由Spring来创建的；</li>
<li>反转：程序本身不创建对象，而变成<strong>被动的接收对象</strong>。</li>
<li>IOC即对象由Spring来创建，管理和装配。我们只需要修改相应的配置文件，例如此处由xml文件配置，则修改xml文件即可修改程序实现。</li>
</ul>
<h2 id="spring中ioc创建对象的方式"><a class="markdownIt-Anchor" href="#spring中ioc创建对象的方式"></a> Spring中IOC创建对象的方式</h2>
<ol>
<li>通过类的无参构造方法类构造对象，默认使用这种。</li>
<li>使用有参的构造方法构造：
<ol>
<li>下标赋值：</li>
</ol>
 <pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;exampleBean&quot; class&#x3D;&quot;examples.ExampleBean&quot;&gt;
&lt;constructor-arg index&#x3D;&quot;0&quot; value&#x3D;&quot;7500000&quot;&#x2F;&gt;
&lt;constructor-arg index&#x3D;&quot;1&quot; value&#x3D;&quot;42&quot;&#x2F;&gt;
&lt;&#x2F;bean&gt;</code></pre>
<ol start="2">
<li>类型赋值：</li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;exampleBean&quot; class&#x3D;&quot;examples.ExampleBean&quot;&gt;
 &lt;constructor-arg type&#x3D;&quot;int&quot; value&#x3D;&quot;7500000&quot;&#x2F;&gt;
 &lt;constructor-arg type&#x3D;&quot;java.lang.String&quot; value&#x3D;&quot;42&quot;&#x2F;&gt;
&lt;&#x2F;bean&gt;</code></pre>
<ol start="3">
<li>参数名赋值(常用)：</li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;exampleBean&quot; class&#x3D;&quot;examples.ExampleBean&quot;&gt;
 &lt;constructor-arg name&#x3D;&quot;years&quot; value&#x3D;&quot;7500000&quot;&#x2F;&gt;
 &lt;constructor-arg name&#x3D;&quot;ultimateAnswer&quot; value&#x3D;&quot;42&quot;&#x2F;&gt;
&lt;&#x2F;bean&gt;</code></pre>
</li>
</ol>
<h1 id="spring配置"><a class="markdownIt-Anchor" href="#spring配置"></a> Spring配置</h1>
<h2 id="alias别名"><a class="markdownIt-Anchor" href="#alias别名"></a> alias(别名)</h2>
<ul>
<li>如果配置了别名，我们也可以使用别名来获取到这个对象：</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;alias name&#x3D;&quot;userDaoImpl&quot; alias&#x3D;&quot;userDaoImpl2&quot;&#x2F;&gt;</code></pre>
<h2 id="bean配置"><a class="markdownIt-Anchor" href="#bean配置"></a> Bean配置</h2>
<ul>
<li>id:bean的唯一标识符，相当于对象名；</li>
<li>class：bean对象所对应的类的完全限定类名</li>
<li>name：也是别名，而且那么可以同时取多个别名，并且别名之间可以用空格，<code>,</code>,<code>;</code>等来分隔</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;userDaoImpl&quot; class&#x3D;&quot;com.zestaken.dao.UserDaoImpl&quot; name&#x3D;&quot;zhangjie lisi,zestaken;zhangsan&quot;&#x2F;&gt;</code></pre>
<h2 id="import配置"><a class="markdownIt-Anchor" href="#import配置"></a> import配置</h2>
<ul>
<li>一般用于团队开发使用，可以将多个配置文件导入到一个配置文件从而合并为一个配置文件:</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;import resource&#x3D;&quot;bean1.xml&quot;&#x2F;&gt;
&lt;import resource&#x3D;&quot;bean2.xml&quot;&#x2F;&gt;
&lt;import resource&#x3D;&quot;bean3.xml&quot;&#x2F;&gt;</code></pre>
<h1 id="依赖注入di"><a class="markdownIt-Anchor" href="#依赖注入di"></a> 依赖注入(DI)</h1>
<h2 id="一构造器注入"><a class="markdownIt-Anchor" href="#一构造器注入"></a> 一：构造器注入</h2>
<ul>
<li>构造器注入即有参数的构造方法来构造对象，在构造时将对象属性初始化。</li>
<li>三种方式：
<ol>
<li>下标赋值：</li>
</ol>
  <pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;exampleBean&quot; class&#x3D;&quot;examples.ExampleBean&quot;&gt;
&lt;constructor-arg index&#x3D;&quot;0&quot; value&#x3D;&quot;7500000&quot;&#x2F;&gt;
&lt;constructor-arg index&#x3D;&quot;1&quot; value&#x3D;&quot;42&quot;&#x2F;&gt;
&lt;&#x2F;bean&gt;</code></pre>
<ol start="2">
<li>类型赋值：</li>
</ol>
 <pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;exampleBean&quot; class&#x3D;&quot;examples.ExampleBean&quot;&gt;
 &lt;constructor-arg type&#x3D;&quot;int&quot; value&#x3D;&quot;7500000&quot;&#x2F;&gt;
 &lt;constructor-arg type&#x3D;&quot;java.lang.String&quot; value&#x3D;&quot;42&quot;&#x2F;&gt;
&lt;&#x2F;bean&gt;</code></pre>
<ol start="3">
<li>参数名赋值(常用)：</li>
</ol>
 <pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;exampleBean&quot; class&#x3D;&quot;examples.ExampleBean&quot;&gt;
 &lt;constructor-arg name&#x3D;&quot;years&quot; value&#x3D;&quot;7500000&quot;&#x2F;&gt;
 &lt;constructor-arg name&#x3D;&quot;ultimateAnswer&quot; value&#x3D;&quot;42&quot;&#x2F;&gt;
&lt;&#x2F;bean&gt;</code></pre>
</li>
</ul>
<h2 id="二setter方法注入"><a class="markdownIt-Anchor" href="#二setter方法注入"></a> 二:setter方法注入</h2>
<ul>
<li>依赖：bean对象的创建依赖于容器；</li>
<li>注入:bean对象中的所有属性由容器来注入。</li>
<li>使用这种方式注入的属性，必须全部使用setter方法来设置属性。</li>
<li>不同类型的属性的注入方式不同：
<ol>
<li>基本类型以及String类型的注入：通过<code>value</code>来实现</li>
</ol>
  <pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;zhangjie&quot;&#x2F;&gt;</code></pre>
<ol start="2">
<li>bean类型注入（即属性类型是类类型，且这个类的实现对象必须在Spring中注册）：使用<code>ref</code>:</li>
</ol>
 <pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;address&quot; class&#x3D;&quot;com.zestaken.pojo.Address&quot;&#x2F;&gt;
&lt;bean id&#x3D;&quot;person&quot; class&#x3D;&quot;com.zestaken.pojo.Person&quot;&gt;
     &lt;property name&#x3D;&quot;address&quot; ref&#x3D;&quot;address&quot;&#x2F;&gt;
&lt;&#x2F;bean&gt;</code></pre>
<ol start="3">
<li>数组，list集合 map集合,set集合类型的注入，需要使用专门的标签：</li>
</ol>
 <pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">   &lt;!-- 数组 --&gt;
       &lt;property name&#x3D;&quot;books&quot;&gt;
        &lt;array&gt;
            &lt;value&gt;红楼梦&lt;&#x2F;value&gt;
            &lt;value&gt;西游记&lt;&#x2F;value&gt;
        &lt;&#x2F;array&gt;
    &lt;&#x2F;property&gt;
    &lt;!--list集合  --&gt;
    &lt;property name&#x3D;&quot;hobbys&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;写代码&lt;&#x2F;value&gt;
            &lt;value&gt;看书&lt;&#x2F;value&gt;
        &lt;&#x2F;list&gt;
    &lt;&#x2F;property&gt;
    &lt;!--map集合  --&gt;
    &lt;property name&#x3D;&quot;card&quot;&gt;
        &lt;map&gt;
            &lt;entry key&#x3D;&quot;身份证&quot; value&#x3D;&quot;123435&quot;&#x2F;&gt;
            &lt;entry key&#x3D;&quot;银行卡&quot; value&#x3D;&quot;2340273&quot;&#x2F;&gt;
        &lt;&#x2F;map&gt;
    &lt;&#x2F;property&gt;
&lt;!--set集合  --&gt;
    &lt;property name&#x3D;&quot;games&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;lol&lt;&#x2F;value&gt;
            &lt;value&gt;csgo&lt;&#x2F;value&gt;
            &lt;value&gt;overwatch&lt;&#x2F;value&gt;
        &lt;&#x2F;set&gt;
    &lt;&#x2F;property&gt;</code></pre>
<ol start="4">
<li>Properties类型的注入：</li>
</ol>
  <pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;property name&#x3D;&quot;properties&quot;&gt;
    &lt;props&gt;
        &lt;prop key&#x3D;&quot;username&quot;&gt;zhangjie&lt;&#x2F;prop&gt;
        &lt;prop key&#x3D;&quot;password&quot;&gt;12435325&lt;&#x2F;prop&gt;
    &lt;&#x2F;props&gt;
&lt;&#x2F;property&gt;</code></pre>
<ol start="5">
<li>赋值为null的注入：</li>
</ol>
  <pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;property name&#x3D;&quot;girlfriend&quot;&gt;
    &lt;null&#x2F;&gt;
&lt;&#x2F;property&gt;</code></pre>
</li>
</ul>
<h2 id="三c命名空间注入"><a class="markdownIt-Anchor" href="#三c命名空间注入"></a> 三：c命名空间注入</h2>
<ul>
<li>对应构造器注入的方式，c命名空间相当于constructor-arg标签，所以必须有有参数的构造方法才能使用这种方式。</li>
<li>使用c命名空间，必须先导入对应的xml约束：</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">xmlns:c&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;c&quot;</code></pre>
<ul>
<li>示例；</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!-- c-namespace declaration with argument names --&gt;
   &lt;bean id&#x3D;&quot;beanOne&quot; class&#x3D;&quot;x.y.ThingOne&quot; c:thingTwo-ref&#x3D;&quot;beanTwo&quot;
       c:thingThree-ref&#x3D;&quot;beanThree&quot; c:email&#x3D;&quot;something@somewhere.com&quot;&#x2F;&gt;</code></pre>
<h2 id="四p命名空间注入"><a class="markdownIt-Anchor" href="#四p命名空间注入"></a> 四：p命名空间注入</h2>
<ul>
<li>对应setter的注入方式，p命名空间相当于property标签，所以必须有setter方法才能使用这种方法。</li>
<li>使用p命名空间，也必须先导入相应的xml约束：</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;</code></pre>
<ul>
<li>示例：</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;bean name&#x3D;&quot;p-namespace&quot; class&#x3D;&quot;com.example.ExampleBean&quot;
    p:email&#x3D;&quot;someone@somewhere.com&quot;&#x2F;&gt;</code></pre>
<h1 id="bean的作用域"><a class="markdownIt-Anchor" href="#bean的作用域"></a> Bean的作用域</h1>
<ol>
<li>单例模式:从一个bean中无论获取多少次获取的都是同一个对象。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210220100546.jpg" alt="" />
<ul>
<li>单例模式是bean的默认作用域，也可以显式设置：</li>
</ul>
 <pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.something.DefaultAccountService&quot;&#x2F;&gt;

&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;
&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.something.DefaultAccountService&quot; scope&#x3D;&quot;singleton&quot;&#x2F;&gt;</code></pre>
</li>
<li>原型模式：每次从bean中获取的对象都是新的对象。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210220100858.jpg" alt="" />
<ul>
<li>设置原型模式：</li>
</ul>
 <pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.something.DefaultAccountService&quot; scope&#x3D;&quot;prototype&quot;&#x2F;&gt;</code></pre>
</li>
<li>Request</li>
<li>Session</li>
<li>Application</li>
<li>WebSocket （后面的四个都是在web开发中使用的）</li>
</ol>
<h1 id="bean的自动装配"><a class="markdownIt-Anchor" href="#bean的自动装配"></a> Bean的自动装配</h1>
<ul>
<li>装配：有些对象的属性是另一个由Spring管理的对象，给这个属性赋值就是装配。所以不是所有由Spring管理的对象都需要装配。</li>
<li>自动装配：Spring会在上下文中自动寻找，并<strong>自动给bean装配属性</strong>。</li>
<li>Spring中的三种装配方式：
<ol>
<li>在xml中显式的配置</li>
<li>在java中显式的配置</li>
<li>隐式的自动装配bean</li>
</ol>
</li>
<li>自动装配的两种方式：
<ol>
<li>byName：会自动在容器上下文中寻找id属性值和自己对象的set方法后面的名称相同的bean。
<ol>
<li>使用byName需要保证所有bean的id唯一，并且这个bean的id值需要和自动注入的属性的对应的set方法值一致。</li>
<li>示例：</li>
</ol>
</li>
</ol>
 <pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;userServiceImpl&quot; class&#x3D;&quot;com.zestaken.service.UserServiceImpl&quot; autowire&#x3D;&quot;byName&quot;&gt;
 &lt;!--        name指定需要赋值的属性 ref指定传递的对象--&gt;
 &lt;!--        &lt;property name&#x3D;&quot;userDao&quot; ref&#x3D;&quot;userDaoImpl&quot;&#x2F;&gt; --&gt;
&lt;&#x2F;bean&gt;</code></pre>
<ol start="2">
<li>byType:会自动在容器上下文中寻找和自己对象的类型相同的bean。</li>
<li>使用byType需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致。</li>
<li>示例：</li>
</ol>
  <pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;userServiceImpl&quot; class&#x3D;&quot;com.zestaken.service.UserServiceImpl&quot; autowire&#x3D;&quot;byType&quot;&gt;
&lt;!--        name指定需要赋值的属性 ref指定传递的对象--&gt;
&lt;!--        &lt;property name&#x3D;&quot;userDao&quot; ref&#x3D;&quot;userDaoImpl&quot;&#x2F;&gt; --&gt;
&lt;&#x2F;bean&gt;</code></pre>
</li>
</ul>
<h1 id="spring注解开发"><a class="markdownIt-Anchor" href="#spring注解开发"></a> Spring注解开发</h1>
<ul>
<li><strong>开启注解</strong>：
<ul>
<li>扫描包中的注解：如扫描<code>@Component</code>注解<code>&lt;context:component-scan base-package=&quot;com.zestaken&quot;/&gt;</code></li>
<li>配置注解的支持：<code>&lt;context:annotation-config/&gt;</code></li>
</ul>
</li>
<li>xml与注解优缺点：
<ul>
<li>xml更加万能，维护更加方便；</li>
<li>注解需要能够修改类中的代码，维护相对困难；</li>
</ul>
</li>
<li>xml与注解配合使用：
<ul>
<li>xml用来管理bean；</li>
<li>注解只负责属性注入，即<code>@Value</code>。</li>
</ul>
</li>
</ul>
<h2 id="注解注册bean"><a class="markdownIt-Anchor" href="#注解注册bean"></a> 注解注册bean</h2>
<ul>
<li><code>@Component</code>注解：
<ul>
<li>组件注解，==放在类上==,说明这个类被Spring管理了，即==注册lbean==；</li>
<li>自动注入的bean对象名是==类名的首字母小写==形成的。</li>
<li>等价于<code>&lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.zestaken.dao.UserDaoImpl&quot; /&gt;</code></li>
</ul>
</li>
<li><code>@Component</code>为mvc模式形成的衍生注解,这些==注解功能完全相同==，只是为了更好的区分架构层而使用：
<ul>
<li>dao层:<code>@Repository</code></li>
<li>service层：<code>@Service</code></li>
<li>controller层：<code>@Controller</code></li>
</ul>
</li>
</ul>
<h2 id="注解注入属性"><a class="markdownIt-Anchor" href="#注解注入属性"></a> 注解注入属性</h2>
<ul>
<li><code>@Value(&quot;属性值&quot;)</code>注解：
<ul>
<li>在基本类型以及字符串类型对象上使用，为创建的对象的的对应属性赋值。</li>
<li>等价于<code>&lt;property name=&quot;name&quot; value=&quot;zestaken&quot;/&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="注解配置作用域"><a class="markdownIt-Anchor" href="#注解配置作用域"></a> 注解配置作用域</h2>
<ul>
<li><code>@Scope(&quot;作用域&quot;)</code>注解：
<ul>
<li>用于配置bean对象的作用域，如：<code>@Scope(&quot;prototype&quot;)</code></li>
</ul>
</li>
</ul>
<h2 id="注解实现自动装配"><a class="markdownIt-Anchor" href="#注解实现自动装配"></a> 注解实现自动装配</h2>
<ul>
<li>注解使用配置：
<ol>
<li>导入约束：
<ul>
<li><code>xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</code></li>
<li><code>http://www.springframework.org/schema/context</code></li>
<li><code>https://www.springframework.org/schema/context/spring-context.xsd&quot;</code><br />
2.配置注解的支持：<code>&lt;context:annotation-config/&gt;</code></li>
</ul>
</li>
<li>示例：</li>
</ol>
  <pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;
    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
    xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;
    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans
        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd
        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context
        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;

    &lt;context:annotation-config&#x2F;&gt;

&lt;&#x2F;beans&gt;</code></pre>
</li>
<li><code>@Autowired</code>注解：
<ul>
<li>使用该注解在类中需要导入包:<code>import org.springframework.beans.factory.annotation.Autowired;</code>
<ul>
<li>这个包需要在maven中配置导入。</li>
</ul>
</li>
<li>直接在==属性==上使用即可，也可以在set方法上使用。</li>
<li>使用这个注解，可以==不用编写属性对应的set方法==。前提是要被装配的属性在Spring容器中存在。</li>
<li>配置注解<code>@Autowired(required = false)</code>可以使属性可以为空，默认不能。与注解<code>@Nullable</code>作用相同。</li>
<li><code>@Autowird</code>注解：会自动根据该属性的==类型或者名字==来自动装配;
<ul>
<li>可以配合使用<code>@Qualifier(value = &quot;属性名&quot;)</code>来限定根据bean id的名字来装配。</li>
</ul>
</li>
<li>示例：</li>
</ul>
  <pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.service;

import com.zestaken.dao.UserDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;

public class UserServiceImpl implements UserService&#123;
    @Autowired
    @Qualifier(value &#x3D; &quot;userDaoImpl&quot;)
    private UserDao userDao ;

    &#x2F;&#x2F;注入UserDao的值
    &#x2F;&#x2F;使用Spring管理的类的属性，必须由set方法设定
    public void setUserDao(UserDao userDao) &#123;
        this.userDao &#x3D; userDao;
    &#125;

    @Override
    public void getUsers() &#123;
        userDao.getUsers();
    &#125;
&#125;</code></pre>
</li>
<li><code>@Resource</code>注解：
<ul>
<li><code>@Resource</code>注解是java==原生==的，无需导入包；</li>
<li><code>@Resource</code>相当于拥有<code>@Autowired</code>和<code>@Qualifier</code>两个注解的功能。</li>
<li>直接使用该注解，和<code>@Autowired</code>一样；</li>
<li>该注解可以设置参数，限定查找的bean id属性名，如：<code>@Resource(name = &quot;userDaoImpl&quot;)</code>.</li>
</ul>
</li>
</ul>
<h1 id="使用java来配置spring"><a class="markdownIt-Anchor" href="#使用java来配置spring"></a> 使用Java来配置Spring</h1>
<ul>
<li>本质：使用一个java配置类通过注解的方式来完全取代xml配置文件。</li>
</ul>
<ol>
<li>配置类：</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.config;

import com.zestaken.dao.UserDao;
import com.zestaken.dao.UserDaoImpl;
import com.zestaken.service.UserService;
import com.zestaken.service.UserServiceImpl;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig &#123;

    @Bean
    public UserDao userDao() &#123;
        return new UserDaoImpl();
    &#125;

    @Bean
    public UserService userService() &#123;
        return new UserServiceImpl();
    &#125;
&#125;</code></pre>
<ul>
<li><code>@Configuration</code>注解：在配置类上面使用，代表这是一个配置类。（这个配置类的底层实质也是一个被Spring容器管理的类）</li>
<li><code>@Bean</code>注解：类似xml文件中的bean标签的作用，用于设置bean对象的方法之上：
<ul>
<li>这个==方法的名字，相当于bean对象中的id属性==；</li>
<li>这个==方法的返回值，相当于bean对象中的class属性==。</li>
</ul>
</li>
<li>还有一些诸如扫描包，导入其它配置类的注解等。</li>
</ul>
<ol start="2">
<li>被注册到Spring容器的类</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;UserDao
package com.zestaken.dao;

import org.springframework.stereotype.Component;

@Component
public class UserDaoImpl implements UserDao&#123;
    @Override
    public void getUsers() &#123;
        System.out.println(&quot;sql查询&quot;);
    &#125;
&#125;

&#x2F;&#x2F;UserService
package com.zestaken.service;

import com.zestaken.dao.UserDao;

import org.springframework.stereotype.Component;

import javax.annotation.Resource;

@Component
public class UserServiceImpl implements UserService&#123;

    @Resource
    private UserDao userDao ;

    &#x2F;&#x2F;注入UserDao的值
    &#x2F;&#x2F;使用Spring管理的类的属性，必须由set方法设定
    public void setUserDao(UserDao userDao) &#123;
        this.userDao &#x3D; userDao;
    &#125;

    @Override
    public void getUsers() &#123;
        userDao.getUsers();
    &#125;
&#125;</code></pre>
<ul>
<li>和普通注解开发一样。</li>
<li>测试：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.service;

import com.zestaken.config.AppConfig;
import org.junit.jupiter.api.Test;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class ServiceTest &#123;
    @Test
    public void  userServiceImplTest()&#123;
        &#x2F;&#x2F;获取Spring的上下文对象,此处使用AnnotationConfig
        AnnotationConfigApplicationContext annotationConfigApplicationContext &#x3D; new AnnotationConfigApplicationContext(AppConfig.class);
        &#x2F;&#x2F;现在所有的对象都交由Spring管理了，要想使用对象，只需要从Spring中取出即可（Spring中这些对象叫做bean）
        UserService userServiceImpl &#x3D; (UserService)annotationConfigApplicationContext.getBean(&quot;userService&quot;);
        &#x2F;&#x2F;获取出对象之后，即可正常使用
        userServiceImpl.getUsers();
    &#125;
&#125;</code></pre>
<ul>
<li><strong>获取上下文的方式</strong>：<code>AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);</code>
<ul>
<li><strong>参数</strong>:参数是要使用的配置类的class属性值。</li>
</ul>
</li>
</ul>
<h1 id="aop"><a class="markdownIt-Anchor" href="#aop"></a> AOP</h1>
<ul>
<li><strong>AOP(Aspect Oriented Programming)</strong>:面向切面编程，通过==预编译技术和运行期间动态代理==实现程序功能的统一维护的一种技术。</li>
<li>Spring中AOP：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210228205043.jpg" alt="" /></li>
<li>AOP在Spring中的作用：
<ul>
<li>提供声明式事务：允许用户自定义切面。</li>
</ul>
</li>
</ul>
<h2 id="spring中aop概念"><a class="markdownIt-Anchor" href="#spring中aop概念"></a> Spring中AOP概念</h2>
<ul>
<li><strong>横切关注点</strong>：
<ul>
<li>跨越应用程序多个模块的方法或功能。</li>
<li>与我们业务逻辑无关的，但是需要我们关注的的部分，就是横切关注点，如日志，安全，缓存和事务等。</li>
</ul>
</li>
<li><strong>切面（Aspect）</strong>:
<ul>
<li>横切关注点被模块化的特殊对象；</li>
<li>切面==是一个类==。</li>
</ul>
</li>
<li><strong>通知（Advice）</strong>:
<ul>
<li>切面必须要完成的工作；</li>
<li>==通知是切面类中的一个方法==。</li>
<li>Spring中支持五种类型的Advice:
<ol>
<li><strong>前置通知</strong>:
<ol>
<li>连接点：方法前；</li>
<li>实现接口：<code>org.springframework.aop.MethodBeforeAdvice</code></li>
</ol>
</li>
<li><strong>后置通知</strong>：
<ol>
<li>连接点：方法后；</li>
<li>实现接口：<code>org.springframework.aop.AfterReturningAdvice</code></li>
</ol>
</li>
<li><strong>环绕通知</strong>：
<ol>
<li>连接点：方法前后；</li>
<li>实现接口：<code>org.aopalliance.intercept.MethodInterceptor</code></li>
</ol>
</li>
<li><strong>异常抛出通知</strong>：
<ol>
<li>连接点：方法抛出异常；</li>
<li>实现接口：<code>org.springframework.aop.ThrowsAdvice</code></li>
</ol>
</li>
<li><strong>引介通知</strong>：
<ol>
<li>连接点：类中增加新的方法属性。</li>
<li>实现接口：<code>org.springframework.aop.IntroductionInterceptor</code></li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li><strong>目标（Target）</strong>：
<ul>
<li>被通知的对象</li>
</ul>
</li>
<li><strong>代理(Proxy)</strong>:
<ul>
<li>向目标对象应用通知之后创建的==对象==；</li>
</ul>
</li>
<li><strong>切入点（PointCut）</strong>：
<ul>
<li>切面通知执行“地点”的定义；</li>
</ul>
</li>
<li><strong>连接点（JointPoint）</strong>：
<ul>
<li>与切入点匹配的执行点。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210228211039.jpg" alt="" /></li>
</ul>
</li>
</ul>
<h2 id="spring实现aop"><a class="markdownIt-Anchor" href="#spring实现aop"></a> Spring实现AOP</h2>
<ul>
<li>不论采用何种方法，首先都需要先导入一个织入包：</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.aspectj&#x2F;aspectjweaver --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt;
    &lt;version&gt;1.9.6&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>
<h3 id="方式一使用spring的api接口实现aop"><a class="markdownIt-Anchor" href="#方式一使用spring的api接口实现aop"></a> 方式一：使用Spring的API接口实现AOP</h3>
<ul>
<li>主功能的接口：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.service;

public interface UserService &#123;
    void add();
    void delete();
&#125;</code></pre>
<ul>
<li>实现主功能的类：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.service;

public class UserServiceImpl implements UserService &#123;
    @Override
    public void add() &#123;
        System.out.println(&quot;add...&quot;);
    &#125;

    @Override
    public void delete() &#123;
        System.out.println(&quot;delete...&quot;);
    &#125;
&#125;</code></pre>
<ul>
<li>在主功能的方法前加上日志的类：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.log;

import org.springframework.aop.MethodBeforeAdvice;

import java.lang.reflect.Method;

public class Log implements MethodBeforeAdvice &#123;
    @Override
    public void before(Method method, Object[] args, Object target) throws Throwable &#123;
        System.out.println(target.getClass().getName()+&quot;的&quot;+method.getName()+&quot;方法被执行了&quot;);
    &#125;
&#125;</code></pre>
<ul>
<li>before方法的参数：
<ul>
<li>method:要执行的目标对象的方法</li>
<li>args：要执行的目标方法的参数</li>
<li>target：目标对象</li>
</ul>
</li>
<li>要增加到切点的的类，应该==根据这个类中方法插入的位置，来实现不用的Spring的aop的API接口==.</li>
<li>在applicationContext.xml文件中==注册主功能类和增加日志方法的类,并配置aop==：</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;
       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
       xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;
       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans
        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd
        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop
        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt;

&lt;!--    注册主功能类和增加日志功能的类--&gt;
    &lt;bean id&#x3D;&quot;userServiceImpl&quot; class&#x3D;&quot;com.zestaken.service.UserServiceImpl&quot;&#x2F;&gt;
    &lt;bean id&#x3D;&quot;log&quot; class&#x3D;&quot;com.zestaken.log.Log&quot;&#x2F;&gt;

&lt;!--    配置aop，需要导入约束--&gt;
    &lt;aop:config&gt;
&lt;!--        配置切入点--&gt;
&lt;!--        id是切入点的名字--&gt;
&lt;!--        expression描述切入点的位置,使用execution表达式,execution表达式的格式为（修饰词，返回值，类名，方法名，参数）--&gt;
        &lt;aop:pointcut id&#x3D;&quot;pointcut1&quot; expression&#x3D;&quot;execution(* com.zestaken.service.UserService.*(..))&quot;&#x2F;&gt;
&lt;!--        配置增加到切入点的方法--&gt;
        &lt;aop:advisor advice-ref&#x3D;&quot;log&quot; pointcut-ref&#x3D;&quot;pointcut1&quot;&#x2F;&gt;
    &lt;&#x2F;aop:config&gt;

&lt;&#x2F;beans&gt;</code></pre>
<ul>
<li>导入的约束：
<ul>
<li><code>xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</code></li>
<li><code>http://www.springframework.org/schema/aop</code></li>
<li><code>https://www.springframework.org/schema/aop/spring-aop.xsd</code></li>
</ul>
</li>
<li>excution表达式描述切入点的位置，==其中可以用<code>*</code>通配符来表示适用于各种修饰词，返回值，方法名，用<code>(..)</code>表示方法的任何参数==。</li>
<li>测试aop：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import com.zestaken.service.UserService;

import org.junit.jupiter.api.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class MyTest &#123;
    @Test
    public void aopTest() &#123;
        &#x2F;&#x2F;获取配置文件生成上下文对象
        ApplicationContext classPathXmlApplicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        &#x2F;&#x2F;获取接口
        UserService userService &#x3D; (UserService)classPathXmlApplicationContext.getBean(&quot;userServiceImpl&quot;);
        &#x2F;&#x2F;测试方法
        userService.add();
        userService.delete();
    &#125;
&#125;</code></pre>
<ul>
<li><strong>==注意：aop的本质是动态代理，动态代理的是接口，所以从容器中获取出来的应该是接口类型的对象==</strong>。</li>
</ul>
<h3 id="方法二自定义方法实现aop"><a class="markdownIt-Anchor" href="#方法二自定义方法实现aop"></a> 方法二：自定义方法实现AOP</h3>
<ul>
<li>主功能类与接口不变。</li>
<li>在主功能类前增加日志功能的类：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Log &#123;
    void before()&#123;
        System.out.println(&quot;before....&quot;);
    &#125;
&#125;</code></pre>
<ul>
<li>==无需实现接口==，只是一个普通的类。</li>
<li>配置文件：</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;aop:config&gt;
    &lt;aop:aspect ref&#x3D;&quot;log&quot;&gt;
        &lt;aop:pointcut id&#x3D;&quot;pointcut2&quot; expression&#x3D;&quot;execution(* com.zestaken.service.UserServiceImpl.*(..))&quot;&#x2F;&gt;
        &lt;aop:before method&#x3D;&quot;before&quot; pointcut-ref&#x3D;&quot;pointcut2&quot;&#x2F;&gt;
    &lt;&#x2F;aop:aspect&gt;
&lt;&#x2F;aop:config&gt;</code></pre>
<ul>
<li>在类注册好，以及导入必须的约束的情况下，修改aop的配置。</li>
<li><code>&lt;aop:aspect&gt;</code>标签中，用==属性ref设置需要放入切面的方法==</li>
<li><code>&lt;aop:pointcut&gt;</code>标签中，正常设置切入点。</li>
<li><code>&lt;aop:before&gt;</code>以及<code>&lt;aop:after&gt;</code>等标签设置将绑定的方法==放入哪个位置，以及放入的方式==。</li>
</ul>
<h3 id="方法三使用注解实现aop"><a class="markdownIt-Anchor" href="#方法三使用注解实现aop"></a> 方法三：使用注解实现AOP</h3>
<ul>
<li><strong>只修改实现增强功能的类以及xml文件</strong>。</li>
<li>实现增强功能的类:</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect
public class Log &#123;

    @Before(&quot;execution(* com.zestaken.service.UserServiceImpl.*(..))&quot;)
    void before()&#123;
        System.out.println(&quot;before....&quot;);
    &#125;
&#125;</code></pre>
<ul>
<li><code>@Aspect</code>注解：表示该类是用于切面的增强功能的类。</li>
<li><code>@Before</code>注解：表示切入的方式，参数是切入点的位置。
<ul>
<li>可以有多种切入方式。如<code>@After</code>，<code>@Around</code>等。</li>
</ul>
</li>
<li>可以给通知方法传递参数**<code>ProceedingJoinPoint joinPoint</code>连接点对象**，作用是获取切入点的信息。如方法名之类的。</li>
<li>xml配置文件：==省去aop配置，开启aop的注解功能==。但是aop的相关约束还是要有。</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;aop:aspectj-autoproxy proxy-target-class&#x3D;&quot;false&quot;&#x2F;&gt;</code></pre>
<ul>
<li>在注册了相关的bean之后，再开启aop的注解。</li>
<li>aop的动态代理默认是用jdk方式实现的 ，将proxy-target-class属性设为true会改为使用cglib实现。</li>
<li>proxy-target-class属性可以省略，这样默认使用jdk方式。</li>
</ul>
<h1 id="spring整合mybatis"><a class="markdownIt-Anchor" href="#spring整合mybatis"></a> Spring整合Mybatis</h1>
<h2 id="导入相关jar包"><a class="markdownIt-Anchor" href="#导入相关jar包"></a> 导入相关jar包</h2>
<ol>
<li>junit</li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;
    &lt;version&gt;4.13&lt;&#x2F;version&gt;
    &lt;scope&gt;test&lt;&#x2F;scope&gt;
&lt;&#x2F;dependency&gt;</code></pre>
<ol start="2">
<li>mybatis</li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;
    &lt;version&gt;3.5.6&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>
<ol start="3">
<li>mysql数据库</li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;
    &lt;version&gt;8.0.23&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>
<ol start="4">
<li>Spring基本包</li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;
    &lt;version&gt;5.3.3&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>
<ol start="5">
<li>Spring的AOP织入包</li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt;
    &lt;version&gt;1.9.6&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>
<ol start="6">
<li>Spring操作数据库必须的包</li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;
    &lt;version&gt;5.3.4&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>
<ol start="7">
<li>整合Mybatis和Spring的包：mybatis-spring</li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt;
    &lt;version&gt;2.0.6&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>
<h2 id="spring整合mybatis方式一"><a class="markdownIt-Anchor" href="#spring整合mybatis方式一"></a> Spring整合Mybatis方式一</h2>
<p><a target="_blank" rel="noopener" href="http://mybatis.org/spring/zh/index.html">Mybatis-spring文档</a></p>
<ol>
<li>编写Spring对Mybatis的配置文件：</li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;!--suppress ALL --&gt;
&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;
       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans
        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;
&lt;!--    注册DataSource 使用Spring的提供的JDBC来替换Mybatis的数据源配置--&gt;
    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.cj.jdbc.Driver&quot;&#x2F;&gt;
        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;youth_study&quot;&#x2F;&gt;
        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;
        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;
    &lt;&#x2F;bean&gt;

&lt;!--    sqlSessionFactory--&gt;
    &lt;bean id&#x3D;&quot;sqlSessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;
&lt;!--        绑定Mybatis的配置文件，使这两个配置文件同时作用，各自负责一部分配置--&gt;
        &lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;classpath:mybatis-config.xml&quot;&#x2F;&gt;
        &lt;!-- 绑定mapper.xml文件，起到注册mapper的作用 --&gt;
        &lt;property name&#x3D;&quot;mapperLocations&quot; value&#x3D;&quot;classpath:com&#x2F;zestaken&#x2F;dao&#x2F;T_collegeMapper.xml&quot;&#x2F;&gt;
    &lt;&#x2F;bean&gt;

&lt;!--    sqlSessionTemplate：就是实际使用的sqlSession--&gt;
    &lt;bean id&#x3D;&quot;sqlSessionTemplate&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;
&lt;!--        只能使用构造器注入sqlSessionFactory，因为没有set方法--&gt;
        &lt;constructor-arg index&#x3D;&quot;0&quot; ref&#x3D;&quot;sqlSessionFactory&quot;&#x2F;&gt;
    &lt;&#x2F;bean&gt;
&lt;&#x2F;beans&gt;</code></pre>
<ul>
<li>这是一个Spring配置文件，==Spring配置文件的约束要有==。</li>
<li><strong>配置数据源（datasource）</strong>：使用<code>org.springframework.jdbc.datasource.DriverManagerDataSource</code>类。具体配置与mybatis一样。</li>
<li><strong>配置sqlSessionFactory</strong>：
<ul>
<li>使用<code>org.mybatis.spring.SqlSessionFactoryBean</code>类；</li>
<li>配置使用的数据源；</li>
<li>导入mybatis本来的配置；</li>
<li>导入mapper的配置。</li>
</ul>
</li>
<li><strong>配置sqlSessionTemplate</strong>:
<ul>
<li>使用<code>org.mybatis.spring.SqlSessionTemplate</code>类；</li>
<li>用以==取代原来的sqlSession对象。</li>
<li>向sqlSessionTemplate==注入sqlSessionFactory==，并且只能使用构造器注入，因为没有set方法。</li>
</ul>
</li>
<li><strong>将mapper实现类注册为bean</strong>：
<ul>
<li>==将sqlSessionTemplate==注入到mapper实现类中去。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>编写mapper实现类</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.dao;

import com.zestaken.pojo.T_college;

import org.mybatis.spring.SqlSessionTemplate;

import java.util.List;

public class T_collegeMapperImpl implements T_collegeMapper &#123;

&#x2F;&#x2F;    需要导入包，SqlSessionTemplate模板或得sqlSession来执行操作
    private SqlSessionTemplate sqlSession;

&#x2F;&#x2F;设置sqlSession的set方法，方便Spring的注入
    public void setSqlSession(SqlSessionTemplate sqlSession) &#123;
        this.sqlSession &#x3D; sqlSession;
    &#125;


    public List&lt;T_college&gt; getT_collegeList() &#123;
        T_collegeMapper t_collegeMapper &#x3D; sqlSession.getMapper(T_collegeMapper.class);
        List&lt;T_college&gt; t_collegeList &#x3D; t_collegeMapper.getT_collegeList();

        return t_collegeList;
    &#125;
&#125;</code></pre>
<ul>
<li>这个实现类需要实现mapper接口中的方法；</li>
<li>同时==还需创建SqlSessionTemplate属性，并设置它对应的set方法==。
<ul>
<li><code>SqlSessionTemplate属性</code>需要导入包：<code>org.mybatis.spring.SqlSessionTemplate</code></li>
</ul>
</li>
<li>相当于将==实际使用时获取mapper，执行对应sql语句的步骤直接放到这个实现类中去完成==，实际使用的时候，只需==获取该实现类的bean，调用相应的方法即可==。<br />
4.Spring配置文件：</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;!--suppress ALL --&gt;
&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;
       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans
        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;
&lt;!--将数据库操作实现类注册到Spring--&gt;
    &lt;bean id&#x3D;&quot;t_collegeMapperImpl&quot; class&#x3D;&quot;com.zestaken.dao.T_collegeMapperImpl&quot;&gt;
        &lt;property name&#x3D;&quot;sqlSession&quot; ref&#x3D;&quot;sqlSessionTemplate&quot;&#x2F;&gt;
    &lt;&#x2F;bean&gt;
&lt;&#x2F;beans&gt;</code></pre>
<ol start="5">
<li>mybatis-config.xml配置文件：</li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;
        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;
&lt;!-- 核心配置文件 --&gt;
&lt;configuration&gt;

&lt;&#x2F;configuration&gt;</code></pre>
<ol start="6">
<li>测试：</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void getT_collegeListTest()&#123;
    ClassPathXmlApplicationContext classPathXmlApplicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;spring-dao.xml&quot;);
    T_collegeMapper t_collegeMapperImpl &#x3D; classPathXmlApplicationContext.getBean(&quot;t_collegeMapperImpl&quot;, T_collegeMapper.class);

    List&lt;T_college&gt; t_collegeList &#x3D; t_collegeMapperImpl.getT_collegeList();
    for(T_college college : t_collegeList)&#123;
        System.out.println(college);
    &#125;
&#125;</code></pre>
<ul>
<li>Spring整合Mybatis的常用配置方法：
<ul>
<li>mybatis自己的配置文件(一般是mybatis-config.xml)中只放别名和设置的配置；(==将与Spring对Mybaits的配置相同的配置全部移除，如数据源配置，mapper注册等==)</li>
<li>关于Spring的Mybatis配置单独创建一个Spring配置文件来管理；</li>
<li>Spring自己的配置（如注册bean等）用一个单独的Spring配置文件来管理。</li>
</ul>
</li>
</ul>
<h2 id="spring整合mybatis方式二"><a class="markdownIt-Anchor" href="#spring整合mybatis方式二"></a> Spring整合Mybatis方式二</h2>
<ul>
<li>在方式一的基础上==只对mapper实现类获取SqlSessionTemplate的方式作了简化==；</li>
<li>mapper实现类：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.dao;

import com.zestaken.pojo.T_college;

import org.apache.ibatis.session.SqlSession;
import org.mybatis.spring.support.SqlSessionDaoSupport;

import java.util.List;

public class T_collegeMapperImpl extends SqlSessionDaoSupport implements T_collegeMapper &#123;

    public List&lt;T_college&gt; getT_collegeList() &#123;
        SqlSession sqlSession &#x3D; getSqlSession();
        T_collegeMapper t_collegeMapper &#x3D; sqlSession.getMapper(T_collegeMapper.class);
        List&lt;T_college&gt; t_collegeList &#x3D; t_collegeMapper.getT_collegeList();

        return t_collegeList;
    &#125;
&#125;</code></pre>
<ul>
<li>mapper实现类需要==继承SqlSessionDaoSupport类==，使用这个类需要导入包：<code>org.mybatis.spring.support.SqlSessionDaoSupport</code></li>
<li>实现类==无需再设置SqlSessionTemplate属性==，可以直接通过==getSqlSession方法获取SqlSessionTemplate对象==。</li>
<li>mapper实现类注册bean</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!--将数据库操作实现类注册到Spring--&gt;
    &lt;bean id&#x3D;&quot;t_collegeMapperImpl&quot; class&#x3D;&quot;com.zestaken.dao.T_collegeMapperImpl&quot;&gt;
        &lt;property name&#x3D;&quot;sqlSessionFactory&quot; ref&#x3D;&quot;sqlSessionFactory&quot;&#x2F;&gt;
    &lt;&#x2F;bean&gt;</code></pre>
<ul>
<li>虽然无需再向mapper实现类中注入sqlSessionTemplate，但是需要==注入sqlSessionFactory==,用来产生SqlSessionTemplate对象。</li>
</ul>
<h2 id="spring中事务管理"><a class="markdownIt-Anchor" href="#spring中事务管理"></a> Spring中事务管理</h2>
<ul>
<li><strong>事务(Transaction)</strong>：把一组业务绑在一起，看成一个业务，这些业务当且仅当所有业务都执行成功时，每一个业务才能成功执行，只要有一个业务没有成功，那么最后，所有业务都是失败的结果。</li>
<li><strong>事务作用</strong>：确保数据的完整性与一致性。</li>
<li><strong>事务的ACID属性</strong>：
<ol>
<li><strong>原子性（atomicity）</strong>。一个事务是一个不可分割的工作单位，事务中包括的操作==要么都做，要么都不做==。</li>
<li><strong>一致性（consistency）</strong>。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。</li>
<li><strong>隔离性（isolation）</strong>。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，==并发执行的各个事务之间不能互相干扰==。</li>
<li><strong>持久性（durability）</strong>。持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</li>
</ol>
</li>
<li>Spring支持两种事务：
<ul>
<li>声明式事务（又称交由容器管理事务）；</li>
<li>编程式事务：在程序中通过try/catch实现事务。</li>
</ul>
</li>
</ul>
<h3 id="声明式事务配置"><a class="markdownIt-Anchor" href="#声明式事务配置"></a> 声明式事务配置</h3>
<ol>
<li>在Spring对Mybatis的配置文件中==开启声明式事务==：</li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!--    配置声明式事务--&gt;
    &lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;
    &lt;&#x2F;bean&gt;</code></pre>
<ul>
<li>需要给transactionManger==注入datasource数据源==。</li>
</ul>
<ol start="2">
<li>结合AOP实现事务的织入：</li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!--    结合aop实现事务的织入--&gt;
&lt;!--    配置事务通知--&gt;
    &lt;tx:advice id&#x3D;&quot;txAdvice&quot; transaction-manager&#x3D;&quot;transactionManager&quot;&gt;
&lt;!--        给具体的方法配置事务--&gt;
&lt;!--配置每个方法事务的特性,如传播性propagation--&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name&#x3D;&quot;getT_collegeList&quot; propagation&#x3D;&quot;REQUIRED&quot;&#x2F;&gt;
        &lt;&#x2F;tx:attributes&gt;
    &lt;&#x2F;tx:advice&gt;

&lt;!--    配置事务切入--&gt;
    &lt;aop:config&gt;
        &lt;aop:pointcut id&#x3D;&quot;txPointCut&quot;  expression&#x3D;&quot;execution(* com.zestaken.dao.*.*(..))&quot;&#x2F;&gt;
        &lt;aop:advisor advice-ref&#x3D;&quot;txAdvice&quot; pointcut-ref&#x3D;&quot;txPointCut&quot;&#x2F;&gt;
    &lt;&#x2F;aop:config&gt;</code></pre>
<ul>
<li>配置事务通知（即使用tx标签）需要导入tx的约束：
<ul>
<li><code>xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</code></li>
<li><code>http://www.springframework.org/schema/tx</code></li>
<li><code>http://www.springframework.org/schema/tx/spring-tx.xsd</code></li>
</ul>
</li>
<li>给具体的方法配置事务：
<ul>
<li>以后在切入点，只要==方法名和配置相同的方法，就会被配置上事务==。</li>
</ul>
</li>
<li>配置事务的切入：
<ul>
<li>通过切入的方式，使事务在具体的位置生效。</li>
</ul>
</li>
<li>最终效果：
<ul>
<li>一个配置了事务的方法中，对数据库的操作中，只要有一个失败了，其余的所有操作都不会生效。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Mybatis/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Mybatis/index.html" class="post-title-link" itemprop="url">Mybatis</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-08 22:23:17" itemprop="dateCreated datePublished" datetime="2021-02-08T22:23:17+08:00">2021-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-09-26 21:39:31" itemprop="dateModified" datetime="2021-09-26T21:39:31+08:00">2021-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web后端</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>18k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="mybatis简介"><a class="markdownIt-Anchor" href="#mybatis简介"></a> Mybatis简介</h1>
<ul>
<li>MyBatis 是一款优秀的<strong>持久层框架</strong>。
<ul>
<li>持久化：将程序的数据永久存储到硬盘上；</li>
<li>持久层：完成持久化工作的代码块，即三层架构中的<strong>DAO层</strong>。</li>
</ul>
</li>
<li>MyBatis 避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。</li>
<li>MyBatis 可以使用简单的 <strong>XML 或注解来配置和映射原生信息</strong>，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。</li>
<li>Mybatis资料：
<ul>
<li><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/index.html">官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mybatis/mybatis-3/releases">下载地址</a></li>
<li>maven坐标：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.mybatis&#x2F;mybatis --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;
    &lt;version&gt;3.5.6&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>
<ul>
<li>优点：
<ul>
<li>简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件。</li>
<li>灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 <strong>sql写在xml里</strong>，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。</li>
<li>解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离。</li>
<li>提供xml标签，支持编写动态sql。</li>
</ul>
</li>
</ul>
<h1 id="快速入门"><a class="markdownIt-Anchor" href="#快速入门"></a> 快速入门</h1>
<h2 id="一环境搭建"><a class="markdownIt-Anchor" href="#一环境搭建"></a> 一：环境搭建</h2>
<ol>
<li>通过maven导入三个jar包：
<ol>
<li>mysql驱动包：</li>
<li>junit包；</li>
<li>mybatisjar包</li>
</ol>
</li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependencies&gt;
    &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;mysql&#x2F;mysql-connector-java --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;
        &lt;version&gt;8.0.23&lt;&#x2F;version&gt;
    &lt;&#x2F;dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;
        &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;
        &lt;version&gt;4.13&lt;&#x2F;version&gt;
        &lt;scope&gt;test&lt;&#x2F;scope&gt;
    &lt;&#x2F;dependency&gt;&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;
        &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;
        &lt;version&gt;3.5.6&lt;&#x2F;version&gt;
    &lt;&#x2F;dependency&gt;
&lt;&#x2F;dependencies&gt;</code></pre>
<h2 id="二编写核心配置文件"><a class="markdownIt-Anchor" href="#二编写核心配置文件"></a> 二：编写核心配置文件</h2>
<ul>
<li><code>mybatis-config.xml</code>,maven项目放在resources目录下：</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;configuration&gt;
    &lt;environments default&#x3D;&quot;development&quot;&gt;
        &lt;environment id&#x3D;&quot;development&quot;&gt;
            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;
            &lt;!--配置数据源--&gt;
            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;
                &lt;!--注册驱动，同jdbc--&gt;
                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;
                &lt;!--数据库连接路径--&gt;
                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;youth_study&quot;&#x2F;&gt;
                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;
                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;
            &lt;&#x2F;dataSource&gt;
        &lt;&#x2F;environment&gt;
    &lt;&#x2F;environments&gt;
    &lt;!--每一个Mapper.xml文件都需要在这个mybatis核心配置文件中注册--&gt;
    &lt;mappers&gt;
        &lt;mapper resource&#x3D;&quot;org&#x2F;mybatis&#x2F;example&#x2F;BlogMapper.xml&quot;&#x2F;&gt;
    &lt;&#x2F;mappers&gt;
&lt;&#x2F;configuration&gt;</code></pre>
<h2 id="三编写mybatis工具类"><a class="markdownIt-Anchor" href="#三编写mybatis工具类"></a> 三：编写Mybatis工具类</h2>
<ul>
<li>编写一个用来获取SQLSession实例的工具类：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.utils;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.IOException;
import java.io.InputStream;

public class MybatisUtils &#123;
    private static SqlSessionFactory sqlSessionFactory;

    static &#123;
        try &#123;
            &#x2F;&#x2F;1.加载核心配置文件
            String resource &#x3D; &quot;mybatis-config.xml&quot;;
            InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);
            &#x2F;&#x2F;2.根据xml核心配置文件获取对应的SqlSessionFactory对象
            sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    &#x2F;&#x2F;2.从SqlSessionFactory实例中获得 SqlSession 的实例。
    &#x2F;&#x2F; SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。
    &#x2F;&#x2F; 你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。
    public static SqlSession getSqlSession()&#123;
        return sqlSessionFactory.openSession();
    &#125;

&#125;</code></pre>
<h2 id="四编写操作表的接口并实现"><a class="markdownIt-Anchor" href="#四编写操作表的接口并实现"></a> 四：编写操作表的接口并实现</h2>
<ul>
<li>接口：T_collegeMapper</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.dao;

import com.zestaken.Pojo.T_college;

import java.util.List;

public interface T_collegeMapper &#123;
    List&lt;T_college&gt; getT_collegeList();
&#125;</code></pre>
<ul>
<li>实现：Mapper.xml实现了接口实现类的功能</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;
        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;
&lt;!--namespace绑定一个Mapper接口--&gt;
&lt;mapper namespace&#x3D;&quot;com.zestaken.dao.T_collegeMapper&quot;&gt;
    &lt;!--id是需要实现的接口中的方法名--&gt;
    &lt;!--resultType是返回结果的类型，如果返回的是结果集，则用resultMap--&gt;
    &lt;!--select是要执行sql查询语句--&gt;
    &lt;select id&#x3D;&quot;getUserList&quot; resultType&#x3D;&quot;com.zestaken.Pojo.T_college&quot; &gt;
    select * from youth_study.t_college;
  &lt;&#x2F;select&gt;
&lt;&#x2F;mapper&gt;</code></pre>
<ul>
<li>注：Mapper.xml文件需要在mybatis-config.xml文件中注册：</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!--每一个Mapper.xml文件都需要在这个mybatis核心配置文件中注册--&gt;
&lt;mappers&gt;
    &lt;mapper resource&#x3D;&quot;org&#x2F;mybatis&#x2F;example&#x2F;BlogMapper.xml&quot;&#x2F;&gt;
&lt;&#x2F;mappers&gt;</code></pre>
<h2 id="五编写junit测试类"><a class="markdownIt-Anchor" href="#五编写junit测试类"></a> 五：编写junit测试类</h2>
<ul>
<li>编写一个可以查询表的测试类：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.junit.Test;

import java.util.List;

public class T_collegeMapperTest &#123;
    @Test
    public void test()&#123;
        &#x2F;&#x2F;1.获取SqlSession实例
        SqlSession sqlSession &#x3D; MybatisUtils.getSqlSession();
        &#x2F;&#x2F;2.获取Mapper接口的实现类
        T_collegeMapper t_collegeMapper &#x3D; sqlSession.getMapper(T_collegeMapper.class);
        &#x2F;&#x2F;3.执行sql
        List&lt;T_college&gt; t_collegeList &#x3D; t_collegeMapper.getT_collegeList();

        for(T_college college : t_collegeList)&#123;
            System.out.println(college);
        &#125;

        &#x2F;&#x2F;4.释放sqlSession
        sqlSession.close();
    &#125;
&#125;</code></pre>
<h2 id="六常见错误"><a class="markdownIt-Anchor" href="#六常见错误"></a> 六：常见错误</h2>
<ol>
<li>Mapper.xml文件没有在mybatis-config.xml文件中注册；</li>
<li>没有配置maven，使maven可以导入java包下的配置文件。（因为maven默认所有配置文件都是放在resources目录下的）
<ul>
<li>在pom.xml中配置，使maven可以导入java包下的配置文件：</li>
</ul>
</li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">
&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;
                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;
            &lt;&#x2F;includes&gt;
            &lt;filtering&gt;false&lt;&#x2F;filtering&gt;
        &lt;&#x2F;resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;
                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;
            &lt;&#x2F;includes&gt;
            &lt;filtering&gt;false&lt;&#x2F;filtering&gt;
        &lt;&#x2F;resource&gt;
    &lt;&#x2F;resources&gt;
&lt;&#x2F;build&gt;</code></pre>
<h1 id="mybatis的crud操作"><a class="markdownIt-Anchor" href="#mybatis的crud操作"></a> Mybatis的CRUD操作</h1>
<ul>
<li>在mapper接口中增加对应操作的方法，在mapper.xml中增加对应的sql语句。</li>
<li>取参数：
<ul>
<li><strong>表对象传递的属性可以通过<code>#&#123;&#125;</code>取出使用，但是属性名，数据项的名字，以及sql中参数的名字需要一致</strong></li>
<li><strong>Map对象传递的参数也可以通过<code>#&#123;&#125;</code>取出使用，只需要参数名和map中的key名相同即可</strong>。</li>
</ul>
</li>
<li><strong>增删改操作必须提交事务才能生效</strong>。</li>
<li>增删改操作的返回值默认为int，这个类型不需要在<code>resultType</code>中设置，如果操作成功则返回1，操作失败返回0；</li>
<li>参数可以用<code>#&#123;参数名&#125;</code>取出来</li>
<li>parameterType：参数类型</li>
<li>resultType:返回值类型</li>
<li>id：namespace中接口中的方法名</li>
<li>查询操作用<code>&lt;select&gt;&lt;/select&gt;</code></li>
<li>添加操作用<code>&lt;insert&gt;&lt;/insert&gt;</code></li>
<li>修改操作用<code>&lt;update&gt;&lt;/update&gt;</code></li>
<li>删除操作用<code>&lt;delete&gt;&lt;/delete&gt;</code></li>
<li>示例：
<ol>
<li>mapper接口</li>
</ol>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
import com.zestaken.pojo.T_college;

import java.util.List;

public interface T_collegeMapper &#123;
    &#x2F;&#x2F;查询表中的所有值
    List&lt;T_college&gt; getT_collegeList();
    &#x2F;&#x2F;根据id查询表中的值
    T_college getT_collegeByID(int id);
    &#x2F;&#x2F;向表中插入新的数据
    int insertT_collegeList(T_college t_college);
    &#x2F;&#x2F;修改表中某项的数据
    int updateT_collegeList(T_college t_college);
    &#x2F;&#x2F;删除表中指定id的项
    int deleteT_collegeList(int id);

&#125;</code></pre>
<ol start="2">
<li>mapper.xml</li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;
        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;
&lt;!--namespace绑定一个Mapper接口--&gt;
&lt;mapper namespace&#x3D;&quot;com.zestaken.dao.T_collegeMapper&quot;&gt;
    &lt;!--id是需要实现的接口中的方法名--&gt;
    &lt;!--resultType是返回结果的类型，如果返回的是结果集，则用resultMap--&gt;
    &lt;!--select是要执行sql查询语句--&gt;
    &lt;select id&#x3D;&quot;getT_collegeList&quot; resultType&#x3D;&quot;com.zestaken.pojo.T_college&quot; &gt;
    select * from youth_study.t_college;
  &lt;&#x2F;select&gt;
&lt;!--    参数用#&#123;&#125;取出来--&gt;
    &lt;select id&#x3D;&quot;getT_collegeByID&quot; parameterType&#x3D;&quot;int&quot; resultType&#x3D;&quot;com.zestaken.pojo.T_college&quot;&gt;
        select * from youth_study.t_college where id &#x3D; #&#123;id&#125;;
    &lt;&#x2F;select&gt;
    &lt;!--表对象中的属性可以直接取出来   --&gt;
    &lt;insert id&#x3D;&quot;insertT_collegeList&quot; parameterType&#x3D;&quot;com.zestaken.pojo.T_college&quot; &gt;
-- 虽然参数是表对象，但是表对象中的属性可以直接取出来，就相当于传递的参数是一系列的属性值
        insert into youth_study.t_college(id,name) values(#&#123;id&#125;,#&#123;name&#125;);
    &lt;&#x2F;insert&gt;

    &lt;update id&#x3D;&quot;updateT_collegeList&quot; parameterType&#x3D;&quot;com.zestaken.pojo.T_college&quot;&gt;
        update youth_study.t_college set name&#x3D;#&#123;name&#125; where id &#x3D; #&#123;id&#125;;
    &lt;&#x2F;update&gt;
    &lt;delete id&#x3D;&quot;deleteT_collegeList&quot; parameterType&#x3D;&quot;int&quot;&gt;
        delete from youth_study.t_college where id &#x3D; #&#123;id&#125;;
    &lt;&#x2F;delete&gt;
&lt;&#x2F;mapper&gt;</code></pre>
<ol start="3">
<li>测试类</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.dao;

import com.zestaken.pojo.T_college;
import com.zestaken.utils.MybatisUtils;
import org.apache.ibatis.session.SqlSession;
import org.junit.Test;

import java.util.List;

public class T_collegeMapperTest &#123;
    @Test
    public void get()&#123;
        &#x2F;&#x2F;1.获取SqlSession实例
        SqlSession sqlSession &#x3D; MybatisUtils.getSqlSession();
        &#x2F;&#x2F;2.获取Mapper接口的实现类
        T_collegeMapper t_collegeMapper &#x3D; sqlSession.getMapper(T_collegeMapper.class);
        &#x2F;&#x2F;3.执行sql
        List&lt;T_college&gt; t_collegeList &#x3D; t_collegeMapper.getT_collegeList();

        for(T_college college : t_collegeList)&#123;
            System.out.println(college);
        &#125;

        &#x2F;&#x2F;4.释放sqlSession
        sqlSession.close();
    &#125;

    @Test
    public void getByID()&#123;
        SqlSession sqlSession &#x3D; MybatisUtils.getSqlSession();
        T_collegeMapper mapper &#x3D; sqlSession.getMapper(T_collegeMapper.class);

        T_college college &#x3D; mapper.getT_collegeByID(100);
        System.out.println(college);


        sqlSession.close();
    &#125;

    @Test
    public void insert()&#123;
        SqlSession sqlSession &#x3D; MybatisUtils.getSqlSession();
        T_collegeMapper mapper &#x3D; sqlSession.getMapper(T_collegeMapper.class);

        T_college t_college &#x3D; new T_college();
        t_college.setId(100);
        t_college.setName(&quot;zhangjie&quot;);
        mapper.insertT_collegeList(t_college);

        &#x2F;&#x2F;增删改操作必须提交事务才能生效
        sqlSession.commit();

        sqlSession.close();
    &#125;

    @Test
    public void updateT_collegeList()&#123;
        SqlSession sqlSession &#x3D; MybatisUtils.getSqlSession();
        T_collegeMapper mapper &#x3D; sqlSession.getMapper(T_collegeMapper.class);

        T_college t_college &#x3D; new T_college();
        t_college.setId(100);
        t_college.setName(&quot;zhangsi&quot;);
        mapper.updateT_collegeList(t_college);

        sqlSession.commit();

        sqlSession.close();
    &#125;

    @Test
    public void deleteT_collegeList()&#123;
        SqlSession sqlSession &#x3D; MybatisUtils.getSqlSession();
        T_collegeMapper mapper &#x3D; sqlSession.getMapper(T_collegeMapper.class);

        mapper.deleteT_collegeList(100);

        sqlSession.commit();

        sqlSession.close();
    &#125;
&#125;</code></pre>
<h1 id="配置解析"><a class="markdownIt-Anchor" href="#配置解析"></a> 配置解析</h1>
<h2 id="核心配置文件"><a class="markdownIt-Anchor" href="#核心配置文件"></a> 核心配置文件</h2>
<ul>
<li>核心配置文件（即mybatis-config.xml）.</li>
<li>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 配置文档的顶层结构如下：</li>
<li>configuration（配置）
<ol>
<li>properties（属性）</li>
<li>settings（设置）</li>
<li>typeAliases（类型别名）</li>
<li>typeHandlers（类型处理器）</li>
<li>objectFactory（对象工厂）</li>
<li>plugins（插件）</li>
<li>environments（环境配置）</li>
<li>environment（环境变量）</li>
<li>transactionManager（事务管理器）</li>
<li>dataSource（数据源）</li>
<li>databaseIdProvider（数据库厂商标识）</li>
<li>mappers（映射器）</li>
</ol>
</li>
</ul>
<h2 id="环境配置environments"><a class="markdownIt-Anchor" href="#环境配置environments"></a> 环境配置（environments）</h2>
<ul>
<li>MyBatis 可以配置成<strong>适应多种环境</strong>，这种机制有助于将 SQL 映射应用于多种数据库之中,现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置。</li>
<li>尽管可以配置多个环境，但<strong>每个 SqlSessionFactory 实例只能选择一种环境</strong></li>
<li>配置详情：
<ul>
<li>默认使用的环境默认ID（比如：default=“development”）。
<ul>
<li>默认环境和环境ID顾名思义。 环境可以随意命名，但务必保证默认的环境ID要匹配其中一个环境ID。。</li>
</ul>
</li>
<li>每个environment元素定义的环境ID（比如：id=“development”）。</li>
<li>事务管理器的配置（比如：type=“JDBC”）。
<ul>
<li>Mybatis有两种事务管理器：JDBC、MANGED；</li>
<li>Spring+Mybatis的搭配没有必要设置事务管理器，因为会被Spring的配置覆盖。</li>
</ul>
</li>
<li>数据源的配置（比如：type=“POOLED”）。
<ul>
<li>Mybatis有三种内建的数据源类型：
<ul>
<li>POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来（主要使用POOLED）</li>
<li>UNPOOLED：这个数据源的实现会每次请求时打开和关闭连接。</li>
<li>JNDI：这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;environments default&#x3D;&quot;development&quot;&gt;
  &lt;environment id&#x3D;&quot;development&quot;&gt;
    &lt;transactionManager type&#x3D;&quot;JDBC&quot;&gt;
      &lt;property name&#x3D;&quot;...&quot; value&#x3D;&quot;...&quot;&#x2F;&gt;
    &lt;&#x2F;transactionManager&gt;
    &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;
      &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt;
      &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;
      &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;
      &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt;
    &lt;&#x2F;dataSource&gt;
  &lt;&#x2F;environment&gt;
&lt;&#x2F;environments&gt;</code></pre>
<h2 id="属性properties"><a class="markdownIt-Anchor" href="#属性properties"></a> 属性（properties）</h2>
<ul>
<li>通过properties<strong>实现引用配置文件</strong>；</li>
<li>示例：
<ol>
<li>创建db.properties文件</li>
</ol>
</li>
</ul>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">driver&#x3D;com.mysql.jdbc.Driver
url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;youth_study
username&#x3D;root</code></pre>
<ol start="2">
<li>在mybatis-config.xml文件中导入配置文件</li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;
        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;
&lt;!-- 核心配置文件 --&gt;
&lt;configuration&gt;

    &lt;properties resource&#x3D;&quot;db.properties&quot;&gt;
        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;
    &lt;&#x2F;properties&gt;

    &lt;environments default&#x3D;&quot;development&quot;&gt;
        &lt;environment id&#x3D;&quot;development&quot;&gt;
            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;
            &lt;!--配置数据源--&gt;
            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;
                &lt;!--注册驱动，同jdbc--&gt;
                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt;
                &lt;!--数据库连接路径--&gt;
                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;
                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;
                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt;
            &lt;&#x2F;dataSource&gt;
        &lt;&#x2F;environment&gt;
    &lt;&#x2F;environments&gt;
    &lt;!--每一个Mapper.xml文件都需要在这个mybatis核心配置文件中注册--&gt;
    &lt;mappers&gt;
        &lt;mapper resource&#x3D;&quot;com&#x2F;zestaken&#x2F;dao&#x2F;T_collegeMapper.xml&quot;&#x2F;&gt;
    &lt;&#x2F;mappers&gt;
&lt;&#x2F;configuration&gt;</code></pre>
<ul>
<li>properties配置**必须放在<code>&lt;configuration&gt;&lt;/configuration&gt;</code>标签内的最开始位置。</li>
<li>properties属性可以直接引入外部的配置文件；</li>
<li>可以在properties标签中通过property标签动态设置属性</li>
<li>如果在property标签中动态配置的属性与外部配置文件有冲突，则<strong>优先使用外部配置文件的配置</strong>。</li>
</ul>
<h2 id="类型别名typealiases"><a class="markdownIt-Anchor" href="#类型别名typealiases"></a> 类型别名（typeAliases）</h2>
<ul>
<li>类型别名可为 Java 类型设置一个缩写名字。</li>
<li>它仅用于 XML 配置，意在降低冗余的全限定类名书写。</li>
<li>typeAliases配置需要写在配置的第三位，即properties之后。</li>
<li>三种配置别名的方法：
<ol>
<li>完全限定名配置：</li>
</ol>
</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;typeAliases&gt;
  &lt;typeAlias alias&#x3D;&quot;Author&quot; type&#x3D;&quot;domain.blog.Author&quot;&#x2F;&gt;
&lt;&#x2F;typeAliases&gt;</code></pre>
<ol start="2">
<li>包名配置：
<ol>
<li>Mybaits会在指定的包名下搜索需要的javabean</li>
<li>扫描实体类的包，它的默认名就为<strong>这个类的类名，并且首字母小写</strong>。</li>
</ol>
</li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;typeAliases&gt;
  &lt;package name&#x3D;&quot;domain.blog&quot;&#x2F;&gt;
&lt;&#x2F;typeAliases&gt;</code></pre>
<ol start="3">
<li>注解配置，需要结合包名配置：
<ol>
<li>每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。</li>
<li>若有注解，则别名为其注解值。</li>
</ol>
</li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">@Alias(&quot;author&quot;)
public class Author &#123;
    ...
&#125;</code></pre>
<h2 id="设置settings"><a class="markdownIt-Anchor" href="#设置settings"></a> 设置（settings）</h2>
<ul>
<li>常用设置：
<ul>
<li>cacheEnabled：全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。</li>
<li>lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。</li>
<li>logImpl：指定 MyBatis 所用日志的具体实现，未指定时将自动查找。</li>
</ul>
</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;settings&gt;
  &lt;setting name&#x3D;&quot;cacheEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;
  &lt;setting name&#x3D;&quot;lazyLoadingEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;
  &lt;setting name&#x3D;&quot;multipleResultSetsEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;
  &lt;setting name&#x3D;&quot;useColumnLabel&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;
  &lt;setting name&#x3D;&quot;useGeneratedKeys&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;
  &lt;setting name&#x3D;&quot;autoMappingBehavior&quot; value&#x3D;&quot;PARTIAL&quot;&#x2F;&gt;
  &lt;setting name&#x3D;&quot;autoMappingUnknownColumnBehavior&quot; value&#x3D;&quot;WARNING&quot;&#x2F;&gt;
  &lt;setting name&#x3D;&quot;defaultExecutorType&quot; value&#x3D;&quot;SIMPLE&quot;&#x2F;&gt;
  &lt;setting name&#x3D;&quot;defaultStatementTimeout&quot; value&#x3D;&quot;25&quot;&#x2F;&gt;
  &lt;setting name&#x3D;&quot;defaultFetchSize&quot; value&#x3D;&quot;100&quot;&#x2F;&gt;
  &lt;setting name&#x3D;&quot;safeRowBoundsEnabled&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;
  &lt;setting name&#x3D;&quot;mapUnderscoreToCamelCase&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;
  &lt;setting name&#x3D;&quot;localCacheScope&quot; value&#x3D;&quot;SESSION&quot;&#x2F;&gt;
  &lt;setting name&#x3D;&quot;jdbcTypeForNull&quot; value&#x3D;&quot;OTHER&quot;&#x2F;&gt;
  &lt;setting name&#x3D;&quot;lazyLoadTriggerMethods&quot; value&#x3D;&quot;equals,clone,hashCode,toString&quot;&#x2F;&gt;
&lt;&#x2F;settings&gt;</code></pre>
<h2 id="插件plugins"><a class="markdownIt-Anchor" href="#插件plugins"></a> 插件（plugins）</h2>
<ul>
<li>可以使用一些mybaits插件来简化代码的书写。</li>
<li>mybatis常用插件：
<ol>
<li>mybatis-generator-core</li>
<li>mybatis-plus</li>
<li>通用mapper</li>
</ol>
</li>
</ul>
<h2 id="映射器mappers"><a class="markdownIt-Anchor" href="#映射器mappers"></a> 映射器（mappers）</h2>
<ul>
<li>mapper.xml文件在使用之前必须注册，注册有三种方式。</li>
</ul>
<ol>
<li>方式一：通过xml文件的完全限定名来注册（推荐使用）</li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!-- 使用相对于类路径的资源引用 --&gt;
&lt;mappers&gt;
  &lt;mapper resource&#x3D;&quot;org&#x2F;mybatis&#x2F;builder&#x2F;AuthorMapper.xml&quot;&#x2F;&gt;
  &lt;mapper resource&#x3D;&quot;org&#x2F;mybatis&#x2F;builder&#x2F;BlogMapper.xml&quot;&#x2F;&gt;
  &lt;mapper resource&#x3D;&quot;org&#x2F;mybatis&#x2F;builder&#x2F;PostMapper.xml&quot;&#x2F;&gt;
&lt;&#x2F;mappers&gt;</code></pre>
<ol start="2">
<li>方式二：使用接口名来注册</li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;mappers&gt;
  &lt;mapper class&#x3D;&quot;org.mybatis.builder.AuthorMapper&quot;&#x2F;&gt;
  &lt;mapper class&#x3D;&quot;org.mybatis.builder.BlogMapper&quot;&#x2F;&gt;
  &lt;mapper class&#x3D;&quot;org.mybatis.builder.PostMapper&quot;&#x2F;&gt;
&lt;&#x2F;mappers&gt;</code></pre>
<ul>
<li><strong>接口和mapper.xml文件必须同名</strong></li>
<li><strong>接口和mapper配置文件必须再同一个包下</strong>。</li>
</ul>
<ol start="3">
<li>方式三:使用包名来注册</li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;mappers&gt;
  &lt;package name&#x3D;&quot;org.mybatis.builder&quot;&#x2F;&gt;
&lt;&#x2F;mappers&gt;</code></pre>
<ul>
<li><strong>接口和mapper.xml文件必须同名</strong></li>
<li><strong>接口和mapper配置文件必须再同一个包下</strong>。</li>
</ul>
<h1 id="mybatis注解开发"><a class="markdownIt-Anchor" href="#mybatis注解开发"></a> Mybatis注解开发</h1>
<ul>
<li>不使用mapper.xml文件来实现Mapper接口，而使用注解的方式来实现接口。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package org.mybatis.example;
public interface BlogMapper &#123;
  @Select(&quot;SELECT * FROM blog WHERE id &#x3D; #&#123;id&#125;&quot;)
  Blog selectBlog(int id);
&#125;</code></pre>
<ul>
<li>同时还需要在mybatis-config.xml文件中绑定接口：</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;mappers&gt;
  &lt;mapper class&#x3D;&quot;org.mybatis.example.BlogMapper&quot;&#x2F;&gt;
&lt;&#x2F;mappers&gt;</code></pre>
<h2 id="注解实现crud"><a class="markdownIt-Anchor" href="#注解实现crud"></a> 注解实现CRUD</h2>
<ol>
<li>在编写工具类的时候实现自动提交事务：</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public static SqlSession getSqlSession()&#123;
  &#x2F;&#x2F;只需要传递一个boolean参数即可
    return sqlSessionFactory.openSession(true);
&#125;</code></pre>
<ol start="2">
<li>编写接口增加注解：
<ol>
<li>增：<code>@insert()</code></li>
<li>删：<code>@delete()</code></li>
<li>改：<code>@update()</code></li>
<li>查：<code>@select()</code></li>
</ol>
</li>
<li><code>@param()</code>参数设置：
<ol>
<li>基本类型的参数或者String类型的参数，需要加上；</li>
<li>引用类型的参数不用加；</li>
<li>如果只有一个基本类型的话，可以忽略，但是建议加上；</li>
<li>在sql中引用<code>@param()</code>设置的属性名</li>
<li>如果<code>@param()</code>括号中没有内容，则属性名和参数名默认相同。</li>
<li>示例：</li>
</ol>
</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@delete(delete from youth_study.t_college where id &#x3D; #&#123;id&#125; and name &#x3D; #&#123;name&#125;)
int delete(@param(&quot;id&quot;) int id, @param(&quot;name&quot;) String name);</code></pre>
<h1 id="mybatis日志"><a class="markdownIt-Anchor" href="#mybatis日志"></a> Mybatis日志</h1>
<ul>
<li>操作出现了异常的时候，日志是很好的排错工具；</li>
<li>settings中的logImpl可以设置日志的实现方式，共有以下几种：
<ol>
<li>SLF4J</li>
<li>LOG4J</li>
<li>LOG4J2</li>
<li>JDK_LOGGING</li>
<li>COMMONS_LOGGING</li>
<li>STDOUT_LOGGING：标准日志输出，一旦在settins中启用，便无需其他的配置</li>
<li>NO_LOGGING</li>
</ol>
</li>
<li>配置STDOUT_LOGGING:</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;settings&gt;
  &lt;setting name &#x3D; &quot;logImpl&quot; value &#x3D; &quot;STDOUT_LOGGING&quot;&#x2F;&gt;
&lt;&#x2F;settings&gt;</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">蜀ICP备2021022902号-1 </a>
      <img src="/images/beian_icon.png" alt=""><a href="https://beian.mps.gov.cn/#/query/webSearch?code=51010802032250" rel="noopener" target="_blank">川公网安备51010802032250号 </a>
  </div>
  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Zestaken</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">678k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:17</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js" integrity="sha256-4mJNT2bMXxcc1GCJaxBmMPdmah5ji0Ldnd79DKd1hoM=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha256-AjM0J5XIbiB590BrznLEgZGLnOQWrt62s3BEq65Q/I0=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha256-9cmf7tcLdXpKsPi/2AWE93PbZpTp4M4tqzFk+lWomjU=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
