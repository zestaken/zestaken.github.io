<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.zestaken.top","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":true,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="吾好梦中读书~">
<meta property="og:type" content="website">
<meta property="og:title" content="ZestJourney">
<meta property="og:url" content="http://www.zestaken.top/page/6/index.html">
<meta property="og:site_name" content="ZestJourney">
<meta property="og:description" content="吾好梦中读书~">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zestaken">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://www.zestaken.top/page/6/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/6/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ZestJourney</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ZestJourney</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">乐游记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zestaken</p>
  <div class="site-description" itemprop="description">吾好梦中读书~</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">84</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">60</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%89%8D%E7%AB%AF/HTML/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%89%8D%E7%AB%AF/HTML/index.html" class="post-title-link" itemprop="url">HTML</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-08 09:05:40" itemprop="dateCreated datePublished" datetime="2020-12-08T09:05:40+08:00">2020-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:27:52" itemprop="dateModified" datetime="2022-09-17T19:27:52+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web前端</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h1>
<ul>
<li>最基础的网页开发语言。</li>
<li>HTML：Hyper Text Markup Language 超文本标记语言。</li>
<li>超文本：超文本是用超链接的方法，将不同空间的文字信息组织在一起的网状文本。</li>
<li>标记语言：
<ul>
<li>由标签（&lt;标签内容&gt;）构成的语言，如html，xml</li>
<li>标记语言不是编程语言，没有逻辑性。</li>
</ul>
</li>
<li>HTML 文档描述网页,HTML 文档包含 HTML 标签和纯文本,HTML 文档也被称为网页</li>
</ul>
<h1 id="快速入门"><a class="markdownIt-Anchor" href="#快速入门"></a> 快速入门</h1>
<ul>
<li>html文档的后缀名：html或者htm</li>
<li>标签分为：
<ul>
<li>围堵标签：有开始标签和结束标签。如：<code>&lt;html&gt;&lt;/html&gt;</code></li>
<li>自闭和标签：开始标签和结束标签在一起。如：<code>&lt;br/&gt;</code></li>
</ul>
</li>
<li>标签可以被嵌套：
<ul>
<li>需要正确嵌套，不能你中有我，我中有你</li>
<li>错误：<code>&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;</code></li>
<li>正确：<code>&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;</code></li>
</ul>
</li>
<li>在<strong>开始标签</strong>中可以定义属性。属性是由键值对构成，值需要用引号(单双都可，但是要统一)引起来。</li>
<li>html的标签不区分大小写，但是建议使用小写</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;html&gt;

    &lt;head&gt;
            &lt;title&gt;title&lt;&#x2F;title&gt;
    &lt;&#x2F;head&gt;

    &lt;body&gt;
        &lt;font color&#x3D;&#39;red&#39;&gt;Hello world&lt;&#x2F;font&gt;&lt;br&#x2F;&gt;
        &lt;font color&#x3D;&#39;green&#39;&gt;Hello world&lt;&#x2F;font&gt;
    &lt;&#x2F;body&gt;
&lt;&#x2F;html&gt;</code></pre>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201208092240.jpg" alt="" /></p>
<h1 id="标签"><a class="markdownIt-Anchor" href="#标签"></a> 标签</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/tags/index.asp">参考手册</a></li>
</ul>
<h2 id="文件标签"><a class="markdownIt-Anchor" href="#文件标签"></a> 文件标签</h2>
<ul>
<li>构成html最基本的标签。</li>
<li>html:html文档的根标签,<html> 与 </html> 之间的文本描述网页</li>
<li>head：头标签。用于指定html文档的一些属性，引入外部的资源。</li>
<li>title:标题标签；</li>
<li>body；体标签，放网页显示内容.<code>&lt;body&gt;</code> 与 <code>&lt;/body&gt;</code> 之间的文本是<strong>可见</strong>的页面内容。</li>
<li><code>&lt;!DOCTYPE&gt;</code>:定义文档类型标签,html5中定义文档类型的方式。如：<code>&lt;!DOCTYPE html&gt;</code></li>
</ul>
<h2 id="文本标签"><a class="markdownIt-Anchor" href="#文本标签"></a> 文本标签</h2>
<ul>
<li>注释：<code>&lt;!--注释内容 --&gt;</code>(后面没有感叹号)</li>
<li>标题：<code>&lt;h1&gt;标题内容&lt;/h1&gt;</code>共有6级标题。</li>
<li>定义段落：<code>&lt;p&gt;这是段落内容&lt;/p&gt;</code>,p 元素会自动在其前后创建一些空白。浏览器会自动添加这些空间，您也可以在样式表中规定。</li>
<li>换行：<code>&lt;br&gt;</code>，如：<code>白日依山尽，&lt;br&gt;黄河入海流</code>,注意这是一个<strong>自闭合标签</strong>无需结束标签。（<code>&lt;br/&gt;</code>具有相同的效果）。</li>
<li>定义水平线：<code>&lt;hr&gt;</code>或者<code>&lt;hr/&gt;</code>可以定义一条水平线。</li>
<li>粗体：<code>&lt;b&gt;需要粗体内容&lt;/b&gt;</code>。</li>
<li>斜体：<code>&lt;i&gt;需要斜体的内容&lt;/i&gt;</code>.</li>
<li>类似打字机或者等宽的文本效果：<code>&lt;tt&gt;需要等宽显示的内容&lt;tt&gt;</code></li>
<li>呈现大号字体效果:<code>&lt;big&gt;需要显示大号字体的内容&lt;/big&gt;</code></li>
<li>呈现小号字体效果:<code>&lt;small&gt;需要显示小号字体的内容&lt;small&gt;</code></li>
<li>规定文本的字体、字体尺寸、字体颜色:<code>&lt;font color=&quot;red&quot;, size=&quot;5&quot;,face=&quot;楷体&quot;&gt; 我是红色&lt;/font&gt;</code>,face是指的字体。<strong>已经不建议使用，改变样式现在用css</strong></li>
<li>文本居中：<code>&lt;center&gt;需要居中的内容&lt;/center&gt;</code>,居中是相对于父元素来说的。示例：</li>
</ul>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;center&gt;
&lt;font color&#x3D;&quot;red&quot;, size&#x3D;&quot;5&quot;,face&#x3D;&quot;楷体&quot;&gt; 我是红色&lt;&#x2F;font&gt;
&lt;&#x2F;center&gt;</code></pre>
<ul>
<li>属性：
<ul>
<li>color:颜色：
<ul>
<li>英文单词：red,green,blue等</li>
<li>rgb(值1，值2，值3)；rgb分别是红，绿，蓝三种颜色的占比。值的范围：0~255（不常用）</li>
<li><code>#值1值2值3</code>:值的范围：00~FF之间。效果也是通过三种颜色的占比来配色。如：<code>#FF00FF</code>。</li>
</ul>
</li>
<li>width:
<ul>
<li>数值:width=‘20’,数值的单位，默认是像素px(像素)；</li>
<li>数值%：width=‘50%’,相对于父元素的占比。</li>
</ul>
</li>
<li>align:对齐方式
<ul>
<li>center:居中</li>
<li>left：左对齐</li>
<li>right：右对齐</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="图片标签"><a class="markdownIt-Anchor" href="#图片标签"></a> 图片标签</h2>
<ul>
<li><code>&lt;img /&gt;</code>:图片标签是自闭合标签</li>
<li>属性：src
<ul>
<li>src后输入图片的位置；</li>
<li>相对路径：
<ul>
<li><code>./...</code>代表当前目录；如：<code>./image/1.jpg</code></li>
<li><code>../...</code>代表上一级目录：如：<code>../image/2.jpg</code></li>
</ul>
</li>
<li>绝对路径也可以使用</li>
<li>直接使用链接也可以</li>
</ul>
</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;img src &#x3D; &quot;https:&#x2F;&#x2F;zjpicture.oss-cn-beijing.aliyuncs.com&#x2F;giteePic&#x2F;picgo-master&#x2F;img&#x2F;20201208092240.jpg&quot;&gt;</code></pre>
<h2 id="列表标签"><a class="markdownIt-Anchor" href="#列表标签"></a> 列表标签</h2>
<ul>
<li>有序列表
<ul>
<li>ol:定义有序列表（order list）
<ul>
<li>通过type属性来定义顺序表示的方式，如type=“A”,则用A,B，C。。。表示顺序，type=“I”,则表示用罗马数字表示顺序</li>
<li>通过start属性来定义从哪里开始计算顺序，如：start=“5”,则顺序从5，6，7，8开始下去。</li>
</ul>
</li>
<li>li：定义<strong>列表的项目</strong>(list)</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;ol&gt;
  &lt;li&gt;Coffee&lt;&#x2F;li&gt;
  &lt;li&gt;Tea&lt;&#x2F;li&gt;
  &lt;li&gt;Milk&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;</code></pre>
<p>效果：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201211102931.jpg" alt="" /></p>
<ul>
<li>无序列表：
<ul>
<li>ul:定义无序列表
<ul>
<li>通过type属性来定义列表项前面的符号样式：有disc，square，circle三种样式。</li>
</ul>
</li>
<li>li：定义列表的项目</li>
<li>示例：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;ul&gt;
  &lt;li&gt;Coffee&lt;&#x2F;li&gt;
  &lt;li&gt;Tea&lt;&#x2F;li&gt;
  &lt;li&gt;Milk&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;</code></pre>
<p>效果：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201211103137.jpg" alt="" /></p>
<h2 id="链接标签"><a class="markdownIt-Anchor" href="#链接标签"></a> 链接标签</h2>
<ul>
<li><code>&lt;a&gt;&lt;/a&gt;</code>:定义超链接</li>
<li>属性：
<ul>
<li>href：指定访问资源的url
<ul>
<li>既可以是网页链接</li>
<li>也可以是本地的资源，如：<code>./5_列表标签.html</code>。</li>
</ul>
</li>
<li>target:
<ul>
<li>“_self”,在当前页面打开链接的网页</li>
<li>“_blank”:在一个空白标签页打开链接的网页</li>
</ul>
</li>
</ul>
</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;a href &#x3D; &quot;https:&#x2F;&#x2F;zjpicture.oss-cn-beijing.aliyuncs.com&#x2F;giteePic&#x2F;picgo-master&#x2F;img&#x2F;20201211103137.jpg&quot; target &#x3D; &quot;_blank&quot;&gt;我是超链接&lt;&#x2F;a&gt;</code></pre>
<h2 id="div和span"><a class="markdownIt-Anchor" href="#div和span"></a> div和span</h2>
<ul>
<li><code>&lt;span&gt;&lt;/span&gt;</code>:没有任何样式，文本信息在<strong>一行展示</strong>，是行内标签，内联标签。</li>
<li><code>&lt;div&gt;&lt;/div&gt;</code>:没有任何样式，每一个div占满一整行，是块级标签。</li>
<li>这两个是结合css来控制样式的。</li>
</ul>
<h2 id="语义化标签"><a class="markdownIt-Anchor" href="#语义化标签"></a> 语义化标签</h2>
<ul>
<li>html5中为了提高程序的可读性，提供了一些标签</li>
<li>如：<code>&lt;header&gt;</code>是页眉</li>
<li>如：<code>&lt;footer&gt;</code>是页脚。</li>
</ul>
<h2 id="表格标签"><a class="markdownIt-Anchor" href="#表格标签"></a> 表格标签</h2>
<ul>
<li>html中的表格只有行的概念。所谓的“列”是行中的单元格。</li>
<li>table；定义表格
<ul>
<li>width:宽度</li>
<li>border:边框，会出现两条线，一条是行的边框线，一条是单元格的边框线。数字定义的是边框的宽度（像素为单位）</li>
<li>cellpadding；定义内容和单元格的距离</li>
<li>cellspaciing:定义单元格之间的距离。如果指定为0，则单元格的线合并为一条。</li>
<li>bgcolor:背景色</li>
<li>align：对齐方式</li>
</ul>
</li>
<li>tr：定义行
<ul>
<li>可以定义每一行的属性，如背景色，对齐方式等。</li>
</ul>
</li>
<li>td:定义单元格
<ul>
<li>属性colspan:合并列</li>
<li>属性rowspan；合并行</li>
<li>属性align:也可以设置单元格的对齐方式</li>
</ul>
</li>
<li>th:定义表头单元格</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;table border&#x3D;&quot;1&quot; width&#x3D;&quot;50%&quot; cellpading&#x3D;&quot;0&quot; cellspacing&#x3D;&quot;0&quot; align&#x3D;&quot;center&quot; bgcolor&#x3D;&quot;red&quot;&gt;
  &lt;!-- 表头行--&gt;
    &lt;tr&gt;
    &lt;!-- 表头单元格 --&gt;
        &lt;th&gt;编号&lt;&#x2F;th&gt;
        &lt;th&gt;姓名&lt;&#x2F;th&gt;
        &lt;th&gt;成绩&lt;&#x2F;th&gt;
    &lt;&#x2F;tr&gt;
    &lt;tr&gt;
        &lt;td&gt;1&lt;&#x2F;td&gt;
        &lt;td&gt;小龙女&lt;&#x2F;td&gt;
        &lt;td&gt;100&lt;&#x2F;td&gt;
    &lt;&#x2F;tr&gt;
    &lt;tr&gt;
        &lt;td&gt;2&lt;&#x2F;td&gt;
        &lt;td&gt;杨过&lt;&#x2F;td&gt;
        &lt;td&gt;60&lt;&#x2F;td&gt;
    &lt;&#x2F;tr&gt;
&lt;&#x2F;table&gt;</code></pre>
<ul>
<li>效果：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201212111419.jpg" alt="" /></li>
<li>caption:表格的标题</li>
<li>thead,tbody,tfoot；分别定义表格的头部分，体部分和脚部分，与语义标签类似，起到增强代码可读性的作用。</li>
</ul>
<h2 id="表单标签"><a class="markdownIt-Anchor" href="#表单标签"></a> 表单标签</h2>
<ul>
<li>表单概念：用于采集用户输入的数据，用于和服务器进行交互。</li>
</ul>
<h3 id="form标签"><a class="markdownIt-Anchor" href="#form标签"></a> form标签</h3>
<ul>
<li>form标签：用于定义表单，可以定义一个范围，范围表示采集用户数据的页面范围。
<ul>
<li>action属性：指定数据提交的url</li>
<li>method属性：指定提交方式(一共有7种，常用以下两种)
<ul>
<li>get:
<ul>
<li>请求的参数会在地址栏中显示，封装在请求行中。</li>
<li>请求参数大小有限制</li>
<li>不安全</li>
</ul>
</li>
<li>post:
<ul>
<li>请求参数不会在地址栏中显示，会封装在请求体中。</li>
<li>请求参数的大小没有限制</li>
<li>较为安全。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>表单项中的数据想要被提交，必须<strong>指明name属性</strong>，且要位于form标签的范围之内。</li>
</ul>
<h3 id="表单项标签"><a class="markdownIt-Anchor" href="#表单项标签"></a> 表单项标签</h3>
<h4 id="input标签"><a class="markdownIt-Anchor" href="#input标签"></a> input标签</h4>
<ul>
<li>input:可以通过<strong>type</strong>属性值，改变展现元素的格式。
<ul>
<li>type属性：
<ul>
<li>text:文本输入框，是<strong>默认</strong>的type属性值。
<ul>
<li>placeholder；指定输入框的提示信息，当输入框的内容发生变化之后，会自动清空提示信息；</li>
</ul>
</li>
<li>password:密码输入框
<ul>
<li>效果是输入的密码都变为密文，不可见。</li>
</ul>
</li>
<li>radio；单选框
<ul>
<li>要想让多个单选框实现单选的效果，则多个单选框的<strong>name属性值</strong>必须一样。</li>
<li>一般会给每一个单选框提供<strong>value属性值</strong>，指定其被选中后提交的值。</li>
<li><strong>checked属性值</strong>可以指定默认值，即没有选择的时候会默认选择的值。设置方式：<code>checked=&quot;checked&quot;</code>或者直接写一个<code>checked</code></li>
</ul>
</li>
<li>checkbox复选框：
<ul>
<li>一般会给每一个单选框提供<strong>value属性值</strong>，指定其被选中后提交的值。</li>
<li><strong>checked属性值</strong>可以指定默认值，即没有选择的时候会默认选择的值。设置方式：<code>checked=&quot;checked&quot;</code>或者直接写一个<code>checked</code></li>
</ul>
</li>
<li>file；文件选择框</li>
<li>hidden:隐藏域，用于提交一些信息。</li>
<li>按钮：
<ul>
<li>submit:提交按钮，可以提交表单,用<strong>value属性</strong>定义按钮显示的内容。</li>
<li>button:普通按钮，<strong>没有提交表单的功能</strong>。</li>
<li>image:图片提交按钮，通过<strong>src</strong>属性指定图片。</li>
</ul>
</li>
<li>color：取色器（html5新增的属性）</li>
<li>date:定义date控件，包括年月日</li>
<li>datetime-local：定义date和time控件，包括年月日时分。</li>
<li>email：定义用于输入邮箱地址的输入框，如果输入的数据不符合邮箱格式规范，则会报错无法提交。</li>
<li>number：定义用于输入数字的输入框，不能输入其它数据类型。</li>
</ul>
</li>
<li>label属性：指定输入项的文字描述信息
<ul>
<li>label的<strong>for属性</strong>值与input的<strong>id属性</strong>值相对应，如果对应了，则点击label区域，会让input输入框获取焦点。</li>
</ul>
</li>
<li>示例：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;form action&#x3D;&quot;#&quot;, method&#x3D;&quot;post&quot;&gt;
    &lt;label for&#x3D;&quot;username&quot;&gt;用户名：&lt;&#x2F;label&gt;&lt;input type&#x3D;&quot;text&quot; name &#x3D; &quot;用户名&quot; id &#x3D; &quot;username&quot; placeholder&#x3D;&quot;请输入用户名&quot;&gt; &lt;br&gt;
    &lt;label for&#x3D;&quot;password&quot;&gt;密码：&lt;&#x2F;label&gt;&lt;input type&#x3D;&quot;password&quot; name &#x3D; &quot;password&quot; id&#x3D;&quot;password&quot; placeholder&#x3D;&quot;请输入密码&quot;&gt;&lt;br&gt;
    性别：
        &lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot; value&#x3D;&quot;male&quot; checked&gt;男
        &lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot; value&#x3D;&quot;female&quot;  &gt;女&lt;br&gt;
    爱好：
        &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot; value&#x3D;&quot;java&quot; checked&gt;java
        &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot; value&#x3D;&quot;c&quot; &gt;c&lt;br&gt;
    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;登录&quot;&gt;
&lt;&#x2F;form&gt;</code></pre>
<ul>
<li>效果：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201212175934.jpg" alt="" /></li>
</ul>
<h4 id="select标签"><a class="markdownIt-Anchor" href="#select标签"></a> select标签</h4>
<ul>
<li>select:下拉列表
<ul>
<li>子元素：option，指定列表项</li>
<li>属性selected可以指定默认选项,如果不指定默认选项，则显示的是第一个列表项。</li>
</ul>
</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">省份：&lt;select name&#x3D;&quot;province&quot;&gt;
          &lt;option value&#x3D;&quot;&quot;&gt;--请选择--&lt;&#x2F;option&gt;
          &lt;option value&#x3D;&quot;1&quot; &gt;北京&lt;&#x2F;option&gt;
          &lt;option value&#x3D;&quot;2&quot; selected&gt;上海&lt;&#x2F;option&gt;
      &lt;&#x2F;select&gt;&lt;br&gt;</code></pre>
<h4 id="textarea标签"><a class="markdownIt-Anchor" href="#textarea标签"></a> textarea标签</h4>
<ul>
<li>textarea:文本域标签
<ul>
<li>cols：指定文本框的列数，每一行有少个字符；</li>
<li>rows：指定文本框的默认行数，行数如果不够会自动扩充。</li>
</ul>
</li>
</ul>
<h1 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h1>
<ul>
<li>代码：</li>
</ul>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang&#x3D;&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;
    &lt;title&gt;login&lt;&#x2F;title&gt;
&lt;&#x2F;head&gt;
&lt;body&gt;
    &lt;!--定义表单--&gt;
    &lt;form action&#x3D;&quot;#&quot; method&#x3D;&quot;post&quot;&gt;
            &lt;table border&#x3D;&quot;1&quot; align&#x3D;&quot;center&quot; width&#x3D;&quot;500&quot;&gt;
                    &lt;tr&gt;
                        &lt;td&gt;&lt;label for&#x3D;&quot;username&quot;&gt;用户名&lt;&#x2F;label&gt;&lt;&#x2F;td&gt;
                        &lt;td&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; id&#x3D;&quot;username&quot;&gt;&lt;&#x2F;td&gt;
                    &lt;&#x2F;tr&gt;
                    &lt;tr&gt;
                        &lt;td&gt;&lt;label for&#x3D;&quot;password&quot;&gt;密码&lt;&#x2F;label&gt;&lt;&#x2F;td&gt;
                        &lt;td&gt;&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot; id&#x3D;&quot;password&quot;&gt;&lt;&#x2F;td&gt;
                    &lt;&#x2F;tr&gt;
                    &lt;tr&gt;
                        &lt;td&gt;&lt;label for&#x3D;&quot;email&quot;&gt;Email&lt;&#x2F;label&gt;&lt;&#x2F;td&gt;
                        &lt;td&gt;&lt;input type&#x3D;&quot;email&quot; name&#x3D;&quot;email&quot; id&#x3D;&quot;email&quot;&gt;&lt;&#x2F;td&gt;
                    &lt;&#x2F;tr&gt;
                    &lt;tr&gt;
                        &lt;td&gt;&lt;label for&#x3D;&quot;name&quot;&gt;姓名&lt;&#x2F;label&gt;&lt;&#x2F;td&gt;
                        &lt;td&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;name&quot; id&#x3D;&quot;name&quot;&gt;&lt;&#x2F;td&gt;
                    &lt;&#x2F;tr&gt;
                    &lt;tr&gt;
                        &lt;td&gt;&lt;label for&#x3D;&quot;phonenumber&quot;&gt;手机号&lt;&#x2F;label&gt;&lt;&#x2F;td&gt;
                        &lt;td&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;phonenumber&quot; id&#x3D;&quot;phonenumber&quot;&gt;&lt;&#x2F;td&gt;
                    &lt;&#x2F;tr&gt;
                    &lt;tr&gt;
                        &lt;td&gt;&lt;label &gt;性别&lt;&#x2F;label&gt;&lt;&#x2F;td&gt;
                        &lt;td&gt;&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot; value&#x3D;&quot;male&quot;&gt;男
                            &lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot; value&#x3D;&quot;female&quot;&gt;女
                        &lt;&#x2F;td&gt;
                    &lt;&#x2F;tr&gt;
                    &lt;tr&gt;
                        &lt;td&gt;&lt;label for&#x3D;&quot;date&quot;&gt;出生日期&lt;&#x2F;label&gt;&lt;&#x2F;td&gt;
                        &lt;td&gt;&lt;input type&#x3D;&quot;date&quot; name&#x3D;&quot;date&quot; id&#x3D;&quot;date&quot;&gt;&lt;&#x2F;td&gt;
                    &lt;&#x2F;tr&gt;
                    &lt;tr&gt;
                        &lt;td colspan&#x3D;&quot;2&quot; align&#x3D;&quot;center&quot;&gt;&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;注册&quot;&gt;&lt;&#x2F;td&gt;
                    &lt;&#x2F;tr&gt;
            &lt;&#x2F;table&gt;
    &lt;&#x2F;form&gt;
&lt;&#x2F;body&gt;
&lt;&#x2F;html&gt;</code></pre>
<ul>
<li>效果<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201212201738.jpg" alt="" /></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/java-web%E6%A6%82%E5%BF%B5/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/java-web%E6%A6%82%E5%BF%B5/index.html" class="post-title-link" itemprop="url">java web概念</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-07 19:01:06" itemprop="dateCreated datePublished" datetime="2020-12-07T19:01:06+08:00">2020-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-09-26 21:38:44" itemprop="dateModified" datetime="2021-09-26T21:38:44+08:00">2021-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web后端</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="javaweb"><a class="markdownIt-Anchor" href="#javaweb"></a> JavaWeb</h1>
<ul>
<li>使用Java语言开发基于互联网的项目。</li>
</ul>
<h1 id="软件架构"><a class="markdownIt-Anchor" href="#软件架构"></a> 软件架构</h1>
<ul>
<li>C/S:Cient/Server 客户端/服务器端
<ul>
<li>在用户本地有一个客户端程序，在远程有一个服务器端程序。</li>
<li>如：QQ等</li>
<li>优点：
<ul>
<li>用户体验好</li>
</ul>
</li>
<li>缺点：
<ul>
<li>开发，安装，部署，维护麻烦</li>
</ul>
</li>
</ul>
</li>
<li>B/S:Brower/Server 浏览器/服务器端
<ul>
<li>只需要一个浏览器，用户通过不同的网址(URL),客户访问不同的服务器端程序</li>
<li>优点：
<ul>
<li>开发，安装，部署，维护，简单</li>
</ul>
</li>
<li>缺点；
<ul>
<li>如果应用过大，用户体验可能会受到影响；</li>
<li>对硬件要求过高。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="bs架构"><a class="markdownIt-Anchor" href="#bs架构"></a> B/S架构</h1>
<ul>
<li>
<p>资源分类：</p>
<ol>
<li>静态资源：
<ol>
<li>使用静态网页开发技术发布的资源</li>
<li>特点:
<ol>
<li>所有用户访问得到的结果是<strong>一样</strong>的；</li>
<li>如：文本，图片，音频，视频，HTML,CSS,JavaScript（静态开发技术）</li>
<li>如果用户<strong>请求</strong>的是静态资源，那么服务器会直接将静态资源发送给浏览器，浏览器<strong>内置了静态资源的解析引擎</strong>，可以展示静态资源,称为<strong>响应</strong>。</li>
</ol>
</li>
</ol>
</li>
<li>动态资源
<ol>
<li>使用动态网页技术发布的资源</li>
<li>特点：
<ol>
<li>所有用户访问，得到的结果<strong>可能不一样。</strong></li>
<li>如：jsp/servlet,php,asp等动态网页开发技术</li>
<li>如果用户请求的是动态资源，服务器会<strong>执行动态资源，转换为静态资源</strong>再发送给浏览器。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>学习动态资源必须先学习静态资源，即静态网页技术三剑客。（HTML，CSS，JavaScript）</p>
</li>
<li>
<p>HTML:用于搭建基础网页，展示页面内容；</p>
</li>
<li>
<p>CSS:用于美化页面，布局页面。</p>
</li>
<li>
<p>JavaScript：控制页面的元素，使页面有动态的效果。</p>
</li>
</ul>
<h1 id="网络通信三要素"><a class="markdownIt-Anchor" href="#网络通信三要素"></a> 网络通信三要素</h1>
<ol>
<li>IP：电子设备（计算机）在网络中的唯一标识</li>
<li>端口：<strong>应用程序</strong>在计算机中的唯一标识，0~65536</li>
<li>传输协议：规定了数据传输的规则
<ol>
<li>基础协议：
<ol>
<li>tcp：安全协议，三次握手，速度较慢</li>
<li>udp：不安全协议，速度快</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="web服务器软件"><a class="markdownIt-Anchor" href="#web服务器软件"></a> web服务器软件</h1>
<ul>
<li>服务器：安装了服务器软件的计算机；</li>
<li>服务器软件：接收用户的请求，处理请求，做出响应；</li>
<li>web服务器软件：也能接收用户的请求，处理请求，做出响应，但有其特点：
<ul>
<li>在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目；</li>
<li>动态资源必须在web服务器软件上使用，web服务器软件也被称为<strong>web容器</strong>。</li>
</ul>
</li>
<li>常见的java相关的web服务器软件：
<ul>
<li>webLogic：orgcle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费；</li>
<li>webSphere:IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费；</li>
<li>JBOSS：JBOSS公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费；</li>
<li>Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servle/jso、开源，免费。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/JDBC/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/JDBC/index.html" class="post-title-link" itemprop="url">JDBC</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-25 17:17:57" itemprop="dateCreated datePublished" datetime="2020-11-25T17:17:57+08:00">2020-11-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:27:52" itemprop="dateModified" datetime="2022-09-17T19:27:52+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web后端</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>15k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>14 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="jdbc概念"><a class="markdownIt-Anchor" href="#jdbc概念"></a> JDBC概念</h1>
<ul>
<li>JDBC是java database connectivity的缩写。是使用java语言来操作数据库。JDBC实现了使用统一的java代码来操作所有关系型数据库。</li>
<li>JDBC是sun公司定义的操作所有关系型数据库的规则，即定义了一套接口。</li>
<li>每一个数据库厂商实现JDBC接口来操作自己的数据库。这些实现类的jar包就叫做<strong>数据库驱动</strong>。</li>
<li>MySQL 8.0 以上版本的数据库连接有所不同：
<ol>
<li>MySQL 8.0 以上版本驱动包版本 mysql-connector-java-8.0.16.jar。</li>
<li><code>com.mysql.jdbc.Driver</code> 更换为 <code>com.mysql.cj.jdbc.Driver</code></li>
</ol>
</li>
</ul>
<h1 id="jdbc基本使用"><a class="markdownIt-Anchor" href="#jdbc基本使用"></a> JDBC基本使用</h1>
<h2 id="1导入驱动jar包到项目目录下"><a class="markdownIt-Anchor" href="#1导入驱动jar包到项目目录下"></a> 1.导入驱动jar包到项目目录下</h2>
<ol>
<li>mysql的jar包下载:<a target="_blank" rel="noopener" href="https://dev.mysql.com/downloads/connector/">官网</a>;下载时选择platformIndependent，选择5.xx的版本</li>
<li>复制jar包到项目的libs目录下（也可以直接导入），右键-&gt;add as library</li>
</ol>
<h2 id="2-注册驱动"><a class="markdownIt-Anchor" href="#2-注册驱动"></a> 2. 注册驱动</h2>
<ul>
<li><code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code>,会产生ClsaaNotFoundException的异常。</li>
<li><code>The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server.</code>:如果对应的数据库服务未开启，或者名字输错了，就会报这个错。</li>
</ul>
<h2 id="3-获取数据库的连接对象"><a class="markdownIt-Anchor" href="#3-获取数据库的连接对象"></a> 3. 获取数据库的连接对象</h2>
<ul>
<li><code>Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/youth_study&quot;, &quot;root&quot;,&quot;root&quot;);</code>
<ul>
<li>参数依次为连接地址，用户名，密码。</li>
<li>连接地址中，后面是主机名：端口/数据库名</li>
</ul>
</li>
</ul>
<h2 id="4定义sql"><a class="markdownIt-Anchor" href="#4定义sql"></a> 4.定义sql</h2>
<ul>
<li><code>String sql = &quot;update t_branch set college_id = 2 where id = 1&quot;;</code>,定义一个存储sql语句的字符串。</li>
</ul>
<h2 id="5获取执行sql语句的对象"><a class="markdownIt-Anchor" href="#5获取执行sql语句的对象"></a> 5.获取执行sql语句的对象</h2>
<ul>
<li><code>Statement stmt = conn.createStatement();</code>conn是数据库的连接对象。</li>
</ul>
<h2 id="6执行sql接受返回结果"><a class="markdownIt-Anchor" href="#6执行sql接受返回结果"></a> 6.执行sql，接受返回结果；</h2>
<ul>
<li><code>int count = stmt.executeUpdate(sql);</code></li>
<li><code>System.out.println(count);</code></li>
</ul>
<h2 id="7-释放资源"><a class="markdownIt-Anchor" href="#7-释放资源"></a> 7. 释放资源</h2>
<ul>
<li><code>conn.close();</code></li>
<li><code>stmt.close();</code></li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
package com;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;

&#x2F;*
 * JDBC入门
 *&#x2F;
public class Jdbc1 &#123;
    public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;
        &#x2F;&#x2F;注册驱动
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
        &#x2F;&#x2F;获取数据库连接对象
        Connection conn &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;3306&#x2F;youth_study&quot;, &quot;root&quot;,&quot;root&quot;);
        &#x2F;&#x2F;定义sql语句
        String sql &#x3D; &quot;update t_branch set college_id &#x3D; 2 where id &#x3D; 1&quot;;
        &#x2F;&#x2F; 获取执行sql的对象
        Statement  stmt &#x3D; conn.createStatement();
        &#x2F;&#x2F; 执行sql
        int count &#x3D; stmt.executeUpdate(sql);
        &#x2F;&#x2F; 处理结果
        System.out.println(count);
        &#x2F;&#x2F; 释放资源
        conn.close();
        stmt.close();
    &#125;
&#125;</code></pre>
<h1 id="jdbc对象"><a class="markdownIt-Anchor" href="#jdbc对象"></a> JDBC对象</h1>
<h2 id="drivermanager"><a class="markdownIt-Anchor" href="#drivermanager"></a> DriverManager</h2>
<ul>
<li>驱动管理对象</li>
<li>功能：
<ol>
<li>注册驱动</li>
<li>获取数据库的连接</li>
</ol>
</li>
</ul>
<h3 id="注册驱动"><a class="markdownIt-Anchor" href="#注册驱动"></a> 注册驱动</h3>
<ul>
<li>告诉程序该使用哪一个数据库驱动jar包</li>
<li>方法：<code>static void registerDriver(Driver driver)</code>,注册与给定的驱动程序</li>
<li>实际使用：<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code></li>
<li>在com.mysql.jdbc.Driver的源码中存在静态代码块：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Static &#123;
      try &#123;
        java.sql.DriverManager.registerDriver(new Driver());
      &#125; catch (SQLException E) &#123;
        throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);
      &#125;
&#125;</code></pre>
<ul>
<li>通过导入jar包，就会自动注册驱动程序</li>
</ul>
<h3 id="获取数据库连接"><a class="markdownIt-Anchor" href="#获取数据库连接"></a> 获取数据库连接</h3>
<ul>
<li>让程序连接到具体的数据库；</li>
<li>方法：<code>static Connection getConnection(String url, String user, String password);</code></li>
<li>参数：
<ul>
<li>url:指定连接数据库的路径
<ul>
<li>语法：<code>jdbc:mysql://ip地址(域名):端口号/数据库名称</code></li>
<li>例子：<code>jdbc:mysql://localhost:3306/db1</code></li>
<li>特例:如果连接的是本机mysql的服务器，并且MySQL服务器的默认端口是3306，则URL可以简写为：<code>jdbc:mysql:///数据库名称</code></li>
</ul>
</li>
<li>user:用户名</li>
<li>password：用户密码</li>
</ul>
</li>
</ul>
<h2 id="connection"><a class="markdownIt-Anchor" href="#connection"></a> Connection</h2>
<ul>
<li>数据库连接对象</li>
<li>功能：
<ol>
<li>获取执行sql的对象</li>
<li>管理事务</li>
</ol>
</li>
</ul>
<h3 id="获取执行sql的对象"><a class="markdownIt-Anchor" href="#获取执行sql的对象"></a> 获取执行sql的对象</h3>
<ul>
<li>创建一个能够接收sql语句的对象；</li>
<li>方法：
<ul>
<li><code>Statement createStatement();</code></li>
<li><code>PreparedStatement prepareStatement(String sql);</code></li>
</ul>
</li>
</ul>
<h3 id="管理事务"><a class="markdownIt-Anchor" href="#管理事务"></a> 管理事务</h3>
<ul>
<li>包含处理事务的开启，提交，回滚的方法；</li>
<li>开启事务：<code>void setAutoCommit(boolean autoCommit);</code>,调用该方法并设置参数为<strong>false</strong>，即可开启事务。（因为设为true则代表着着事务是自动提交，也就没有人的管理，所以也就没有开不开启事务之说）,在执行sql之前开启事务（通常是刚创建连接生成Conneection对象时），示例：<code>conn.setAutoCommit(false);</code></li>
<li>提交事务：<code>void commit()</code>，在所有sql执行完时提交，示例：<code>conn.commit();</code></li>
<li>回滚事务：<code>void rollback();</code>，回滚事务的操作一般放在catch块中，即出现异常时才回滚。调用示例：<code>conn.rollback();</code></li>
</ul>
<h2 id="statement"><a class="markdownIt-Anchor" href="#statement"></a> Statement</h2>
<ul>
<li>用于执行<strong>静态SQL语句</strong>并放回其生成的结果的对象。</li>
<li><code>boolean execute(String sql);</code>,可以执行任意的sql语句，不常用。</li>
<li><code>int executeUpdate(String sql);</code>:执行DML（insert， update， delete）语句，也可以执行DDL（create， alter ，drop）语句（但是这些操作一般不会使用java代码实现，所以这个方法常用于执行DML语句）。
<ul>
<li>返回值：该方法的返回值是<strong>执行该sql语句影响的行数</strong>，通过这个返回值来判断sql语句是否执行成功（返回值&gt;0则成功）。</li>
</ul>
</li>
<li><code>ResultSet executeQuery(String sql);</code>:执行DQL（select）语句。</li>
</ul>
<h2 id="resultset"><a class="markdownIt-Anchor" href="#resultset"></a> ResultSet</h2>
<ul>
<li>结果集对象，封装了查询的结果；</li>
<li>Result对象可以想象为是一个指向查询结果表的<strong>游标</strong>（类似c语言的指针概念），这个“游标”开始是指向表头的。</li>
<li><code>boolean next()</code>:使游标指向下一行，并判断当前行是否有数据，如果没有则返回false。</li>
<li><code>getXxx(参数)</code>:获取某一个数据
<ul>
<li>Xxx；代表返回的数据类型，与要查询的数据的数据类型相匹配、如：<code>int getInt(), String getString()</code>;</li>
<li>参数：
<ol>
<li>int类型的参数：代表列的编号，从左往右数，从1开始。如：<code>getString(1);</code>表示取出当前游标所指行的第一列的数据</li>
<li>String类型的参数：代表列的名称。如:<code>getDouble(&quot;balance&quot;)</code>表示取出当前行名为balance列的数据。</li>
</ol>
</li>
</ul>
</li>
<li>使用步骤：
<ol>
<li>游标向下移动一行</li>
<li>判断是否有数据</li>
<li>获取数据</li>
<li>如果有多行数据需要输出，则使用循环重复以上三个步骤，可以遍历整个结果集的数据。</li>
</ol>
</li>
</ul>
<h2 id="preparedstatement"><a class="markdownIt-Anchor" href="#preparedstatement"></a> PreparedStatement</h2>
<ul>
<li>是Statement的子类，但是功能更加强大；</li>
<li>SQL注入问题：在拼接sql语句时，有一些sql的特殊关键字参与字符串的拼接，会造成sql语句的含义改变，导致安全问题。
<ul>
<li>示例：<code>String sql = &quot;select * from user where username = '&quot;+username+&quot;' and password = '&quot;+password+&quot;'&quot;</code>,其中被单双引号包裹的是传进来的字符串参数。(注意这种拼接字符串的特殊格式)。这种直接拼接参数的sql语句也叫做<strong>静态sql语句</strong>。</li>
<li>如果username = “zhangsan”,password = “a’ or ‘a’ = 'a”,那么拼接上参数的值后的sql语句为：<code>sql = &quot;select * from user where username = '&quot;+&quot;zhangsan&quot;+&quot;' and password = '&quot;+&quot;a' or 'a' = 'a&quot;&quot;'&quot;</code>将双引号合并之后为:<code>sql = &quot;select * from user where username = 'zhangsan' and password = 'a' or 'a' = 'a'&quot;</code>,这个sql语句的含义就和我们原本的想象大不相同了。</li>
</ul>
</li>
<li>解决SQL注入问题：使用PreparedStatement对象替换原来的Statement对象。</li>
<li><strong>预编译的sql语句</strong>：将sql语句中的参数使用占位符<code>?</code>来代替。</li>
<li>ParparedStatement类型才是一般情况下通用的JDBC使用方法；</li>
<li>可以防止sql注入问题，效率更高。</li>
</ul>
<h3 id="使用步骤"><a class="markdownIt-Anchor" href="#使用步骤"></a> 使用步骤</h3>
<ol>
<li>导入驱动jar包</li>
<li>注册驱动</li>
<li>获取数据库连接对象Connection</li>
<li>定义sql语句：
<ol>
<li>需要参数的地方使用<code>?</code>来代替。如：<code>String sql = &quot;select * from user where username = ? and password = ?</code></li>
</ol>
</li>
<li>获取执行sql语句的PreparedStatement对象：使用Connection.prepareStatement(String sql)方法，如<code>PreparedStatement patmt = conn.prepareStatement(sql);</code></li>
<li>给<code>?</code>占位符赋上参数的值：</li>
</ol>
<ul>
<li>方法：<code>setXxx(参数1，参数2)</code>
<ul>
<li>Xxx是参数的类型；</li>
<li>参数1是int类型：是参数在sql语句中的相对位置来定的，从左往右，从1开始编号。第一个参数的参数1就是1</li>
<li>参数2：就是具体的参数。</li>
<li>示例：<code>pstmt.setString(1,username);</code></li>
<li><code>pstmt.setString(2, password);</code></li>
</ul>
</li>
</ul>
<ol start="7">
<li>执行sql，接收返回结果，<strong>不需要传递sql语句</strong>（与Statement不同），如：<code>ResultSet rs = pstmt.excuteQuery();</code></li>
<li>处理结果</li>
<li>释放资源</li>
</ol>
<h1 id="jdbc工具类"><a class="markdownIt-Anchor" href="#jdbc工具类"></a> JDBC工具类</h1>
<ul>
<li>作用：将重复的代码封装进一个类中，简化代码的书写。</li>
<li>抽取的代码：
<ul>
<li>注册驱动的代码；
<ul>
<li>驱动只需注册一次，所以直接在静态代码块中实现</li>
</ul>
</li>
<li>抽取获取连接对象的代码：
<ul>
<li>需求：不传递参数的同时，保证工具类的通用性。</li>
<li>解决方法：书写<code>.properties</code>配置文件。此处是<code>jdbc.properties</code>文件.在这个文件中将获取连接对象的参数写好,之后再次使用该工具类连接不同的数据库时，只需要修改配置文件即可。<strong>.properties文件是直接放在src文件夹下</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">url &#x3D; jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db3
user &#x3D; root
password &#x3D; root
driver &#x3D; com.mysql.jdbc.Driver</code></pre>
<ul>
<li>抽取释放资源的代码。</li>
<li>工具类的实现：JDBCUtils类</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.FileReader;
import java.io.IOException;
import java.net.URL;
import java.sql.*;
import java.util.Properties;

public class JDBCUtils &#123;
    private static String url;
    private static String user;
    private static String password;
    private static String driver;

    &#x2F;*
     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块，只读取一次这些值
     *&#x2F;
    static &#123;
        try &#123;
            &#x2F;&#x2F;1. 创建Properties集合类
            Properties pro &#x3D; new Properties();
            &#x2F;&#x2F;2. 获取src路径下的文件的方式:使用ClassLoader类加载器
            &#x2F;&#x2F;获取src文件夹在计算机中的绝对路径
            ClassLoader classLoader &#x3D; JDBCUtils.class.getClassLoader();
            &#x2F;&#x2F;获取src文件夹下配置文件的url格式的路径
            URL res &#x3D; classLoader.getResource(&quot;jdbc.properties&quot;);
            &#x2F;&#x2F;将url路径转换为字符串形式
            String path &#x3D; res.getPath();

            &#x2F;&#x2F;3.加载文件
            pro.load(new FileReader(path));

            &#x2F;&#x2F;4.获取数据，赋值
            url &#x3D; pro.getProperty(&quot;url&quot;);
            user &#x3D; pro.getProperty(&quot;user&quot;);
            password &#x3D; pro.getProperty(&quot;password&quot;);
            driver &#x3D; pro.getProperty(&quot;driver&quot;);

            &#x2F;&#x2F;5. 注册驱动
            Class.forName(driver);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    &#x2F;**
     * 获取连接
     * @return 连接对象
     *&#x2F;
    public static Connection getConnection() throws SQLException &#123;
        return DriverManager.getConnection(url, user, password);
    &#125;

    &#x2F;**
     * 释放资源
     * @param stmt
     * @param conn
     * @param rs
     *&#x2F;
    public static void close(ResultSet rs, Statement stmt, Connection conn) &#123;
        if(rs !&#x3D; null) &#123;
            try &#123;
                rs.close();
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        if(stmt !&#x3D; null) &#123;
            try &#123;
                stmt.close();
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        
        if(conn !&#x3D; null) &#123;
            try &#123;
                conn.close();
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

    &#125;
&#125;</code></pre>
<h1 id="数据库连接池"><a class="markdownIt-Anchor" href="#数据库连接池"></a> 数据库连接池</h1>
<ul>
<li>概念：
<ul>
<li>在一个容器（集合）中存放数据库连接对象（Connection对象）。</li>
<li>当系统初始化后，容器被创建，容器中会申请需要使用的连接对象，当用户需要访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。</li>
<li>优化了之前的在用户需要使用连接对象时才申请连接对象，用户用完就释放的连接对象使用方式，节约资源，提高用户访问数据库的效率。</li>
</ul>
</li>
</ul>
<h2 id="数据库连接池实现"><a class="markdownIt-Anchor" href="#数据库连接池实现"></a> 数据库连接池实现</h2>
<ul>
<li>标准接口；DataSource接口，在javax.sql包下；
<ul>
<li>方法：
<ul>
<li>获取连接：<code>getConnection()</code></li>
<li>归还连接：<code>Connect.close()</code>。如果连接对象Conneection是从连接池获取的，那么调用Connection.close()方法，则不会关闭连接，而是归还连接到数据连接池中去。</li>
</ul>
</li>
</ul>
</li>
<li>具体实现一般是由具体的数据库厂商来完成的，常见的有C3P0、Druid（阿里巴巴实现的）等数据库连接池技术。</li>
</ul>
<h3 id="c3p0"><a class="markdownIt-Anchor" href="#c3p0"></a> C3P0</h3>
<ul>
<li>步骤；
<ol>
<li>导入三个jar包；c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar 以及数据库的驱动jar包</li>
<li>第一配置文件
<ol>
<li>名称；c3p0.properties或者c3p0-config.xml</li>
<li>路径：直接将文件放在src目录下即可。</li>
</ol>
</li>
</ol>
</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;c3p0-config&gt;

    &lt;!-- 默认配置 --&gt;
    &lt;default-config&gt;
        &lt;!-- 连接参数 --&gt;
        &lt;property name &#x3D;&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt;
        &lt;property name &#x3D;&quot;jdbcUrl&quot;&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;youth_study&lt;&#x2F;property&gt;
        &lt;property name&#x3D;&quot;user&quot;&gt;root&lt;&#x2F;property&gt;
        &lt;property name&#x3D;&quot;password&quot;&gt;root&lt;&#x2F;property&gt;

        &lt;!-- 连接池参数 --&gt;
        &lt;!-- &lt;property name&#x3D;&quot;automaticTestTable&quot;&gt;con_test&lt;&#x2F;property&gt; --&gt;
        &lt;property name&#x3D;&quot;checkoutTimeout&quot;&gt;3000&lt;&#x2F;property&gt;
        &lt;!-- &lt;property name&#x3D;&quot;idleConnectionTestPeriod&quot;&gt;30&lt;&#x2F;property&gt; --&gt;
        &lt;property name&#x3D;&quot;initialPoolSize&quot;&gt;5&lt;&#x2F;property&gt;
        &lt;!-- &lt;property name&#x3D;&quot;maxIdleTime&quot;&gt;30&lt;&#x2F;property&gt; --&gt;
        &lt;!-- &lt;property name&#x3D;&quot;maxIdleTimeExcessConnections&quot;&gt;10&lt;&#x2F;property&gt; --&gt;
        &lt;!-- &lt;property name&#x3D;&quot;maxConnectionAge&quot;&gt;60&lt;&#x2F;property&gt; --&gt;
        &lt;!-- &lt;property name&#x3D;&quot;propertyCycle&quot;&gt;1&lt;&#x2F;property&gt; --&gt;
        &lt;property name&#x3D;&quot;maxPoolSize&quot;&gt;10&lt;&#x2F;property&gt;
        &lt;!-- &lt;property name&#x3D;&quot;minPoolSize&quot;&gt;5&lt;&#x2F;property&gt; --&gt;
        &lt;!-- &lt;property name&#x3D;&quot;maxStatements&quot;&gt;0&lt;&#x2F;property&gt; --&gt;
        &lt;!-- &lt;property name&#x3D;&quot;maxStatementsPerConnection&quot;&gt;5&lt;&#x2F;property&gt; --&gt;
        &lt;!-- &lt;property name&#x3D;&quot;maxAdministrativeTaskTime&quot;&gt;4&lt;&#x2F;property&gt; --&gt;
        &lt;!-- &lt;property name&#x3D;&quot;connectionCustomizerClassName&quot;&gt;com.mchange.v2.c3p0.test.TestConnectionCustomizer&lt;&#x2F;property&gt; --&gt;
        &lt;!-- &lt;property name&#x3D;&quot;unreturnedConnectionTimeout&quot;&gt;15&lt;&#x2F;property&gt; --&gt;
        &lt;!-- &lt;property name&#x3D;&quot;debugUnreturnedConnectionStackTraces&quot;&gt;true&lt;&#x2F;property&gt; --&gt;

        &lt;!-- &lt;property name&#x3D;&quot;dataSourceName&quot;&gt;poop&lt;&#x2F;property&gt; --&gt;

        &lt;!-- &lt;property name&#x3D;&quot;driverClass&quot;&gt;org.postgresql.Driver&lt;&#x2F;property&gt; --&gt;
        &lt;!-- &lt;property name&#x3D;&quot;jdbcUrl&quot;&gt;jdbc:postgresql:&#x2F;&#x2F;localhost&#x2F;c3p0-test&lt;&#x2F;property&gt; --&gt;

    &lt;&#x2F;default-config&gt;
    
    &lt;!-- 指定名称的配置 --&gt;
    &lt;named-config name &#x3D; &quot;otherconfig&quot;&gt;
        &lt;!-- 连接参数 --&gt;
        &lt;property name &#x3D;&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt;
        &lt;property name &#x3D;&quot;jdbcUrl&quot;&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;youth_study&lt;&#x2F;property&gt;
        &lt;property name&#x3D;&quot;user&quot;&gt;root&lt;&#x2F;property&gt;
        &lt;property name&#x3D;&quot;password&quot;&gt;root&lt;&#x2F;property&gt;

        &lt;!-- 连接池参数 --&gt;
        &lt;property name&#x3D;&quot;checkoutTimeout&quot;&gt;3000&lt;&#x2F;property&gt;
        &lt;property name&#x3D;&quot;initialPoolSize&quot;&gt;5&lt;&#x2F;property&gt;
        &lt;property name&#x3D;&quot;maxPoolSize&quot;&gt;8&lt;&#x2F;property&gt;
    &lt;&#x2F;named-config&gt;
&lt;&#x2F;c3p0-config&gt;</code></pre>
<ol start="3">
<li>创建核心对象:数据库连接池对象，<code>ComboPooledDataSource</code></li>
</ol>
  <pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;获取DataSorce，使用默认的c3p0-config.xml配置
 DataSource ds &#x3D; new ComboPooledDataSource();
 &#x2F;&#x2F;获取DataSource,指定名称配置
  DataSource ds &#x3D; new ComboPooledDataSource(&quot;Otherc3p0&quot;);</code></pre>
<ol start="4">
<li>获取连接：getConnection</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Connection conn &#x3D; ds.getConnection();</code></pre>
<ol start="5">
<li>归还连接</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">conn.close();</code></pre>
<h3 id="druid"><a class="markdownIt-Anchor" href="#druid"></a> druid</h3>
<h4 id="使用步骤-2"><a class="markdownIt-Anchor" href="#使用步骤-2"></a> 使用步骤</h4>
<ol>
<li>导入jar包：druid-1.0.9.jar</li>
<li>定义配置文件：
<ol>
<li>是<code>.properties</code>文件</li>
<li>可以叫任意名称，放在任意目录下，需要手动加载。</li>
</ol>
</li>
</ol>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">driverClassName&#x3D;com.mysql.jdbc.Driver
url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;youth_study
username&#x3D;root
password&#x3D;root
# 初始化连接数量
initialSize&#x3D;5
# 最大连接数量
maxActive&#x3D;10
# 最长等待时间
maxWait&#x3D;3000</code></pre>
<ol start="3">
<li>加载配置文件</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Properties pro &#x3D; new Properties(); &#x2F;&#x2F;创建Properties对象
InputStream is &#x3D; DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); &#x2F;&#x2F;获取properties文件的输入流
pro.load(is); &#x2F;&#x2F;根据输入流来加载配置文件</code></pre>
<ol start="4">
<li>获取数据库连接池对象：
<ol>
<li>通过工厂类来获取，DruidDataSourceFactory,需要将Properties配置文件对象传递给工厂方法。</li>
</ol>
</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">DataSource ds &#x3D; DruidDataSourceFactory.createDataSource(pro);;</code></pre>
<ol start="5">
<li>获取连接：getConnnection</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Connection conn &#x3D; ds.getConnection();
System.out.println(conn);</code></pre>
<h4 id="druid工具类"><a class="markdownIt-Anchor" href="#druid工具类"></a> druid工具类</h4>
<ol>
<li>定义一个类JDBCUtils</li>
<li>提供静态代码块加载配置文件，初始化连接池对象</li>
<li>提供方法：
<ol>
<li>获取连接方法：通过数据库连接池获取连接</li>
<li>释放资源</li>
<li>获取连接池的方法</li>
</ol>
</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.Utils;

import com.alibaba.druid.pool.DruidDataSourceFactory;

import javax.sql.DataSource;
import java.io.IOException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

&#x2F;**
 * druid连接池的工具类
 *&#x2F;
public class JDBCUtils &#123;

    &#x2F;&#x2F;1.定义成员变量
    private static DataSource ds;

    static &#123;
        try &#123;
            &#x2F;&#x2F;1.加载配置文件
            Properties pro &#x3D; new Properties();
            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));;
            &#x2F;&#x2F;2. 获取DataSource
            ds &#x3D; DruidDataSourceFactory.createDataSource(pro);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    &#x2F;**
     * 获取连接
     *&#x2F;
    public static Connection getConnection() throws SQLException &#123;
        return ds.getConnection();
    &#125;

    &#x2F;**
     * 释放资源
     *&#x2F;
    public static void close(ResultSet rs, Statement stmt, Connection conn) &#123;
        if (rs !&#x3D; null) &#123;
            try &#123;
                rs.close();
            &#125; catch (SQLException throwables) &#123;
                throwables.printStackTrace();
            &#125;
        &#125;

        if (stmt !&#x3D; null) &#123;
            try &#123;
                stmt.close();
            &#125; catch (SQLException throwables) &#123;
                throwables.printStackTrace();
            &#125;
        &#125;

        if (conn !&#x3D; null) &#123;
            try &#123;
                conn.close(); &#x2F;&#x2F;归还连接
            &#125; catch (SQLException throwables) &#123;
                throwables.printStackTrace();
            &#125;
        &#125;
    &#125;

    &#x2F;**
     * 释放资源的重载，两个参数
     *&#x2F;
    public static void close (Statement stmt, Connection conn) &#123;
        JDBCUtils.close(null, stmt, conn);
    &#125;

    &#x2F;**
     * 获取连接池
     *&#x2F;
    public static DataSource getDataSource() &#123;
        return ds;
    &#125;
&#125;</code></pre>
<ul>
<li>工具类使用示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.druid;

import com.Utils.JDBCUtils;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Properties;

&#x2F;**
 * 使用工具类
 *&#x2F;
public class DruidDemo2 &#123;
    public static void main(String[] args) &#123;

        &#x2F;&#x2F;把要被释放的资源的定义放在try-catch语块之外，使得释放资源时方便，不会出现没有定义的错误
        Connection conn &#x3D; null;
        PreparedStatement pstmt &#x3D; null;
        try &#123;
            &#x2F;&#x2F;1.获取连接
            conn &#x3D; JDBCUtils.getConnection();
            &#x2F;&#x2F;2. 定义sql
            String sql &#x3D; &quot;update t_branch set college_id &#x3D; ? where id &#x3D; ?&quot;;
            &#x2F;&#x2F;3. 获取PreparedStatement对象
            pstmt &#x3D; conn.prepareStatement(sql);
            &#x2F;&#x2F;4.给sql语句里面的参数赋值
            pstmt.setInt(1, 333);
            pstmt.setInt(2,1);
            &#x2F;&#x2F;执行sql语句
            int count &#x3D; pstmt.executeUpdate();
            &#x2F;&#x2F;结果处理
            System.out.println(count);
        &#125; catch (SQLException throwables) &#123;
            throwables.printStackTrace();
        &#125;finally &#123;
            &#x2F;&#x2F;释放资源
            JDBCUtils.close(pstmt, conn);
        &#125;
    &#125;
&#125;</code></pre>
<h1 id="spring-jdbc"><a class="markdownIt-Anchor" href="#spring-jdbc"></a> Spring JDBC</h1>
<ul>
<li>Spring框架对JDBC的简单封装。提供了一个<strong>JDBCTemplate对象</strong>简化JDBC的开发。</li>
</ul>
<h2 id="spring-jdbc的使用步骤"><a class="markdownIt-Anchor" href="#spring-jdbc的使用步骤"></a> Spring JDBC的使用步骤</h2>
<ol>
<li>导入jar包<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201207173331.jpg" alt="" /></li>
<li>创建JDBCTemplate对象。依赖于数据源对象<code>DataSource ds</code>
<ol>
<li><code>JDBCTemplate template = new JDBCTemplate(ds);</code></li>
</ol>
</li>
<li>调用JDBCTemplate的方法来完成CRUD的操作：
<ol>
<li><code>update()</code>:执行DML语句，完成增，删，改语句。
<ol>
<li>如果需要往sql语句中传入参数，就使用<code>update(sql,参数1，参数2...)</code>,参数的顺序就是他们在sql语句中从左至右的顺序。</li>
</ol>
</li>
<li><code>queryForMap()</code>:查询结果将结果集封装为Map集合；
<ol>
<li>查询结果集长度只能是1。</li>
</ol>
</li>
<li><code>queryForList()</code>:查询结果将结果集封装为List集合；</li>
<li><code>query()</code>:查询结果，将结果封装为JavaBean对象；</li>
<li><code>queryForObject()</code>:查询结果，将结果集封装为对象（一般是基本数据类型）。</li>
</ol>
</li>
<li>使用JDBCTemplat<strong>无需释放资源</strong>（会自动进行）。</li>
</ol>
<ul>
<li>使用示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.JDBCtemplate;

import com.Utils.JDBCUtils;
import org.springframework.jdbc.core.JdbcTemplate;

&#x2F;**
 * JDBCTemplate入门使用
 *&#x2F;
public class JdbcTemplateDemo1 &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F;1.导入jar包
        &#x2F;&#x2F;2.创建JDBCTemplate对象
        JdbcTemplate template &#x3D; new JdbcTemplate(JDBCUtils.getDataSource());
        &#x2F;&#x2F;3.调用方法
        String sql &#x3D; &quot;update t_branch set college_id &#x3D; ? where id &#x3D; ?&quot;;
        &#x2F;&#x2F;4,执行sql并传参
        int count&#x3D; template.update(sql,555,1);
        System.out.println(count);
    &#125;
&#125;</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/docker/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/docker/index.html" class="post-title-link" itemprop="url">docker</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-23 16:34:04" itemprop="dateCreated datePublished" datetime="2020-11-23T16:34:04+08:00">2020-11-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:27:52" itemprop="dateModified" datetime="2022-09-17T19:27:52+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="docker概述"><a class="markdownIt-Anchor" href="#docker概述"></a> Docker概述</h1>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-tutorial.html">参考教程</a></p>
<ul>
<li>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。</li>
<li>Docker的应用场景：
<ul>
<li>Web 应用的自动化打包和发布。</li>
<li>自动化测试和持续集成、发布。</li>
<li>在服务型环境中部署和调整数据库或其他的后台应用。</li>
<li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li>
</ul>
</li>
</ul>
<h2 id="docker架构"><a class="markdownIt-Anchor" href="#docker架构"></a> Docker架构</h2>
<ul>
<li>Docker 包括三个基本概念:
<ul>
<li>镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li>
<li>容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li>
<li>仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。</li>
</ul>
</li>
<li>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。</li>
<li>Docker 容器通过 Docker 镜像来创建。容器与镜像的关系类似于面向对象编程中的对象与类。</li>
</ul>
<h1 id="docker安装"><a class="markdownIt-Anchor" href="#docker安装"></a> Docker安装</h1>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/ubuntu-docker-install.html">参考资料</a></p>
<h1 id="docker的基础使用"><a class="markdownIt-Anchor" href="#docker的基础使用"></a> Docker的基础使用</h1>
<h2 id="运行helloworld"><a class="markdownIt-Anchor" href="#运行helloworld"></a> 运行helloworld</h2>
<ul>
<li>命令：<code>docker run ubuntu:15.10 /bin/echo &quot;Hello world&quot;</code>
<ul>
<li>docker: Docker 的二进制执行文件。</li>
<li>run: 与前面的 docker 组合来运行一个容器。</li>
<li>ubuntu:15.10 指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。</li>
<li>/bin/echo “Hello world”: 在启动的容器里执行的命令。</li>
</ul>
</li>
<li>以上命令完整的意思可以解释为：Docker 以 ubuntu15.10 镜像创建一个新容器，然后在容器里执行 bin/echo “Hello world”，然后输出结果。</li>
</ul>
<h2 id="运行交互式容器"><a class="markdownIt-Anchor" href="#运行交互式容器"></a> 运行交互式容器</h2>
<ul>
<li>我们通过 docker 的两个参数 -i -t，让 docker 运行的容器实现&quot;对话&quot;的能力；
<ul>
<li>-t: 在新容器内指定一个伪终端或终端。</li>
<li>-i: 允许你对容器内的标准输入 (STDIN) 进行交互。</li>
</ul>
</li>
<li>命令示例：<code>docker run -i -t ubuntu:15.10</code>，-i，-t两个参数必须同时使用，如果只使用-t则会只有一个终端界面，但是输入命令不会有反应。</li>
<li>我们可以通过运行 exit 命令或者使用 CTRL+D 来退出容器。</li>
</ul>
<h2 id="启动容器后台模式"><a class="markdownIt-Anchor" href="#启动容器后台模式"></a> 启动容器（后台模式）</h2>
<ul>
<li>命令:<code>docker run -d ubuntu:15.10 /bin/echo &quot;helloworld&quot;</code>
<ul>
<li>在输出中，我们没有看到期望的 “hello world”，而是一串长字符串2b1b7a428627c51ab8810d541d759f072b4fc75487eed05812646b8534a2fe63。这个长字符串叫做容器 ID，对每个容器来说都是唯一的，我们可以通过容器 ID 来查看对应的容器发生了什么。</li>
</ul>
</li>
<li>确认容器有在运行，可以通过 docker ps 来查看：
<ul>
<li>输出详情介绍：
<ul>
<li>CONTAINER ID: 容器 ID。</li>
<li>IMAGE: 使用的镜像。</li>
<li>COMMAND: 启动容器时运行的命令。</li>
<li>CREATED: 容器的创建时间。</li>
<li>STATUS: 容器状态。
<ul>
<li>状态有7种：
<ul>
<li>created（已创建）</li>
<li>restarting（重启中）</li>
<li>running 或 Up（运行中）</li>
<li>removing（迁移中）</li>
<li>paused（暂停）</li>
<li>exited（停止）</li>
<li>dead（死亡）</li>
</ul>
</li>
</ul>
</li>
<li>PORTS: 容器的端口信息和使用的连接类型（tcp\udp）。</li>
<li>NAMES: 自动分配的容器名称。</li>
</ul>
</li>
</ul>
</li>
<li>在宿主主机内使用 docker logs 命令，查看容器内的标准输出：
<ul>
<li>示例：<code>docker logs 2b1b7a428627</code>(这串数字是容器id的前面一部分)</li>
</ul>
</li>
<li>我们使用 docker stop 命令来停止容器：
<ul>
<li>示例：<code>docker stop 2b1b7a428627</code></li>
</ul>
</li>
</ul>
<h1 id="docker容器使用"><a class="markdownIt-Anchor" href="#docker容器使用"></a> Docker容器使用</h1>
<h2 id="docker客户端"><a class="markdownIt-Anchor" href="#docker客户端"></a> Docker客户端</h2>
<ul>
<li>docker 客户端非常简单 ,我们可以直接输入 <code>docker</code>命令来查看到 Docker 客户端的所有命令选项。</li>
<li>可以通过命令 <code>docker &lt;command&gt; --help</code>更深入的了解指定的 Docker 命令使用方法。例如我们要查看 docker stats 指令的具体使用方法：<code>docker stats --help</code></li>
</ul>
<h2 id="容器的使用"><a class="markdownIt-Anchor" href="#容器的使用"></a> 容器的使用</h2>
<h3 id="获取镜像"><a class="markdownIt-Anchor" href="#获取镜像"></a> 获取镜像</h3>
<ul>
<li>如果我们本地没有 ubuntu 镜像，我们可以使用 docker pull 命令来载入 ubuntu 镜像：<code>docker pull ubuntu</code></li>
</ul>
<h3 id="启动容器"><a class="markdownIt-Anchor" href="#启动容器"></a> 启动容器</h3>
<ul>
<li>以下命令使用 ubuntu 镜像启动一个容器，参数为以命令行模式进入该容器：<code>docker run -it ubuntu /bin/bash</code>;</li>
<li>参数说明：
<ul>
<li>-i: 交互式操作。</li>
<li>-t: 终端。</li>
<li>ubuntu: ubuntu 镜像。</li>
<li>/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。（省略/bin/bash也能达到同样的效果）</li>
</ul>
</li>
<li>要退出终端，直接输入 exit;</li>
<li>docker的许多命令都需要使用<code>sudo</code>权限；</li>
</ul>
<h3 id="启动已停止的容器"><a class="markdownIt-Anchor" href="#启动已停止的容器"></a> 启动已停止的容器</h3>
<ul>
<li>查看所有的容器命令：<code>docker ps -a</code>,不加参数名，则只有表头，没有具体容器的信息。</li>
<li>查看最后一次创建的容器<code>docker ps -l</code>。</li>
<li>使用 docker start 启动一个已停止的容器：<code>docker start b750bbbcfd88</code>,最后那串数字是容器id的开头一部分，终端会自动识别出整个容器ID。但是这样容器启动后并不会输出相应的数据，我们能看见的只是终端上<strong>打印出的容器id</strong>.</li>
</ul>
<h3 id="后台运行"><a class="markdownIt-Anchor" href="#后台运行"></a> 后台运行</h3>
<ul>
<li>在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过参数<code>-d</code> 指定容器的运行模式为后台运行。</li>
<li>加了<code>-d</code> 参数默认不会进入容器，想要进入容器需要使用指令 <code>docker exec</code></li>
<li>后台运行的指令成功后，终端只会打印容器的id。示例:<code>docker run -itd --name ubuntu-test ubuntu /bin/bash</code></li>
</ul>
<h3 id="停止容器"><a class="markdownIt-Anchor" href="#停止容器"></a> 停止容器</h3>
<ul>
<li>停止容器的命令如下：<code>docker stop &lt;容器 ID&gt;</code></li>
<li>停止的容器和正在运行的容器可以通过 docker restart 重启：<code>docker restart &lt;容器 ID&gt;</code></li>
</ul>
<h3 id="进入容器"><a class="markdownIt-Anchor" href="#进入容器"></a> 进入容器</h3>
<ul>
<li>在使用 -d 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：</li>
<li><code>docker attach</code>：
<ul>
<li>示例：<code>docker attach 1e560fca3906</code>,没有参数之类的东西，直接使用容器id进入即可。</li>
</ul>
</li>
<li><code>docker exec</code>：推荐大家使用 docker exec 命令，因为使用此命令在退出容器终端后，不会导致容器的停止。
<ul>
<li>示例：<code>docker exec -it 243c32535da7 /bin/bash</code>,就像普通打开一个容器一样，docker exec命令后要有完整的参数，容器id和运行的命令（此处的/bin/bash）不可省略，退出终端仍然使用exit。</li>
</ul>
</li>
</ul>
<h3 id="导出和导入容器"><a class="markdownIt-Anchor" href="#导出和导入容器"></a> 导出和导入容器</h3>
<ul>
<li>如果要导出本地某个容器，可以使用<code>docker export</code> 命令。
<ul>
<li>示例:<code>docker export 1e560fca3906 &gt; ./test/ubuntu.tar</code>,导出容器 1e560fca3906 快照到本地文件 ubuntu.tar。</li>
</ul>
</li>
<li>可以使用<code>docker import</code> 从容器快照文件中再导入为镜像，以下实例将快照文件 ubuntu.tar 导入到镜像 test/ubuntu:v1:<code>cat test/ubuntu.tar | sudo docker import - ubuntu1</code>.</li>
<li>此外，也可以通过指定 URL 或者某个目录来导入，例如：<code>docker import http://example.com/exampleimage.tgz example/imagerepo</code></li>
<li>导出和导入的实际上都是镜像，要使用的话，还需根据镜像创建容器。</li>
</ul>
<h3 id="删除容器"><a class="markdownIt-Anchor" href="#删除容器"></a> 删除容器</h3>
<ul>
<li>删除容器使用 docker rm 命令，删除的容器必须是终止的，否则会报错。
<ul>
<li>示例：<code>docker rm -f 1e560fca390</code>,这串数字是容器id。</li>
</ul>
</li>
<li>下面的命令可以清理掉所有处于终止状态的容器:<code>docker container prune</code></li>
</ul>
<h2 id="web应用使用"><a class="markdownIt-Anchor" href="#web应用使用"></a> web应用使用</h2>
<h3 id="运行一个web应用"><a class="markdownIt-Anchor" href="#运行一个web应用"></a> 运行一个web应用</h3>
<ul>
<li>我们尝试使用 docker 构建一个 web 应用程序。我们将在docker容器中运行一个 Python Flask 应用来运行一个web应用。</li>
<li>载入镜像：<code>docker pull training/webapp</code></li>
<li>后台运行：<code>docker run -d -P training/webapp python app.py</code>
<ul>
<li>参数说明:
<ul>
<li>-d:让容器在后台运行。</li>
<li>-P:将容器内部使用的网络端口随机映射到我们使用的主机上。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="查看web应用容器"><a class="markdownIt-Anchor" href="#查看web应用容器"></a> 查看web应用容器</h3>
<ul>
<li>使用<code>sudo docker ps -a</code>来查看web应用容器。
<ul>
<li>这里多了端口信息。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">PORTS
0.0.0.0:32769-&gt;5000&#x2F;tcp</code></pre>
<ul>
<li>Docker 开放了 5000 端口（默认 Python Flask 端口）映射到主机端口 32769 上。这时我们可以通过浏览器访问WEB应用. 在浏览器地址栏输入<code>localhost:32769</code>即可访问web应用。</li>
<li>我们也可以通过<code>-p</code> 参数来设置不一样的端口：<code>docker run -d -p 5000:5000 training/webapp python app.py</code>容器内部的 5000 端口映射到我们本地主机的 5000 端口上。</li>
<li>查看端口号的快捷方式：<code>docker port &lt;容器id&gt;/&lt;容器名&gt;</code>来直接查看容器的端口的映射情况。</li>
</ul>
<h3 id="查看web应用的日志信息"><a class="markdownIt-Anchor" href="#查看web应用的日志信息"></a> 查看web应用的日志信息</h3>
<ul>
<li><code>docker logs &lt;容器id&gt;/&lt;容器名&gt;</code> 可以查看容器内部的标准输出。示例：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">docker logs -f bf08b7f2cd89
 * Running on http:&#x2F;&#x2F;0.0.0.0:5000&#x2F; (Press CTRL+C to quit)
192.168.239.1 - - [09&#x2F;May&#x2F;2016 16:30:37] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 200 -
192.168.239.1 - - [09&#x2F;May&#x2F;2016 16:30:37] &quot;GET &#x2F;favicon.ico HTTP&#x2F;1.1&quot; 404 -</code></pre>
<ul>
<li>-f: 让 docker logs 像使用 tail -f 一样来输出容器内部的标准输出。</li>
</ul>
<h3 id="查看web应用容器的进程"><a class="markdownIt-Anchor" href="#查看web应用容器的进程"></a> 查看web应用容器的进程</h3>
<ul>
<li>我们还可以使用 <code>docker top &lt;容器id&gt;/&lt;容器名&gt;</code> 来查看容器内部运行的进程。</li>
</ul>
<h3 id="检查web应用程序"><a class="markdownIt-Anchor" href="#检查web应用程序"></a> 检查web应用程序</h3>
<ul>
<li>使用<code>docker inspect &lt;容器id&gt;/&lt;容器名&gt;</code> 来查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息.</li>
</ul>
<h1 id="docker镜像使用"><a class="markdownIt-Anchor" href="#docker镜像使用"></a> Docker镜像使用</h1>
<ul>
<li>当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。</li>
</ul>
<h2 id="列出镜像列表"><a class="markdownIt-Anchor" href="#列出镜像列表"></a> 列出镜像列表</h2>
<ul>
<li>我们可以使用 <code>docker images</code> 来列出本地主机上的镜像。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">runoob@runoob:~$ docker images           
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ubuntu              14.04               90d5884b1ee0        5 days ago          188 MB
php                 5.6                 f40e9e0f10c8        9 days ago          444.8 MB
nginx               latest              6f8d099c3adc        12 days ago         182.7 MB
mysql               5.6                 f2e8d6c772c0        3 weeks ago         324.6 MB
httpd               latest              02ef73cf1bc0        3 weeks ago         194.4 MB
ubuntu              15.10               4e3b13c8a266        4 weeks ago         136.3 MB
hello-world         latest              690ed74de00f        6 months ago        960 B
training&#x2F;webapp     latest              6fae60ef3446        11 months ago       348.8 MB</code></pre>
<ul>
<li>各个选项说明:
<ul>
<li>REPOSITORY：表示镜像的仓库源</li>
<li>TAG：镜像的标签
<ul>
<li>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</li>
<li>如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。</li>
</ul>
</li>
<li>IMAGE ID：镜像ID</li>
<li>CREATED：镜像创建时间</li>
<li>SIZE：镜像大小</li>
</ul>
</li>
</ul>
<h2 id="获取新镜像"><a class="markdownIt-Anchor" href="#获取新镜像"></a> 获取新镜像</h2>
<ul>
<li>当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 <code>docker pull &lt;镜像名&gt;:&lt;标签&gt;</code>命令来下载它。</li>
</ul>
<h2 id="查找镜像"><a class="markdownIt-Anchor" href="#查找镜像"></a> 查找镜像</h2>
<ul>
<li>我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></li>
<li>我们也可以使用<code>docker search &lt;镜像名&gt;</code> 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 <code>docker search httpd</code> 来寻找适合我们的镜像。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201125085937.jpg" alt="" /></li>
<li>选项说明：
<ul>
<li>NAME: 镜像仓库源的名称</li>
<li>DESCRIPTION: 镜像的描述</li>
<li>OFFICIAL: 是否 docker 官方发布</li>
<li>stars: 类似 Github 里面的 star，表示点赞、喜欢的意思。</li>
<li>AUTOMATED: 自动构建。</li>
</ul>
</li>
</ul>
<h2 id="删除镜像"><a class="markdownIt-Anchor" href="#删除镜像"></a> 删除镜像</h2>
<ul>
<li>镜像删除使用<code>docker rmi &lt;镜像名&gt;:&lt;标签&gt;</code> 命令，比如我们删除 hello-world 镜像：<code>docker rmi hello-world</code>,省略标签，则默认只会删除标签为latest的镜像。</li>
</ul>
<h2 id="创建镜像"><a class="markdownIt-Anchor" href="#创建镜像"></a> 创建镜像</h2>
<ul>
<li>当我们从 docker 镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改。
<ol>
<li>从<strong>已经创建的容器中更新镜像</strong>，并且提交这个镜像;</li>
<li>使用 <strong>Dockerfile 指令</strong>来创建一个新的镜像;</li>
</ol>
</li>
</ul>
<h3 id="更新镜像"><a class="markdownIt-Anchor" href="#更新镜像"></a> 更新镜像</h3>
<ul>
<li>更新镜像之前，我们需要使用镜像来<strong>创建一个容器</strong>。</li>
<li>示例：
<ul>
<li><code>docker run -t -i ubuntu:15.10 /bin/bash</code></li>
<li>在运行的容器内使用 apt-get update 命令进行更新。</li>
<li>在完成操作之后，输入 exit 命令来退出这个容器。</li>
<li>此时 ID 为 e218edb10161 的容器，是按我们的需求更改的容器。我们可以通过命令<code>docker commit</code>来提交容器副本。</li>
<li><code>docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2</code></li>
</ul>
</li>
<li><code>docker commit</code>的各个参数说明：
<ul>
<li>-m: 提交的描述信息</li>
<li>-a: 指定镜像作者</li>
<li>e218edb10161：容器 ID</li>
<li>runoob/ubuntu:v2: 指定要创建的目标镜像名</li>
</ul>
</li>
</ul>
<h3 id="构建镜像"><a class="markdownIt-Anchor" href="#构建镜像"></a> 构建镜像</h3>
<ul>
<li>我们使用命令<code>docker build</code> ， 从零开始来创建一个新的镜像。为此，我们需要创建一个<code>Dockerfile</code>文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">runoob@runoob:~$ cat Dockerfile 
FROM    centos:6.7
MAINTAINER      Fisher &quot;fisher@sudops.com&quot;

RUN     &#x2F;bin&#x2F;echo &#39;root:123456&#39; |chpasswd
RUN     useradd runoob
RUN     &#x2F;bin&#x2F;echo &#39;runoob:123456&#39; |chpasswd
RUN     &#x2F;bin&#x2F;echo -e &quot;LANG&#x3D;\&quot;en_US.UTF-8\&quot;&quot; &gt;&#x2F;etc&#x2F;default&#x2F;local
EXPOSE  22
EXPOSE  80
CMD     &#x2F;usr&#x2F;sbin&#x2F;sshd -D</code></pre>
<ul>
<li>每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。</li>
<li>第一条FROM，指定使用哪个<strong>镜像源</strong></li>
<li>RUN 指令告诉docker 在镜像内执行命令，安装了什么。。。</li>
<li>然后，我们使用Dockerfile 文件，通过 docker build 命令来构建一个镜像。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">runoob@runoob:~$ docker build -t runoob&#x2F;centos:6.7 .
Sending build context to Docker daemon 17.92 kB
Step 1 : FROM centos:6.7
 ---&gt; d95b5ca17cc3
Step 2 : MAINTAINER Fisher &quot;fisher@sudops.com&quot;
 ---&gt; Using cache
 ---&gt; 0c92299c6f03
Step 3 : RUN &#x2F;bin&#x2F;echo &#39;root:123456&#39; |chpasswd
 ---&gt; Using cache
 ---&gt; 0397ce2fbd0a
Step 4 : RUN useradd runoob
......</code></pre>
<ul>
<li>参数说明：
<ul>
<li>-t ：指定要创建的目标镜像名</li>
<li>. ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径</li>
</ul>
</li>
</ul>
<h2 id="设置镜像标签"><a class="markdownIt-Anchor" href="#设置镜像标签"></a> 设置镜像标签</h2>
<ul>
<li>我们可以使用<code>docker tag</code>命令，为镜像添加一个新的标签。</li>
<li>示例：<code>docker tag 860c279d2fec runoob/centos:dev</code></li>
<li><code>docker tag 镜像ID 用户名称/镜像源名(repository name):新的标签名(tag)</code></li>
</ul>
<h1 id="docker容器连接"><a class="markdownIt-Anchor" href="#docker容器连接"></a> Docker容器连接</h1>
<ul>
<li>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</li>
</ul>
<h2 id="网络端口映射"><a class="markdownIt-Anchor" href="#网络端口映射"></a> 网络端口映射</h2>
<ul>
<li>创建了一个 python 应用的容器：<code>docker run -d -P training/webapp python app.py</code></li>
<li>我们使用 <code>-P</code> 参数创建一个容器，使用 docker ps 可以看到容器端口 5000 绑定主机端口 32768。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">runoob@runoob:~$ docker ps
CONTAINER ID    IMAGE               COMMAND            ...           PORTS                     NAMES
fce072cc88ce    training&#x2F;webapp     &quot;python app.py&quot;    ...     0.0.0.0:32768-&gt;5000&#x2F;tcp   grave_hopper</code></pre>
<ul>
<li>我们也可以使用 <code>-p</code> 标识来指定容器端口绑定到主机端口。</li>
<li>两种方式的区别是:
<ul>
<li><code>-P</code> :是容器内部端口<strong>随机</strong>映射到主机的高端口。</li>
<li><code>-p</code> : 是容器内部端口<strong>绑定</strong>到指定的主机端口,需要自己指定映射关系(如果不指定，则会报错）。</li>
<li><code>docker run -d -p 5000:5000 training/webapp python app.py</code></li>
</ul>
</li>
<li>另外，我们可以指定容器绑定的<strong>网络地址</strong>，比如绑定 127.0.0.1：<code>docker run -d -p 127.0.0.1:5001:5000 training/webapp python app.py</code>.</li>
<li>上面的例子中，默认都是绑定 tcp 端口，如果要绑定 UDP 端口，可以在端口后面加上 <code>/udp</code>。<code>docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</code>。</li>
</ul>
<h2 id="docker容器互联"><a class="markdownIt-Anchor" href="#docker容器互联"></a> Docker容器互联</h2>
<ul>
<li>端口映射并不是唯一把docker 连接到另一个容器的方法。docker 有一个连接系统允许将多个容器连接在一起，共享连接信息。docker 连接会创建一个父子关系，其中父容器可以看到子容器的信息。</li>
</ul>
<h3 id="容器命名"><a class="markdownIt-Anchor" href="#容器命名"></a> 容器命名</h3>
<ul>
<li>当我们创建一个容器的时候，docker 会<strong>自动对它进行命名</strong>。另外，我们也可以使用 <code>--name</code>标识来命名容器，例如：<code>docker run -d -P --name runoob training/webapp python app.py</code></li>
</ul>
<h3 id="新建网络"><a class="markdownIt-Anchor" href="#新建网络"></a> 新建网络</h3>
<ul>
<li>创建一个新的 Docker 网络:<code>docker network create -d bridge test-net</code></li>
<li>参数说明：
<ul>
<li>-d：参数指定 Docker 网络类型，有 bridge、overlay。</li>
<li><code>docker nerwork create</code>是固定的指令</li>
<li><code>test-net</code>是网络的名称。</li>
</ul>
</li>
<li>通过<code>docker network ls</code>来查看已经存在的网络。</li>
</ul>
<h3 id="连接容器"><a class="markdownIt-Anchor" href="#连接容器"></a> 连接容器</h3>
<ul>
<li>运行一个容器并连接到新建的 test-net 网络:<code>docker run -itd --name test1 --network test-net ubuntu /bin/bash</code>
<ul>
<li><code>--network</code>参数指定要连接的网络名。</li>
</ul>
</li>
<li>打开新的终端，再运行一个容器并加入到 test-net 网络:<code>docker run -itd --name test2 --network test-net ubuntu /bin/bash</code></li>
<li>下面通过 <code>ping</code> 来证明 test1 容器和 test2 容器建立了互联关系。
<ul>
<li>如果 test1、test2 容器内中无 ping 命令，则在容器内执行以下命令安装 ping（即学即用：可以在一个容器里安装好，提交容器到镜像，在以新的镜像重新运行以上两个个容器）。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">apt-get update
apt install iputils-ping</code></pre>
<ul>
<li>
<p>在test1容器内输入<code>ping test2</code>（test2中同理），即可连接。</p>
</li>
<li>
<p>如果有多个容器之间需要互相连接，推荐使用 Docker Compose。</p>
</li>
</ul>
<h3 id="配置dns"><a class="markdownIt-Anchor" href="#配置dns"></a> 配置DNS</h3>
<ul>
<li>我们可以在宿主机的 /etc/docker/daemon.json 文件中增加以下内容来设置全部容器的 DNS：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#123;
  &quot;dns&quot; : [
    &quot;114.114.114.114&quot;,
    &quot;8.8.8.8&quot;
  ]
&#125;</code></pre>
<ul>
<li>设置后，启动容器的 DNS 会自动配置为 114.114.114.114 和 8.8.8.8。配置完，需要重启 docker 才能生效。</li>
<li>查看容器的 DNS 是否生效可以使用以下命令，它会输出容器的 DNS 信息：<code>docker run -it --rm ubuntu cat etc/resolv.conf</code></li>
<li>如果只想在<strong>指定的容器设置 DNS</strong>，则可以使用以下命令：<code>docker run -it --rm -h host_ubuntu --dns=114.114.114.114 --dns-search=test.com ubuntu</code></li>
<li>参数说明：
<ul>
<li>–rm：容器退出时自动清理容器内部的文件系统。</li>
<li>-h HOSTNAME 或者 --hostname=HOSTNAME： 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts。</li>
<li>–dns=IP_ADDRESS： 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。</li>
<li>–dns-search=DOMAIN： 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索` host，还会搜索 <a target="_blank" rel="noopener" href="http://host.example.com">host.example.com</a>。</li>
</ul>
</li>
<li>如果在容器启动时没有指定 --dns 和 --dns-search，Docker 会默认用宿主主机上的 /etc/resolv.conf 来配置容器的 DNS。</li>
</ul>
<h1 id="docker仓库管理"><a class="markdownIt-Anchor" href="#docker仓库管理"></a> Docker仓库管理</h1>
<ul>
<li>仓库（Repository）是集中存放镜像的地方。以下介绍一下 Docker Hub。当然不止 docker hub，只是远程的服务商不一样，操作都是一样的。</li>
</ul>
<h2 id="dockerhub"><a class="markdownIt-Anchor" href="#dockerhub"></a> DockerHub</h2>
<ul>
<li>目前 Docker 官方维护了一个公共仓库 Docker Hub。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</li>
</ul>
<h3 id="注册"><a class="markdownIt-Anchor" href="#注册"></a> 注册</h3>
<ul>
<li>在 <a target="_blank" rel="noopener" href="https://hub.docker.com">DockerHub</a> 免费注册一个 Docker 账号。</li>
</ul>
<h3 id="登录和退出"><a class="markdownIt-Anchor" href="#登录和退出"></a> 登录和退出</h3>
<ul>
<li>登录需要输入用户名和密码，登录成功后，我们就可以从 docker hub 上拉取自己账号下的全部镜像。<code>docker login</code>;</li>
<li>退出 docker hub 可以使用以下命令：<code>docker logout</code></li>
</ul>
<h3 id="查找和拉取镜像"><a class="markdownIt-Anchor" href="#查找和拉取镜像"></a> 查找和拉取镜像</h3>
<ul>
<li>你可以通过 docker search 命令来查找官方仓库中的镜像，并利用 docker pull 命令来将它下载到本地。</li>
<li>查找：<code>docker search &lt;镜像名&gt;</code>,必须带有镜像名；</li>
<li>拉取：<code>docker pull &lt;镜像名&gt;</code>.</li>
</ul>
<h3 id="推送镜像"><a class="markdownIt-Anchor" href="#推送镜像"></a> 推送镜像</h3>
<ul>
<li>在登录进了dockerhub的前提下：</li>
<li>首先需要将本地的镜像名改为<code>(dockerhub的用户名)/镜像名</code>的格式。示例：<code>docker tag ubuntu:18.04 zestaken/ubuntu:18.04</code>(其中zestaken是我的dockerhub用户名)。</li>
<li>之后再使用<code>docker push &lt;镜像名&gt;</code>将镜像推送到dockerhub。</li>
<li>被自己推送到自己仓库的镜像可以直接使用<code>docker pull &lt;镜像名&gt;</code>拉取下来，但是search不能够搜到(因为开启这个功能需要花钱升级dockerhub账号到pro版）。</li>
</ul>
<h1 id="dockerfile"><a class="markdownIt-Anchor" href="#dockerfile"></a> Dockerfile</h1>
<h1 id="dockermachine"><a class="markdownIt-Anchor" href="#dockermachine"></a> Dockermachine</h1>
<h1 id="docker安装的ubuntu问题"><a class="markdownIt-Anchor" href="#docker安装的ubuntu问题"></a> docker安装的Ubuntu问题</h1>
<ul>
<li>通过镜像安装的ubuntu容器为纯净的环境，其好多命令执行不了，即缺少很多可执行脚本，安装即可~~~</li>
</ul>
<p>执行一切安装之前请先执行 apt-get update</p>
<ol>
<li>lsb_release</li>
</ol>
<p>apt-get install lsb-release</p>
<ol start="2">
<li>ifconfig</li>
</ol>
<p>apt install net-tools</p>
<ol start="3">
<li>ping</li>
</ol>
<p>apt install iputils-ping</p>
<ol start="4">
<li>sudo</li>
</ol>
<p>apt-get install sudo</p>
<ol start="5">
<li>vim</li>
</ol>
<p>apt-get install vim</p>
<ol start="6">
<li>add-apt-repository</li>
</ol>
<p>sudo apt-get install software-properties-common</p>
<p>同理可安装git ,Python等</p>
<p>（</p>
<p>apt-get install git python-virtualenv libssl-dev libffi-dev build-essential libpython-dev python2.7-minimal authbind<br />
）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Linux/linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Linux/linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/index.html" class="post-title-link" itemprop="url">linux虚拟文件系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-20 11:15:11" itemprop="dateCreated datePublished" datetime="2020-11-20T11:15:11+08:00">2020-11-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:27:52" itemprop="dateModified" datetime="2022-09-17T19:27:52+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="vfs虚拟文件系统基本概念"><a class="markdownIt-Anchor" href="#vfs虚拟文件系统基本概念"></a> VFS虚拟文件系统基本概念</h1>
<ul>
<li>VFS: Virtual File System ( Virtual Filesystem Switch)概念：
<ul>
<li><strong>逻辑文件系统(实际文件系统)</strong>  如EXT2、MINIX、MSDOS等.</li>
<li>VFS为逻辑文件系统提供<strong>统一的接口</strong>，<strong>屏蔽</strong>实际文件系统的实现细节.</li>
<li>VFS的所有数据结构在<strong>系统运行以后建立，并在卸载时删除</strong>。</li>
<li>VFS必须<strong>与实际的文件系统相接合</strong>,才能实现文件管理功能。</li>
</ul>
</li>
<li>VFS的功能：
<ul>
<li>对逻辑文件系统的<strong>数据结构进行抽象</strong>；</li>
<li>接受用户<strong>系统调用</strong> 如open, write等；</li>
<li>支持<strong>多种逻辑文件系统</strong>之间相互访问；</li>
<li>接受<strong>内核其他子系统</strong>的操作请求，特别是内存管理子系统。</li>
</ul>
</li>
<li>linux文件系统逻辑关系：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201120114340.jpg" alt="" /></li>
</ul>
<h1 id="unix文件系统"><a class="markdownIt-Anchor" href="#unix文件系统"></a> Unix文件系统</h1>
<ul>
<li>Unix文件系统采用<strong>统一命名空间</strong>，所有安装的文件系统都作为<strong>根文件系统树的枝叶</strong>出现在系统中。</li>
<li>文件通过<strong>目录</strong>组织起来，VFS将目录视为文件，可以对其进行文件的操作。
<ul>
<li>目录是一种特殊的文件。它用于创建、保持对文件系统中文件的访问路径。</li>
</ul>
</li>
<li><strong>索引节点（inode）</strong>：
<ul>
<li>文件的相关信息，被称为文件的<strong>元数据</strong>，被存储在一个单独的数据结构中，该结构被称为<strong>索引结点</strong>。</li>
<li>Inode中存放描述文件的详细信息，如文件在外存的地址等。</li>
<li>在访问装配的文件系统时，这些文件系统的inode 节点被不断的读出/写入。</li>
<li>VFS文件系统维护一个inode节点的缓存,以加速对所有装配的文件系统的访问。</li>
</ul>
</li>
<li><strong>超级块</strong>；
<ul>
<li>文件系统的<strong>控制信息</strong>存储在超级块中，超级块是一种包含文件系统信息的数据结构。</li>
</ul>
</li>
</ul>
<h1 id="vfs对象及其数据结构"><a class="markdownIt-Anchor" href="#vfs对象及其数据结构"></a> VFS对象及其数据结构</h1>
<ul>
<li>VFS使用<strong>面向对象</strong> 的设计思路，使用一组<strong>数据结构</strong>来表示通用文件对象。</li>
<li>每个主要类型中都包含一个操作对象，这个操作对象描述针对给主要对象的方法。</li>
<li>VFS中四个主要的对象类型：
<ol>
<li>超级块对象：代表一个具体的已安装的文件系统。
<ol>
<li>操作对象：super_operations对象，其中描述了<strong>内核</strong>针对特定<strong>文件系统</strong>所能调用的方法。</li>
<li>各种文件系统都<strong>必须实现超级块对象</strong>，超级块对象由<strong>super_block</strong>结构体表示，存储在&lt;linux/fs.h&gt;中。</li>
</ol>
</li>
<li>索引节点对象：代表一个具体文件。
<ol>
<li>操作对象：inode_operations对象，其中描述了<strong>内核</strong>针对特定<strong>文件</strong>所能调用的方法。</li>
<li>索引节点对象不一定在文件系统中实现，索引节点在文件被访问时才<strong>在内存中创建</strong>。</li>
<li>一个索引节点对象代表内存中的一个文件，也可以是设备或者管道这样的特殊文件。</li>
<li>索引节点由<strong>inode结构体</strong>表示，它定义在文件&lt;linux/fs.h&gt;中。</li>
</ol>
</li>
<li>目录项对象：代表一个目录项，是路径的一个组成部分。（目录项不是目录，目录是另一种形式的文件）。
<ol>
<li>操作对象：dentry_operations对象，描述<strong>内核</strong>针对特定<strong>目录</strong>所能调用的方法。</li>
<li>在路径中，**每一个部分（包括普通文件）**都是一个目录项对象。如：<code>/bin/vi</code>中，<code>/</code>,<code>bin</code>,<code>vi</code>都属于目录项对象。</li>
<li>与超级块和索引节点对象不同，目录项对象<strong>没有对应的磁盘数据结构</strong>，VFS在执行目录操作时在现场根据字符串形式的路径名创建目录项对象。</li>
<li>目录项对象由<strong>dentry结构体</strong>表示，它定义在文件&lt;linux/dentry.h&gt;中。</li>
</ol>
</li>
<li>文件对象：代表由进程已打开的文件。
<ol>
<li>操作对象：file_operations对象，描述<strong>进程</strong>针对已打开文件所能调用的方法。</li>
<li>进程<strong>直接处理的是文件</strong>，而不是超级块，目录项或者索引节点。</li>
<li>多个进程可以同时操作同一个文件，一个文件可以同时有多个文件对象。</li>
<li>类似于目录项对象，文件对象<strong>没有实际的磁盘数据结构</strong>。</li>
<li>文件对象由<strong>file结构体</strong>表示，定义在文件&lt;linux/fs.h&gt;中。</li>
</ol>
</li>
</ol>
</li>
</ul>
<h1 id="和文件系统相关的数据结构"><a class="markdownIt-Anchor" href="#和文件系统相关的数据结构"></a> 和文件系统相关的数据结构</h1>
<ul>
<li>除了以上4种VFS基础对象之外，内核还使用一些标准数据结构来管理文件系统的其它相关数据。</li>
<li><strong>file_system_type</strong>:用来描述各种特定文件系统类型，如ext3,ext4或UDF；
<ul>
<li>因为linux支持各种不同的文件系统，所以需要一个数据结构来描述各种文件系统的功能和行为。</li>
<li>file_system_type结构体被定义在文件&lt;linux/fs.h&gt;中。</li>
<li>每个文件系统对应一个file_system_type结构。</li>
</ul>
</li>
<li><strong>vfsmount</strong>:用来描述一个安装文件系统的实例；</li>
</ul>
<h1 id="和进程有关的数据结构"><a class="markdownIt-Anchor" href="#和进程有关的数据结构"></a> 和进程有关的数据结构</h1>
<ul>
<li>每一个进程都有自己的一组打开的文件。通过三个数据结构将VFS层和进程精密连接在了一起。这三个数据结构是<strong>file_struct</strong>,<strong>fs_struct</strong>,<strong>namespace</strong>.</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4MySql%E8%A7%84%E8%8C%83/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4MySql%E8%A7%84%E8%8C%83/index.html" class="post-title-link" itemprop="url">阿里巴巴MySql规范</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-19 17:19:34" itemprop="dateCreated datePublished" datetime="2020-11-19T17:19:34+08:00">2020-11-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:27:52" itemprop="dateModified" datetime="2022-09-17T19:27:52+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web后端</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>803</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>表达是与否概念的字段，必须使用 is_xxx的方式命名，数据类型是 unsigned tinyint（ 1表示是，0表示否）;</li>
<li>任何字段如果为<strong>非负数，必须是 unsigned</strong>。</li>
<li>表名、字段名必须使用<strong>小写字母或数字</strong>,单词之间用下划线分隔；禁止出现数字开头，禁止两个下划线中间只出现数字;</li>
<li>表名不使用复数名词;</li>
<li>禁用保留字，如 desc、range、match、delayed等，请参考 MySQL官方保留字;</li>
<li><strong>小数类型</strong>为 decimal，禁止使用 float和 double。
<ul>
<li>说明：float和 double在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal的范围，建议将数据拆成整数和小数分开存储。</li>
</ul>
</li>
<li>表必备三字段：id, gmt_create, gmt_modified。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201123111656.png" alt="" />```</li>
<li>说明：其中 id必为主键，类型为 unsigned bigint、单表时自增、步长为 1。gmt_create,gmt_modified的类型均为 date_time类型。</li>
<li>gmt_create和gmt——modifed的设置示例：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 创建学院表
create table t_college (
    &#96;id&#96;  bigint unsigned primary key auto_increment comment &#39;学院id&#39;, 
	  &#96;name&#96; varchar (60) not null comment &#39;学院名称&#39;, 
    &#96;gmt_create&#96; datetime null default current_timestamp comment &#39;记录创建时间&#39;, 
    &#96;gmt_modified&#96; datetime null default current_timestamp on update current_timestamp comment &#39;记录最近修改时间&#39; 
    ); </code></pre>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/IntelliJ-IDEA/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/IntelliJ-IDEA/index.html" class="post-title-link" itemprop="url">IntelliJ IDEA</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-24 08:41:54" itemprop="dateCreated datePublished" datetime="2020-10-24T08:41:54+08:00">2020-10-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-09-26 21:36:05" itemprop="dateModified" datetime="2021-09-26T21:36:05+08:00">2021-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">杂技术</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>853</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="项目结构"><a class="markdownIt-Anchor" href="#项目结构"></a> 项目结构</h1>
<ul>
<li>项目（project）-&gt;模块（module）-&gt; 包（package） -&gt;代码（.java）（module和project均需要在头部选项<code>File</code>中创建）</li>
<li>src文件夹存放源代码。</li>
<li>.idea文件夹和.iml文件是IDEA对项目的配置文件。与项目内容无关。</li>
<li>对包的命名遵循域名颠倒过来(全是小写字母）。如<code>com.zhangjie</code>，这个命名会生成两个文件夹，一个是com文件夹，com文件夹下包含zhangjie文件夹。<code>.</code>起到分开不同包文件夹的作用。</li>
<li>IDEA是实时保存的，写到哪保存到哪。</li>
<li>IDEA编译java文件生成的.class文件是默认保存在out文件夹的，但是这个文件夹默认是隐藏的。</li>
<li>External Libraries下面是jar包。</li>
</ul>
<h1 id="idea配置"><a class="markdownIt-Anchor" href="#idea配置"></a> IDEA配置</h1>
<ul>
<li>字体：File-&gt;settings-&gt;Editor-&gt;Font</li>
<li>自动补全：File-&gt;settings-&gt;keymap(齿轮下选择Duplicate不改变原来的快捷键，即复制一遍)</li>
</ul>
<h1 id="快捷操作"><a class="markdownIt-Anchor" href="#快捷操作"></a> 快捷操作</h1>
<ul>
<li>使用缩写再加上enter可以生成一些常用代码段。如<code>psvm</code>可以快捷生成<code>public static void main(String[] args)&#123;&#125;</code>.</li>
<li><code>ALT + Enter</code>可以自动修复代码。</li>
<li><code>crtl + y</code>删除当前行，<code>ctrl + d</code>复制当前行。</li>
<li><code>ctrl + alt + l</code>格式化当前代码的排版。</li>
<li><code>ctrl + /</code>可以对光标所在行（也可以人为选中）前面加上//注释符。<code>ctrl + shift + /</code>生成/**/多行注释符。</li>
<li><code>alt + insert</code>可以自动添加方法。</li>
<li><code>alt + shift + 上下箭头</code>可以移动光标所在行。</li>
<li><code>ctrl + shit + F10</code>可以运行代码，<code>ctrl + shift + F9</code>调试代码。</li>
<li><code>shift + F6</code>可以对选中的文件进行重命名,所有用到该文件（如变量）的地方都会同时进行重命名。</li>
<li><code>ctrl + o</code>添加override的方法。</li>
<li><code>ctrl</code>按住ctrl再点击调用的方法名，可以直接去看该方法定义的源代码。</li>
</ul>
<h1 id="idea报错"><a class="markdownIt-Anchor" href="#idea报错"></a> idea报错</h1>
<ul>
<li>同一个包内的类不能使用：参见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wanghongsen/p/12574807.html">blog</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Mysql/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Mysql/index.html" class="post-title-link" itemprop="url">Mysql</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-23 12:09:42" itemprop="dateCreated datePublished" datetime="2020-10-23T12:09:42+08:00">2020-10-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:27:52" itemprop="dateModified" datetime="2022-09-17T19:27:52+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web后端</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>17k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="数据库简介"><a class="markdownIt-Anchor" href="#数据库简介"></a> 数据库简介</h1>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/">mysql8.0官方文档</a></p>
<ul>
<li>特点：
<ol>
<li>持久化保存数据；</li>
<li>可以实现结构化查询，方便管理。</li>
</ol>
</li>
<li>DB:数据库（database），存储数据的仓库，保存了有组织的数据。</li>
<li>DBMS:数据库管理系统。数据库是通过DBMS来创建和管理的容器。常见数据库管理系统：MYSQL，Oracle，DB2,SqlServer。</li>
<li>SQL：结构化查询语言（StructureQuery Language），专门用来与数据库通信。几乎所有DBMS都支持SQL。</li>
<li>数据存储数据：
<ol>
<li>将数据存入表中，表再放入库中。一个数据库中可以有多个表，每个表有一个名字，表名具有唯一性。</li>
<li>表具有一些特性，这些特性定义了数据在表中如何存储，类似java中的“类”。</li>
<li>表由列组成，这些列也称为<strong>字段</strong>，每一列类似java中的属性。</li>
<li>表中的数据是按行存储的，每一行类似java中的对象。</li>
</ol>
</li>
</ul>
<h1 id="mysql的安装"><a class="markdownIt-Anchor" href="#mysql的安装"></a> MySQL的安装</h1>
<ul>
<li>MySQL的特点：
<ol>
<li>开放源代码；</li>
<li>性能高</li>
<li>容易安装和使用。</li>
</ol>
</li>
<li>DBMS的分类：
<ol>
<li>基于共享文件系统的（如：Access）</li>
<li>基于客户机-服务器的DBMS（如；MySQL，oracle，sqlsever）。</li>
</ol>
</li>
<li>MySQL下载安装：
<ol>
<li>社区版（免费）</li>
<li>企业版（收费）</li>
<li>下载地址：<a target="_blank" rel="noopener" href="https://devmysql.com/downloads/installer/">https://devmysql.com/downloads/installer/</a></li>
<li>跟随安装指导进行配置。</li>
</ol>
</li>
</ul>
<h1 id="mysql在ubuntu上的安装"><a class="markdownIt-Anchor" href="#mysql在ubuntu上的安装"></a> MySQL在ubuntu上的安装</h1>
<ol>
<li>安装：<code>sudo apt-get install mysql-server</code></li>
<li>配置：<code>sudo mysql_secure_installation</code></li>
</ol>
<h1 id="mysql服务的启动"><a class="markdownIt-Anchor" href="#mysql服务的启动"></a> MySQL服务的启动</h1>
<ul>
<li>在Windows上：
<ol>
<li>搜索服务，点击打开；</li>
<li>在cmd输入<code>services.msc</code>启动；</li>
<li>在管理员cmd输入<code>net start &lt;本机mysql的名字&gt;</code>或者<code>net stop &lt;本机mysql的名字&gt;</code>启动或者关闭。(本机mysql服务的名字叫MYSQL)</li>
</ol>
</li>
<li>在linux上：
<ol>
<li>启动：<code>sudo service mysql start</code></li>
<li>关闭：<code>sudo service mysql stop</code></li>
<li>重启：<code>sudo service mysql restart</code></li>
</ol>
</li>
</ul>
<h1 id="mysql的登录"><a class="markdownIt-Anchor" href="#mysql的登录"></a> MySQL的登录</h1>
<ul>
<li>登录本地用户：<code>mysql -uroot -proot</code>，-u后面接的是用户名，-p后面接的是root用户的密码。<code>mysql -uroot -p</code>,会在之后输入密码。(在linux上登录root用户需要使用sudo)</li>
<li>登录远程用户：<code>mysql -h127.0.0.1 -p</code> -h后面接的是连接目标的ip。</li>
<li>登录：<code>mysql --host=IP --user=用户名 --passward=连接目标的密码</code></li>
<li>Mysql设置远程连接权限，<a target="_blank" rel="noopener" href="https://blog.csdn.net/mxskymx/article/details/88765072">参考文档</a></li>
</ul>
<h1 id="退出mysql"><a class="markdownIt-Anchor" href="#退出mysql"></a> 退出MySQL</h1>
<ul>
<li>输入<code>exit</code></li>
</ul>
<h1 id="mysql的目录结构"><a class="markdownIt-Anchor" href="#mysql的目录结构"></a> MySQL的目录结构</h1>
<p>1.MySQL的安装目录：</p>
<ol>
<li>bin：二进制可执行文件，包括很多命令的执行程序。</li>
<li>data：存放mysql的日志文件，数据文件等。</li>
<li>include：放置.h头文件；</li>
<li>lib：所需的jar包；</li>
<li>share：错误信息存放<br />
2.MySQL的数据目录：（在c盘下的programdata下）</li>
<li>数据库及其中的数据；</li>
<li>my.ini是MySQL的配置文件。</li>
</ol>
<h1 id="sqlyog图形化界面"><a class="markdownIt-Anchor" href="#sqlyog图形化界面"></a> SQLyog图形化界面</h1>
<ul>
<li>可以使用sql语句控制，也可以直接使用鼠标控制。</li>
</ul>
<h1 id="sql语句"><a class="markdownIt-Anchor" href="#sql语句"></a> SQL语句</h1>
<h2 id="sql的简介"><a class="markdownIt-Anchor" href="#sql的简介"></a> SQL的简介</h2>
<ul>
<li>SQL：结构化查询语言（StructureQuery Language），专门用来与数据库通信。几乎所有DBMS都支持SQL。可以用来操作所有的关系型数据库。</li>
</ul>
<h2 id="sql的通用语法"><a class="markdownIt-Anchor" href="#sql的通用语法"></a> SQL的通用语法</h2>
<ul>
<li>SQL可以单行或者多行书写，以分号结尾。</li>
<li>使用空格和缩进来规范格式。</li>
<li>Mysql的SQL语句不区分大小写。，关键字建议使用大写。</li>
<li>注释：
<ol>
<li>单行注释：<code>--</code>或者<code>#</code>之后写注释内容。（–注释符后面有空格。#可以没有空格，是MySQL特有的。）</li>
</ol>
</li>
</ul>
<h2 id="sql的分类"><a class="markdownIt-Anchor" href="#sql的分类"></a> SQL的分类</h2>
<ul>
<li>DDL（data definition language）：操作数据库和表；</li>
<li>DML（Data Manipulation Language）；增删改表中的数据。</li>
<li>DQL（Data Query Language）:查询表中的数据。</li>
<li>DCL（Data control Language）:数据控制语言，控制访问权限和安全级别等。</li>
</ul>
<h2 id="ddl"><a class="markdownIt-Anchor" href="#ddl"></a> DDL</h2>
<h3 id="操作数据库crud"><a class="markdownIt-Anchor" href="#操作数据库crud"></a> 操作数据库（CRUD）</h3>
<ol>
<li>C（creat）:创建；
<ol>
<li>创建数据库：<code>creat database 数据库名称;</code></li>
<li>判断数据库不存在，再创建：<code>creat database if not exists 数据库名称;</code></li>
<li>创建数据库，并指定字符集：<code>creat database 数据库名称 character set 字符集名;</code></li>
</ol>
</li>
<li>R（Retrieve）：查询；
<ol>
<li>查询已经存在的数据库：<code>show databases;</code></li>
<li>查看某个数据库的字符集：<code>show creat database 数据库名称;</code>(同时也是查询数据库的创建语句)</li>
</ol>
</li>
<li>U（Update）：修改；
<ol>
<li>修改数据库的字符集：<code>alter database 数据库名称 character set 字符集名称;</code></li>
</ol>
</li>
<li>D(Delete):删除；
<ol>
<li>删除数据库：<code>drop database 数据库名称;</code>。</li>
<li>判断数据库存在，再删除：<code>drop database if exists 数据库名称;</code></li>
</ol>
</li>
<li>使用数据库。
<ol>
<li>查询当前正在使用的数据库名称:<code>select database();</code></li>
<li>使用数据库：<code>use 数据库名称;</code></li>
</ol>
</li>
</ol>
<h3 id="操作表crud"><a class="markdownIt-Anchor" href="#操作表crud"></a> 操作表（CRUD）</h3>
<ol>
<li>C（creat）:创建；
<ol>
<li>创建语法:<code>creat table 表名（列名1， 数据类型1， 列名2 数据类型2， ... 列名n 数据类型n）;</code><strong>创建表时，至少有一个列，否则创建会直接失败</strong></li>
<li>复制：<code>creat table 表名（即将创建） like 表名（被复制的）</code></li>
</ol>
</li>
<li>R（Retrieve）：查询；
<ol>
<li>查询数据库中所有表的名称：<code>show tables;</code></li>
<li>查询表结构：<code>desc 表名;</code></li>
</ol>
</li>
<li>U（Update）：修改；
<ol>
<li>修改表名：<code>alter table 表名 rename to 新表名;</code></li>
<li>修改表的字符集：<code>alter table 表名 character set 字符集名称;</code></li>
<li>添加一列：<code>alter table 表名 add 列名 数据类型;</code></li>
<li>修改列名称 类型：<code>alter table 表名 modify 列名 新数据类型;</code>（仅修改列的数据类型）或者<code>alter table 表名 change 列名 新列名 新数据类型;</code></li>
<li>删除列：<code>alter table 表名 drop 列名;</code></li>
</ol>
</li>
<li>D(Delete):删除；
<ol>
<li>删除数据库中的表;·drop table 表名;`</li>
<li>判断表存在后再修改:<code>drop table if exists 表名;</code></li>
</ol>
</li>
</ol>
<h3 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h3>
<ul>
<li>MySQL支持多种类型的SQL数据类型：数值，日期和时间类型，字符串（字符和字节）类型，空间类型和 JSON数据类型等</li>
<li>数据类型描述使用以下约定：
<ul>
<li>M表示整数类型的<strong>最大显示宽度</strong>。M表示整数类型的最大显示宽度。对于浮点和定点类型， M是可以存储的总位数（精度）。对于字符串类型， M是最大长度。允许的最大值M取决于数据类型。</li>
<li>D适用于浮点和定点类型，并指示<strong>小数点后面的位数</strong>。最大可能值为30，但不应大于 M-2。</li>
<li>[ ]表示类型定义的<strong>可选部分</strong>,例如：int[(M)],但是可以不填整型的宽度。</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yuzhiqiang_1993/article/details/81453569?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160592530619724838553623%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160592530619724838553623&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-81453569.pc_first_rank_v2_rank_v28p&amp;utm_term=mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&amp;spm=1018.2118.3001.4449">借鉴博客</a></li>
</ul>
</li>
</ul>
<h4 id="数值类型"><a class="markdownIt-Anchor" href="#数值类型"></a> 数值类型</h4>
<h5 id="整型"><a class="markdownIt-Anchor" href="#整型"></a> 整型</h5>
<ul>
<li><code>TINYINT[(M)] [UNSIGNED] [ZEROFILL]</code>： <strong>范围非常小的整数</strong>，有符号的范围是 -128到127，无符号的范围是0到 255</li>
<li><code>SMALLINT[(M)] [UNSIGNED] [ZEROFILL]</code> ：范围较小的整数，有符号的范围是 -32768到32767，无符号的范围是0到 65535</li>
<li><code>MEDIUMINT[(M)] [UNSIGNED] [ZEROFILL]</code>: 中等大小的整数，有符号的范围是 -8388608到8388607，无符号的范围是0到 16777215。</li>
<li><code>INT[(M)] [UNSIGNED] [ZEROFILL]</code>: 正常大小的整数，有符号的范围是 -2147483648到 2147483647。无符号的范围是 0到4294967295。</li>
<li><code>BIGINT[(M)] [UNSIGNED] [ZEROFILL]</code>: 大整数，有符号的范围是 -9223372036854775808到 9223372036854775807，无符号的范围是0到 18446744073709551615。</li>
</ul>
<h5 id="浮点型"><a class="markdownIt-Anchor" href="#浮点型"></a> 浮点型</h5>
<ul>
<li><code>FLOAT[(M,D)] [UNSIGNED] [ZEROFILL]</code>：一个小的（单精度）浮点数。允许值是-3.402823466E+38 到-1.175494351E-38， 0以及1.175494351E-38 到3.402823466E+38,M是总位数，D是小数点后面的位数。</li>
<li><code>DOUBLE[(M,D)] [UNSIGNED] [ZEROFILL]</code>：正常大小（双精度）浮点数。允许值是 -1.7976931348623157E+308到-2.2250738585072014E-308，0以及 2.2250738585072014E-308到 1.7976931348623157E+308。</li>
<li><strong>M是总位数，D是小数点后面的位数</strong>，float和double在不指定精度时，默认会按照<strong>实际的精度</strong>来显示。</li>
</ul>
<h5 id="定点型"><a class="markdownIt-Anchor" href="#定点型"></a> 定点型</h5>
<ul>
<li><code>DECIMAL[(M[,D])] [UNSIGNED] [ZEROFILL]</code>:常用于存储<strong>精确的小数</strong>，<strong>M是总位数</strong>，<strong>D是小数点后的位数</strong>。小数点和（负数） -符号不计入 M。如果 <strong>D为0，则值没有小数点或小数部分</strong>。最大位数（M）为 65. 最大支持小数（D）为30.<strong>如果D省略，则默认值为0.如果M省略，则默认值为10</strong>,如果二者都省略，则默认为decimal(10,0)。M的范围是1到65。D范围为0到30，且不得大于M。</li>
</ul>
<h5 id="时间类型"><a class="markdownIt-Anchor" href="#时间类型"></a> 时间类型</h5>
<ul>
<li><code>TIME</code>: 范围是’-838:59:59.000000’ 到’838:59:59.000000’;
<ul>
<li>TIME的完整的显示为 <code>D HH:MM:SS</code>:</li>
<li>D：表示天数，当指定该值时，存储时小时会先乘以该值</li>
<li>HH：表示小时</li>
<li>MM：表示分钟</li>
<li>SS:表示秒</li>
<li>示例：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">INSERT time_db() VALUES(&#39;22:14:16&#39;);

--   -2表示间隔了2两天
INSERT time_db() VALUES(&#39;-2 22:14:16&#39;);

-- 有冒号从小时开始
INSERT time_db() VALUES(&#39;14:16&#39;);

-- 没有冒号且没有天数则数据从秒开始
INSERT time_db() VALUES(&#39;30&#39;);

-- 有天数也从小时开始
INSERT time_db() VALUES(&#39;3 10&#39;);

-- 直接使用数字代替也可以
INSERT time_db() VALUES(253621);</code></pre>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201121142312.png" alt="" /></p>
<ul>
<li><code>DATE</code>: 支持的范围是 '1000-01-01’到 ‘9999-12-31’;
<ul>
<li>示例：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">INSERT date_db() VALUES(20180813);
INSERT date_db() VALUES(“2018-06-1”);
INSERT date_db() VALUES(“2018-4-1”);
INSERT date_db() VALUES(“2018-04-07”);</code></pre>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201121142549.png" alt="" /></p>
<ul>
<li><code>DATETIME</code>: <strong>日期和时间组合</strong>。支持的范围是 '1000-01-01 00:00:00.000000’到 ‘9999-12-31 23:59:59.999999’;
<ul>
<li>示例：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">INSERT datetime_db() VALUES(20180102235432);
INSERT datetime_db() VALUES(&quot;2015-04-21 21:14:32&quot;);
INSERT datetime_db() VALUES(&quot;2015-04-23&quot;);</code></pre>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201121142737.png" alt="" /></p>
<ul>
<li><code>TIMESTAMP</code>: 时间戳。范围是’1970-01-01 00:00:01.000000’UTC到’2038-01-19 03:14:07.999999’UTC。与datetime类型有差不多，只是范围较小。
<ul>
<li>示例：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">INSERT timestamp_db() VALUES(20020121);
INSERT timestamp_db() VALUES(20020121142554);
INSERT timestamp_db() VALUES(&quot;2015-12-16 21:14:15&quot;);
INSERT timestamp_db() VALUES(&quot;2015-12-17&quot;);
INSERT timestamp_db() VALUES(NULL);
INSERT timestamp_db() VALUES(CURRENT_TIMESTAMP);
INSERT timestamp_db() VALUES();</code></pre>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201121143202.png" alt="" /></p>
<ul>
<li><code>YEAR</code>: 范围是 1901到2155;
<ul>
<li>示例：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">INSERT year_db() VALUES(&quot;1993&quot;);
INSERT year_db() VALUES(1993);</code></pre>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201121143340.png" alt="" /></p>
<h5 id="字符串类型"><a class="markdownIt-Anchor" href="#字符串类型"></a> 字符串类型</h5>
<h6 id="char和varchar"><a class="markdownIt-Anchor" href="#char和varchar"></a> char和varchar</h6>
<ul>
<li><code>CHAR[(M)]</code>: 一个<strong>固定长度</strong>的字符串，在存储时始终<strong>用空格填充</strong>指定长度。 M表示以字符为单位的列长度。M的范围为0到255.如果<strong>M省略，则长度为1</strong>，存储时占用M个字节</li>
<li><code>VARCHAR(M)</code>:<strong>可变长度</strong>的字符串，M 表示字符的最大列长度，M的范围是0到65,535，存储时占用L+1（L&lt;=M,L为实际字符的长度）个字节,此处的参数<strong>M是必须指定的</strong>。</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 创建表
CREATE TABLE str_db(
a CHAR(4),
b VARCHAR(4)
);

-- 插入数据
INSERT str_db() VALUES(&quot;&quot;,&quot;&quot;);
INSERT str_db() VALUES(&quot;ab&quot;,&quot;ab&quot;);
INSERT str_db() VALUES(&quot;abcd&quot;,&quot;abcd&quot;);
INSERT str_db() VALUES(&quot;abcdefg&quot;,&quot;abcdefg&quot;);&#x2F;&#x2F;在严格模式下，改条数据会插入失败，非严格模式则会对数据进行截取</code></pre>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201123110639.png" alt="" /></p>
<ul>
<li>char的参数M规定的是字符串必须的长度，不够长度用空格来补充；</li>
<li>varchar的参数M规定的是字符串最长的长度，没有超出最长的长度就存储字符串原来的长度。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201123110718.png" alt="" /></li>
</ul>
<h6 id="text系列"><a class="markdownIt-Anchor" href="#text系列"></a> text系列</h6>
<ul>
<li><code>TINYTEXT[(M)]</code>: 不能有默认值，占用L+1个字节，L&lt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">2^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>;</li>
<li><code>TEXT[(M)]</code>: 不能有默认值，占用L+2个字节，L&lt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup><mn>6</mn></mrow><annotation encoding="application/x-tex">2^16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mord">6</span></span></span></span>;</li>
<li><code>MEDIUMTEXT[(M)]</code>: 不能有默认值，占用L+3个字节，L&lt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup><mn>4</mn></mrow><annotation encoding="application/x-tex">2^24</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">4</span></span></span></span>;</li>
<li><code>LONGTEXT[(M)]</code>: 不能有默认值，占用L+4个字节，L&lt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup><mn>2</mn></mrow><annotation encoding="application/x-tex">2^32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord">2</span></span></span></span>;
<ul>
<li>TEXT系列的存储范围比VARCHAR要大，当VARCHAR不满足时可以用TEXT系列中的类型。需要注意的是TEXT系列类型的字段不能有默认值，在检索的时候不存在大小写转换，没有CHAR和VARCHAR的效率高</li>
</ul>
</li>
</ul>
<h6 id="enum枚举类型"><a class="markdownIt-Anchor" href="#enum枚举类型"></a> enum枚举类型</h6>
<ul>
<li><code>ENUM('value1','value2',...)</code>: ENUM是一个字符串对象，其值从允许值列表中选择，它只能有一个值，从值列表中选择,最多可包含65,535个不同的元素;</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TABLE enum_db (
  gender ENUM(&quot;男&quot;,&quot;女&quot;)
);

INSERT enum_db() VALUES(&quot;男&quot;);
INSERT enum_db() VALUES(1); 也可以使用编号插入值，等同于&quot;男&quot;，序号从1开始
INSERT enum_db() VALUES(&quot;女&quot;);
INSERT enum_db() VALUES(2);等同于&quot;女&quot;</code></pre>
<h6 id="set"><a class="markdownIt-Anchor" href="#set"></a> set</h6>
<p>在ENUM中我们只能从允许值列表中给字段插入一个值，而在SET类型中可以给字段插入多个值</p>
<ul>
<li><code>SET('value1','value2',...)</code>: 字符串对象，该对象可以有零个或多个值，最多可包含64个不同的成员;
<ul>
<li>在ENUM中我们只能从允许值列表中给字段插入一个值，而在SET类型中可以给字段插入多个值.</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TABLE set_db (
a SET(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;)
);


INSERT set_db() VALUES(&#39;1&#39;)
INSERT set_db() VALUES(&#39;1,2,3&#39;)</code></pre>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201123111656.png" alt="" /></p>
<h2 id="dml"><a class="markdownIt-Anchor" href="#dml"></a> DML</h2>
<ol>
<li>添加数据：
<ol>
<li>添加语法：<code>insert into 表名 （列名1， 列名2，... ，列名n）value（值1，值2，...,值n）;</code>
<ol>
<li>列名和值要一一对应；</li>
<li>如果表名后不给列名，在提供和列数相同个数值的前提下，会默认依次给所有列添加值，否则会报错。<br />
2.删除数据：</li>
</ol>
</li>
<li>删除语法：<code>delete from where 条件；</code>如果没有加条件，就会删除表中所有的数据。示例：<code>delete from where id=1;</code></li>
<li>删除表，然后再创建一个一模一样的空表：<code>truncate table 表名;</code><br />
3.修改数据：</li>
<li>修改语法：<code>update 表名 set 列名1 = 值1，列名2 =值2 ... where 条件;</code>,示例：<code>update stu set age = 19， score = 12 where id = 1;</code>。如果不加任何条件则会将表中所有的数据全部修改。</li>
</ol>
</li>
</ol>
<h2 id="dql"><a class="markdownIt-Anchor" href="#dql"></a> DQL</h2>
<p>1.排序查询：</p>
<ol>
<li>排序基础语法：<code>order by 子句</code></li>
<li><code>order by 排序字段1 排序方式1, 排序字段2 排序方式2, ... 排序字段n 排序方式n;</code></li>
<li>示例：<code>select * from stu order by id desc;</code></li>
<li>位于后面的排序字段的优先级较低，则当当前面的条件值一样时，才会去判断之后的条件来排序。</li>
<li>排序方式：
<ol>
<li>ASC：升序排列，如果不指定排序方式，默认升序；</li>
<li>DESC：降序排列；<br />
2.聚合函数：将一列数据作为一个整体，进行<strong>纵向</strong>的计算。聚合函数会默认排除为null的项。<br />
1.count：计算个数；</li>
</ol>
<ul>
<li>示例:<code>select count(列名) from 表名;</code>,会忽略为null的项。</li>
<li><code>select count(ifnull(列名，0)) from 表名;</code>，会将值为null的项的值转为0，再计数。</li>
<li><code>select count(*) from 表名;</code>,会综合所有列来计数（除非有一行都为null）<br />
2.max：计算最大值；<br />
3.min;计算最小值；<br />
4.sum：求和；<br />
5.avg：计算平均值。</li>
</ul>
</li>
</ol>
<ul>
<li>适用于count的特殊方法也会适用于其他函数（除了<code>*</code>）<br />
3.分组查询</li>
</ul>
<ol>
<li>语法：<code>group by 分组字段</code>，可以增加条件：<code>where 条件 group by 分组字段;</code>（分组前进行限定，如果不满足条件，则不参与分组。where后不可以跟聚合函数进行判断）或者`group by 分组字段 having 条件</li>
<li>示例：<code>select sex avg(math), count(id) from student group by sex;</code>,有条件：<code>select sex from student where math&gt;70 group by sex;</code>(math&gt;70 才能有被分组的资格)，<code>select sex feom student group by sex having count(id) &gt; 2;</code>(id的个数要大于2，才会参与分组)。</li>
<li>分组后查询的字段：只能是被查询的字段，或者是聚合函数。<br />
4.分页查询</li>
<li>分页语法：<code>limit 分页索引，每页显示的条数</code>（limit是mysql的方言）</li>
<li>分页索引的计算：开始的索引 - （当前的页码 -1）* 每页的条数。</li>
<li>示例：<code>select * from stu limit 0,3;</code>(第一页)， <code>selct * from stu limit 3,3;</code>(第二页)</li>
</ol>
<h3 id="dql查询表中的数据"><a class="markdownIt-Anchor" href="#dql查询表中的数据"></a> DQL查询表中的数据</h3>
<ul>
<li>查询所有数据：<code>select * from 表名</code>(将表中的所有数据查询出来)</li>
<li>总语法：<code>select 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件限定 order by 排序子句 limit 分页限定</code></li>
</ul>
<h4 id="基础数据查询"><a class="markdownIt-Anchor" href="#基础数据查询"></a> 基础数据查询</h4>
<ul>
<li>查询指定列：<code>select 列名1，列名2 from 表名</code>.示例：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select 
      name, -- 姓名
      age,  -- 年龄
from
      student; --学生表</code></pre>
<ul>
<li>去除重复的结果集显示某列的内容:<code>select distinct 需去重的列名1，需去重的列名2 from 表名</code>（必须去重的所有的列的数据完全一样才会去掉）</li>
<li>计算列的的结果再显示：<code>select 列名1， 列名2，列名1 + 列名2 form 表明;</code>(如果某一列的数据为null，则计算结果都为null)
<ul>
<li>一般可以使用四则运算进行运算（只有数值型计算）。</li>
<li>ifnull函数：<code>ifnull(表达式1，表达式2);</code>表达式1：需要判断是否为null的字段；表达式2；被查询字段为null后替代的值。</li>
</ul>
</li>
<li>给列起别名：<code>select 列名1 as 别名1 form 表名</code>或者省略as<code>select 列名1 别名1 form 表名</code>(列名和别名之间用空格)</li>
</ul>
<h4 id="条件查询"><a class="markdownIt-Anchor" href="#条件查询"></a> 条件查询</h4>
<ul>
<li>where子句后跟条件；</li>
<li>运算符：
<ul>
<li><code>&gt;, &lt;, &gt;= , &lt;=, =(没有==，=就是等于) , !=, &lt;&gt;(也是不等号）</code></li>
<li><code>between...and...(在两者之间，包含边界0</code></li>
<li>逻辑运算符：<code>and(与&amp;&amp;相同),or(与||相同)，not(与!相同)</code></li>
<li><code>in(数据1，数据2，数据3，...)</code>数据等于数据1，或者数据2，或者数据3都可以。</li>
<li><code>is null, is not null</code>null值不能被直接查询，只能使用这两个特殊语句判断。</li>
<li><code>like</code>:模糊查询
<ul>
<li>占位符:
<ul>
<li><code>_</code>：单个任意字符；</li>
<li><code>%</code>:多个任意字符；</li>
</ul>
</li>
<li>示例：
<ul>
<li><code>select name from stu where name like '马%';</code>(name中第一个字是马)</li>
<li><code>select name from stu where name like '_化_</code>（name中第二个字是化）</li>
<li>`select naem from stu where name like ‘%德%’(name中含马)</li>
<li><code>select name from stu where name like '___'</code>(name为三个字)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="dcl"><a class="markdownIt-Anchor" href="#dcl"></a> DCL</h2>
<ul>
<li>管理用户，授权。对应DBA(数据库管理员)</li>
<li>管理用户：
<ul>
<li>添加用户：
<ul>
<li>创建用户并设置账户密码：<code>creat user '用户名'@'主机名' identified by '密码';</code></li>
</ul>
</li>
<li>查询用户：
<ul>
<li>切换到mysql数据库<code>use mysql;</code></li>
<li>查询user表：<code>select * from user;</code>,通配符%表示可以在任意主机上使用该用户。<code>localhost 127.0.0.1 ::1</code>三者都表示本地机。</li>
</ul>
</li>
<li>删除用户：
<ul>
<li><code>drop user '用户名'@'主机名';</code></li>
</ul>
</li>
<li>修改用户的密码（在已经登录用户的条件下）：
<ul>
<li>`update user set password = password(‘新密码’) where user = ‘用户名’;</li>
<li><code>set password for '用户名'@'主机名' = password('新密码');</code></li>
<li>使用password()函数，将密码进行加密之后存储。</li>
</ul>
</li>
</ul>
</li>
<li>授权：
<ul>
<li>查询权限：<code>show grants for '用户名'@'主机名';</code></li>
<li>授予权限：<code>grant 权限列表 on 数据库名.表名 to '用户名'@'主机名';</code>
<ul>
<li>示例：<code>grant select,delete,update on db3.account to 'zhangsan'@'%';</code></li>
<li>授予所有库和表的所有权限：<code>grant all on *.* to 'zhangsan'@'%';</code></li>
</ul>
</li>
<li>撤销权限：<code>revote 权限列表 on 数据库名.表名 from '用户名'@'主机名';</code></li>
</ul>
</li>
</ul>
<h2 id="约束"><a class="markdownIt-Anchor" href="#约束"></a> 约束</h2>
<h3 id="约束概念"><a class="markdownIt-Anchor" href="#约束概念"></a> 约束概念</h3>
<ul>
<li>约束：对表中的数据进行限定，从而保证数据的正确性，有效性和完整性。</li>
<li>约束的分类：
<ol>
<li>主键约束：primary key</li>
<li>非空约束：not null</li>
<li>唯一约束：unique</li>
<li>外键约束：foreign key</li>
</ol>
</li>
</ul>
<h3 id="非空约束-not-null"><a class="markdownIt-Anchor" href="#非空约束-not-null"></a> 非空约束 NOT NULL</h3>
<ul>
<li>在创建表时添加约束：
<ul>
<li>示例：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TABLE stu1(
id INT,
NAME VARCHAR(20) NOT NULL -- name必须为非空，才能加入表中
);</code></pre>
</li>
<li>创建表完成后添加或删除约束：
<ul>
<li>示例：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER TABLE stu1 MODIFY NAME VARCHAR(20); -- 将原来有约束的name改为没有not null的
ALTER TABLE stu1 MODIFY NAME VARCHAR(20) NOT NULL; -- 给name添加not null约束</code></pre>
</li>
</ul>
<h3 id="唯一约束-unique"><a class="markdownIt-Anchor" href="#唯一约束-unique"></a> 唯一约束 UNIQUE</h3>
<ul>
<li>创建表时添加约束：
<ul>
<li>示例：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">   CREATE TABLE stu1(
   id INT,
   NAME VARCHAR(20) UNIQUE -- name必须为是唯一没有重复的，才能加入表中
   );
* 创建表完成后添加或者删除约束：
   * 示例：
   &#96;&#96;&#96;sql
   ALTER TABLE stu1 DROP INDEX NAME VARCHAR(20); -- 删除创建表时的唯一约束（使用DROP INDEX 而不是MODIFY）
   ALTER TABLE stu1 MODIFY NAME VARCHAR(20) UNIQUE; -- 添加唯一约束，仍然使用MODIFY</code></pre>
</li>
<li>MySQL中多个null不认为是重复的</li>
</ul>
<h3 id="主键约束primary-key"><a class="markdownIt-Anchor" href="#主键约束primary-key"></a> 主键约束：PRIMARY KEY</h3>
<ul>
<li>主键约束：非空且唯一，一张表中只能有一个字段为主键，主键就是表中记录的唯一标识。</li>
<li>创建时添加主键，示例：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create table stu (
   id int primary key, -- 给id添加主键约束
   name varchar(20)
)</code></pre>
<ul>
<li>删除主键约束，示例：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">alter table stu1  drop primary key;</code></pre>
<ul>
<li>因为一个表中的主键是唯一的，所以无需指定特定的列。</li>
<li>创建完表之后，添加主键，示例：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">alter table stu1 modify id int primary key;</code></pre>
<ul>
<li><strong>自动增长</strong>：
<ul>
<li>如果某一列是数值类型的，使用auto_increment可以完成值的自动增长。一般和主键联合在一起使用。</li>
<li>创建表时添加主键约束，并且实现主键的自增长，示例：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create table stu1 (
   id int primary key auto_increment, -- 给id添加主键约束，并自动增长。
   name varchar(20)
);</code></pre>
</li>
<li>使用自动增长：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">insert into stu1 values(null, &#39;name1&#39;); -- 每次执行此操作，如果不指定id的值，就会自动根据上一行的数据加一来作为本行的id值</code></pre>
<ul>
<li>删除自动增长：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">alter table stu1 modify id int; -- 能够去除自动增长，但是不能这样删除主键</code></pre>
<ul>
<li>创建完表后添加自动增长：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">alter table stu modify id int auto_increment;</code></pre>
<h3 id="外键约束foreign-key"><a class="markdownIt-Anchor" href="#外键约束foreign-key"></a> 外键约束：FOREIGN KEY</h3>
<ul>
<li>联系两个表某些列，之后关联的两列的删除添加操作都是相互制约的,从而保证数据的正确性。</li>
<li>创建表时添加外键：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create table 表名 (
   ...
   外键列(和其它表有关系的列)
   constanit  外键名称 foreign key (外键列的名称) references 主表名称(主表的列（一般为主键列）名称)
)

示例：

creat table department (
   id int primary key,
   name varchar(20)
)

create table empolyee (
   id int primary key,
   dep_id int -- 外键对应主表的主键（外键列）
   constraint emp_dept_fk foreign key (dep_id) references department(id)
)</code></pre>
<ul>
<li>删除外键：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">alter table employee drop foreign key emp_dept_key;</code></pre>
<ul>
<li>创建表之后添加外键：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">alter table employee add constraint emp_dept_fk foreign key (dep_id) references department(id);</code></pre>
<ul>
<li><strong>级联操作</strong>:修改有外键连接的两个表的列中的数据，操作会自动同步给关联的另一个列。
<ul>
<li>添加级联操作语法：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 
       FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELTE CASCADE;</code></pre>
<ul>
<li>级联更新：ON UPDATE CASADE;</li>
<li>级联删除：ON DELTE CASCADE;</li>
</ul>
</li>
</ul>
<h1 id="数据库的设计"><a class="markdownIt-Anchor" href="#数据库的设计"></a> 数据库的设计</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/guangod/article/details/88714091?biz_id=102&amp;utm_term=%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-88714091&amp;spm=1018.2118.3001.4449">参考blog</a></li>
</ul>
<h2 id="多表关系"><a class="markdownIt-Anchor" href="#多表关系"></a> 多表关系</h2>
<ol>
<li>一对一关系（使用较少）
<ol>
<li>如：人与身份证</li>
<li>实现：一对一关系实现，可以在任意一方添加<strong>唯一外键</strong>指向另一方的主键。可以直接合成一张表。</li>
</ol>
</li>
<li>一对多关系
<ol>
<li>如：部门和员工</li>
<li>实现：在“多”的一方建立外键，指向“一”的一方的主键。</li>
</ol>
</li>
<li>多对多关系：
<ol>
<li>如：课程与学生</li>
<li>实现：多对多关系需要借助<strong>中间表</strong>，中间表至少包含两个字段，这两个字段（这两个字段是<strong>联合</strong>的）作为第三张表的外键，分别指向两张表的主键。</li>
</ol>
</li>
</ol>
<h2 id="数据库设计的范式"><a class="markdownIt-Anchor" href="#数据库设计的范式"></a> 数据库设计的范式</h2>
<ul>
<li>范式概念：设计数据库时需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求。
<ul>
<li>设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。（前三种足矣。）</li>
</ul>
</li>
<li>范式分类：
<ol>
<li>第一范式（1NF）：每一列都是不可分割的原子数据项。（数据库中创建表的基本要求）
<ol>
<li>存在严重的数据冗余问题</li>
<li>数据添加存在问题</li>
<li>数据删除存在问题**</li>
</ol>
</li>
<li>第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于候选码（在1NF的基础上消除了非主属性对主码的<strong>部分依赖</strong>，解决了数据冗余问题）
<ol>
<li>概念：
<ol>
<li>函数依赖：A-&gt;B，如果通过A属性（属性组）的值，可以确定唯一B属性的值，则称B依赖于A</li>
<li>完全函数依赖：A-&gt;B,如果A是一个属性组，则B的值的确定需要依赖于A属性组中所有的属性值</li>
<li>部分函数依赖：A-&gt;B,如果A是一个属性组，则B属性值的确定只需要依赖于A属性组中某一些属性值即可。</li>
<li>传递函数依赖：A-&gt;B, B-&gt;C,如果通过A属性（属性值）的值，可以唯一确定B属性的值，在通过B属性（属性组）的值可以确定唯一的C属性的值，则称C传递函数依赖于A.</li>
<li>码：如果在一张表中，如果一个属性或者属性组，被其它所有属性完全依赖，则称这个属性（属性组）为该表的码。</li>
<li>主属性：码属性组中的所有属性。</li>
<li>非主属性：除了码属性组的属性。</li>
</ol>
</li>
</ol>
</li>
<li>第三范式（3NF）：在2NF的基础上，任何非主属性不依赖于其它非主属性（在2NF的基础上消除传递依赖，解决了数据添加和删除存在的问题）</li>
</ol>
</li>
</ul>
<h2 id="触发器"><a class="markdownIt-Anchor" href="#触发器"></a> 触发器</h2>
<p>…</p>
<h1 id="数据库的备份和还原"><a class="markdownIt-Anchor" href="#数据库的备份和还原"></a> 数据库的备份和还原</h1>
<ul>
<li>语法：<code>mysqldump -u用户名 -p密码 数据库名称 &gt; 备份保存的路径</code>（保存到以.sql结尾的文件）</li>
<li>还原：
<ol>
<li>登录数据库；<code>mysql -u用户名 -p密码;</code></li>
<li>创建一个新数据库；<code>create database 新数据库名;</code></li>
<li>使用数据库:<code>use 数据库名;</code></li>
<li>执行备份的文件:<code>source 文件路径;</code></li>
</ol>
</li>
</ul>
<h1 id="多表查询"><a class="markdownIt-Anchor" href="#多表查询"></a> 多表查询</h1>
<h2 id="多表查询的基本概念"><a class="markdownIt-Anchor" href="#多表查询的基本概念"></a> 多表查询的基本概念</h2>
<ul>
<li>查询基本语法：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select
   列名列表
from
   表的列表（可以写多个表）
where
   ...(条件)</code></pre>
<ul>
<li>示例：<code>select * from table1, table2;</code>。不加任何条件查询多个表的结果是：所有表的组合（两个表时是笛卡尔积）。</li>
</ul>
<h2 id="多表查询的分类"><a class="markdownIt-Anchor" href="#多表查询的分类"></a> 多表查询的分类</h2>
<ol>
<li>内连接查询</li>
<li>外连接查询</li>
<li>子查询</li>
</ol>
<h3 id="内连接查询"><a class="markdownIt-Anchor" href="#内连接查询"></a> 内连接查询</h3>
<ol>
<li>隐式内连接：使用where条件来消除多个表组合后的无用信息。</li>
</ol>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select 
      * 
from 
      table1, table2 
where 
      table1.&#96;id1&#96; &#x3D; &#96;table.id2&#96;; -- 组合后不满足的这个条件的行都会被去掉


select 
      table1.name, table2.name -- 要查询两个表里的同名列，需要在列名前面加上表名的限定。
from 
      table1, table2 
where       
      table1.&#96;id1&#96; &#x3D; table2.&#96;id2&#96;; 


select 
      t1.name, t2.name 
from 
      table1 t1, table2 t2 -- 通过取别名来简化对表名的书写。
where 
      t1.&#96;id1&#96; &#x3D; t2.&#96;id2&#96;; </code></pre>
<ol start="2">
<li>显式内连接：
<ul>
<li>语法：<code>select 字段列表 from 表名1 inner join 表名2 on 条件;</code></li>
<li>同样支持对表取别名来简化书写</li>
</ul>
</li>
</ol>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select
      * 
from
      table1
inner join
      table2  -- 两个表是分开放的
on 
      table1.&#96;id1&#96; &#x3D; table2.&#96;id2&#96;;


select
      * 
from
      table1 t1
join              -- inner可以省略
      table2 t2
on 
      t1.&#96;id1&#96; &#x3D; t2.&#96;id2&#96;;</code></pre>
<h3 id="外连接查询"><a class="markdownIt-Anchor" href="#外连接查询"></a> 外连接查询</h3>
<ol>
<li>左外连接：
<ul>
<li>语法：<code>select 字段列表 from 表1 left outer join 表2 on 条件;</code>(outer同样是可以省略的)</li>
<li>查询的是左表所有数据以及左表和右表数据交集部分。from后面的是左表，join后面是右表。</li>
</ul>
</li>
<li>右外连接：
<ul>
<li>语法：<code>select 字段列表 from 表1 right outer join 表2 on 条件;</code>(outer同样是可以省略的)</li>
<li>查询的是右表所有数据以及左表和右表数据交集部分。from后面的是左表，join后面是右表。</li>
</ul>
</li>
</ol>
<h3 id="子查询"><a class="markdownIt-Anchor" href="#子查询"></a> 子查询</h3>
<ul>
<li>查询中嵌套查询，嵌套的查询称为子查询。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"># 查询工资最高的员工的信息需完成两步操作：一：查询最高的工资；二：查询最高工资对应的员工信息
select
      * 
from 
      table1 -- 外层查询整个表的员工信息
where 
      table1.&#96;salary&#96; &#x3D; (select max(salary) from table1); -- 嵌套一个子查询语句在条件里，完成最高工资的限定</code></pre>
<h4 id="子查询的不同结果"><a class="markdownIt-Anchor" href="#子查询的不同结果"></a> 子查询的不同结果</h4>
<ul>
<li>子查询结果是<strong>单行单列</strong>的：
<ul>
<li>子查询结果可以作为条件，使用判断运算符去判断,如：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">table1.&#96;salary&#96; &#x3D; (select max(salary) from table1);</code></pre>
</li>
<li>子查询结果是<strong>多行单列</strong>的：
<ul>
<li>子查询可以作为条件，使用运算符<code>in</code>（是否在这个集合中）去判断，如：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">table.&#96;id&#96; in (select id from table1 where name &#x3D; &#39;1&#39; or name &#x3D; &#39;2&#39;);</code></pre>
</li>
<li>子查询的结果是<strong>多行多列</strong>的：
<ul>
<li>子查询可以作为一张虚拟表，参与查询，如：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"># 查询员工的入职日期是&#96;2011-11-11&#96;日之后的员工信息和部门信息

-- 子查询方式
 select
       *
 from 
       dept t1,(select * from emp where emp.&#96;join_date&#96; &gt; &#39;2011-11-11&#39;) t2   -- 子查询结果作为一张表参与查询
 where
       t1.id &#x3D; t2.dept_id;

 -- 普通内连接
 select
       * 
 from
       emp t1, dept t2
 where
       t1.&#96;dept_id&#96; &#x3D; t2.&#96;id&#96; and t1.&#96;join_date&#96; &gt; &#39;2011-11-11&#39;;</code></pre>
</li>
</ul>
<h1 id="事务"><a class="markdownIt-Anchor" href="#事务"></a> 事务</h1>
<h2 id="事务的基本介绍"><a class="markdownIt-Anchor" href="#事务的基本介绍"></a> 事务的基本介绍</h2>
<ul>
<li>事务概念：如果一个包含多个步骤的业务操作，被事务管理，那么这些操作<strong>要么同时成功，要么同时失败</strong>。</li>
<li>基本操作；
<ol>
<li>开启事务：start transaction；</li>
<li>回滚：rollback；</li>
<li>提交：commit。</li>
</ol>
</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"># 实现张三给李四的账户上转去500：1.张三的账户减五百 2.李四的账户加500 （如果这两步中有任何一步出错了的话，事务管理机制保证账户信息不被修改）
start transaction; -- 开启事务

update account set money &#x3D; money - 500 where name &#x3D; &#39;zhangsan&#39;; -- 张三的账户减500

update account set money &#x3D; money +500 where name &#x3D; &#39;lisi&#39;; -- 李四的账户加500

-- 如果两步执行完没有异常，则提交，提交后的数据库改变才真正生效
commit;
-- 如果执行出错，则回滚，数据库的状态维持启动事务时的状态
rollback;</code></pre>
<ul>
<li>在MySQL中，事务是默认自动提交的
<ul>
<li>自动提交：
<ul>
<li>一条DML（增删改）语句会自动提交一次事务</li>
</ul>
</li>
<li>手动提交：
<ul>
<li>需要先开启事务，再提交</li>
</ul>
</li>
<li>修改事务的默认提交方式：
<ul>
<li>查看默认提交方式：<code>select @@autocommit;</code>,结果为1代表自动提交</li>
<li>设置默认提交方式：<code>set @@autocommit = 0;</code>，改为0代表手动提交</li>
</ul>
</li>
</ul>
</li>
<li>在oracle中，事务是默认手动提交的。</li>
</ul>
<h2 id="事务的四大特征"><a class="markdownIt-Anchor" href="#事务的四大特征"></a> 事务的四大特征</h2>
<ol>
<li>原子性：是不可分割的最小单位，要么同时成功，要么同时失败。</li>
<li>持久性：事务一旦提交或者回滚后，数据库会持久化地保存数据。</li>
<li>隔离性：多个事务之间相互独立。</li>
<li>一致性：事务操作前后，数据总量不变。（即如果事务执行到中途出错了，则整个数据库都回滚到事务开始前的状态。）</li>
</ol>
<h2 id="事务的隔离级别"><a class="markdownIt-Anchor" href="#事务的隔离级别"></a> 事务的隔离级别</h2>
<ul>
<li>概念：理论上多个事务之间是隔离的，相互独立。如果多个事务操作同一批数据，那么这些事务之间就不是隔离的了，会引发一些问题，设置不同的隔离级别来解决这些问题。</li>
<li>存在的问题：
<ol>
<li>脏读：一个事务，读取到了另一个事务中<strong>没有提交</strong>的数据。</li>
<li>不可重复读（虚读）：在同一个事务中，两次读到的数据不一样。(原因可能是其它事务在两次查询之间的时间修改了数据库)</li>
<li>幻读：一个事务操作（DML）数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。</li>
</ol>
</li>
<li>隔离级别：隔离级别从小到大安全性越来越高，但是效率越来越低。
<ol>
<li>read uncommited：读未提交
<ol>
<li>产生的问题：脏读，不可重复读，幻读。</li>
</ol>
</li>
<li>read commited:读已提交（oracle默认）
<ol>
<li>产生的问题：不可重复读，幻读</li>
</ol>
</li>
<li>repeatable read：可重复读（MySQL默认）
<ol>
<li>产生的问题：幻读</li>
</ol>
</li>
<li>serializable：串行化（一个事务在操作一个表时，其它事务是不可以操作这个表，类似给这个表“加锁”）
<ol>
<li>可以解决所有问题。</li>
</ol>
</li>
</ol>
</li>
<li>数据库查询隔离级别：<code>select @@tx_isolation;</code></li>
<li>数据库设置隔离级别：<code>set global transaction isolation level 级别字符串;</code></li>
</ul>
<h1 id="易错语法"><a class="markdownIt-Anchor" href="#易错语法"></a> 易错语法</h1>
<ul>
<li>语句括号内部少逗号，最后一行多了逗号:</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 创建学生表
create table &#96;student&#96; (
    &#96;id&#96; int primary key auto_increment comment &#39;学生id&#39;, -- 学生id
	&#96;name&#96; varchar (30) not null comment &#39;学生姓名&#39;, -- 学生姓名
	&#96;phone&#96; varchar (36) not null comment &#39;学生电话&#39;, -- 学生电话
	&#96;youth_league_branch_name&#96; varchar (60) not null comment &#39;所属团支部名称&#39;, -- 所属团支部名称
	&#96;study_time&#96; datetime not null comment &#39;学习时间&#39;  -- 学习时间 # 少了逗号
    &#96;gmt_create&#96; datetime null default current_timestamp comment &#39;记录创建时间&#39;, -- 记录创建时间
    &#96;gmt_modified&#96; datetime null default current_timestamp on update current_timestamp comment &#39;记录最近修改时间&#39;, -- 记录最近修改时间
    &#96;youth_league_branch_id&#96; int not null, -- 所属团支部id # 多了逗号
); 


修改：

-- 创建学生表
create table &#96;student&#96; (
    &#96;id&#96; int primary key auto_increment comment &#39;学生id&#39;, -- 学生id
	&#96;name&#96; varchar (30) not null comment &#39;学生姓名&#39;, -- 学生姓名
	&#96;phone&#96; varchar (36) not null comment &#39;学生电话&#39;, -- 学生电话
	&#96;youth_league_branch_name&#96; varchar (60) not null comment &#39;所属团支部名称&#39;, -- 所属团支部名称
	&#96;study_time&#96; datetime not null comment &#39;学习时间&#39;,  -- 学习时间
    &#96;gmt_create&#96; datetime null default current_timestamp comment &#39;记录创建时间&#39;, -- 记录创建时间
    &#96;gmt_modified&#96; datetime null default current_timestamp on update current_timestamp comment &#39;记录最近修改时间&#39;, -- 记录最近修改时间
    &#96;youth_league_branch_id&#96; int not null -- 所属团支部id 
); </code></pre>
<ul>
<li>在<code>student</code>外面加上引号是为了设置大小写敏感，否则所有的大写都会被自动转换为小写。</li>
</ul>
<p>JSON parse error: Cannot deserialize value of type <code>java.util.Date</code> from String “2020-11-24”: expected format “yyyy-MM-dd HH:mm:ss”; nested exception is com.fasterxml.jackson.databind.exc.InvalidFormatException: Cannot deserialize value of type <code>java.util.Date</code> from String “2020-11-24”: expected format “yyyy-MM-dd HH:mm:ss” at [Source: (PushbackInputStream); line: 1, column: 30] (through reference chain: com.zw.admin.server.model.TSchedule[“deadline”])</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Servlet/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Servlet/index.html" class="post-title-link" itemprop="url">Servlet</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-10 07:40:40" itemprop="dateCreated datePublished" datetime="2020-10-10T07:40:40+08:00">2020-10-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:27:52" itemprop="dateModified" datetime="2022-09-17T19:27:52+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web后端</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="servlet简介"><a class="markdownIt-Anchor" href="#servlet简介"></a> servlet简介</h1>
<ul>
<li>Servlet：即Server Applet。</li>
<li>Servlet其实就是一个遵循Servlet开发的<strong>java类</strong>。Servlet是由<strong>服务器调用的，运行在服务器端</strong>。Servlet<strong>没有main方法</strong>，它的创建、使用、销毁都由Servlet容器(即web服务器）进行管理（如Tomcat：提供了Servlet功能的服务器称作Servlet容器）。即虽然没有main方法，但是通过Servlet容器可以自动调用。</li>
<li>servelet用来实现对服务器的动态资源的控制。</li>
<li>servelet就是一个<strong>接口</strong>，定义了java类被浏览器访问的规则。</li>
<li>我们需要自定义一个类，这个类<strong>实现servelet接口，复写其方法</strong>。</li>
<li>Servlet带给我们最大的作用就是能够<strong>处理浏览器带来HTTP请求</strong>，并<strong>返回一个响应</strong>给浏览器，从而实现<strong>浏览器和服务器的交互</strong>。servlet是作用于服务器这一端。</li>
</ul>
<h1 id="快速入门"><a class="markdownIt-Anchor" href="#快速入门"></a> 快速入门</h1>
<h2 id="idea上配置tomcat"><a class="markdownIt-Anchor" href="#idea上配置tomcat"></a> IDEA上配置tomcat</h2>
<ul>
<li>使用的ide是IDEA，需要先在IDEA上配置Tomcat。(需要IDEA的utilmate版).
<ol>
<li>点击Run—EDit Configurations…<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201010165243.jpg" alt="" /><br />
2.点击左侧“+”号，找到Tomcat Server—Local。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201010165641.jpg" alt="" /><br />
3.找到tomcat存放位置并配置到idea中：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201010165926.jpg" alt="" /></li>
</ol>
</li>
<li>IDEA会为每一个tomcat部署的项目单独建立一份配置文件
<ul>
<li>查看控制台的log找到这个配置文件的存储位置：<code>CATALINA_BASE: /home/zestaken/.cache/JetBrains/IntelliJIdea2020.2/tomcat/Tomcat_9_0_411_tomcat3</code></li>
</ul>
</li>
<li>WEB-INF目录下的资源不能被浏览器直接访问。</li>
</ul>
<h2 id="编写servlet程序的步骤"><a class="markdownIt-Anchor" href="#编写servlet程序的步骤"></a> 编写servlet程序的步骤</h2>
<ol>
<li>创建<strong>javaEE</strong>项目</li>
<li>定义一个类，实现Servlet接口：<code>public class ServletDemo1 implements Servlet</code></li>
<li>实现接口中的抽象方法</li>
<li>配置servlet，在web.xml中</li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!-- 配置Servlet --&gt;
&lt;servlet&gt;
        &lt;servlet-name&gt;demo1&lt;&#x2F;servlet-name&gt;
        &lt;servlet-class&gt;web.ServletDemo1&lt;&#x2F;servlet-class&gt;
    &lt;&#x2F;servlet&gt;
    
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;demo1&lt;&#x2F;servlet-name&gt;
        &lt;url-pattern&gt;&#x2F;demo1&lt;&#x2F;url-pattern&gt;
    &lt;&#x2F;servlet-mapping&gt;</code></pre>
<h1 id="执行原理解析过程"><a class="markdownIt-Anchor" href="#执行原理解析过程"></a> 执行原理/解析过程</h1>
<ol>
<li>当服务器接受到浏览器的请求后，会解析URL路径，获取访问的<strong>Servlet</strong>的资源路径。</li>
<li>查找web.xml文件，是否有对应的<code>&lt;url-pattern&gt;</code>标签内容。</li>
<li>如果有，则再找到对应的<code>&lt;servlet-class&gt;</code>全类名。</li>
<li>tomcat会将字节码文件加载进内存，并且创建其对象。</li>
<li>调用其方法。</li>
</ol>
<h1 id="生命周期"><a class="markdownIt-Anchor" href="#生命周期"></a> 生命周期</h1>
<ul>
<li>方法</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">import javax.servlet.*;
import java.io.IOException;

public class ServletDemo1 implements Servlet &#123;
    &#x2F;**
     * 初始化方法
     * 在servlet被创建时执行，只会执行一次
     * @param servletConfig
     * @throws ServletException
     *&#x2F;
    @Override
    public void init(ServletConfig servletConfig) throws ServletException &#123;
        System.out.println(&quot;init&quot;);
    &#125;

    &#x2F;**
     * 获取ServletConfig对象
     * ServletConfig：Servlet的配置对象
     * @return
     *&#x2F;
    @Override
    public ServletConfig getServletConfig() &#123;
        return null;
    &#125;

    &#x2F;**
     * 提供服务的方法
     * 每一次Servlet被访问时，执行，可以执行多次（每刷新一次页面都会执行一次）
     * @param servletRequest
     * @param servletResponse
     * @throws ServletException
     * @throws IOException
     *&#x2F;
    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;
        System.out.println(&quot;service&quot;);
    &#125;

    &#x2F;**
     * 获取Servlet的一些信息，版本，作者等。
     * @return
     *&#x2F;
    @Override
    public String getServletInfo() &#123;
        return null;
    &#125;

    &#x2F;**
     * 销毁方法
     * 在服务器正常关闭时执行一次。
     *&#x2F;
    @Override
    public void destroy() &#123;
        System.out.println(&quot;destroy&quot;);
    &#125;
&#125;</code></pre>
<ul>
<li>生命周期
<ol>
<li>被创建：执行init方法，只执行一次,一般用于<strong>加载资源</strong>.
<ol>
<li>Servlet被创建的时间
<ol>
<li>默认情况下，第一次被访问时（即在浏览器中访问该页面时），Servlet被创建</li>
<li>可以在web.xml配置执行Servlet的创建时间：
<ul>
<li>在<code>&lt;servlet&gt;</code>标签下配置
<ol>
<li>第一次被访问时创建:<code>&lt;load-on-startup&gt;</code>的值为负数</li>
<li>在服务器启动时创建：<code>&lt;load-on-startup&gt;</code>的值为0或者正数。</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li>Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的
<ol>
<li>多个用户同时访问时，可能存在线程安全问题。</li>
<li>解决：尽量不再在Servlet中定义成员变量，即使定义了，也不要修改它。</li>
</ol>
</li>
</ol>
</li>
<li>提供服务：执行service方法，可执行多次
<ol>
<li>每次被访问Servlet时，Service方法都会被调用一次。</li>
</ol>
</li>
<li>被销毁：执行destroy方法，只执行一次
<ol>
<li>Servlet被销毁时执行。</li>
<li>服务器关闭时，Servlet被销毁</li>
<li>只有服务器正常关闭时，才会执行destroy方法</li>
<li>destroy方法在Servlet被销毁之前执行，一般用于<strong>释放资源</strong>。</li>
</ol>
</li>
</ol>
</li>
</ul>
<h1 id="注解配置"><a class="markdownIt-Anchor" href="#注解配置"></a> 注解配置</h1>
<ul>
<li>Servlet3.0之后，**支持注解配置，可以不用写web.xml了。</li>
<li>步骤：
<ol>
<li>创建JavaEE项目，选择Servlet的版本3.0以上，<strong>可以不创建web.xml</strong>(也可以创建，因为注解配置会覆盖web.xml的配置)</li>
<li>定义一个类，实现Servlet接口;</li>
<li>复写方法;</li>
<li>在类上使用<code>@WebServlet</code>注解，进行配置：
<ol>
<li><code>@WebServlet(loadOnStartup=&quot;资源路径名&quot;)</code>与<code>@WebServlet(value=&quot;资源路径名&quot;)</code>与<code>@WebServlet(&quot;资源路径名&quot;)</code>等效。</li>
</ol>
</li>
</ol>
</li>
<li><code>@WebServlet</code>注解的具体内容：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package javax.servlet.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(&#123;ElementType.TYPE&#125;)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface WebServlet &#123;
    String name() default &quot;&quot;;

    String[] value() default &#123;&#125;;

    String[] urlPatterns() default &#123;&#125;;

    int loadOnStartup() default -1;

    WebInitParam[] initParams() default &#123;&#125;;

    boolean asyncSupported() default false;

    String smallIcon() default &quot;&quot;;

    String largeIcon() default &quot;&quot;;

    String description() default &quot;&quot;;

    String displayName() default &quot;&quot;;
&#125;</code></pre>
<h2 id="urlparttern的配置"><a class="markdownIt-Anchor" href="#urlparttern的配置"></a> urlparttern的配置</h2>
<ul>
<li>一个Servlet可以定义多个访问路径，<code>@WebServlet(&#123;&quot;/d4&quot;.&quot;/dd4&quot;&#125;)</code>,如果只有一个路径，则大括号可以省略。</li>
<li>路径的定义规则：
<ol>
<li><code>/xxx</code>;</li>
<li><code>/xxx/xxx</code>:多层路径，目录结构(不止可以写两层，可以写更多层)</li>
<li><code>*.xxx</code>:不管.之前写的是什么，只要最后的后缀一样即可访问。一般是<code>*.do</code>形式。</li>
</ol>
</li>
<li>通配符<code>*</code>:<code>*</code>所占的位置输入任何名字都可以，但是优先级很低（即如果有那个名字的资源，则访问那个资源）。</li>
</ul>
<h1 id="servlet的体系结构"><a class="markdownIt-Anchor" href="#servlet的体系结构"></a> Servlet的体系结构</h1>
<ul>
<li>Servlet接口：最上层。</li>
<li>GenericServlet:实现了Servlet接口的<strong>抽象类</strong>,处于第二层。
<ul>
<li>将Servlet接口中的其他的方法都做了默认空实现，只将service()方法作为抽象。</li>
<li>将来定义Servlet的类时，可以继承GenericServlet，实现<strong>service()方法即可</strong>。（但是不常用）</li>
</ul>
</li>
<li>HttpServlet：继承自GenricServlet的<strong>抽象类</strong>,处于第三层。
<ul>
<li>所有方法都没有要求实现。</li>
<li>对http协议的一种封装，简化操作。</li>
<li>使用：
<ul>
<li>定义类继承HttpServlet</li>
<li>复写doGet()/doPost()等方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="javaweb的目录结构"><a class="markdownIt-Anchor" href="#javaweb的目录结构"></a> JAVAWEB的目录结构</h1>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201009104107.png" alt="" /></p>
<ul>
<li>bbs目录代表一个web应用</li>
<li>bbs目录下的html,jsp文件可以直接被浏览器访问</li>
<li>WEB-INF目录下的资源是<strong>不能直接被浏览器访问</strong>的</li>
<li><code>web.xml</code>文件是web程序的<strong>主要配置文件</strong>。</li>
<li>所有的<strong>classes</strong>文件都放在classes目录下</li>
<li><strong>jar文件</strong>放在lib目录下。</li>
</ul>
<h1 id="request对象和resoponse对象"><a class="markdownIt-Anchor" href="#request对象和resoponse对象"></a> Request对象和Resoponse对象</h1>
<h2 id="服务器与客户端交互流程"><a class="markdownIt-Anchor" href="#服务器与客户端交互流程"></a> 服务器与客户端交互流程</h2>
<ol>
<li>tomcat服务器会根据请求url中的资源路径创建对应的<strong>实现Servlet的类的对象</strong>;</li>
<li>tomcat<strong>服务器</strong>会创建<strong>request</strong>和<strong>response</strong>对象，request对象中封装请求的消息数据;</li>
<li>tomcat将request和response对象传递给<strong>service</strong>方法，并且调用service方法;</li>
<li>程序员通过request对象<strong>获取请求的消息数据</strong>，通过response对象**设置响应的消息数据;</li>
<li>服务器在给浏览器做出响应之前会从<strong>response对象</strong>中拿程序员设置的响应消息数据。</li>
</ol>
<h2 id="request对象"><a class="markdownIt-Anchor" href="#request对象"></a> Request对象</h2>
<ul>
<li>原理：
<ul>
<li>request对象和reponse对象是由服务器创建的;</li>
<li>request对象获取请求消息，response对象设置响应消息。</li>
</ul>
</li>
<li>request对象的继承体系结构：
<ol>
<li>ServletRequest:最上层接口;</li>
<li>HttpServletRequest:继承自ServletRequest的接口;</li>
<li>org.apache.catalina.connector.RequestFacade：tomcat实现的实现了HttpServlet接口的类。</li>
</ol>
</li>
</ul>
<h3 id="request功能"><a class="markdownIt-Anchor" href="#request功能"></a> request功能</h3>
<h4 id="获取请求消息数据"><a class="markdownIt-Anchor" href="#获取请求消息数据"></a> 获取请求消息数据</h4>
<ol>
<li>获取请求行数据：（get方式就放在doget方法中，POST方法则放在dopost方法中）</li>
<li><strong>获取虚拟目录</strong>：<code>/tomcat3_war_exploded</code></li>
<li><code>String getContextPath();</code></li>
<li><strong>获取请求的URI或URL</strong>:
<ol>
<li><code>String getRequestURI();</code>:获取URI，如：<code>/tomcat3_war_exploded/ServletDemo3</code></li>
<li><code>String getRequestURL();</code>获取URL，如：<code>http://localhost:8080/tomcat3_war_exploded/ServletDemo3</code></li>
<li>URI和URL都是<strong>统一资源定位符</strong>,但是URI表示的范围比URL大。</li>
</ol>
</li>
<li>获取Servlet路径：<code>/ServletDemo3</code>
<ol>
<li><code>String getServletPath();</code></li>
</ol>
</li>
<li>获取get方式请求参数：
<ol>
<li><code>String getQueryString();</code>,如：<code>name=%22zhangsan%22&amp;age=13</code></li>
</ol>
</li>
<li>获取请求头数据：
<ol>
<li><code>String getHeader(String name)</code>:通过请求头的名称获取请求头的数据;</li>
<li><code>Enumeration&lt;String&gt; getHeaderName()</code>:获取所有的请求头数据;</li>
</ol>
</li>
<li>获取请求体数据：
<ol>
<li>请求体：只有POST方式才有。</li>
<li>步骤：
<ol>
<li>获取流对象：
<ol>
<li><code>BufferedReader getReader();</code>获取字符输入流，只能操作字符数据;</li>
<li><code>ServletInputStream getInputStream()</code>:获取字节输入流，可以操作所有类型的数据；</li>
</ol>
</li>
<li>从流对象中将数据拿出来</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="获取请求参数的通用方式"><a class="markdownIt-Anchor" href="#获取请求参数的通用方式"></a> 获取请求参数的通用方式</h4>
<ul>
<li>不论是get还是post方式都可以使用。（如果doget和dopost的代码完全一样的话，在doget里写<code>this.doPost()</code>即可)</li>
</ul>
<ol>
<li><strong>根据参数名称来获取参数值</strong>:<code>String getParameter(String name)</code>，如果一个参数有多个值的话，则无法获取完。</li>
<li>根据参数名称来获取参数值的数组：<code>String[] getParameterValues(String name)</code>;</li>
<li>获取所有请求的参数名称：<code>Enumeration&lt;String&gt; getParameterNames()</code>;</li>
<li><strong>获取所有参数的Map集合</strong>：<code>Map&lt;String, String[]&gt; getParameterMap()</code>。</li>
</ol>
<ul>
<li>获取请求参数的中文乱码问题：
<ul>
<li>get方式：tomcat 8 已经将get方式乱码问题解决了;</li>
<li>post方式：在获取参数前，设置request的编码<code>request.setCharacterEncoding(&quot;utf-8&quot;);</code></li>
</ul>
</li>
</ul>
<h4 id="请求转发forward"><a class="markdownIt-Anchor" href="#请求转发forward"></a> 请求转发(forward)</h4>
<ul>
<li>在服务器内部之间的资源跳转方式。</li>
<li>步骤：
<ol>
<li>通过request对象来获取请求转发器对象：<code>RequestDispatcher getRequestDispatcher(String path)</code></li>
<li>使用RequestDispatcher对象来进行转发：<code>forward(ServletRequest request, ServletResponse response)</code></li>
<li>示例：<code>request.getRequestDispathcher(&quot;/ServletDemo4&quot;).forward(request,response)</code></li>
</ol>
</li>
<li>特点：
<ul>
<li>浏览器地址栏路径不会发生变化;</li>
<li>只能转发到当前服务器内部资源中;</li>
<li>转发是一次请求（即多个资源共用一次请求的信息）。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210106131528.png" alt="" /></li>
</ul>
</li>
</ul>
<h4 id="共享数据"><a class="markdownIt-Anchor" href="#共享数据"></a> 共享数据</h4>
<ul>
<li>域对象：一个有作用范围的对象，可以在范围内共享数据;</li>
<li>request域：代表<strong>一次请求</strong>的范围，一般用于请求转发的多个资源中共享数据;</li>
<li>request共享数据的方法：
<ul>
<li>存储数据：<code>void setAttribute(String name, Object obj)</code>;</li>
<li>通过键获取值：<code>Object getAttribute(String name)</code>;</li>
<li>通过键移除值对：<code>void removeAttribute(String name)</code>;</li>
</ul>
</li>
</ul>
<h4 id="获取servletcontext对象"><a class="markdownIt-Anchor" href="#获取servletcontext对象"></a> 获取ServletContext对象</h4>
<ul>
<li>request对象获取ServletContext对象的方法：<code>ServletContext getServletContext();</code></li>
</ul>
<h2 id="response对象"><a class="markdownIt-Anchor" href="#response对象"></a> Response对象</h2>
<ul>
<li>功能：设置响应消息</li>
<li>设置<strong>响应消息</strong>:
<ul>
<li><code>setStatus(int sc)</code></li>
</ul>
</li>
<li>设置<strong>响应头</strong>:
<ul>
<li><code>setHeader(String name , String value)</code></li>
</ul>
</li>
<li>设置<strong>响应体</strong>:
<ol>
<li>获取输出流：
<ol>
<li>字符输出流：<code>PrintWrtier getWriter()</code></li>
<li>字节输出流：<code>ServletOutputStream getOutputStream()</code></li>
</ol>
</li>
<li>使用输出流：将数据输出到客户端浏览器。</li>
</ol>
</li>
</ul>
<h3 id="使用案例"><a class="markdownIt-Anchor" href="#使用案例"></a> 使用案例</h3>
<h4 id="重定向redirect"><a class="markdownIt-Anchor" href="#重定向redirect"></a> 重定向（redirect)</h4>
<ul>
<li>资源的跳转方式</li>
<li>方式一：逐步设置响应状态码和响应头</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet(&quot;&#x2F;ServletDemo2&quot;)
public class ServletDemo2 extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;

     System.out.println(&quot;demo2&quot;);
    resp.setStatus(302);
    resp.setHeader(&quot;location&quot;, &quot;&#x2F;tomcat3_war_exploded&#x2F;ServletDemo3&quot;);
    &#125;
&#125;

@WebServlet(&quot;&#x2F;ServletDemo3&quot;)
public class ServletDemo3 extends HttpServlet &#123;
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;

    &#125;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;

        System.out.println(&quot;demo3&quot;);
    &#125;
&#125;</code></pre>
<ul>
<li>方式二：直接使用<code>sendRedirect</code>方法</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet(&quot;&#x2F;ServletDemo2&quot;)
public class ServletDemo2 extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;

     System.out.println(&quot;demo2&quot;);
     &#x2F;&#x2F;动态获取虚拟目录
     String contextPath &#x3D; req.getContextPath();
     resp.sendRedirect(contextpath+&quot;&#x2F;ServletDemo3&quot;);
    &#x2F;&#x2F; resp.sendRedirect(&quot;&#x2F;tomcat3_war_exploded&#x2F;ServletDemo3&quot;);
    &#125;
&#125;

@WebServlet(&quot;&#x2F;ServletDemo3&quot;)
public class ServletDemo3 extends HttpServlet &#123;
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;

    &#125;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;

        System.out.println(&quot;demo3&quot;);
    &#125;
&#125;</code></pre>
<ul>
<li>转发的特点：
<ul>
<li>浏览器地址栏路径不会发生变化;</li>
<li>只能转发到当前服务器内部资源中;</li>
<li>转发是一次请求（即多个资源共用一次请求的信息），可以使用request对象来共享数据。</li>
</ul>
</li>
<li>重定向的特点：
<ul>
<li>浏览器地址栏路径<strong>会发生变化</strong>;</li>
<li>重定向可以访问**其他站点（服务器）**资源;</li>
<li>重定向是<strong>两次请求</strong>。<strong>不能使用request对象来共享数据</strong>。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210106130407.png" alt="" /></li>
</ul>
</li>
<li>动态方式获取<strong>虚拟目录</strong>。<code>String contextPath = request.getContextPath();</code></li>
<li>路径写法：
<ul>
<li>相对路径：
<ul>
<li>不以<code>/</code>开头，以<code>.</code>开头;</li>
<li>规则：
<ul>
<li><code>./</code>：当前目录下;</li>
<li><code>../</code>：上一级目录下;</li>
</ul>
</li>
</ul>
</li>
<li>绝对路径：
<ul>
<li>以<code>/</code>开头的路径;</li>
<li>给客户端浏览器使用的绝对路径需要加<strong>虚拟目录</strong>(项目的访问路径);
<ul>
<li>建议虚拟目录动态获取;</li>
<li>如：重定向中使用的路径是<code>/tomcat3_war_exploded/ServletDemo3</code></li>
</ul>
</li>
<li>给服务器使用，不需要加虚拟目录;
<ul>
<li>如转发中使用的路径：<code>/ServletDemo3</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="服务器输出字符数据到浏览器"><a class="markdownIt-Anchor" href="#服务器输出字符数据到浏览器"></a> 服务器输出字符数据到浏览器</h4>
<ul>
<li>步骤：
<ol>
<li>获取字符输出流：<code>PrintWriter pw = response.getWriter();</code>(获取的流的默认编码是ISO-8859-1)</li>
<li>输出数据：<code>pw.write(&quot;你好 response&quot;)</code></li>
<li>流对象是由response创建的，会随着response的关闭而关闭，不用再人为的close。</li>
</ol>
</li>
<li>中文乱码问题：
<ul>
<li>原因：因为浏览器使用的字符集和服务器使用的字符集不一致导致的。</li>
<li>需要在<strong>获取字符输出流之前</strong>返回一个告诉浏览器服务器返回消息使用的字符集和格式：
<ul>
<li>通过设置content-type头的内容来解决：<code>response.setHeader(&quot;content-type&quot;, &quot;text/html;charset=utf-8&quot;);</code></li>
<li>response对象有一个内置的简化方法：<code>responde.setContentType(&quot;text/html;charset=utf-8&quot;);</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="服务器输出字节数据到浏览器"><a class="markdownIt-Anchor" href="#服务器输出字节数据到浏览器"></a> 服务器输出字节数据到浏览器</h4>
<ul>
<li>步骤：
<ol>
<li>获取字节输出流：<code>ServletOutputStream sos = response.getOutputStream();</code></li>
<li>输出数据：<code>sos.write(&quot;你好&quot;.getBytes(&quot;utf-8&quot;));</code></li>
</ol>
</li>
<li>还是需要在<strong>获取字节输出流之前</strong>通知浏览器字符集的设置。</li>
</ul>
<h4 id="服务器验证码"><a class="markdownIt-Anchor" href="#服务器验证码"></a> 服务器验证码</h4>
<ul>
<li>验证码的作用：防止恶意重复提交表单。（机器人）</li>
<li>实现的功能，服务器自动生成验证码图片，并且对图片进行美化。</li>
<li>步骤：
<ol>
<li>创建图片</li>
<li>美化图片（增加验证码的内容）</li>
<li>输出图片到浏览器上</li>
</ol>
</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">    &#x2F;&#x2F;图片长宽设置
    int width &#x3D; 100;
    int height &#x3D; 50;
    
    &#x2F;&#x2F;1.创建一对象，在内存中创建图片（验证码的图片）
    BufferedImage image &#x3D; new BufferedImage(width, height,BufferedImage.TYPE_INT_RGB);

    &#x2F;&#x2F;2.美化图片
    Graphics g &#x3D; image.getGraphics();&#x2F;&#x2F;获取画笔对象
    g.setColor(Color.PINK);&#x2F;&#x2F;设置画笔颜色
    g.fillRect(0,0,width,height);&#x2F;&#x2F;填充背景色
    g.setColor(Color.BLACK);&#x2F;&#x2F;设置画笔颜色
    g.drawRect(0,0,width-1, height - 1);&#x2F;&#x2F;画边框

    String str &#x3D; &quot;QWERTYUIOOOOOPASDFGHJKKLZXCVBNMMqwertyuiopasdfghjklzxcvbnm0123456789&quot;;&#x2F;&#x2F;设置可以写到验证码图片上的字符
    Random random &#x3D; new Random();&#x2F;&#x2F;获取生成随机数的对象
    &#x2F;&#x2F;将随即字符写到图片上去
    for(int i &#x3D; 1; i &lt; 5; i++) &#123;
        int index &#x3D; random.nextInt(str.length());&#x2F;&#x2F;获取在字符串大小范围内的随机索引值
        char ch &#x3D; str.charAt(index);
        g.drawString(ch+&quot;&quot;, width&#x2F;5*i ,height&#x2F;2);
    &#125;
    
    &#x2F;&#x2F;画干扰线
    g.setColor(Color.GREEN);

    &#x2F;&#x2F;生成随机坐标来划线
    for(int i &#x3D; 0; i &lt; 10; i++) &#123;
        int x1 &#x3D; random.nextInt(width);
        int x2 &#x3D; random.nextInt(width);
        int y1 &#x3D; random.nextInt(height);
        int y2 &#x3D; random.nextInt(height);
        g.drawLine(x1,y1,x2,y2);
    &#125;

    &#x2F;&#x2F;3.将图片输出到浏览器上
    ImageIO.write(image, &quot;jpg&quot;, resp.getOutputStream());
&#125;</code></pre>
<h1 id="servletcontext对象"><a class="markdownIt-Anchor" href="#servletcontext对象"></a> ServletContext对象</h1>
<ol>
<li>概念:代表整个web应用（一个web应用里只有唯一的一个ServletContext对象），可以和程序的容器（服务器）来通信;</li>
<li>获取ServletContext对象：
<ol>
<li>通过Request对象来获取:<code>request.getServletContext();</code></li>
<li>通过HttpServlet获取（我们创建的Servlet类都是从这里继承的）：<code>this.getServletContext();</code></li>
</ol>
</li>
<li>方法：
<ol>
<li>获取MIME类型：
<ol>
<li>MIME类型：在互联网通信过程中定义的一种文件数据类型，格式为：<code>大类型/小类型</code>，如：<code>text/html</code>,<code>image/jpeg</code>.</li>
<li>获取的方法：<code>String getMIMEType(String file)</code>,参数是文件名称;</li>
</ol>
</li>
<li>作为域对象：
<ol>
<li>ServletContext对象的范围：所有用户所有请求的数据;</li>
<li><code>setAttribute(String name, Object value);</code></li>
<li><code>getAttribute(String name)</code></li>
<li><code>removeAttribute(String name)</code></li>
</ol>
</li>
<li>获取文件的真实（服务器）路径：
<ol>
<li>我们经常需要使用的是一个文件部署到服务器上的路径，而不是该文件在本地工作空间的路径;</li>
<li>方法：<code>String getRealPath(String path)</code></li>
<li>参数：文件在本地工作空间的相对路径
<ol>
<li>在web目录下的资源：<code>/文件名</code></li>
<li>在WEB_INF目录下的资源：<code>/WEB-INF/文件名</code></li>
<li>在源文件（src目录或者java目录下）的资源：<code>/WEB-INF/classes/文件名</code></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Tomcat/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Tomcat/index.html" class="post-title-link" itemprop="url">Tomcat</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-08 16:42:03" itemprop="dateCreated datePublished" datetime="2020-10-08T16:42:03+08:00">2020-10-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:27:52" itemprop="dateModified" datetime="2022-09-17T19:27:52+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">Web后端</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="tomcat简介"><a class="markdownIt-Anchor" href="#tomcat简介"></a> Tomcat简介</h1>
<ul>
<li>Tomcat 服务器是一个免费的开放源代码的<strong>Web 应用服务器</strong>，属于轻量级应用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a>，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。Tomcat是一个使别人能够访问我写的页面的一个程序。</li>
<li>Tomcat与servlet以及数据库的关系：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201008164643.png" alt="" /></li>
</ul>
<h1 id="tomcat的安装"><a class="markdownIt-Anchor" href="#tomcat的安装"></a> Tomcat的安装</h1>
<ul>
<li>
<p>Tomcat需要jdk的支持，需要先在电脑上装上jdk，Tomcat会在环境变量中去寻找jdk的支持。</p>
</li>
<li>
<p>去<a target="_blank" rel="noopener" href="https://tomcat.apache.org">官网</a>下载Windows系统的tomcat安装器：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201008165449.jpg" alt="" /></p>
</li>
<li>
<p>找到Tomcat安装目录的bin目录中的startup.bat文件，打开得到如下界面：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201008170319.jpg" alt="" /></p>
</li>
<li>
<p>之后再浏览器地址栏输入http://localhost:8080成功显示出如下界面，则证明Tomcat的配置成功了。<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201008170513.jpg" alt="" /></p>
</li>
<li>
<p>如果要卸载，则删除目录即可。</p>
</li>
</ul>
<h1 id="tomcat的基础知识"><a class="markdownIt-Anchor" href="#tomcat的基础知识"></a> Tomcat的基础知识</h1>
<h2 id="链接url简介"><a class="markdownIt-Anchor" href="#链接url简介"></a> 链接URL简介</h2>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201008173307.png" alt="" /></p>
<h2 id="tomcat的目录结构"><a class="markdownIt-Anchor" href="#tomcat的目录结构"></a> Tomcat的目录结构</h2>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201008173457.png" alt="" /></p>
<ul>
<li>conf文件：
<ul>
<li><code>server.xml</code>该文件用于配置server相关的信息，比如tomcat启动的端口号，配置主机(Host)</li>
<li><code>web.xml</code>文件配置与web应用（web应用相当于一个web站点）</li>
<li><code>tomcat-user.xml</code>配置用户名密码和相关权限.</li>
</ul>
</li>
<li>work文件：
<ul>
<li>work工作目录：该目录用于存放<strong>jsp被访问后生成对应的server文件和.class文件</strong></li>
</ul>
</li>
</ul>
<h2 id="启动"><a class="markdownIt-Anchor" href="#启动"></a> 启动</h2>
<ul>
<li>bin/startup.bat:运行该文件</li>
<li>访问；浏览器输入：
<ul>
<li><code>http://localhost:8080</code> 访问自己</li>
<li><code>http://别人的IP地址：8080</code> 访问别人</li>
<li>8080是Tomcat的默认端口号。</li>
<li>可能遇到的问题：
<ul>
<li>黑窗口一闪而过：
<ul>
<li>原因：没有配置好JAVA_HOME</li>
</ul>
</li>
<li>启动报错：
<ol>
<li>原因：端口号被占用</li>
<li>解决方案：
<ol>
<li>找到占用的端口号对应的进程，杀死该进程
<ol>
<li>找到进程：<code>netstat -ano</code></li>
<li>杀死进程：<code>taskkill /pid 进程号 -t -f</code></li>
</ol>
</li>
<li>修改自身的端口号
<ol>
<li>修改conf/server.xml下的默认端口号</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="关闭"><a class="markdownIt-Anchor" href="#关闭"></a> 关闭</h2>
<ul>
<li>正常关闭
<ul>
<li>bin/shutdown.bat</li>
<li>ctrl+c</li>
</ul>
</li>
<li>强制关闭
<ul>
<li>点击启动窗口的x</li>
</ul>
</li>
</ul>
<h2 id="动态项目和静态项目"><a class="markdownIt-Anchor" href="#动态项目和静态项目"></a> 动态项目和静态项目</h2>
<ul>
<li>目录结构：
<ul>
<li>java动态项目：
<ul>
<li>项目名称
<ul>
<li>WEB-INF
<ul>
<li>web.xml:该项目的核心配置文件</li>
<li>classes目录：放置了字节码文件</li>
<li>lib目录：放置项目依赖的jar包</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h1>
<ul>
<li>部署项目的方式
<ol>
<li>直接将项目放到webapps目录下
<ol>
<li>创建一个项目目录，在这个目录中放置资源文件，启动这个项目需要使用在端口地址后增加<code>/项目目录名/资源文件名</code>，
<ol>
<li><code>/项目目录名</code>:项目的的访问路径-&gt;<strong>虚拟项目</strong>。</li>
</ol>
</li>
<li>简化部署：将项目打包成一个war包，直接放到webapps目录下，tomcat会自动解压缩这个包。</li>
</ol>
</li>
<li>配置虚拟目录法</li>
</ol>
</li>
</ul>
<h2 id="webapps目录部署项目"><a class="markdownIt-Anchor" href="#webapps目录部署项目"></a> webapps目录部署项目</h2>
<ul>
<li>
<p><strong>在webapps中建立了web1目录</strong>，下面放置我们的html文件，jsp文件，图片等等，<strong>则web1就被当做web应用管理起来</strong>。示例：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201009103542.jpg" alt="" /></p>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201009103533.jpg" alt="" /></p>
<ul>
<li>注意路径是严格大小写的，路径出错是无法显示的。</li>
</ul>
</li>
<li>
<p>web站点的目录规范：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201009104107.png" alt="" /></p>
<ul>
<li>
<p>作用：我有多个html文件，想把其中的一个html文件作为我web站点的首页。如果没有WEB-INF目录下的web.xml文件支持，是无法解决我的需求的。这个规范是约定熟成的。</p>
</li>
<li>
<p>web.xml使helloworld2.html做首页示例：</p>
<ul>
<li>新建一个WEB-INF目录<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201009151532.jpg" alt="" /></li>
<li>在WEB-INF目录下创建一个web.xml</li>
<li>web.xml我们不可能会写，所以可以<strong>在webapps目录下其他的站点中抄一份过来</strong>【复制ROOT/WEB-INF/web.xml的文件到自己的站点中】</li>
<li>在web.xml中添加以下代码</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;welcome-file-list&gt;
      &lt;welcome-file&gt;helloworld2.html&lt;&#x2F;welcome-file&gt;
&lt;&#x2F;welcome-file-list&gt;</code></pre>
<ul>
<li>最终的web.xml如图：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201009151441.jpg" alt="" /></li>
<li>在浏览器输入<code>localhost:8080/web1/</code>得：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201009151224.jpg" alt="" />
<ul>
<li>因为已经规定了首页为helloworld2.html所以无需指明具体的html文件。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="配置虚拟目录"><a class="markdownIt-Anchor" href="#配置虚拟目录"></a> 配置虚拟目录</h2>
<ul>
<li>
<p>虚拟目录的作用：</p>
<ul>
<li>如果把所有web站点的目录都放在webapps下，可能导致<strong>磁盘空间不够用</strong>，也<strong>不利于对web站点目录的管理</strong>【如果存在非常多的web站点目录】</li>
<li>把<strong>web站点的目录分散到其他磁盘管理就需要配置虚拟目录【默认情况下，只有webapps下的目录才能被Tomcat自动管理成一个web站点】</strong></li>
<li>把web应用所在目录交给web服务器管理，这个过程称之为虚拟目录的映射。</li>
</ul>
</li>
<li>
<p>虚拟目录的配置方法一（不推荐使用）：</p>
<ul>
<li>在其他地方创建一个web站点目录，并创建WEB-INF目录和一个html文件。<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201009152314.jpg" alt="" /></li>
<li>找到Tomcat目录下**/conf/server.xml**文件</li>
<li>在server.xml中的<Host>节点下添加如下代码。<strong>path表示的是访问时输入的web项目名，docBase表示的是站点目录的绝对路径</strong><code>&lt;Context path=&quot;/web&quot; docBase=&quot;C:\03Temporary\web&quot;/&gt;</code></li>
<li>最后访问配置好的站点:<code>localhost:8080/web/helloworld.html</code>.
<ul>
<li>注：需要重启tomcat，配置文件才能生效。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>虚拟目录的配置方法二（最推荐部署项目的方法）：</p>
<ul>
<li>
<p>进入到conf/Catalina/localhost文件下，创建一个xml文件，<strong>该文件的名字就是站点的名字。</strong>（此处名为<code>hello3.xml</code>）</p>
</li>
<li>
<p>xml文件中的内容：</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;Context docBase&#x3D;&quot;C:\03Temporary\web1&quot; &#x2F;&gt;  </code></pre>
</li>
<li>
<p>输入<code>localhost:8080/hello3/helloworld.html</code>来访问页面。结果如图：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201009181521.jpg" alt="" /></p>
</li>
<li>
<p>修改文件后就会<strong>立即生效</strong>，不需要重启服务器，是一种热部署的方式。</p>
</li>
</ul>
</li>
</ul>
<h1 id="将tomcat集成到idea"><a class="markdownIt-Anchor" href="#将tomcat集成到idea"></a> 将Tomcat集成到IDEA</h1>
<ul>
<li>实际操作界面和教程完全不同，如何解决？</li>
</ul>
<h1 id="配置临时域名"><a class="markdownIt-Anchor" href="#配置临时域名"></a> 配置临时域名</h1>
<p>访问Tomcat服务器有好几种方式：</p>
<ul>
<li>
<p>使用localhost域名访问【localhost代表本机】</p>
</li>
<li>
<p>使用ip地址127.0.0.1访问【该ip地址也是本机】</p>
</li>
<li>
<p>使用机器名称访问【只限用于本机上或者局域网】</p>
</li>
<li>
<p>使用本机IP地址访问【<strong>在cmd中输入ipconfig可以查询到本机IP地址</strong>】</p>
</li>
<li>
<p>还可以为机器配置临时域名。</p>
</li>
<li>
<p>示例：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201009183154.jpg" alt="" /></p>
</li>
</ul>
<p>配置临时域名的步骤：</p>
<ul>
<li>
<p>打开到C:Windows/System32/drivers/etc下，找到hosts文件，在其中添加<code>127.0.0.1 localhost</code>和<code>127.0.0.1 zhangjie</code>两行。<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201009182837.jpg" alt="" /></p>
</li>
<li>
<p>在浏览器中输入<code>zhangjie:8080/hello3/helloworld.html</code>访问失败d是因为没有保存修改后的hosts文件，保存后可以正常运行。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201010074530.jpg" alt="" /></p>
</li>
</ul>
<h1 id="配置虚拟主机"><a class="markdownIt-Anchor" href="#配置虚拟主机"></a> 配置虚拟主机</h1>
<h3 id="什么是虚拟主机"><a class="markdownIt-Anchor" href="#什么是虚拟主机"></a> 什么是虚拟主机？</h3>
<ul>
<li><strong>多个不同域名的网站共存于一个Tomcat中</strong></li>
</ul>
<h3 id="为什么需要用到虚拟主机"><a class="markdownIt-Anchor" href="#为什么需要用到虚拟主机"></a> 为什么需要用到虚拟主机？</h3>
<ul>
<li>例子：我现在开发了4个网站，有4个域名。如果我不配置虚拟主机，一个Tomcat服务器运行一个网站，我就需要4台电脑才能把4个网站运行起来。</li>
</ul>
<p>配置虚拟主机的步骤：</p>
<ul>
<li>
<p>在tomcat的server.xml文件中添加主机名，添加内容如下：</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;&#x2F;Host&gt;

      &lt;Host name&#x3D;&quot;zhang&quot; appBase&#x3D;&quot;C:\03Temporary\web1&quot;&gt;
                    &lt;Context path&#x3D;&quot;&#x2F;web1&quot; docBase&#x3D;&quot;C:\03Temporary\web1&quot;&#x2F;&gt;
      &lt;&#x2F;Host&gt;</code></pre>
</li>
<li>
<p>之后在浏览器输入<code>zhang:8080/hello3/helloworld.html</code>来访问。结果失败。。。</p>
</li>
</ul>
<h1 id="tomcat的结构体系"><a class="markdownIt-Anchor" href="#tomcat的结构体系"></a> Tomcat的结构体系</h1>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201009184720.png" alt="" /></p>
<h1 id="浏览器访问web资源的流程图"><a class="markdownIt-Anchor" href="#浏览器访问web资源的流程图"></a> 浏览器访问WEB资源的流程图</h1>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201009184857.png" alt="" /></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">蜀ICP备2021022902号-1 </a>
      <img src="/images/beian_icon.png" alt="">
  </div>
  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Zestaken</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">678k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:17</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js" integrity="sha256-4mJNT2bMXxcc1GCJaxBmMPdmah5ji0Ldnd79DKd1hoM=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha256-AjM0J5XIbiB590BrznLEgZGLnOQWrt62s3BEq65Q/I0=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha256-9cmf7tcLdXpKsPi/2AWE93PbZpTp4M4tqzFk+lWomjU=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
