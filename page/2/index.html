<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.zestaken.top","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":true,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="吾好梦中读书~">
<meta property="og:type" content="website">
<meta property="og:title" content="ZestJourney">
<meta property="og:url" content="http://www.zestaken.top/page/2/index.html">
<meta property="og:site_name" content="ZestJourney">
<meta property="og:description" content="吾好梦中读书~">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zestaken">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://www.zestaken.top/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ZestJourney</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ZestJourney</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">乐游记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zestaken</p>
  <div class="site-description" itemprop="description">吾好梦中读书~</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">84</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">60</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/Python%E6%96%87%E6%9C%AC%E8%AF%BB%E5%86%99/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/Python%E6%96%87%E6%9C%AC%E8%AF%BB%E5%86%99/index.html" class="post-title-link" itemprop="url">Python文件读写</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-12 15:01:19" itemprop="dateCreated datePublished" datetime="2021-10-12T15:01:19+08:00">2021-10-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:41:21" itemprop="dateModified" datetime="2022-09-17T19:41:21+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="读取文本文件"><a class="markdownIt-Anchor" href="#读取文本文件"></a> 读取文本文件</h1>
<h2 id="读取文本文件的基本函数"><a class="markdownIt-Anchor" href="#读取文本文件的基本函数"></a> 读取文本文件的基本函数</h2>
<ul>
<li>以只读模式打开文件：r代表读取模式，若文件不存在则会报错。</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">fp &#x3D; open(&quot;iris.txt&quot;, &quot;r&quot;)
print(file)</code></pre>
<pre><code>out: &lt;_io.TextIOWrapper name='iris.txt' mode='r' encoding='UTF-8'&gt;
</code></pre>
<ul>
<li>一次读入文件的一行，然后“游标&quot;自动转到文件的下一行首</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">fp.readline() # 读取一行</code></pre>
<pre><code>'150\t4\tsetosa\tversicolor\tvirginica\n'
</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">fp.readline() #再一次调用，则已经读到下一行</code></pre>
<pre><code>'5.1\t3.5\t1.4\t0.2\t0\n'
</code></pre>
<ul>
<li>一次读取到文件末尾</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">fp.readlines()</code></pre>
<pre><code>['4.9\t3\t1.4\t0.2\t0\n',
 '4.7\t3.2\t1.3\t0.2\t0\n',
 '4.6\t3.1\t1.5\t0.2\t0\n',
	......
 '6.5\t3\t5.2\t2\t2\n',
 '6.2\t3.4\t5.4\t2.3\t2\n',
 '5.9\t3\t5.1\t1.8\t2\n']
</code></pre>
<ul>
<li>将游标跳到文件开始位置</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">fp.seek(0) # 将游标跳到第一行再读取一行，则又读到了文件的第一行
fp.readline()</code></pre>
<pre><code>'150\t4\tsetosa\tversicolor\tvirginica\n' 
</code></pre>
<ul>
<li>close关闭文件</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">fp.close() # 关闭文件后再次读取就会报错：在关闭的文件上进行IO操作
fp.readline()</code></pre>
<pre><code>---------------------------------------------------------------------------

ValueError                                Traceback (most recent call last)

&lt;ipython-input-9-f83b4d936024&gt; in &lt;module&gt;
      1 fp.close()
----&gt; 2 fp.readline()


ValueError: I/O operation on closed file.
</code></pre>
<h2 id="三种读取文本文件全部数据的方法"><a class="markdownIt-Anchor" href="#三种读取文本文件全部数据的方法"></a> 三种读取文本文件全部数据的方法</h2>
<ul>
<li>
<ol>
<li>打开文件，利用while循环，一行行的readline</li>
</ol>
</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">fp &#x3D; open(&quot;iris.txt&quot;, &quot;r&quot;)
line &#x3D; fp.readline()
while line:
    print(line) #因为是使用print打印输出，\n等转义符号都已转义后输出，不再保持原样
    line &#x3D; fp.readline()
fp.close()</code></pre>
<pre><code>150	4	setosa	versicolor	virginica

5.1	3.5	1.4	0.2	0

4.9	3	1.4	0.2	0

......

5.9	3	5.1	1.8	2
</code></pre>
<ul>
<li>
<ol start="2">
<li>打开文件，通过for in循环来遍历文件指针来获取文件的每一行</li>
</ol>
</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">fp &#x3D; open(&quot;iris.txt&quot;)
for line2 in fp: # 遍历的是文件指针，能够自动获得每一行的内容
    print(line2)
fp.close()</code></pre>
<pre><code>150	4	setosa	versicolor	virginica

5.1	3.5	1.4	0.2	0

4.9	3	1.4	0.2	0

4.7	3.2	1.3	0.2	0

.......

5.9	3	5.1	1.8	2
</code></pre>
<ul>
<li>
<ol start="3">
<li>打开文件，先读取文件的全部内容（readlines）存入一个对象中，然后通过for in循环遍历这个对象，获取每一行的内容</li>
</ol>
</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">fp &#x3D; open(&quot;iris.txt&quot;)
lines &#x3D; fp.readlines()
for line in lines: #遍历的是存储所有文件内容的对象
    print(line)
fp.close()</code></pre>
<pre><code>150	4	setosa	versicolor	virginica

5.1	3.5	1.4	0.2	0

4.9	3	1.4	0.2	0

.......

5.9	3	5.1	1.8	2
</code></pre>
<h1 id="读取csv文件"><a class="markdownIt-Anchor" href="#读取csv文件"></a> 读取CSV文件</h1>
<h2 id="读取csv文件的基本函数"><a class="markdownIt-Anchor" href="#读取csv文件的基本函数"></a> 读取CSV文件的基本函数</h2>
<ul>
<li>导入Pandas包（需要提前安装好，我是使用Anaconda管理这些包）</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import pandas as pd</code></pre>
<ul>
<li>采用pandas中的函数将csv表格形式文件直接读取到一个Pyhton的<strong>DataFrame</strong>对象中，常用的函数有read_csv和read_table函数</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">df &#x3D; pd.read_csv(&#39;iris.csv&#39;) # 结果存储在DataFrame对象中
df # 直接查看DataFrame对象中内容</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>150</th>
      <th>4</th>
      <th>setosa</th>
      <th>versicolor</th>
      <th>virginica</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>5.1</td>
      <td>3.5</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4.9</td>
      <td>3.0</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>4.7</td>
      <td>3.2</td>
      <td>1.3</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4.6</td>
      <td>3.1</td>
      <td>1.5</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5.0</td>
      <td>3.6</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>145</th>
      <td>6.7</td>
      <td>3.0</td>
      <td>5.2</td>
      <td>2.3</td>
      <td>2</td>
    </tr>
    <tr>
      <th>146</th>
      <td>6.3</td>
      <td>2.5</td>
      <td>5.0</td>
      <td>1.9</td>
      <td>2</td>
    </tr>
    <tr>
      <th>147</th>
      <td>6.5</td>
      <td>3.0</td>
      <td>5.2</td>
      <td>2.0</td>
      <td>2</td>
    </tr>
    <tr>
      <th>148</th>
      <td>6.2</td>
      <td>3.4</td>
      <td>5.4</td>
      <td>2.3</td>
      <td>2</td>
    </tr>
    <tr>
      <th>149</th>
      <td>5.9</td>
      <td>3.0</td>
      <td>5.1</td>
      <td>1.8</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
<p>150 rows × 5 columns</p>
</div>
<ul>
<li>
<p>最左列为自动生成的索引</p>
</li>
<li>
<p>DataFrame对象非常适合处理表格数据</p>
</li>
<li>
<p><code>read_table</code>不仅可以读取csv文件（以,分隔的表格型文件),还可以读取以其它方式分隔的表格，所以需要设置分隔符</p>
</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">df &#x3D; pd.read_table(&quot;iris.csv&quot;, sep &#x3D; &#39;,&#39;) # 设置分隔符为,，才能处理csv文件
df</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>150</th>
      <th>4</th>
      <th>setosa</th>
      <th>versicolor</th>
      <th>virginica</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>5.1</td>
      <td>3.5</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4.9</td>
      <td>3.0</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>4.7</td>
      <td>3.2</td>
      <td>1.3</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4.6</td>
      <td>3.1</td>
      <td>1.5</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5.0</td>
      <td>3.6</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>145</th>
      <td>6.7</td>
      <td>3.0</td>
      <td>5.2</td>
      <td>2.3</td>
      <td>2</td>
    </tr>
    <tr>
      <th>146</th>
      <td>6.3</td>
      <td>2.5</td>
      <td>5.0</td>
      <td>1.9</td>
      <td>2</td>
    </tr>
    <tr>
      <th>147</th>
      <td>6.5</td>
      <td>3.0</td>
      <td>5.2</td>
      <td>2.0</td>
      <td>2</td>
    </tr>
    <tr>
      <th>148</th>
      <td>6.2</td>
      <td>3.4</td>
      <td>5.4</td>
      <td>2.3</td>
      <td>2</td>
    </tr>
    <tr>
      <th>149</th>
      <td>5.9</td>
      <td>3.0</td>
      <td>5.1</td>
      <td>1.8</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
<p>150 rows × 5 columns</p>
</div>
<h2 id="逐块的读取文件一次读取其中几行"><a class="markdownIt-Anchor" href="#逐块的读取文件一次读取其中几行"></a> 逐块的读取文件（一次读取其中几行):</h2>
<ul>
<li>逐块读取文件的两种方法
<ul>
<li>设置nrows参数</li>
<li>或者chunksize参数,但是将文件按块存储在一个TextParser对象中</li>
</ul>
</li>
<li><code>read_table</code>设置nrows参数</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">df5 &#x3D; pd.read_table(&#39;iris.csv&#39;, sep &#x3D; &#39;,&#39;, nrows&#x3D;5)
df5</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>150</th>
      <th>4</th>
      <th>setosa</th>
      <th>versicolor</th>
      <th>virginica</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>5.1</td>
      <td>3.5</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4.9</td>
      <td>3.0</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>4.7</td>
      <td>3.2</td>
      <td>1.3</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4.6</td>
      <td>3.1</td>
      <td>1.5</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5.0</td>
      <td>3.6</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>
<ul>
<li><code>read-_csv</code>设置nrows参数</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">df5 &#x3D; pd.read_csv(&quot;iris.csv&quot;, nrows&#x3D;5)
df5</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>150</th>
      <th>4</th>
      <th>setosa</th>
      <th>versicolor</th>
      <th>virginica</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>5.1</td>
      <td>3.5</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4.9</td>
      <td>3.0</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>4.7</td>
      <td>3.2</td>
      <td>1.3</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4.6</td>
      <td>3.1</td>
      <td>1.5</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5.0</td>
      <td>3.6</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>
<ul>
<li><code>read_csv</code>函数设置chunksize参数</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">chunk &#x3D; pd.read_csv(&quot;iris.csv&quot;, chunksize&#x3D;5)
chunk</code></pre>
<pre><code>&lt;pandas.io.parsers.TextFileReader at 0x7f824f359cd0&gt;
</code></pre>
<ul>
<li>使用设置chuncksize参数生成的textparser对象对文件进行逐块迭代</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">tot &#x3D; 0
for piece in chunk:
    tot &#x3D; tot + 1
    print(piece)
    print(&quot;-------&quot;)
print(tot) # 总共有150行，每5行一块有30块，存储在这些块存储在chunk对象中</code></pre>
<pre><code>   150    4  setosa  versicolor  virginica
0  5.1  3.5     1.4         0.2          0
1  4.9  3.0     1.4         0.2          0
2  4.7  3.2     1.3         0.2          0
3  4.6  3.1     1.5         0.2          0
4  5.0  3.6     1.4         0.2          0
-------
   150    4  setosa  versicolor  virginica
5  5.4  3.9     1.7         0.4          0
6  4.6  3.4     1.4         0.3          0
7  5.0  3.4     1.5         0.2          0
8  4.4  2.9     1.4         0.2          0
9  4.9  3.1     1.5         0.1          0
-------

.......

     150    4  setosa  versicolor  virginica
145  6.7  3.0     5.2         2.3          2
146  6.3  2.5     5.0         1.9          2
147  6.5  3.0     5.2         2.0          2
148  6.2  3.4     5.4         2.3          2
149  5.9  3.0     5.1         1.8          2
-------
30
</code></pre>
<h1 id="写入文本文件"><a class="markdownIt-Anchor" href="#写入文本文件"></a> 写入文本文件</h1>
<ul>
<li>创建文件对象，使用w模式写入,w模式是覆盖式写入，一旦用w模式打开文件，文件中之前的内容全都删除了，若文件不存在则会先创建再写入。</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">myData &#x3D; [&#39;Date&#39;, &#39;Time&#39;] #创建测试的数据</code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">myfile &#x3D; open(&quot;test.txt&quot;,&#39;w&#39;) #用w模式打开文件
for line in myData:
    myfile.write(line+&#39;\n&#39;)
myfile.close()</code></pre>
<ul>
<li>以r模式打开文件，检查写入文件是否成功</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">myfile &#x3D; open(&quot;test.txt&quot;, &#39;r&#39;)
print(myfile.read())</code></pre>
<pre><code>Date
Time
</code></pre>
<ul>
<li>使用a模式可以追加写</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">print(&quot;写之前输出：&quot;)
myfile1 &#x3D; open(&quot;test.txt&quot;, &#39;r&#39;)
print(myfile1.read())

myfile2 &#x3D; open(&quot;test.txt&quot;, &#39;a&#39;)
myfile2.write(&quot;a&quot;)

print(&quot;写之后输出：&quot;)
myfile3 &#x3D; open(&quot;test.txt&quot;, &#39;r&#39;)
print(myfile3.read())</code></pre>
<pre><code>写之前输出：
Date
Time

写之后输出：
Date
Time
a
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/LeetCode-%E6%A0%91/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/LeetCode-%E6%A0%91/index.html" class="post-title-link" itemprop="url">LeetCode-树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-26 10:20:59" itemprop="dateCreated datePublished" datetime="2021-09-26T10:20:59+08:00">2021-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:41:21" itemprop="dateModified" datetime="2022-09-17T19:41:21+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-二叉树的最大深度-104"><a class="markdownIt-Anchor" href="#1-二叉树的最大深度-104"></a> 1. 二叉树的最大深度 104</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">题目</a></li>
</ul>
<hr />
<p>给定一个二叉树，找出其最大深度。<br />
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br />
说明: 叶子节点是指没有子节点的节点。<br />
示例：<br />
给定二叉树 <code>[3,9,20,null,null,15,7]</code><br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/hKwQG4.png" alt="hKwQG4" /><br />
返回它的最大深度 3 。</p>
<h2 id="java解法"><a class="markdownIt-Anchor" href="#java解法"></a> Java解法</h2>
<ul>
<li>法一：递归进行深度优先搜索：将一一颗二叉树划为三个部分：根节点，左子树，右子树，子树的高度加上根节点的高度（1）就是整颗二叉树的高度。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/Su4uv1.png" alt="Su4uv1" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MaximumDepthOfBinaryTree104 &#123;

    public int maxDepth(TreeNode root) &#123;
        &#x2F;&#x2F;利用递归的思想来求解
        &#x2F;&#x2F;将一一颗二叉树划为三个部分：根节点，左子树，右子树，子树的高度加上根节点的高度（1）就是整颗二叉树的高度
        &#x2F;&#x2F;实质是深度优先搜索
        if(root !&#x3D; null) &#123;
            &#x2F;&#x2F;注意要加上代表根节点的1
            int depth &#x3D; 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
            return depth;
        &#125; else &#123;
            &#x2F;&#x2F;当当前二叉树的根节点为null时返回0，也是递归到底返回的条件
            return 0;
        &#125;
    &#125;
&#125;

&#x2F;&#x2F;根据一个数组构造二叉树的方法
    &#x2F;**
     * 输入值的数组，生成二叉树（null用-1替代）
     * @param nums
     * @return
     *&#x2F;
    public static TreeNode mkBT(int[] nums) &#123;
        &#x2F;&#x2F;当数组长度为0时，直接返回空
         if(nums.length &#x3D;&#x3D; 0) &#123;
             return null;
         &#125;
        &#x2F;&#x2F;先根据数组依次生成节点，存储到集合中
        ArrayList&lt;TreeNode&gt; treeNodes &#x3D; new ArrayList&lt;&gt;();
        for(int i : nums) &#123;
            if(i &#x3D;&#x3D; -1) &#123;
                treeNodes.add(null);
            &#125; else &#123;
                treeNodes.add(new TreeNode(i));
            &#125;
         &#125;
        &#x2F;&#x2F;遍历前一半的节点（因为只有这些节点不是叶子节点）
        &#x2F;&#x2F; 根据子节点与根节点的下标对应关系，找到每一个非叶子节点的左右子节点并连接
         for(int i &#x3D; 0; i &lt; nums.length &#x2F; 2; i++) &#123;
             TreeNode cur &#x3D; treeNodes.get(i);
             cur.left &#x3D; treeNodes.get(2 * (i + 1) - 1);
             cur.right &#x3D; treeNodes.get(2 * (i + 1) + 1 - 1);
         &#125;
        &#x2F;&#x2F;返回总的根节点（就是集合中的第一个节点）
         return treeNodes.get(0);
    &#125;</code></pre>
<h1 id="2-平衡二叉树-110"><a class="markdownIt-Anchor" href="#2-平衡二叉树-110"></a> 2. 平衡二叉树 110</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree/">题目</a></li>
</ul>
<hr />
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。<br />
本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。<br />
示例 1：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/IGtDFV.jpg" alt="IGtDFV" /></p>
<pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [3,9,20,null,null,15,7]
输出：true</code></pre>
<p>示例2:<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/JRslxu.jpg" alt="JRslxu" /></p>
<pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [1,2,2,3,3,null,null,4,4]
输出：false</code></pre>
<p>示例3:</p>
<pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; []
输出：true</code></pre>
<p>提示：<br />
树中的节点数在范围 [0, 5000] 内<br />
-104 &lt;= Node.val &lt;= 104</p>
<h2 id="java解法-2"><a class="markdownIt-Anchor" href="#java解法-2"></a> Java解法</h2>
<ul>
<li>法一：递归获取左右子树的高度，并比较，如果高度差不大于1，则正常返回左右子树中最大高度，否则返回-1。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/V0Yg9H.png" alt="V0Yg9H" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BalancedBinaryTree110 &#123;

    public boolean isBalanced(TreeNode root) &#123;
        if (getDepth(root) !&#x3D; -1) &#123;
            return true;
        &#125;
        return false;
    &#125;

    &#x2F;**
     * 递归获取左右子树的高度并比较，如果高度差大于1，则返回-1
     * @param root
     * @return
     *&#x2F;
    int getDepth(TreeNode root) &#123;
        &#x2F;&#x2F;当root为null，说明已遍历到底部，返回0
        if(root &#x3D;&#x3D; null) &#123;
            return 0;
        &#125;
        &#x2F;&#x2F;获取左右子树的高度，并比较
        int left &#x3D; getDepth(root.left);
        int right &#x3D; getDepth(root.right);
        &#x2F;&#x2F;如果左右子树高度返回为-1，说明左右子树内部高度差超过了1
        if(left &#x3D;&#x3D; -1 || right &#x3D;&#x3D; -1 ||Math.abs(left - right) &gt; 1) &#123;
            return -1;
        &#125;
        &#x2F;&#x2F;如果正常，返回左右子树中的最大高度
        return 1 + Math.max(left, right);
    &#125;
&#125;</code></pre>
<h1 id="3-二叉树的直径-543"><a class="markdownIt-Anchor" href="#3-二叉树的直径-543"></a> 3. 二叉树的直径 543</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">题目</a></li>
</ul>
<hr />
<p>示例 :<br />
给定二叉树<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/JuYUaG.png" alt="JuYUaG" /><br />
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。<br />
注意：两结点之间的路径长度是以它们之间边的数目表示。</p>
<h2 id="java解法-3"><a class="markdownIt-Anchor" href="#java解法-3"></a> Java解法</h2>
<ul>
<li>法一：递归获取左右子树的节点数，每层相对根节点都根据左右子树节点数计算直径，最后选择最大的直径。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/lGTZ2E.png" alt="lGTZ2E" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DiameterOfBinaryTree543 &#123;

    &#x2F;&#x2F;记录直径值，设为类属性便于在方法间传递
    int diameter;

    public int diameterOfBinaryTree(TreeNode root) &#123;
        &#x2F;&#x2F;将初始直径设置为0
        diameter &#x3D; 0;
        &#x2F;&#x2F;获取二叉树的深度的同时修改最长直径值
        getDepth(root);
        return diameter;
    &#125;

    &#x2F;**
     * 递归获取二叉树的深度的同时修改最长直径值
     * @param root
     * @return
     *&#x2F;
    int getDepth(TreeNode root) &#123;
        &#x2F;&#x2F;当当前根节点为null，说明已经递归到了叶子节点，触底返回
        if(root &#x3D;&#x3D; null) &#123;
            return 0;
        &#125;
        &#x2F;&#x2F;获取左右子树的节点数（不加一是除去了根节点，以防计算直径的时候重复计算）
        int left &#x3D; getDepth(root.left);
        int right &#x3D; getDepth(root.right);
        &#x2F;&#x2F;当前节点为根节点时的最长直径是左右子树的节点数相加
        &#x2F;&#x2F;每次比较当前节点下的最长直径与前面直径，取最大值（因为最长直径必然经过某个相对根节点）
        diameter &#x3D; Math.max(left + right, diameter);
        &#x2F;&#x2F;返回左右子树的深度（加一算上当前根节点）
        return Math.max(left, right) + 1;
    &#125;
&#125;</code></pre>
<h1 id="4-路径总和-iii-437"><a class="markdownIt-Anchor" href="#4-路径总和-iii-437"></a> 4. 路径总和 III 437</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-iii/">题目</a></li>
</ul>
<hr />
<p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。<br />
示例 1：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/n1g3RH.jpg" alt="n1g3RH" /></p>
<pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], targetSum &#x3D; 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。</code></pre>
<p>示例2:</p>
<pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22
输出：3</code></pre>
<p>提示:</p>
<pre class="line-numbers language-none"><code class="language-none">二叉树的节点个数的范围是 [0,1000]
-109 &lt;&#x3D; Node.val &lt;&#x3D; 109 
-1000 &lt;&#x3D; targetSum &lt;&#x3D; 1000 </code></pre>
<h2 id="java解法-4"><a class="markdownIt-Anchor" href="#java解法-4"></a> Java解法</h2>
<ul>
<li>法一：
<ul>
<li>结果：</li>
<li>代码：</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%96%87/%E4%BA%BA%E6%96%87/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%96%87/%E4%BA%BA%E6%96%87/index.html" class="post-title-link" itemprop="url">人文</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-02 18:19:25" itemprop="dateCreated datePublished" datetime="2021-09-02T18:19:25+08:00">2021-09-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-09-23 23:03:52" itemprop="dateModified" datetime="2021-09-23T23:03:52+08:00">2021-09-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%96%87/" itemprop="url" rel="index"><span itemprop="name">文</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>58</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="我的书库"><a class="markdownIt-Anchor" href="#我的书库"></a> <a target="_blank" rel="noopener" href="https://www.wolai.com/zestaken/2Ex2nyQw1tJZm6TTXJb1zP?theme=light">我的书库</a></h1>
<blockquote>
<p>吾好梦中读书~</p>
</blockquote>
<ul>
<li>点击<a target="_blank" rel="noopener" href="https://www.wolai.com/zestaken/2Ex2nyQw1tJZm6TTXJb1zP?theme=light">我的书库</a>链接或者以下图片进入书库。<br />
<a target="_blank" rel="noopener" href="https://www.wolai.com/zestaken/2Ex2nyQw1tJZm6TTXJb1zP?theme=light"><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210918173443.png" alt="" /></a></li>
</ul>
<h1 id="我的视频库"><a class="markdownIt-Anchor" href="#我的视频库"></a> <a target="_blank" rel="noopener" href="https://www.wolai.com/zestaken/uuy4VDmPrTqA8UrZh5AdPC?theme=light">我的视频库</a></h1>
<blockquote>
<p>永远记录~</p>
</blockquote>
<ul>
<li>点击<a target="_blank" rel="noopener" href="https://www.wolai.com/zestaken/uuy4VDmPrTqA8UrZh5AdPC?theme=light">我的视频库</a>或以下图片进入视频库。<br />
<a target="_blank" rel="noopener" href="https://www.wolai.com/zestaken/uuy4VDmPrTqA8UrZh5AdPC?theme=light"><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210918173748.png" alt="" /></a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E9%A1%B9%E7%9B%AE/Java%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E9%BB%84%E9%87%91%E7%9F%BF%E5%B7%A5/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E9%A1%B9%E7%9B%AE/Java%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E9%BB%84%E9%87%91%E7%9F%BF%E5%B7%A5/index.html" class="post-title-link" itemprop="url">Java实现简易黄金矿工</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-01 18:20:59" itemprop="dateCreated datePublished" datetime="2021-09-01T18:20:59+08:00">2021-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:41:21" itemprop="dateModified" datetime="2022-09-17T19:41:21+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="项目地址"><a class="markdownIt-Anchor" href="#项目地址"></a> 项目地址</h1>
<ul>
<li>点击图片跳转到项目源码地址。<br />
<a target="_blank" rel="noopener" href="https://github.com/zestaken/GoldMiner"><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210901222738.png" alt="" /></a></li>
</ul>
<h1 id="游戏玩法"><a class="markdownIt-Anchor" href="#游戏玩法"></a> 游戏玩法</h1>
<ul>
<li>本游戏仿制于童年经典游戏黄金矿工。</li>
<li>主要操作有点击鼠标右键和点击鼠标左键。</li>
<li>在游戏进行界面，点击鼠标左键可伸长钩子抓取物体，在抓取到物体后点击鼠标右键可以使用药水，药水根据抓取的物体的种类不同有两种不同的效果：如果抓取到金块，则效果为加速钩子的收回；如果抓取到的物体是石块，则效果为石块从钩子上消失（无声爆破石块。。。）</li>
<li>游戏的积分设置：金块按照大小分为三种，积分从小到大依次为1，2， 4。每一关在规定时间内使积分达到目标积分则可通关，目前设置了8关。抓到石块没有积分。</li>
<li>游戏难度设置：抓取到越大的金块，钩子收回的速度越慢。抓到石块时，钩子收回的速度最慢。</li>
<li>游戏主要界面有三个：
<ul>
<li>游戏开始前界面：打开游戏进入该界面，点击鼠标右键即可正式开始游戏</li>
<li>游戏进行中界面：游戏运行界面，通过鼠标点击控制矿工抓取金块。</li>
<li>游戏商城界面：在每一关通关后，进入商城界面，在此处可以通过点击鼠标右键用积分购买一瓶药水。每一关只能购买一瓶药水，并且药水的价格是每一关随机的，所以尽可能获得更高的分数，以便通关后有能力购买药水。</li>
</ul>
</li>
</ul>
<h1 id="游戏实现思路"><a class="markdownIt-Anchor" href="#游戏实现思路"></a> 游戏实现思路</h1>
<ul>
<li>总的来说，这个简易的游戏采用面向对象的思想开发，所以我们就要思考这个游戏中有一些什么对象和这些对象的属性和行为？</li>
<li>游戏中的对象：
<ul>
<li>首先我们要知道这整个游戏是运行在一个窗口中，所以要有一个窗口对象：<code>GameWindow</code></li>
<li>其次在整个游戏中首先映入眼帘的就是游戏的背景，所以有一个背景对象：<code>Bg</code></li>
<li>游戏的主要模式就是用钩子抓取物体，而钩子的实质是一条线，所有有一个线对象：<code>Line</code></li>
<li>最后就是代表金块，石块等物体的物体对象：<code>Object</code></li>
</ul>
</li>
<li><code>GameWindow</code>对象：
<ul>
<li>属性：
<ul>
<li>在游戏窗口中，要包含其它所有对象，所以在<code>GameWindow</code>对象中要包含，<code>Bg, Line, Object</code>对象，其中因为一个窗口中会同时存在多个物体，所以要用一个集合来存储多个<code>Object</code>对象.</li>
<li>此外，因为游戏有多种状态和界面，所以要有一个标志游戏状态的属性。</li>
</ul>
</li>
<li>行为：
<ul>
<li>整个<code>GameWindow</code>主要实现三个功能：控制游戏窗口状态、监听鼠标动作、绘制物体和图片</li>
</ul>
</li>
</ul>
</li>
<li><code>Bg</code>对象：
<ul>
<li>属性：
<ul>
<li>因为在玩家的整个游戏过程中，有很多要全程保存的信息，考虑到背景对象是一直不发生大改变的，所以将玩家游戏过程中的信息记录在这个对象中，如：游戏分数，游戏时间，药水数量，药水价格等。</li>
</ul>
</li>
<li>行为：
<ul>
<li><code>Bg</code>对象的变化代表着游戏状态的变化，所以背景对象除了绘制背景图片和书写一些游戏信息外，还有游戏判断游戏计时是否结束，重新开始游戏这些涉及游戏状态改变的功能。</li>
</ul>
</li>
</ul>
</li>
<li><code>Line</code>对象
<ul>
<li>属性：
<ul>
<li>线对象的属性主要都是描述线在游戏中的状态的，如：线的起始坐标，线的长度，线的角度等。</li>
</ul>
</li>
<li>行为：
<ul>
<li>绘制不同游戏状态下的线</li>
<li>检测线与物体的接触状态来控制游戏状态切换</li>
</ul>
</li>
</ul>
</li>
<li><code>Object</code>对象
<ul>
<li>属性：
<ul>
<li>主要是标识物体性质的属性，如：物体的长宽，质量属性（用于计算线的拉取速度），积分价值，类型标识（金块还是石块），状态标识（是否被抓取），物体图片等。</li>
</ul>
</li>
<li>行为：
<ul>
<li>物体并没有特殊的行为</li>
</ul>
</li>
<li>继承关系：因为游戏中有两种不同的物体（金块、石块），所以二者分别继承自<code>Object</code>对象，并有自己的一些独特属性
<ul>
<li><code>Gold</code>对象：金块对象，通过内部类实现三种不同的金块</li>
<li><code>Rock</code>对象：石块对象。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="一些技术点"><a class="markdownIt-Anchor" href="#一些技术点"></a> 一些技术点</h1>
<ul>
<li>游戏界面的绘制通过Java提供的AWT（Abstract Window Toolkit）工具包和AWT的升级版Swing用户界面库来实现。</li>
<li>Java Swing绘图时的坐标和平常意义的不太一样：在图形坐标系中，其原点位于构件的左上角，坐标轴沿向下和右的方向增长，小圈代表坐标，正方形代表像素，坐标位于像素之间。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210905114505.png" alt="" /></li>
</ul>
<h2 id="双缓存解决图像闪动问题"><a class="markdownIt-Anchor" href="#双缓存解决图像闪动问题"></a> 双缓存解决图像闪动问题</h2>
<ul>
<li>问题出现的原因：因为整个窗口中有多个图像，它们是依次调用<code>paint</code>方法一个一个地画上去的，不同图像绘画的时间间隔就导致了闪动问题。</li>
<li>解决问题的思路：用一个新的画布，先将所有的图像都绘制到这个画布上，然后再将这个画布整体绘制到窗口中去，这样就不会有不同图像绘制的间隔时间，从而解决闪动问题。</li>
<li>代码分析</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
&#x2F;&#x2F;定义画布，用于实现双缓存
Image offScreenImage;

&#x2F;**
 * 传入画笔，绘制图片
 *&#x2F;
public void paint(Graphics g) &#123;
    &#x2F;&#x2F;初始化实现双缓存的画布，和窗口大小相同
    offScreenImage &#x3D; this.createImage(768, 1000);

    &#x2F;&#x2F;创建属于画布的画笔，调用这个画笔就是向这个画布上绘制
    Graphics gImage &#x3D; offScreenImage.getGraphics();

    &#x2F;&#x2F;将各种图案绘制到画布中,先画物体再画线使抓取时线在物体上面
    bg.paintSelf(gImage);

    &#x2F;&#x2F;仅在游戏状态才绘制物体和钩子
    if(state &#x3D;&#x3D; 1) &#123;
        &#x2F;&#x2F;遍历金块集合，将每个金块绘制出来
        for(Object obj : objs) &#123;
            obj.paintSelf(gImage);
        &#125;
        line.paintSelf(gImage);
    &#125;

    &#x2F;&#x2F;将画布绘制到窗口中,使用传入的画笔
    g.drawImage(offScreenImage, 0, 0, null);

&#125;</code></pre>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<ul>
<li>虽然是一个非常简单的游戏，但是这之中面向对象开发思想得到了淋漓尽致地体现。此外，今后对这种游戏的开发思路也有了一个大致地了解，以后玩游戏的时候看着游戏种种设计，也有了一个思考其实现方法的方向。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/LeetCode-%E5%93%88%E5%B8%8C%E8%A1%A8/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/LeetCode-%E5%93%88%E5%B8%8C%E8%A1%A8/index.html" class="post-title-link" itemprop="url">LeetCode-哈希表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-31 19:20:59" itemprop="dateCreated datePublished" datetime="2021-08-31T19:20:59+08:00">2021-08-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:41:21" itemprop="dateModified" datetime="2022-09-17T19:41:21+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="代码地址"><a class="markdownIt-Anchor" href="#代码地址"></a> 代码地址</h1>
<p><a target="_blank" rel="noopener" href="https://github.com/zestaken/newblog/tree/master/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/Code/src/main/java/hashTable">Github</a></p>
<h1 id="1-两数之和-1"><a class="markdownIt-Anchor" href="#1-两数之和-1"></a> 1. 两数之和 1</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum/">题目</a></li>
</ul>
<hr />
<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。<br />
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br />
你可以按任意顺序返回答案。</p>
<pre class="line-numbers language-none"><code class="language-none">示例 1：

输入：nums &#x3D; [2,7,11,15], target &#x3D; 9
输出：[0,1]
解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。
示例 2：

输入：nums &#x3D; [3,2,4], target &#x3D; 6
输出：[1,2]
示例 3：

输入：nums &#x3D; [3,3], target &#x3D; 6
输出：[0,1]
 

提示：

2 &lt;&#x3D; nums.length &lt;&#x3D; 104
-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109
-109 &lt;&#x3D; target &lt;&#x3D; 109
只会存在一个有效答案
进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？</code></pre>
<h2 id="java解法"><a class="markdownIt-Anchor" href="#java解法"></a> Java解法</h2>
<ul>
<li>法一: 首先遍历一次数组，将数组每个元素的值和下标以键值对的形式存入哈希表中，然后再次遍历数组，将目标值减去当前数组元素值得到一个结果，然后查询这个结果是否在哈希表中存在（注意避免查到自身的情况，如3 + 3 = 6）
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210831215434.png" alt="" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TwoSum1 &#123;

    public int[] twoSum(int[] nums, int target) &#123;

        &#x2F;&#x2F;创建哈希表，键为数组元素值，值为数组元素下标
        Map&lt;Integer, Integer&gt; hashtable &#x3D; new HashMap&lt;Integer, Integer&gt;();

        &#x2F;&#x2F;将数组元素的值和下标存入哈希表中
        for(int i &#x3D; 0; i &lt; nums.length; i++) &#123;
            hashtable.put(nums[i], i);
        &#125;

        &#x2F;&#x2F;存储结果的数组
        int[] res &#x3D; new int[2];
        &#x2F;&#x2F;遍历数组，将目标值减去数组元素值得到结果，然后查找哈希表中是否存在这个结果
        for(int i &#x3D; 0; i &lt; nums.length; i++) &#123;
            int temp &#x3D; target - nums[i];
            &#x2F;&#x2F;当在哈希表中查找到不是自身的数时，确认结果返回
            if(hashtable.containsKey(temp) &amp;&amp; hashtable.get(temp) !&#x3D; i) &#123;
                res[0] &#x3D; i;
                res[1] &#x3D; hashtable.get(temp);
                return res;
            &#125;
        &#125;

        return res;
    &#125;
&#125;</code></pre>
<h1 id="2-最长连续序列-128"><a class="markdownIt-Anchor" href="#2-最长连续序列-128"></a> 2. 最长连续序列 128</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">题目</a></li>
</ul>
<hr />
<p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。<br />
请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>
<pre class="line-numbers language-none"><code class="language-none">示例 1：

输入：nums &#x3D; [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
示例 2：

输入：nums &#x3D; [0,3,7,2,5,8,4,6,0,1]
输出：9
 

提示：

0 &lt;&#x3D; nums.length &lt;&#x3D; 105
-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</code></pre>
<h2 id="java解法-2"><a class="markdownIt-Anchor" href="#java解法-2"></a> Java解法</h2>
<ul>
<li>法一：用一个哈希集合存储数组元素（方便查找，同时去除重复的元素），然后遍历数组元素，已当前数组元素为中心向前和向后枚举与其连续的整数并在集合中查找，如果找到则在集合中删除该元素并且计数，如果没有找到则中断该方向的查找。每一次查找都能将一堆连续的数找到并清除出集合，在集合被清空时则确认得到了最长的连续整数长度。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210831231239.png" alt="" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class LongestConsecutiveSequence128 &#123;

    public int longestConsecutive(int[] nums) &#123;

        &#x2F;&#x2F;创建一个集合
        &#x2F;&#x2F;使用集合便于直接查找元素,并且利用集合的唯一性去除重复出现的元素
        Set&lt;Integer&gt; hashTable &#x3D; new HashSet&lt;&gt;();
        &#x2F;&#x2F;将数组中的值全部存入集合
        for(int i : nums) &#123;
            hashTable.add(i);
        &#125;

        &#x2F;&#x2F;最长长度
        int longestLength &#x3D; 0;

        &#x2F;&#x2F;遍历数组，在集合中找每一个数组元素的前后连续元素，然后将这些元素都删除并记录数量
        for(int num : nums) &#123;
            &#x2F;&#x2F;当集合已空则停止寻找连续元素
            if(!hashTable.isEmpty()) &#123;
                &#x2F;&#x2F;临时存储连续元素个数
                int tempRes &#x3D; 0;
                &#x2F;&#x2F;向左寻找当前元素的连续元素
                for(int i &#x3D; 0;  hashTable.contains(num - i); i++) &#123;
                    hashTable.contains(num - i);
                    hashTable.remove(num - i);
                    tempRes++;
                &#125;
                &#x2F;&#x2F;向右寻找当前元素的连续元素（不包含自身)
                for(int i &#x3D; 1; hashTable.contains(num + i); i++) &#123;
                    hashTable.contains(num + i);
                    hashTable.remove(num + i);
                    tempRes++;
                &#125;
                &#x2F;&#x2F;比较长短
                if(tempRes &gt; longestLength) &#123;
                    longestLength &#x3D; tempRes;
                &#125;
            &#125; else &#123;
                break;
            &#125;
        &#125;
        return longestLength;
    &#125;
&#125;</code></pre>
<h1 id="3-直线上最多的点数-149"><a class="markdownIt-Anchor" href="#3-直线上最多的点数-149"></a> 3. 直线上最多的点数 149</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-points-on-a-line/">题目</a></li>
</ul>
<hr />
<p>给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。求最多有多少个点在同一条直线上。<br />
示例1：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210831232314.png" alt="" /></p>
<pre class="line-numbers language-none"><code class="language-none">输入：points &#x3D; [[1,1],[2,2],[3,3]]
输出：3</code></pre>
<p>示例2：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210831232354.png" alt="" /></p>
<pre class="line-numbers language-none"><code class="language-none">输入：points &#x3D; [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
输出：4</code></pre>
<p>提示：</p>
<pre class="line-numbers language-none"><code class="language-none">1 &lt;&#x3D; points.length &lt;&#x3D; 300
points[i].length &#x3D;&#x3D; 2
-104 &lt;&#x3D; xi, yi &lt;&#x3D; 104
points 中的所有点 互不相同</code></pre>
<h2 id="java解法-3"><a class="markdownIt-Anchor" href="#java解法-3"></a> Java解法</h2>
<ul>
<li>法一：因为一条直线有一个点和斜率确定，所以我们遍历数组取出点，然后计算这个点与其它点的斜率，将这个斜率和其出现的次数存入哈希表中，在一个点与其它点的关系计算结束后，取出哈希表中出现次数最多的斜率，然后清空哈希表，进行下一轮的计算。因为一旦与前面的点能构成直线，在前面点计算时已经包含，所以只用计算当前点之后的点（按照在数组中出现的次序而言）。这个解法虽然通过了，但是有缺陷：如果计算的斜率超出了double的小数范围，就有可能不准确。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210901134149.png" alt="" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MaxPointsOnALine149 &#123;

    public int maxPoints(int[][] points) &#123;

        &#x2F;&#x2F;如果少于三个点则无需计算
        if(points.length &lt; 2) &#123;
            return points.length;
        &#125;
        &#x2F;&#x2F;创建哈希表，键为斜率，值为斜率出现的次数
        Map&lt;Double, Integer&gt; hashMap &#x3D; new HashMap&lt;&gt;();
        &#x2F;&#x2F;记录构成直线的最多点数
        int res &#x3D; 0;

        &#x2F;&#x2F;遍历点数组，计算之后的点与自己构成直线的次数（因为一旦与前面的点能构成直线，在前面点计算时已经包含，所以只用计算当前点之后的点）
        for(int i &#x3D; 0; i &lt; points.length; i++) &#123;
                &#x2F;&#x2F;斜率不存在的情况单独存储
                int sameX &#x3D; 1;
                &#x2F;&#x2F;遍历当前点之后的数组，将与当前点的斜率以及出现次数存入哈希表 
                for(int j &#x3D; i + 1; j &lt; points.length; j++) &#123;
                    &#x2F;&#x2F;当斜率存在时才计算
                    if((points[i][0] - points[j][0]) !&#x3D; 0) &#123;
                        &#x2F;&#x2F;计算斜率
                        double k &#x3D; ((double)(points[i][1] - points[j][1]))&#x2F;((double)(points[i][0] - points[j][0]));
                        &#x2F;&#x2F;因为哈希表判断键时将0 和 -0看作两个不同的数，所以需要处理一下
                        if(k &#x3D;&#x3D; -0) &#123;
                            k &#x3D; 0;
                        &#125;
                        &#x2F;&#x2F;查询哈希表中是否存在该斜率，如果存在则取出，如果不存在则初始为1（因为要包含自身，一旦构成直线就是两个点）
                        int count &#x3D; hashMap.getOrDefault(k, 1);
                        &#x2F;&#x2F;将该斜率的计数加一再存入哈希表中
                        count++;
                        hashMap.remove(k);
                        hashMap.put(k, count);
                    &#125; else &#123;
                        sameX++;
                    &#125;
                &#125;
                &#x2F;&#x2F;获取经过当前点构成直线的最多点数
                int temp &#x3D; 0;
                for(int count : hashMap.values()) &#123;
                    if(count &gt; temp) &#123;
                        temp &#x3D; count;
                    &#125;
                &#125;
                if(temp &lt; sameX) &#123;
                    temp &#x3D; sameX;
                &#125;
                &#x2F;&#x2F;如果经过当前点的构成直线的最多点数比以及统计的要多则赋给最后的结果
                if(temp &gt; res) &#123;
                    res &#x3D; temp;
                &#125;
                &#x2F;&#x2F;清空当前点构成的哈希表，进入下一个点的统计
                hashMap.clear();
        &#125;

        return res;
    &#125;
&#125;</code></pre>
<h1 id="4-重新安排行程-332"><a class="markdownIt-Anchor" href="#4-重新安排行程-332"></a> 4. 重新安排行程 332</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reconstruct-itinerary/">题目</a></li>
</ul>
<hr />
<p>给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。<br />
所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。<br />
例如，行程 <code>[&quot;JFK&quot;, &quot;LGA&quot;] 与 [&quot;JFK&quot;, &quot;LGB&quot;]</code> 相比就更小，排序更靠前。<br />
假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。<br />
示例1:<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/pz0dhe.jpg" alt="pz0dhe" /></p>
<pre class="line-numbers language-none"><code class="language-none">输入：tickets &#x3D; [[&quot;MUC&quot;,&quot;LHR&quot;],[&quot;JFK&quot;,&quot;MUC&quot;],[&quot;SFO&quot;,&quot;SJC&quot;],[&quot;LHR&quot;,&quot;SFO&quot;]]
输出：[&quot;JFK&quot;,&quot;MUC&quot;,&quot;LHR&quot;,&quot;SFO&quot;,&quot;SJC&quot;]</code></pre>
<p>示例2:<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/SIHzdm.jpg" alt="SIHzdm" /></p>
<pre class="line-numbers language-none"><code class="language-none">输入：tickets &#x3D; [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]
输出：[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]
解释：另一种有效的行程是 [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;] ，但是它字典排序更大更靠后。</code></pre>
<p>提示：</p>
<pre class="line-numbers language-none"><code class="language-none">1 &lt;&#x3D; tickets.length &lt;&#x3D; 300
tickets[i].length &#x3D;&#x3D; 2
fromi.length &#x3D;&#x3D; 3
toi.length &#x3D;&#x3D; 3
fromi 和 toi 由大写英文字母组成
fromi !&#x3D; toi</code></pre>
<h2 id="java解法-4"><a class="markdownIt-Anchor" href="#java解法-4"></a> Java解法</h2>
<ul>
<li>法一：
<ul>
<li>结果：</li>
<li>代码：</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/LeetCode-%E9%98%9F%E5%88%97/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/LeetCode-%E9%98%9F%E5%88%97/index.html" class="post-title-link" itemprop="url">LeetCode-队列</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-31 11:20:59" itemprop="dateCreated datePublished" datetime="2021-07-31T11:20:59+08:00">2021-07-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:41:21" itemprop="dateModified" datetime="2022-09-17T19:41:21+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="代码地址"><a class="markdownIt-Anchor" href="#代码地址"></a> 代码地址</h1>
<p><a target="_blank" rel="noopener" href="https://github.com/zestaken/newblog/tree/master/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/Code/src/main/java/queue">github</a></p>
<h1 id="1-合并k个升序链表-23"><a class="markdownIt-Anchor" href="#1-合并k个升序链表-23"></a> 1. 合并k个升序链表 23</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">题目</a></li>
</ul>
<hr />
<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p></p>
<p>示例 1：</p>
<pre class="line-numbers language-none"><code class="language-none">输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
将它们合并到一个有序链表中得到。
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
示例 2：

输入：lists &#x3D; []
输出：[]
示例 3：

输入：lists &#x3D; [[]]
输出：[]</code></pre>
<p>提示：</p>
<pre class="line-numbers language-none"><code class="language-none">k &#x3D;&#x3D; lists.length
0 &lt;&#x3D; k &lt;&#x3D; 10^4
0 &lt;&#x3D; lists[i].length &lt;&#x3D; 500
-10^4 &lt;&#x3D; lists[i][j] &lt;&#x3D; 10^4
lists[i] 按 升序 排列
lists[i].length 的总和不超过 10^4</code></pre>
<h2 id="java解法"><a class="markdownIt-Anchor" href="#java解法"></a> Java解法</h2>
<ul>
<li>法一：使用<a target="_blank" rel="noopener" href="https://www.apiref.com/java11-zh/java.base/java/util/PriorityQueue.html">优先队列</a>，开始将各个链表的头节点加入优先队列中，优先队列会自动按值大小顺序添加到队列中，之后弹出队列元素，因为链表自身是有序的，弹出的一定是当前最小的元素，之后将弹出元素的下一节点添加到优先队列中，则又会自动排序，直到队列为空时，所有链表的元素都已经添加完了。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/KM82lW.png" alt="KM82lW" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MergeKLists23 &#123;
    &#x2F;**
     * 创建一个实现Comparable接口的ListNode，作为优先队列的元素
     * 使用优先队列PriorityQueue需要实现Comparable接口
     *&#x2F;
    class Status implements Comparable&lt;Status&gt;&#123;
        int val;
        ListNode node;

        Status(int val, ListNode node) &#123;
            this.val &#x3D; val;
            this.node &#x3D; node;
        &#125;

        &#x2F;**
         * 新添加进优先队列的元素通过这个方法获得优先级，较小的元素优先级高放在队列前面
         * @param status2
         * @return
         *&#x2F;
        @Override
        public int compareTo(Status status2) &#123;
            return this.val - status2.val;
        &#125;
    &#125;

    public ListNode mergeKLists(ListNode[] lists) &#123;

        &#x2F;&#x2F;创建以Status作为元素的优先队列
        PriorityQueue&lt;Status&gt; queue &#x3D; new PriorityQueue&lt;&gt;();

        &#x2F;&#x2F;首先将每个链表的头节点放入优先队列中
        for(ListNode node : lists) &#123;
            if(node !&#x3D; null) &#123;
                queue.offer(new Status(node.val, node));
            &#125;
        &#125;

        &#x2F;&#x2F;创建一个不存值的头节点便于返回结果
        ListNode head &#x3D; new ListNode();
        &#x2F;&#x2F;使用tail指针便于尾插法
        ListNode tail &#x3D; head;

        &#x2F;&#x2F;逐步弹出优先队列中元素，直到队列为空
        while(!queue.isEmpty()) &#123;
            &#x2F;&#x2F;弹出队列头部节点并插入结果链表尾部
            Status temp &#x3D; queue.poll();
            tail.next &#x3D; temp.node;
            tail &#x3D; temp.node;
            &#x2F;&#x2F;将当前被弹出节点的下一节点加入优先队列中
            if(temp.node.next !&#x3D; null) &#123;
                queue.offer(new Status(temp.node.next.val, temp.node.next));
            &#125;
        &#125;
        tail.next &#x3D; null;

        return head.next;
    &#125;

&#125;</code></pre>
<h1 id="2-天际线问题-218"><a class="markdownIt-Anchor" href="#2-天际线问题-218"></a> 2. 天际线问题 218</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/the-skyline-problem/">题目</a></li>
</ul>
<hr />
<p>城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回由这些建筑物形成的 天际线 。</p>
<p>每个建筑物的几何信息由数组 buildings 表示，其中三元组 buildings[i] = [lefti, righti, heighti] 表示：</p>
<p>lefti 是第 i 座建筑物左边缘的 x 坐标。<br />
righti 是第 i 座建筑物右边缘的 x 坐标。<br />
heighti 是第 i 座建筑物的高度。<br />
天际线 应该表示为由 “关键点” 组成的列表，格式 [[x1,y1],[x2,y2],…] ，并按 x 坐标 进行 排序 。关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，y 坐标始终为 0 ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</p>
<p>注意：输出天际线中不得有连续的相同高度的水平线。例如 […[2 3], [4 5], [7 5], [11 5], [12 7]…] 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：[…[2 3], [4 5], [12 7], …]</p>
<p>示例1:<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/AIl1gT.jpg" alt="AIl1gT" /></p>
<pre class="line-numbers language-none"><code class="language-none">输入：buildings &#x3D; [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]
输出：[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]
解释：
图 A 显示输入的所有建筑物的位置和高度，
图 B 显示由这些建筑物形成的天际线。图 B 中的红点表示输出列表中的关键点。
示例 2：

输入：buildings &#x3D; [[0,2,3],[2,5,3]]
输出：[[0,3],[5,0]]
 

提示：

1 &lt;&#x3D; buildings.length &lt;&#x3D; 104
0 &lt;&#x3D; lefti &lt; righti &lt;&#x3D; 231 - 1
1 &lt;&#x3D; heighti &lt;&#x3D; 231 - 1
buildings 按 lefti 非递减排序</code></pre>
<h2 id="java解法-2"><a class="markdownIt-Anchor" href="#java解法-2"></a> Java解法</h2>
<ul>
<li>法一：首先先要观察出关键点出现的规律：1 关键点的横坐标必然在建筑物的左右边界上 2 处于建筑物左边界上的关键点的高度就是该建筑的高度，右边界上的则不然，得出建筑包含关键点的概念：大于等于建筑左坐标，小于建筑右坐标；之后使用<strong>扫描线法</strong>，逐个遍历所有的建筑的边界横坐标，并找出包含该边界的建筑物，将该建筑物信息存储。然后在所有包含该边界的建筑物中（遍历）选出最高的高度就是关键点的坐标。在基本思路清晰后，使用<strong>优先队列</strong>减少遍历包含边界的建筑物信息得出最大高度的过程：以高度为比较变量，高度最高的放在队列最前，每次只要确保队列最前的建筑包含边界即可使用其高度作为关键点高度（如果不包含，说明边界已经超过了该建筑所在区域，因为边界是从左到右遍历的，所以该建筑在确定关键点上已经失效（之后的边界它必然也不会包含），可以从队列中移除）。最后要注意每次得到新的关键点时都要确定是否<strong>与以前的关键点高度相同</strong>，如果相同则丢弃这个关键点。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210830084011.png" alt="" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SkyLine218 &#123;

    public List&lt;List&lt;Integer&gt;&gt; getSkyline(int[][] buildings) &#123;
        &#x2F;&#x2F;创建优先队列，
        PriorityQueue&lt;int[]&gt; priorityQueue &#x3D; new PriorityQueue&lt;int[]&gt;((a, b)-&gt;b[1] - a[1]);

        &#x2F;&#x2F;存储建筑物的边界的集合(建筑物的左右横坐标)
        List&lt;Integer&gt; boundaries &#x3D; new ArrayList&lt;&gt;();
        for(int[] building : buildings) &#123;
            boundaries.add(building[0]);
            boundaries.add(building[1]);
        &#125;
        &#x2F;&#x2F;对边界进行排序(从小到大)
        Collections.sort(boundaries);

        &#x2F;&#x2F;存储结果天际线的集合
        List&lt;List&lt;Integer&gt;&gt; result &#x3D; new ArrayList&lt;&gt;();

        int n &#x3D; buildings.length;
        int index &#x3D; 0;
        &#x2F;&#x2F;遍历边界一个个地找到天际线关键点
        for(int boundary : boundaries) &#123;
            &#x2F;&#x2F;从左到右遍历并找到包含该边界的建筑物，并添加到优先队列中去
            &#x2F;&#x2F;已经添加了的建筑不会再遍历
            while(index &lt; n &amp;&amp; buildings[index][0] &lt;&#x3D; boundary) &#123;
                &#x2F;&#x2F;将建筑物的右边界和高度整体存入优先队列中
                priorityQueue.offer(new int[] &#123;buildings[index][1], buildings[index][2]&#125;);
                index++;
            &#125;
            &#x2F;&#x2F;确保优先队列首部的元素包含该边界（即右横坐标大于边界坐标）
            while(!priorityQueue.isEmpty() &amp;&amp; priorityQueue.peek()[0] &lt;&#x3D; boundary) &#123;
                priorityQueue.poll();
            &#125;

            &#x2F;&#x2F;获取优先队列首部的元素（建筑物）的高度，即最大高度（同时这个高度对应的建筑包含该边界）
            int maxHeight &#x3D; priorityQueue.isEmpty() ? 0 : priorityQueue.peek()[1];
            &#x2F;&#x2F;如果这个高度没有与前面的高度相同，则和边界一起存入结果集合中
            if(result.size() &#x3D;&#x3D; 0 || maxHeight !&#x3D; result.get(result.size() - 1).get(1)) &#123;
                result.add(Arrays.asList(boundary, maxHeight));
            &#125;
        &#125;
        return result;
    &#125;
&#125;</code></pre>
<h1 id="3-滑动窗口最大值-239"><a class="markdownIt-Anchor" href="#3-滑动窗口最大值-239"></a> 3. 滑动窗口最大值 239</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> *<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sliding-window-maximum/">题目</a></h2>
<p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<pre class="line-numbers language-none"><code class="language-none">示例 1：

输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
示例 2：

输入：nums &#x3D; [1], k &#x3D; 1
输出：[1]
示例 3：

输入：nums &#x3D; [1,-1], k &#x3D; 1
输出：[1,-1]
示例 4：

输入：nums &#x3D; [9,11], k &#x3D; 2
输出：[11]
示例 5：

输入：nums &#x3D; [4,-2], k &#x3D; 2
输出：[4]

提示：

1 &lt;&#x3D; nums.length &lt;&#x3D; 105
-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104
1 &lt;&#x3D; k &lt;&#x3D; nums.length</code></pre>
<h2 id="java解法-3"><a class="markdownIt-Anchor" href="#java解法-3"></a> Java解法</h2>
<ul>
<li>法一：使用双端队列存储窗口内容，每次移动窗口就是将双端队列的最前面去掉在尾部加入新元素。将双端队列中的新元素加入优先队列中去，并且记录每个元素对应的下标。每次移动窗口后，获取优先队列的顶部元素，并根据下标判断他是否是窗口中的元素，如果不是则弹出，再取出新的顶部元素，直到属于窗口中为止，这个顶部元素就是当前窗口最大的元素，将其加入结果数组中。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/M6GE8z.png" alt="M6GE8z" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SlidingWindowMaximum239 &#123;

    public int[] maxSlidingWindow(int[] nums, int k) &#123;

        &#x2F;&#x2F;创建存储结果的数组
        int length  &#x3D; nums.length;
        int[] res &#x3D; new int[length - k + 1];
        &#x2F;&#x2F;创建双端队列
        Deque deque &#x3D; new LinkedList();
        &#x2F;&#x2F;初始化队列，将数组最前面的k位数装入队列
        for(int i &#x3D; 0; i &lt; k; i++) &#123;
            deque.offerLast(nums[i]);
        &#125;

        &#x2F;&#x2F;用于比较的栈
        Stack stack &#x3D; new Stack();
        &#x2F;&#x2F;用优先队列来比较大小,优先队列元素：&#123;num, index&#125;,数以及它对应的下标来感知最大值是否已经超出窗口
        PriorityQueue&lt;int[]&gt; priorityQueue &#x3D; new PriorityQueue&lt;int[]&gt;((a, b)-&gt;b[0] - a[0]);
        &#x2F;&#x2F;先计算出队列中的最大值
        for(int j &#x3D; 0; j &lt; k; j++) &#123;
            int temp &#x3D; (int) deque.pollLast();
            priorityQueue.offer(new int[]&#123;temp, k - j - 1&#125;);
            &#x2F;&#x2F;用栈来保存，以便复原双端队列
            stack.push(temp);
        &#125;
        &#x2F;&#x2F;复原双端队列
        while (!stack.isEmpty()) &#123;
            int temp &#x3D; (int) stack.pop();
            deque.offerLast(temp);
        &#125;

        for(int i &#x3D; 0; k + i &lt;&#x3D; length; i++) &#123;

            &#x2F;&#x2F;获取在当前窗口的最大值
            boolean flag &#x3D; false; &#x2F;&#x2F;是否获取到当前窗口最大值的标志
            while(!flag) &#123;
                if(i &lt;&#x3D; priorityQueue.peek()[1] &amp;&amp; priorityQueue.peek()[1]  &lt; k + i) &#123;
                    res[i] &#x3D; priorityQueue.peek()[0];
                    flag &#x3D; true;
                &#125; else &#123;
                    priorityQueue.poll();
                &#125;
            &#125;
            &#x2F;&#x2F;移动窗口
            if(k + i &lt; length) &#123;
                deque.pollFirst();
                deque.offerLast(nums[k + i]);
            &#125;
            &#x2F;&#x2F;将最新加入窗口的元素加入优先队列
            int temp &#x3D; (int) deque.getLast();
            priorityQueue.offer(new int[]&#123;temp, k + i&#125;);
        &#125;

        return res;
    &#125;
&#125;</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E9%A1%B9%E7%9B%AE/Java%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%9D%97%E9%93%BEDemo/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E9%A1%B9%E7%9B%AE/Java%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%9D%97%E9%93%BEDemo/index.html" class="post-title-link" itemprop="url">Java实现区块链Demo</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-26 08:02:19" itemprop="dateCreated datePublished" datetime="2021-07-26T08:02:19+08:00">2021-07-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:29:23" itemprop="dateModified" datetime="2022-09-17T19:29:23+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>25k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>22 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="区块链与比特币概念"><a class="markdownIt-Anchor" href="#区块链与比特币概念"></a> 区块链与比特币概念</h1>
<ul>
<li>
<p>区块链（BlockChain）起源于比特币，2008年11月1日，一位自称中本聪(Satoshi Nakamoto)的人发表了《比特币:一种点对点的电子现金系统》一文，阐述了基于P2P网络技术、加密技术、时间戳技术、区块链技术等的电子现金系统的构架理念，这标志着比特币的诞生。</p>
</li>
<li>
<p>在比特币系统中，区块（Block）是一个一个的存储单元，记录了一定时间内各个区块节点全部的交流信息。各个区块之间通过随机散列(也称哈希算法)实现链接，后一个区块包含前一个区块的哈希值，随着信息交流的扩大，一个区块与一个区块相继接续，形成的结果就叫区块链（BlockChain）。</p>
</li>
<li>
<p>在知乎上看到一个漫画讲得很形象：</p>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/0QlkTi.jpg" alt="0QlkTi" /></p>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/XhKOwy.jpg" alt="XhKOwy" /></p>
<p><img src="https://pic2.zhimg.com/v2-8317abc7bb2e2058bb2e5242739aba01_r.jpg" alt="preview" /></p>
<p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/y71QB4.jpg" alt="y71QB4" /></p>
</li>
<li>
<p>看着这些概念头脑中也难以形成一个具体的印象，不如实现一个区块链的demo来看一看。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://medium.com/programmers-blockchain/create-simple-blockchain-java-tutorial-from-scratch-6eeed3cb03fa">参考教程</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://github.com/zestaken/BlockChainDemo">代码地址</a></p>
</li>
</ul>
<h1 id="1-实现block结构"><a class="markdownIt-Anchor" href="#1-实现block结构"></a> 1. 实现Block结构</h1>
<ul>
<li>区块链（BlockChain）顾名思义，是将一个个区块（Block）链接起来形成。所以我们实现区块链的第一步是实现Block结构。</li>
<li>区块链的链不是传统的通过指针等技术实现，而是通过哈希值来链接。所以一个Block中需要包含自身的哈希值，前一个Block的哈希值，还有自身的数据（这个数据与交易信息有关）。而当前块的哈希值是通过前一个块的哈希值、当前块的创建的时间以及当前块的数据三者根据加密算法计算得出的。所以Block中还要包含时间戳变量表示块创建时间。</li>
<li>Block类实现如下：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Block &#123;

    public String hash;
    public String prevHash;
    private String data;
    private long timestamp;

    public ZJChain.Block(String data, String prevHash) &#123;
        this.data &#x3D; data;
        this.prevHash &#x3D; prevHash;
        this.timestamp &#x3D; new Date().getTime();
        &#x2F;&#x2F;初始化哈希值必须在其它属性都已初始化之后
        try &#123;
            this.hash &#x3D; calculateHash();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    &#x2F;**
     * 计算当前块的哈希值
     * @return
     * @throws Exception
     *&#x2F;
    public String calculateHash() throws Exception &#123;
        String calculatedHash &#x3D; StringUtil.applySha256(prevHash+data+timestamp);
        return calculatedHash;
    &#125;
&#125;</code></pre>
<ul>
<li>应用SHA256算法来计算哈希值：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 应用SHA256算法接收输入字符串计算并返回哈希字符串
 * @param input
 * @return
 * @throws Exception
 *&#x2F;
public static String applySha256(String input) throws Exception &#123;
        &#x2F;&#x2F;返回实现指定摘要算法的 MessageDigest 对象。此处是SHA-256算法
        MessageDigest digest &#x3D; MessageDigest.getInstance(&quot;SHA-256&quot;); &#x2F;&#x2F;getInstance有异常
        &#x2F;&#x2F;根据输入的bytes数组完成哈希计算。
        byte[] hash &#x3D; digest.digest(input.getBytes(&quot;UTF-8&quot;));&#x2F;&#x2F;getBytes有异常
        StringBuffer hexString &#x3D; new StringBuffer();
        for(int i &#x3D; 0; i &lt; hash.length; i++) &#123;
            &#x2F;&#x2F;将生成的哈希字节数组每一字节（8bit）转换16进制数字符串
            String hex &#x3D; Integer.toHexString(0xff &amp; hash[i]);
            if(hex.length() &#x3D;&#x3D; 1) &#123;
                &#x2F;&#x2F;当生成的16进制数只有一位时，在末尾添0，丢弃生成的16进制数（因为8位应是两位的16进制数，除非前面全为0）
                hexString.append(&quot;0&quot;);
            &#125;
            &#x2F;&#x2F;将每一个字节的转换结果连接
            hexString.append(hex);
        &#125;
        return hexString.toString();
&#125;</code></pre>
<ul>
<li>SHA256:
<ul>
<li>SHA256的中文全称叫做“安全哈希算法”。所谓的“哈希”是Hash的音译，而Hash就是进行Hash函数的意思。通常来说，Hash函数的运算有一个共同特点。就是不论原始数据有多少位，只要通过Hash运算后，得到结果的长度都是固定的。</li>
<li>Hash函数的类型有很多种，包括SHA224、SHA256、SHA384、SHA512、SHA512/224、SHA512/256等。但是比特币仅选用了SHA256。这个256代表的意思是，数据经过函数运算后得到的结果必须是一个256位的2进制数字。</li>
<li>每次Hash计算后得到的结果有三个要求：第一、输入Hash函数之前的数据和通过Hash函数处理过后得到的编号必须一一对应。第二、每一个编号的长度都是固定的。第三、我们无法通过编号倒推出数据的内容。</li>
</ul>
</li>
<li>因为哈希值的涉及到前一个块的哈希值，时间，数据等，所以哈希链表是无法在中间插入修改的。</li>
</ul>
<h1 id="2-实现区块链blockchain结构"><a class="markdownIt-Anchor" href="#2-实现区块链blockchain结构"></a> 2. 实现区块链（BlockChain）结构</h1>
<ul>
<li>前面构造了区块（Block），现在把他们连接起来存储就形成了区块链。我们采用ArrayList结构来组织这些Block。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ZJChain &#123;

    &#x2F;&#x2F;blockChain为静态属性，所有对象都是在对同一个blockchain修改
    public static ArrayList&lt;Block&gt; blockChain &#x3D; new ArrayList&lt;Block&gt;();

    &#x2F;**
     * 检查区块链的有效性
     * @return
     *&#x2F;
    public boolean isChainValid() &#123;
        Block curBlock;
        Block prevBlock;

        &#x2F;&#x2F;遍历blockchain，从1开始，保证prevblock的有效性
        for(int i &#x3D; 1; i &lt; blockChain.size(); i++) &#123;
            curBlock &#x3D; blockChain.get(i);
            prevBlock &#x3D; blockChain.get(i - 1);

            try &#123;
                &#x2F;&#x2F;检查hash值计算有效性
                if(!curBlock.hash.equals(curBlock.calculateHash())) &#123;
                    System.out.println(&quot;block的hash值计算错误&quot;);
                    return false;
                &#125;
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;

            &#x2F;&#x2F;检查hash值前后对应关系正确性
            if(!prevBlock.hash.equals(curBlock.prevHash)) &#123;
                System.out.println(&quot;当前block与前面block的hash值不对应&quot;);
                return false;
            &#125;
        &#125;
        return true;
    &#125;

    &#x2F;**
     * 向区块链中添加块
     * @param block
     *&#x2F;
    public void addBlock(Block block) &#123;
        blockChain.add(block);
    &#125;

    &#x2F;**
     * 将blockChain转换为json字符串本地存储
     * @return
     *&#x2F;
    public String toJson() &#123;
        String blockChainString &#x3D; JSON.toJSONString(blockChain);
        return blockChainString;
    &#125;
&#125;</code></pre>
<ul>
<li>因为ArrayList是内存中的数据结构，需要长期保存的话需要转换为JSON字符串写入文件中保存,通过alibaba的fastjson包实现。</li>
<li>构建区块链的测试：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
 public void test1() &#123;
     &#x2F;&#x2F;初始化区块链
     ZJChain zjChain &#x3D; new ZJChain();
     &#x2F;&#x2F;向区块链中添加10个块
     for(int i &#x3D; 0; i &lt; 10; i++) &#123;
         &#x2F;&#x2F;创建新块
         Block block;
         if(zjChain.blockChain.size() &#x3D;&#x3D; 0) &#123;
             block &#x3D; new Block(&quot;Block: &quot; + i, &quot;0&quot;);
         &#125; else &#123;
             block &#x3D; new Block(&quot;Block: &quot; + i, zjChain.blockChain.get(
                     zjChain.blockChain.size() - 1).hash);
         &#125;
         zjChain.addBlock(block);
     &#125;

     for(ZJChain.Block block : zjChain.blockChain) &#123;
         System.out.println(&quot;hash: &quot; + block.hash + &quot; prevHash: &quot; + block.prevHash);
     &#125;
 &#125;</code></pre>
<h1 id="3-准备挖矿"><a class="markdownIt-Anchor" href="#3-准备挖矿"></a> 3. 准备挖矿！！！</h1>
<ul>
<li>提起比特币、区块链，便离不开挖矿这个话题。那什么是挖矿？比特币挖矿就是找到一个随机数（Nonce）参与哈希运算Hash，使得最后得到的哈希值符合难度要求（在很多种组合中试出满足要求的组合, 有一点运气成分），用公式表示就是Hash &lt;= target。具体的说就是使生成的哈希值的开头至少有指定数目个0。实现如下：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public void mineBlock(int difficulty) &#123;
    &#x2F;&#x2F;生成目标字符串：此处是包含指定数量（difficulty）个连续的0的字符串
    String target &#x3D; new String(new char[difficulty]).replace(&#39;\0&#39;, &#39;0&#39;);
    &#x2F;&#x2F;检查当前块的hash值中从0到difficulty部分是否与target字符串相同，如果不相同，则修改nonce，重新计算hash
    while(!hash.substring(0, difficulty).equals(target)) &#123;
        nonce++;
        try &#123;
            hash &#x3D; calculateHash();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    System.out.println(&quot;nonce：&quot; + nonce);
&#125;</code></pre>
<ul>
<li>简单来看挖矿难度的高低就是生成区块头的哈希值有多少0，前面固定的0越多，满足条件的值就越少，计算得到符合标准的hash值的概率就低，宏观上说需要计算的次数就越多。difficulty每增加1，运算量都是呈几何速率增加，十分恐怖。</li>
<li>当难度为4:<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/SAWTcE.png" alt="SAWTcE" /></li>
<li>当难度为5:<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/lVcfrW.png" alt="lVcfrW" /></li>
<li>当难度为6:<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/4IZwd2.png" alt="4IZwd2" />（好家伙，直接跑了8分多钟。。。）</li>
<li>对比可以看出，难度增加1，运算量（nonce可以表示运算的次数）直接增加一个量级，怪不得作为工作量衡量的标准（proof-of-work)。</li>
<li>这里还可以看出，挖矿之所以很耗算力，并不是因为这个哈希计算本身有多么复杂，而是它是需要重复这个哈希计算很多次（我这随便提一点难度，都到千万级了。。。）直到满足要求。这也是为什么GPU挖矿效率比CPU高的原因：其实不是GPU运算速度比CPU快，而是GPU运算的数据是单一的，是经过CPU运算往后分离出来的单一数据。CPU运算的所需求的东西许多，而且不是单一的某种数据。CPU可以运行更复杂的指令。如果是做一个简单的数学计算，一个最大16核的CPU最多只能同时跑16个线程，而一个普通的GPU就可以同时跑3000多个线程，所以做简单数学，GPU就比CPU要快几个数量级，而生成区块要做的哈希计算偏偏就是一个很简单的数学题。</li>
<li>另外，在检查区块链的有效性(isChainValid)的时候，还需要增加检查hash值是否满足难度要求这一点：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">if(!curBlock.hash.substring(0, difficulty).equals(target)) &#123;
    &#x2F;&#x2F;如果不满足难度标准，也无效
    System.out.println(&quot;当前块未满足难度标准！&quot;);
    return false;
&#125;</code></pre>
<h1 id="4-创建钱包"><a class="markdownIt-Anchor" href="#4-创建钱包"></a> 4. 创建钱包</h1>
<ul>
<li>比特币是一种点对点的电子现金系统，没有实物形态，可以存储在比特币钱包里。日常生活中，钱包是用来放钱的，但比特币钱包里却没有比特币，而只是确立比特币所有权的工具：比特币被记录在比特币网络的区块中（即Block，实际记录的也不是具体的比特币而是一笔笔交易记录）中，比特币的所有权是通过数字密钥、比特币地址和数字签名（接下来要实现的）来确立的。</li>
<li>数字密钥并不存储在网络中，而是由用户生成并存储在一个文件或简单的数据库中，称为钱包。比特币钱包里存储着你的比特币信息，包括比特币地址（类似于你的银行卡账号）和数字秘钥。</li>
<li>数字秘钥是用公钥加密创建一个密钥对，用于控制比特币的获取。密钥对包括一个私钥，和由其衍生出的唯一的公钥。公钥用于接收比特币，而私钥用于生成比特币支付时的交易签名（类似于你银行卡的密码）。支付比特币时，比特币的当前所有者需要在交易中提交其公钥和签名（每次交易的签名都不同，但均从同一个私钥生成）。比特币网络中的所有人都可以通过所提交的公钥和签名进行验证，并确认该交易是否有效，即确认支付者在该时刻对所交易的比特币拥有所有权。比特币私钥就用来保护你的钱包，如果私钥丢失，你将永远失去这笔比特币。</li>
<li>Wallet实现：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Wallet &#123;
    public PublicKey publicKey;
    public PrivateKey privateKey;

    public Wallet() &#123;
        generateKeyPair();
    &#125;

    &#x2F;**
     * 生成公私钥
     *&#x2F;
    public void generateKeyPair() &#123;
        try &#123;
            &#x2F;&#x2F;指定算法ECDSA生成密钥对
            KeyPairGenerator keyGen &#x3D; KeyPairGenerator.getInstance(&quot;ECDSA&quot;, &quot;BC&quot;);
            SecureRandom random &#x3D; SecureRandom.getInstance(&quot;SHA1PRNG&quot;);
            ECGenParameterSpec ecSpec &#x3D; new ECGenParameterSpec(&quot;prime192v1&quot;);
            &#x2F;&#x2F;初始化并生成密钥对
            keyGen.initialize(ecSpec, random);
            KeyPair keyPair &#x3D; keyGen.generateKeyPair();
            &#x2F;&#x2F;获取公私钥
            privateKey &#x3D; keyPair.getPrivate();
            publicKey &#x3D; keyPair.getPublic();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>
<ul>
<li>ECDSA:椭圆曲线数字签名算法（Elliptic Curve Digital Signature Algorithm，缩写ECDSA）是一种被广泛应用于数字签名的加密算法。</li>
</ul>
<h1 id="5-实现交易transaction"><a class="markdownIt-Anchor" href="#5-实现交易transaction"></a> 5. 实现交易（Transaction)</h1>
<ul>
<li>既然是一种货币，那么最重要的功能就是用来交易，作为最早出现的加密货币，比特币采用了 UTXO 模型作为其底层存储的数据结构，其全称为 Unspent Transaction output，也就是未被使用的交易输出。</li>
<li>UTXO 模型的加密货币中，某一个账户中的余额并不是由一个数字表示的，而是由当前区块链网络中所有属于当前账户的 UTXO 组成的。每一个UTXO就跟现实世界中的一张纸钞类似，一个UTXO只能用一次，如果数额超出需要支付的价钱则发给自己新的UTXO（自己给自己找零）。</li>
<li>比特币实质上没有存储货币，它有的不过是在一个个交易中记录的数字变化，而这个数字的源头来自矿工。我们挖矿产生的Block实质上是一个账本，其中记录一笔笔交易的记录。每挖出一个Block，就会从无到有生成可以用于交易的value（交易中的数字）给矿工，这便是比特币产生的地方。</li>
<li>交易中每个人用钱包来保管自己的UTXO，以及公私钥。公钥就类似于银行卡号，别人通过指定你的公钥来转账给你。私钥类似于你的密码，但是又有不同：每次你发起转账，都需要通过你的私钥结合交易的内容来生成一个签名，通过验证签名与公钥来确认身份。签名与交易是一一对应的，即使暴露了也无妨，但是私钥是绝对不能泄漏的。</li>
<li>UTXO 其实就是交易的一部分，基于 UTXO 模型的交易由输入和输出两个部分组成:UTXO 模型中的每一笔交易都是由多个交易输入组成的，这些输入其实就是 UTXO + 签名:属于某个人的UTXO加上这个人的签名（由秘钥生成）则可以表示这个人授权使用这个UTXO。每一个交易都可能会有多个输出，每一个输出都可以指向不同的地址，其中也有当前输出包含的值 value，这个value也就是比特币的计量数。</li>
<li>交易实现：
<ul>
<li>Transaction.java</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Transaction &#123;
    &#x2F;**
     * 交易号
     *&#x2F;
    public String transactionId;
    &#x2F;**
     * 交易序号，用于记录交易数量
     *&#x2F;
    public static int sequence &#x3D; 0;
    &#x2F;**
     * 发送方的地址&#x2F;public key
     *&#x2F;
    public PublicKey sender;
    &#x2F;**
     * 接收方的地址&#x2F;public key
     *&#x2F;
    public PublicKey recipient;
    &#x2F;**
     * 交易额
     *&#x2F;
    public float value;
    &#x2F;**
     * 发送方的签名
     *&#x2F;
    public byte[] signature;

    &#x2F;**
     * 本次交易所涉及到的所有交易输入
     *&#x2F;
    public ArrayList&lt;TransactionInput&gt; inputs &#x3D; new ArrayList&lt;TransactionInput&gt;();
    &#x2F;**
     * 本次交易所涉及到的所有交易输出（第0位output是发给别人的，第1位output是发给自己的）
     *&#x2F;
    public ArrayList&lt;TransactionOutput&gt; outputs &#x3D; new ArrayList&lt;TransactionOutput&gt;();

    public Transaction(PublicKey from, PublicKey to, float value, ArrayList&lt;TransactionInput&gt; inputs) &#123;
        this.sender &#x3D; from;
        this.recipient &#x3D; to;
        this.value &#x3D; value;
        this.inputs &#x3D; inputs;
    &#125;

    &#x2F;**
     * 计算用于标识交易的transactionId
     * @return
     * @throws Exception
     *&#x2F;
    private String calculateHash() throws Exception &#123;
        sequence++;
            return StringUtil.applySha256(
                    StringUtil.getStringFromKey(sender) +
                    StringUtil.getStringFromKey(recipient) +
                    value + sequence);
    &#125;

    &#x2F;**
     * 根据私钥和其它数据生成数字签名
     * @param privateKey
     *&#x2F;
    public void generateSignature(PrivateKey privateKey) &#123;
        String data &#x3D; StringUtil.getStringFromKey(sender) + StringUtil.getStringFromKey(recipient) + value;
        signature &#x3D; StringUtil.applyECDSASig(privateKey, data);
    &#125;

    &#x2F;**
     * 检查发送方数字签名，以验证数据没有损坏或者被修改
     * @return
     *&#x2F;
    public boolean verifySignature() throws Exception &#123;
        String data &#x3D; StringUtil.getStringFromKey(sender) + StringUtil.getStringFromKey(recipient) + value;
        return StringUtil.verifyECDSASig(sender, data, signature);
    &#125;

    &#x2F;**
     * 实现一次交易
     * @return
     *&#x2F;
    public boolean processTransaction() &#123;

        &#x2F;&#x2F;验证交易的发送方的数字签名是否有效
        try &#123;
            if(!verifySignature()) &#123;
                System.out.println(&quot;交易签名验证失败&quot;);
                return false;
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;

        &#x2F;&#x2F;根据交易输出的id从整个区块链中有效的UTXO集合中获取对应的UTXO
        for(TransactionInput input : inputs) &#123;
            input.UTXO &#x3D; ZJChain.UTXOs.get(input.transactionOutputId);
        &#125;

        &#x2F;&#x2F;检测交易输入额是否符合最小标准
        if(getInputsValue() &lt; ZJChain.minimumTransaction) &#123;
            System.out.println(&quot;交易输入数额：&quot; + getInputsValue() + &quot; 小于最小交易额&quot;);
            return false;
        &#125;

        &#x2F;&#x2F;计算交易输入还有多少剩余（类似找零）
        float leftover &#x3D; getInputsValue() - value;
        if(leftover &lt; 0) &#123;
            System.out.println(&quot;金额不足，交易终止！&quot;);
            return false;
        &#125;
        &#x2F;&#x2F;计算交易id
        try &#123;
            transactionId &#x3D; calculateHash();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        &#x2F;&#x2F;建立指向收款方的交易输出
        outputs.add(new TransactionOutput(this.recipient, value, transactionId));
        &#x2F;&#x2F;如果需要找零才找零
        if(leftover &gt; 0) &#123;
            &#x2F;&#x2F;建立指向发送方的交易输出（将交易输出中没有用完的还给自己，实现找零功能）
            outputs.add(new TransactionOutput(this.sender, leftover, transactionId));
        &#125;

        &#x2F;&#x2F;将本次交易中的所有交易输出添加到整个区块链的UTXO集合中（实现向所有用户通报这笔交易）
        for(TransactionOutput output : outputs) &#123;
            ZJChain.UTXOs.put(output.id, output);
        &#125;
        &#x2F;&#x2F;移除整个区块链中本次交易中所有交易输入所对应的UTXO（每个UTXO只能用来支付一次）
        for(TransactionInput input : inputs) &#123;
            if(input.UTXO !&#x3D; null) &#123;
                ZJChain.UTXOs.remove(input.UTXO.id);
            &#125;
        &#125;

        return true;

    &#125;

    &#x2F;**
     * 获取所有交易输入中的总价值（计算拥有的钱的总数）
     * @return
     *&#x2F;
    public float getInputsValue() &#123;
        float sum &#x3D; 0;
        for(TransactionInput i : inputs) &#123;
            if(i.UTXO !&#x3D; null) &#123;
                sum +&#x3D; i.UTXO.value;
            &#125;
        &#125;
        return sum;
    &#125;

    &#x2F;**
     * 获取所有交易输出中的总价值（要支付的钱的总数）
     * @return
     *&#x2F;
    public float getOutputsValue() &#123;
        float sum &#x3D; 0;
        for(TransactionOutput output : outputs) &#123;
            sum +&#x3D; output.value;
        &#125;
        return sum;
    &#125;

&#125;</code></pre>
<ul>
<li>TransactionInput.java</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TransactionInput &#123;
    &#x2F;**
     * 这笔交易输入从该ID的交易输出来（类似你曾经收到的某张钞票的编号）
     *&#x2F;
    public String transactionOutputId;
    &#x2F;**
     * UTXO 未花费交易输出（你要使用的具体钞票）
     *&#x2F;
    public TransactionOutput UTXO;

    public TransactionInput(String transactionOutputId) &#123;
        this.transactionOutputId &#x3D; transactionOutputId;
    &#125;

&#125;</code></pre>
<ul>
<li>TransactionOutput.java</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TransactionOutput &#123;
    &#x2F;**
     * 交易输出编号id
     *&#x2F;
    public String id;
    &#x2F;**
     * 这笔交易输出的接收方公钥（类似收款方银行账号）
     *&#x2F;
    public PublicKey recipient;
    &#x2F;**
     * 交易输出额
     *&#x2F;
    public float value;
    &#x2F;**
     * 创建这个交易输出的交易id
     *&#x2F;
    public String parentTransactionId;


    public TransactionOutput(PublicKey recipient, float value, String parentTransactionId) &#123;
        this.recipient &#x3D; recipient;
        this.value &#x3D; value;
        this.parentTransactionId &#x3D; parentTransactionId;
        &#x2F;&#x2F;前面属性均赋值后再计算id
        try &#123;
            this.id &#x3D; StringUtil.applySha256(StringUtil.getStringFromKey(recipient) + this.value + this.parentTransactionId);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    &#x2F;&#x2F;检查UTXO（未消费的交易输出）是否是指定publickey的拥有者的
    public boolean isMine(PublicKey publicKey) &#123;
        return (publicKey &#x3D;&#x3D; recipient);
    &#125;
&#125;</code></pre>
<h1 id="6-完善钱包wallet"><a class="markdownIt-Anchor" href="#6-完善钱包wallet"></a> 6. 完善钱包（Wallet）</h1>
<ul>
<li>一个钱包中保存着每个账户的公私钥，并且具备统计该账户拥有的UTXO并计算余额的能力，此外钱包还有创建交易发起支出的能力。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Wallet &#123;
    &#x2F;&#x2F;公私钥
    public PublicKey publicKey;
    public PrivateKey privateKey;

    &#x2F;**
     * 钱包存储属于自己的UTXO（未消费交易输出）
     *&#x2F;
    public HashMap&lt;String, TransactionOutput&gt; UTXOs &#x3D; new HashMap&lt;&gt;();

    public Wallet() &#123;
        generateKeyPair();
    &#125;

    &#x2F;**
     * 生成公私钥
     *&#x2F;
    public void generateKeyPair() &#123;
        try &#123;
            &#x2F;&#x2F;指定算法ECDSA生成密钥对
            KeyPairGenerator keyGen &#x3D; KeyPairGenerator.getInstance(&quot;ECDSA&quot;, &quot;BC&quot;);
            SecureRandom random &#x3D; SecureRandom.getInstance(&quot;SHA1PRNG&quot;);
            ECGenParameterSpec ecSpec &#x3D; new ECGenParameterSpec(&quot;prime192v1&quot;);
            &#x2F;&#x2F;初始化并生成密钥对
            keyGen.initialize(ecSpec, random);
            KeyPair keyPair &#x3D; keyGen.generateKeyPair();
            &#x2F;&#x2F;获取公私钥
            privateKey &#x3D; keyPair.getPrivate();
            publicKey &#x3D; keyPair.getPublic();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    &#x2F;**
     * 计算钱包的总余额
     * @return
     *&#x2F;
    public float getBalance() &#123;
        float sum &#x3D; 0;
        &#x2F;&#x2F;遍历Map集合获取键值对对象
        for(Map.Entry&lt;String, TransactionOutput&gt; item : ZJChain.UTXOs.entrySet()) &#123;
            TransactionOutput UTXO &#x3D;  item.getValue();
            &#x2F;&#x2F;检查该UTXO是否属于该钱包
            if(UTXO.isMine(publicKey)) &#123;
                &#x2F;&#x2F;添加到钱包的UTXOs集合中
                UTXOs.put(UTXO.id, UTXO);
                sum +&#x3D; UTXO.value;
            &#125;
        &#125;
        return sum;
    &#125;

    &#x2F;**
     * 创建交易，支出
     * @param _recipient
     * @param value
     * @return
     *&#x2F;
    public Transaction sendFunds(PublicKey _recipient, float value) &#123;
        &#x2F;&#x2F;检查余额是否足够
        if(getBalance() &lt; value) &#123;
            System.out.println(&quot;余额不足，交易终止！&quot;);
            return null;
        &#125;
        &#x2F;&#x2F;建立动态数组用来记录作为交易输入使用的UTXO
        ArrayList&lt;TransactionInput&gt; inputs &#x3D; new ArrayList&lt;&gt;();

        &#x2F;&#x2F;查找钱包的UTXO，直到总金额达到要支付的金额
        float total &#x3D; 0;
        for(Map.Entry&lt;String, TransactionOutput&gt; item : UTXOs.entrySet()) &#123;
            TransactionOutput UTXO &#x3D; item.getValue();
            total +&#x3D; UTXO.value;
            inputs.add(new TransactionInput(UTXO.id));
            if(total &gt;&#x3D; value) &#123;
                break;
            &#125;
        &#125;

        &#x2F;&#x2F;创建交易
        Transaction newTransaction &#x3D; new Transaction(publicKey, _recipient, value, inputs);
        newTransaction.generateSignature(privateKey);

        &#x2F;&#x2F;将已经使用的UTXO从钱包中移除
        for(TransactionInput input : inputs) &#123;
            UTXOs.remove(input.transactionOutputId);
        &#125;

        return  newTransaction;
    &#125;
    
&#125;</code></pre>
<h1 id="7-完善其它类"><a class="markdownIt-Anchor" href="#7-完善其它类"></a> 7. 完善其它类</h1>
<ul>
<li>在StringUtil工具类中，增加生成和验证数字签名的功能。同时还有根据添加到区块中的交易记录生成merkleRoot的功能，merkelRoot用于标识区块及其中的唯一性。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class StringUtil &#123;

    &#x2F;**
     * 应用SHA256算法接收输入字符串计算并返回哈希字符串
     * @param input
     * @return
     * @throws Exception
     *&#x2F;
    public static String applySha256(String input) throws Exception &#123;
            &#x2F;&#x2F;返回实现指定摘要算法的 MessageDigest 对象。此处是SHA-256算法
            MessageDigest digest &#x3D; MessageDigest.getInstance(&quot;SHA-256&quot;); &#x2F;&#x2F;getInstance有异常
            &#x2F;&#x2F;根据输入的bytes数组完成哈希计算。
            byte[] hash &#x3D; digest.digest(input.getBytes(&quot;UTF-8&quot;));&#x2F;&#x2F;getBytes有异常
            StringBuffer hexString &#x3D; new StringBuffer();
            for(int i &#x3D; 0; i &lt; hash.length; i++) &#123;
                &#x2F;&#x2F;将生成的哈希字节数组每一字节（8bit）转换16进制数字符串
                String hex &#x3D; Integer.toHexString(0xff &amp; hash[i]);
                if(hex.length() &#x3D;&#x3D; 1) &#123;
                    &#x2F;&#x2F;当生成的16进制数只有一位时，在末尾添0，丢弃生成的16进制数（因为8位应是两位的16进制数，除非前面全为0）
                    hexString.append(&quot;0&quot;);
                &#125;
                &#x2F;&#x2F;将每一个字节的转换结果连接
                hexString.append(hex);
            &#125;
            return hexString.toString();
    &#125;

    &#x2F;**
     * 根据秘钥获得字符串
     * @param key
     * @return
     *&#x2F;
    public static String getStringFromKey(Key key) &#123;
        return Base64.getEncoder().encodeToString(key.getEncoded());
    &#125;

    &#x2F;**
     * 根据ECDSA算法，由privatekey生成数字签名（字节数组）
     * @param privateKey
     * @param data
     * @return
     *&#x2F;
    public static byte[] applyECDSASig(PrivateKey privateKey, String data) &#123;
        Signature dsa;
        &#x2F;&#x2F;提前声明变量，避免最后不能返回有效值
        byte[] output &#x3D; new byte[0];
        try&#123;
            dsa &#x3D; Signature.getInstance(&quot;ECDSA&quot;, &quot;BC&quot;);
            dsa.initSign(privateKey);
            byte[] strByte &#x3D; data.getBytes();
            dsa.update(strByte);
            byte[] realSig &#x3D; dsa.sign();
            output &#x3D; realSig;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;

        return output;
    &#125;

    &#x2F;**
     * 由publickey验证数字签名是否正确
     * @param publicKey
     * @param data
     * @param signature
     * @return
     *&#x2F;
    public static boolean verifyECDSASig(PublicKey publicKey, String data, byte[] signature) throws Exception &#123;
            Signature ecdsaVerify &#x3D; Signature.getInstance(&quot;ECDSA&quot;, &quot;BC&quot;);
            ecdsaVerify.initVerify(publicKey);
            ecdsaVerify.update(data.getBytes());
            return ecdsaVerify.verify(signature);
    &#125;

    &#x2F;**
     * 根据交易生成merkleRoot标志区块
     * @param transactions
     * @return
     *&#x2F;
    public static String getMerkleRoot(ArrayList&lt;Transaction&gt; transactions) &#123;
        int count &#x3D; transactions.size();
        ArrayList&lt;String&gt; previousTreeLayer &#x3D; new ArrayList&lt;&gt;();
        for(Transaction transaction : transactions) &#123;
            previousTreeLayer.add(transaction.transactionId);
        &#125;

        ArrayList&lt;String&gt; treeLayer &#x3D; previousTreeLayer;

        while(count &gt; 1) &#123;
            treeLayer &#x3D; new ArrayList&lt;&gt;();
            for(int i &#x3D; 1; i &lt; previousTreeLayer.size(); i++) &#123;
                try &#123;
                    treeLayer.add(StringUtil.applySha256(previousTreeLayer.get(i - 1) + previousTreeLayer.get(i)));
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125;
                count &#x3D; treeLayer.size();
                previousTreeLayer &#x3D; treeLayer;
            &#125;
        &#125;

        String merkleRoot &#x3D; (treeLayer.size() &#x3D;&#x3D; 1) ? treeLayer.get(0) : &quot;&quot;;

        return merkleRoot;
    &#125;
&#125;</code></pre>
<ul>
<li>Block类的设置中，用merkleRoot来做数据生成哈希值，同时新增将交易记录添加到区块中的功能。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Block &#123;

    public String hash;
    public String prevHash;
    public long timestamp;
    public int nonce; &#x2F;&#x2F;用于挖矿的变量
    public ArrayList&lt;Transaction&gt; transactions &#x3D; new ArrayList&lt;&gt;();
    &#x2F;&#x2F;merkleRoot充当data的作用（因为区块block本质就是个账本，用交易来充当数据最合理）
    public String merkleRoot;

    public Block(String prevHash) &#123;
        this.prevHash &#x3D; prevHash;
        this.timestamp &#x3D; new Date().getTime();
        &#x2F;&#x2F;初始化哈希值必须在其它属性都已初始化之后
        try &#123;
            this.hash &#x3D; calculateHash();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    &#x2F;**
     * 计算当前块的哈希值
     * @return
     * @throws Exception
     *&#x2F;
    public String calculateHash() throws Exception &#123;
        &#x2F;&#x2F;取消使用data生成hash而使用merkleRoot
        String calculatedHash &#x3D; StringUtil.applySha256(prevHash+merkleRoot+timestamp+nonce);
        return calculatedHash;
    &#125;

    &#x2F;**
     * 挖矿计算
     * @param difficulty
     *&#x2F;
    public void mineBlock(int difficulty) &#123;
        &#x2F;&#x2F;挖矿前计算merkleRoot值
        merkleRoot &#x3D; StringUtil.getMerkleRoot(transactions);
        &#x2F;&#x2F;生成目标字符串：此处是包含指定数量（difficulty）个连续的0的字符串
        String target &#x3D; new String(new char[difficulty]).replace(&#39;\0&#39;, &#39;0&#39;);
        &#x2F;&#x2F;检查当前块的hash值中从0到difficulty部分是否与target字符串相同，如果不相同，则修改nonce，重新计算hash
        while(!hash.substring(0, difficulty).equals(target)) &#123;
            nonce++;
            try &#123;
                hash &#x3D; calculateHash();
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        System.out.println(&quot;nonce：&quot; + nonce);
    &#125;

    &#x2F;**
     * 在将交易添加到块时执行交易
     * @param transaction
     * @return
     *&#x2F;
    public boolean addTransaction(Transaction transaction) &#123;
        &#x2F;&#x2F;验证交易的有效性
        if(transaction &#x3D;&#x3D; null) return false;
        if(!prevHash.equals(&quot;0&quot;)) &#123;
            if(!transaction.processTransaction()) &#123;
                System.out.println(&quot;交易处理失败！&quot;);
                return false;
            &#125;
        &#125;
        &#x2F;&#x2F;将交易记录添加到区块中
        transactions.add(transaction);
        System.out.println(&quot;交易成功添加到Block中！&quot;);
        return true;
    &#125;
&#125;</code></pre>
<ul>
<li>ZJchain类:加强验证区块链有效功能，在将一个块添加到区块前进行挖矿计算。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ZJChain &#123;                                                                                   
                                                                                                         
    &#x2F;&#x2F;blockChain为静态属性，所有对象都是在对同一个blockchain修改                                                            
    public static ArrayList&lt;Block&gt; blockChain &#x3D; new ArrayList&lt;Block&gt;();                                  
    public static int difficulty &#x3D; 5;                                                                    
    &#x2F;**                                                                                                  
     * 用于记录所有有效的UTXO，键是String类型的TransactionOutputId                                                      
     *&#x2F;                                                                                                  
    public static HashMap&lt;String, TransactionOutput&gt; UTXOs &#x3D; new HashMap&lt;&gt;();                            
    &#x2F;**                                                                                                  
     * 每次交易的最小交易额                                                                                        
     *&#x2F;                                                                                                  
    public static float minimumTransaction &#x3D; 0.1f;                                                       
    public static Wallet walletA;                                                                        
    public static Wallet walletB;                                                                        
    &#x2F;**                                                                                                  
     * 初始交易（创建区块链时初始化第一笔交易）                                                                              
     *&#x2F;                                                                                                  
    public static Transaction genesisTransaction;                                                        
                                                                                                         
    &#x2F;**                                                                                                  
     * 检查区块链的有效性                                                                                         
     * @return                                                                                           
     *&#x2F;                                                                                                  
    public boolean isChainValid() &#123;                                                                      
        Block curBlock;                                                                                  
        Block prevBlock;                                                                                 
        &#x2F;&#x2F;用于检验挖矿难度是否达标的字符串                                                                               
        String target &#x3D; new String(new char[difficulty]).replace(&#39;\0&#39;, &#39;0&#39;);                             
        HashMap&lt;String, TransactionOutput&gt; tempUTXOs &#x3D; new HashMap&lt;&gt;();                                  
        tempUTXOs.put(genesisTransaction.outputs.get(0).id, genesisTransaction.outputs.get(0));          
                                                                                                         
                                                                                                         
        &#x2F;&#x2F;遍历blockchain，从1开始，保证prevblock的有效性                                                              
        for(int i &#x3D; 1; i &lt; blockChain.size(); i++) &#123;                                                     
            curBlock &#x3D; blockChain.get(i);                                                                
            prevBlock &#x3D; blockChain.get(i - 1);                                                           
                                                                                                         
                                                                                                         
            try &#123;                                                                                        
                &#x2F;&#x2F;检查hash值计算有效性                                                                           
                if(!curBlock.hash.equals(curBlock.calculateHash())) &#123;                                    
                    System.out.println(&quot;block的hash值计算错误&quot;);                                               
                    return false;                                                                        
                &#125;                                                                                        
            &#125; catch (Exception e) &#123;                                                                      
                e.printStackTrace();                                                                     
            &#125;                                                                                            
                                                                                                         
            &#x2F;&#x2F;检查hash值前后对应关系正确性                                                                           
            if(!prevBlock.hash.equals(curBlock.prevHash)) &#123;                                              
                System.out.println(&quot;当前block与前面block的hash值不对应&quot;);                                          
                return false;                                                                            
            &#125;                                                                                            
                                                                                                         
            if(!curBlock.hash.substring(0, difficulty).equals(target)) &#123;                                 
                &#x2F;&#x2F;如果不满足难度标准，也无效                                                                          
                System.out.println(&quot;当前块未满足挖矿难度标准！&quot;);                                                     
                return false;                                                                            
            &#125;                                                                                            
                                                                                                         
            TransactionOutput tempOutput;                                                                
            for(int t &#x3D; 0; i &lt; curBlock.transactions.size(); t++) &#123;                                      
                Transaction currentTransaction &#x3D; curBlock.transactions.get(t);                           
                                                                                                         
                &#x2F;&#x2F;检查交易的签名                                                                                
                try &#123;                                                                                    
                    if(!currentTransaction.verifySignature()) &#123;                                          
                        System.out.println(&quot;第&quot; + t + &quot;个交易的签名无效！&quot;);                                       
                        return false;                                                                    
                    &#125;                                                                                    
                &#125; catch (Exception e) &#123;                                                                  
                    e.printStackTrace();                                                                 
                &#125;                                                                                        
                                                                                                         
                &#x2F;&#x2F;检查交易的交易输出额和交易输入额是否相等                                                                   
                if(!(currentTransaction.getInputsValue() &#x3D;&#x3D; currentTransaction.getOutputsValue())) &#123;     
                    System.out.println(&quot;第&quot; + t + &quot;个交易的交易输出与交易输入额不相等！&quot;);                                  
                    return false;                                                                        
                &#125;                                                                                        
                                                                                                         
                &#x2F;&#x2F;检查交易输入是否正确（交易输入要么来源于初始交易（和矿工），要么来源于其它交易输出）                                             
                for(TransactionInput input : currentTransaction.inputs) &#123;                                
                    tempOutput &#x3D; tempUTXOs.get(input.transactionOutputId);                               
                                                                                                         
                    if(tempOutput &#x3D;&#x3D; null) &#123;                                                             
                        System.out.println(&quot;第&quot; + t + &quot;个交易的交易输入不存在！&quot;);                                    
                        return false;                                                                    
                    &#125;                                                                                    
                                                                                                         
                    if(input.UTXO.value !&#x3D; tempOutput.value) &#123;                                           
                        System.out.println(&quot;第&quot; + t + &quot;个交易的交易输入的值无效！&quot;);                                   
                        return false;                                                                    
                    &#125;                                                                                    
                                                                                                         
                    tempUTXOs.remove(input.transactionOutputId);                                         
                &#125;                                                                                        
                                                                                                         
                &#x2F;&#x2F;将交易输出加入临时UTXOs                                                                         
                for(TransactionOutput output : currentTransaction.outputs) &#123;                             
                    tempUTXOs.put(output.id, output);                                                    
                &#125;                                                                                        
                                                                                                         
                if(currentTransaction.outputs.get(0).recipient !&#x3D; currentTransaction.recipient) &#123;        
                    System.out.println(&quot;第&quot; + t + &quot;个交易的交易输出目的方错误！&quot;);                                      
                    return false;                                                                        
                &#125;                                                                                        
                                                                                                         
                if(currentTransaction.outputs.get(1).recipient !&#x3D; currentTransaction.sender) &#123;           
                    System.out.println(&quot;第&quot; + t + &quot;个交易的找零的交易输出没有发给发送者！&quot;);                                 
                    return false;                                                                        
                &#125;                                                                                        
            &#125;                                                                                            
        &#125;                                                                                                
         System.out.println(&quot;区块链有效！&quot;);                                                                   
         return true;                                                                                    
    &#125;                                                                                                    
                                                                                                         
    &#x2F;**                                                                                                  
     * 向区块链中添加块                                                                                          
     * @param newBlock                                                                                   
     *&#x2F;                                                                                                  
    public void addBlock(Block newBlock) &#123;                                                               
        &#x2F;&#x2F;先完成挖矿工作才能加入区块链中                                                                                
        newBlock.mineBlock(difficulty);                                                                  
        blockChain.add(newBlock);                                                                        
    &#125;                                                                                                    
                                                                                                         
    &#x2F;**                                                                                                  
     * 将blockChain转换为json字符串本地存储                                                                         
     * @return                                                                                           
     *&#x2F;                                                                                                  
    public String toJson() &#123;                                                                             
        String blockChainString &#x3D; JSON.toJSONString(blockChain);                                         
        return blockChainString;                                                                         
    &#125;                                                                                                    
                                                                                                         
    &#x2F;**                                                                                                  
     * 设置挖矿难度                                                                                            
     * @param difficulty                                                                                 
     *&#x2F;                                                                                                  
    public void setDifficulty(int difficulty) &#123;                                                          
        this.difficulty &#x3D; difficulty;                                                                    
    &#125;                                                                                                    
                                                                                                         
&#125;                                                                                                        </code></pre>
<h1 id="8-测试"><a class="markdownIt-Anchor" href="#8-测试"></a> 8. 测试</h1>
<ul>
<li>在一个测试类中走一遍基本功能：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public void test2() &#123;
    &#x2F;&#x2F;用于支撑验证签名的功能
    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider()); 

    &#x2F;&#x2F;初始化区块链
    ZJChain zjChain &#x3D; new ZJChain();

    &#x2F;&#x2F;创建钱包
    Wallet walletA &#x3D; new Wallet();
    Wallet walletB &#x3D; new Wallet();
    &#x2F;&#x2F;初始交易的钱包
    Wallet coinBase &#x3D; new Wallet();

    &#x2F;&#x2F;创建初始交易
    &#x2F;&#x2F;最初的交易的value从coinbase凭空出现
    System.out.println(&quot;第一次交易：coinbase向walletA转账100&quot;);
    ZJChain.genesisTransaction &#x3D; new Transaction(coinBase.publicKey, walletA.publicKey, 100f, null);
    &#x2F;&#x2F;生成coinbase对此次交易的签名
    ZJChain.genesisTransaction.generateSignature(coinBase.privateKey);
    &#x2F;&#x2F;初始交易id设为0
    ZJChain.genesisTransaction.transactionId &#x3D; &quot;0&quot;;
    &#x2F;&#x2F;因为初始交易是凭空生成，与普通交易不同，所以很多参数需要手动设置
    ZJChain.genesisTransaction.outputs.add(new TransactionOutput(
            ZJChain.genesisTransaction.recipient,
            ZJChain.genesisTransaction.value,
            ZJChain.genesisTransaction.transactionId));
    &#x2F;&#x2F;将本次交易输出添加到UTXOs
    ZJChain.UTXOs.put(ZJChain.genesisTransaction.outputs.get(0).id,
            ZJChain.genesisTransaction.outputs.get(0));

    System.out.println(&quot;挖矿生成第一个区块。。。&quot;);
    &#x2F;&#x2F;前面的哈希值为手动设为0
    Block genesis &#x3D; new Block(&quot;0&quot;);
    &#x2F;&#x2F;添加交易
    genesis.addTransaction(ZJChain.genesisTransaction);
    &#x2F;&#x2F;将该块加入区块链中
    zjChain.addBlock(genesis);

    System.out.println(&quot;第二笔交易： walletA向walletB转账20&quot;);
    System.out.println(&quot;WalletA的余额：&quot; + walletA.getBalance());
    System.out.println(&quot;WalletB的余额：&quot; + walletB.getBalance());
    &#x2F;&#x2F;新生成一个区块用于记账
    System.out.println(&quot;挖矿生成第二个区块。。。&quot;);
    Block block1 &#x3D; new Block(genesis.hash);
    block1.addTransaction(walletA.sendFunds(walletB.publicKey, 20f));
    zjChain.addBlock(block1);
    System.out.println(&quot;第二笔交易结束&quot;);
    System.out.println(&quot;WalletA的余额：&quot; + walletA.getBalance());
    System.out.println(&quot;WalletB的余额：&quot; + walletB.getBalance());

    zjChain.isChainValid();
&#125;</code></pre>
<ul>
<li>结果：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/5N08eT.png" alt="5N08eT" /></li>
</ul>
<h1 id="9-写在最后"><a class="markdownIt-Anchor" href="#9-写在最后"></a> 9. 写在最后</h1>
<ul>
<li>不得不说，比特币的出现是一次思维的革命。写这个小项目的时候虽然我没有去涉及高深的密码学算法，但是其中蕴含的天才思维逻辑也依旧让我震撼不已（同时也迷糊不已，即使已经粗略写了一下，很多地方还是不能理解得很清楚。。。）。</li>
<li>再想到比特币的创始人至今不知道其真实姓名，此时看这神秘的“中本聪”仿佛有了看金庸笔下的隐世高手的感觉。这或许就是程序员的浪漫吧！</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/Python%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/Python%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/index.html" class="post-title-link" itemprop="url">Python深度学习环境</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-13 08:01:19" itemprop="dateCreated datePublished" datetime="2021-06-13T08:01:19+08:00">2021-06-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:30:12" itemprop="dateModified" datetime="2022-09-17T19:30:12+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="anaconda"><a class="markdownIt-Anchor" href="#anaconda"></a> Anaconda</h1>
<ul>
<li>简介：
<ul>
<li>Anaconda包括Conda、Python以及一大堆安装好的180多个科学包及其依赖项，比如：numpy、pandas等。</li>
<li>Anaconda 是在 conda（一个包管理器和环境管理器）上发展出来的。</li>
<li>conda是一个开源的包、环境管理器，可以用于在同一个机器上安装不同版本的软件包及其依赖，并能够在不同的环境之间切换。</li>
<li>如果计算机上已经安装了 Python，安装Anaconda不会对你有任何影响。实际上，脚本和程序使用的默认 Python 是 Anaconda 附带的 Python，所以安装完Anaconda已经自带安装好了Python，不需要你再安装Python了。</li>
</ul>
</li>
<li>安装 Anaconda:
<ol>
<li>Anaconda 可用于多个平台（ Windows、Mac OS X 和 Linux）。你可以在<a target="_blank" rel="noopener" href="https://docs.anaconda.com/anaconda/install/">官网</a>上找到安装程序和安装说明。根据你的操作系统是32位还是64位选择对应的版本下载。</li>
<li>启动下载的Anaconda安装器(如果是windows 10系统，注意在安装Anaconda软件的时候，右击安装软件→选择以管理员的身份运行。)</li>
</ol>
</li>
<li>最终效果：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210613111434.png" alt="" /></li>
<li>不知道为什么，在我的vpn开着的时候，Anaconda的界面启动不了。。。</li>
<li>在Windows上使用与Anaconda相关的功能（如启动Jupyter，安装包等）尽量都先用管理员身份启动Anaconda Navigator页，然后再在这里面启动相关的功能，不然会有很多奇怪的问题。</li>
</ul>
<h1 id="jupyter-notebook"><a class="markdownIt-Anchor" href="#jupyter-notebook"></a> Jupyter notebook</h1>
<ul>
<li>Jupyter notebook（<a target="_blank" rel="noopener" href="http://jupyter.org/%EF%BC%89">http://jupyter.org/）</a> 是一种 Web 应用，能让用户将说明文本、数学方程、代码和可视化内容全部组合到一个易于共享的文档中。</li>
<li>安装Jupyter notebook：安装 Jupyter 的最简单方法是使用 Anaconda。该发行版附带了 Jupyter notebook。你能够在默认环境下使用 notebook。所以在安装好了Anaconda之后，我们已经有了Jupyter。</li>
</ul>
<h1 id="pycharm"><a class="markdownIt-Anchor" href="#pycharm"></a> Pycharm</h1>
<ul>
<li>PyCharm是一种Python IDE（Integrated Development Environment，集成开发环境），带有一整套可以帮助用户在使用Python语言开发时提高其效率的工具，比如调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制。做一个项目还是需要Pycharm。</li>
<li><a target="_blank" rel="noopener" href="https://www.jetbrains.com/zh-cn/pycharm/">官网</a>下载安装，用学生邮箱白嫖专业版。</li>
<li>直接使用Pycharm时还是Pycharm自己去下载各种包，与Anaconda无关，要想在Pycharm中使用Anaconda中安装好的包，需要Pycharm使用Anaconda的解释器来运行程序。</li>
</ul>
<h1 id="tensorflow"><a class="markdownIt-Anchor" href="#tensorflow"></a> tensorflow</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://tensorflow.google.cn/">tensorflow官网</a></li>
<li>简介：TensorFlow 是由 Google Brain 团队为深度神经网络（DNN）开发的功能强大的开源软件库，它在图形分类、音频处理、推荐系统和自然语言处理等场景下有着丰富的应用，除了 Python，TensorFlow 也提供了 C/C++、Java、Go、R 等其它编程语言的接口。</li>
<li>安装：<code>pip install tensorflow-gpu</code>，因为电脑有一张Nvidia的GTX 1660 ti的显卡，所以使用GPU版本的tensorflow。</li>
<li>因为要使用NVIDA的显卡，所以得安装CUDA和CUDNN：<a target="_blank" rel="noopener" href="https://developer.nvidia.com/cuda-downloads">官网</a>
<ul>
<li>CUDA(ComputeUnified Device Architecture)，是显卡厂商NVIDIA推出的运算平台。 CUDA是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题.
<ul>
<li>CUDA可以在官网获得一个安装程序，运行安装即可。</li>
</ul>
</li>
<li>NVIDIA cuDNN是用于深度神经网络的GPU加速库。它强调性能、易用性和低内存开销。NVIDIA cuDNN可以集成到更高级别的机器学习框架中，如谷歌的Tensorflow、加州大学伯克利分校的流行caffe软件。<a target="_blank" rel="noopener" href="https://developer.nvidia.com/cudnn-download-survey">下载CUDNN</a>
<ul>
<li>CUDNN下载获得一个压缩文件，解压缩后将CUDNN中的文件复制到CUDA对应的目录中去。<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210613132548.png" alt="" /></li>
</ul>
</li>
<li>将<code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.3\lib\x64</code>添加到环境变量</li>
</ul>
</li>
<li>使用<code>import tensorflow as tf</code>检查tensorflow是否安装好。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E9%A1%B9%E7%9B%AE/Python%E5%AE%9E%E7%8E%B0%E8%AF%8D%E4%BA%91/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E9%A1%B9%E7%9B%AE/Python%E5%AE%9E%E7%8E%B0%E8%AF%8D%E4%BA%91/index.html" class="post-title-link" itemprop="url">Python实现词云</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-13 08:00:19" itemprop="dateCreated datePublished" datetime="2021-06-13T08:00:19+08:00">2021-06-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:30:12" itemprop="dateModified" datetime="2022-09-17T19:30:12+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h1>
<ul>
<li>什么是词云：
<ul>
<li>“词云”就是通过形成“关键词云层”或“关键词渲染”，对网络文本中出现频率较高的“关键词”的视觉上的突出。</li>
<li>示例：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210613142756.png" alt="" /></li>
</ul>
</li>
<li>wordcloud包：wordcloud是优秀的词云展示第三方库，<a target="_blank" rel="noopener" href="http://amueller.github.io/word_cloud/index.html">官网</a></li>
<li>Matplotlib：是 Python 的绘图库。 它可与 NumPy 一起使用，提供了一种有效的 MatLab 开源替代方案。<a target="_blank" rel="noopener" href="https://matplotlib.org/">官网</a></li>
<li>jieba: jieba库是一款优秀的 Python 第三方中文分词库.<a target="_blank" rel="noopener" href="https://github.com/fxsjy/jieba">github地址</a></li>
<li>PIL: Python图像库PIL(Python Image Library)是python的第三方图像处理库，但是由于其强大的功能与众多的使用人数，几乎已经被认为是python官方图像处理库了。</li>
<li>安装以上库：<code>pip install wordcloud matplotlib jieba pil</code>，如果使用pycharm的话，也可以不装，在使用到的时候被报错提醒再装。</li>
<li>最好使用Anaconda安装，然后pycharm中使用Anaconda的解释器，毕竟Anaconda是个包管理器，可以一次安装，多次使用：<code>conda install -c conda-forge wordcloud jieba</code>,因为Anaconda原生的库中没有wordcloud 和jieba这两个包，所以要到conda-forge这个库中下载，而matplotlib 和 pil比较通用，直接<code>conda install matplotlib pil</code>就行。（我的Anaconda都自带这两个包）</li>
</ul>
<h1 id="针对英文文本简单尝试"><a class="markdownIt-Anchor" href="#针对英文文本简单尝试"></a> 针对英文文本简单尝试</h1>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"># 导入相关包
from wordcloud import WordCloud
import matplotlib.pyplot as plt

# 打开要读的文档
text &#x3D; open(&#39;English.txt&#39;).read()

# 生成wordcloud对象
wc &#x3D; WordCloud().generate(text)

# 根据wordCloud对象绘图
plt.imshow(wc, interpolation&#x3D;&#39;bilinear&#39;) #绘制图片 interpolation是设置图片的效果
plt.axis(&quot;off&quot;) #关闭坐标轴
plt.show()	#展示结果图

# 将生成的wordcloud对象转化为图片文件存储
wc.to_file(&quot;wordcloud.png&quot;)</code></pre>
<ul>
<li>效果：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210613153856.png" alt="" /></li>
<li>文本：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">Everybody has to face bad days in their life. Some face ailments, some face fears, some face poverty, some face helplessness etc etc. No one can escape from it. It is a rule of life. Two things always combines together like joy and sadness, laugh and cry, health and illness, profit and loss, morning and night, confidence and inferiority complex, victory and failure likewise good days and bad days.</code></pre>
<h1 id="wordcloud的参数"><a class="markdownIt-Anchor" href="#wordcloud的参数"></a> WordCloud()的参数</h1>
<ol>
<li>width:指定词云对象生成图片的宽度,默认400像素,<code>w=wordcloud.WordCloud(width=600)</code></li>
<li>height:指定词云对象生成图片的高度,默认200像素 <code>w=wordcloud.WordCloud(height=400)</code></li>
<li>min_font_size:指定词云中字体的最小字号，默认4号 <code>w=wordcloud.WordCloud(min_font_size=10)</code></li>
<li>max_font_size:指定词云中字体的最大字号，根据高度自动调节, <code>w=wordcloud.WordCloud(max_font_size=20)</code></li>
<li>font_step:指定词云中字体字号的步进间隔，默认为1, <code>w=wordcloud.WordCloud(font_step=2)</code></li>
<li>font_path:指定文体文件的路径，默认None, <code>w=wordcloud.WordCloud(font_path=&quot;msyh.ttc&quot;)</code></li>
<li>max_words:指定词云显示的最大单词数量,默认200, <code>w=wordcloud.WordCloud(max_words=20)</code></li>
<li>stop_words:指定词云的排除词列表，即不显示的单词列表, <code>w=wordcloud.WordCloud(stop_words=&quot;Python&quot;)</code></li>
<li>mask:蒙版，指定词云形状，默认为长方形，需要读取图片来设置</li>
</ol>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">from scipy.msc import imread
mk&#x3D;imread(&quot;pic.png&quot;)
w&#x3D;wordcloud.WordCloud(mask&#x3D;mk)</code></pre>
<ol start="11">
<li>background_color:指定词云图片的背景颜色，默认为黑色, w=wordcloud.WordCloud(background_color=“white”)</li>
<li>mode: 颜色模式，默认为RGB模式，如果为RGBA模式且background_color设置为None，则背景将透明。</li>
</ol>
<h1 id="中文词云"><a class="markdownIt-Anchor" href="#中文词云"></a> 中文词云</h1>
<ul>
<li>因为英文文本用空格分隔，所以不用分词，但是中文文本需要进行分词处理，才能使结果有意义。同时还需要注意编码方式的指定。同时也要注意<strong>wrodcloud</strong>的中文字体的指定</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">from wordcloud import WordCloud
import matplotlib.pyplot as plt
import jieba

# 打开要读的文档
file &#x3D; open(&#39;kyj.txt&#39;, encoding&#x3D;&#39;utf-8&#39;).read()

# 用jieba库来分词
file &#x3D; &#39; &#39;.join(jieba.cut(file))
# 生成wordcloud对象
wc &#x3D; WordCloud(font_path&#x3D;&#39;2.ttf&#39;).generate(file) #一定要指定中文字体，不然无法显示

# 根据wordCloud对象绘图
plt.imshow(wc, interpolation&#x3D;&#39;bilinear&#39;) #绘制图片 interpolation是设置图片的效果
plt.axis(&quot;off&quot;) #关闭坐标轴
plt.show()	#展示结果图

# 将生成的wordcloud对象转化为图片文件存储
wc.to_file(&quot;wordcloud2.png&quot;)</code></pre>
<ul>
<li>分词的效果：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210613171040.png" alt="" /></li>
</ul>
<h1 id="蒙版的使用"><a class="markdownIt-Anchor" href="#蒙版的使用"></a> 蒙版的使用</h1>
<ul>
<li>需要一张蒙版图片，最后词云会对应图片中白色的部分不显示内容，黑色的部分显示内容
<ul>
<li>原始图片<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210613173258.jpg" alt="" /></li>
<li>词云样式：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210613173325.png" alt="" /></li>
</ul>
</li>
<li>代码</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">from wordcloud import WordCloud
import matplotlib.pyplot as plt
import jieba
import numpy as np
from PIL import Image

# 打开要读的文档
file &#x3D; open(&#39;kyj.txt&#39;, encoding&#x3D;&#39;utf-8&#39;).read()

file &#x3D; &#39; &#39;.join(jieba.cut(file))
print(file)
# 生成wordcloud对象
mask &#x3D; np.array(Image.open(&quot;3.jpg&quot;)) #根据图片生成mask，实质是个数组
wc &#x3D; WordCloud(font_path&#x3D;&#39;2.ttf&#39;, mask&#x3D;mask, mode&#x3D;&#39;RGBA&#39;, background_color&#x3D;None).generate(file)

# 根据wordCloud对象绘图
plt.imshow(wc, interpolation&#x3D;&#39;bilinear&#39;) #绘制图片 interpolation是设置图片的效果
plt.axis(&quot;off&quot;) #关闭坐标轴
plt.show()	#展示结果图

# 将生成的wordcloud对象转化为图片文件存储
wc.to_file(&quot;wordcloud2.png&quot;)</code></pre>
<h1 id="词云跟随图片色彩"><a class="markdownIt-Anchor" href="#词云跟随图片色彩"></a> 词云跟随图片色彩</h1>
<ul>
<li>需要导入wordcloud的ImageColorGenerator()方法</li>
<li>代码：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">from wordcloud import WordCloud
import matplotlib.pyplot as plt
import jieba
import numpy as np
from PIL import Image
from wordcloud import ImageColorGenerator

# 打开要读的文档
file &#x3D; open(&#39;kyj.txt&#39;, encoding&#x3D;&#39;utf-8&#39;).read()

file &#x3D; &#39; &#39;.join(jieba.cut(file))
print(file)
# 生成wordcloud对象
mask &#x3D; np.array(Image.open(&quot;3.jpg&quot;)) #根据图片生成mask，实质是个数组
wc &#x3D; WordCloud(font_path&#x3D;&#39;2.ttf&#39;, mask&#x3D;mask, mode&#x3D;&#39;RGBA&#39;, background_color&#x3D;None).generate(file)

# 让词云跟随图片色彩
image_colors &#x3D; ImageColorGenerator(mask) # 获取图片各个部分的颜色
wc.recolor(color_func&#x3D;image_colors) #将这些颜色设置给wordcloud对象

# 根据wordCloud对象绘图
plt.imshow(wc, interpolation&#x3D;&#39;bilinear&#39;) #绘制图片 interpolation是设置图片的效果
plt.axis(&quot;off&quot;) #关闭坐标轴
plt.show()	#展示结果图

# 将生成的wordcloud对象转化为图片文件存储
wc.to_file(&quot;wordcloud2.png&quot;)</code></pre>
<ul>
<li>效果；<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210613174516.png" alt="" /></li>
</ul>
<h1 id="去掉无实意的词"><a class="markdownIt-Anchor" href="#去掉无实意的词"></a> 去掉无实意的词</h1>
<ul>
<li>有一些词如：“的，一些”等，虽然出现频率很高，但并没意义。所以我们需要去掉这些词，这在wordcloud中叫做停用词。</li>
<li>对于英文：
<ul>
<li>wordcloud自带了一个停用词表，是一个集合数据类型。</li>
<li>没有停用词<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210613184511.png" alt="" /></li>
<li>有停用词：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210613184706.png" alt="" /></li>
<li>代码：需要引入wordcloud的STOPWORDS</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">from wordcloud import WordCloud
import matplotlib.pyplot as plt
import jieba
import numpy as np
from PIL import Image
from wordcloud import ImageColorGenerator
from wordcloud import STOPWORDS


# 打开要读的文档
file &#x3D; open(&#39;English.txt&#39;, encoding&#x3D;&#39;utf-8&#39;).read()

# file &#x3D; &#39; &#39;.join(jieba.cut(file))
print(file)
# 生成wordcloud对象
# 停用词
stopwords &#x3D; STOPWORDS #获取wordcloud自带的停用词表
stopwords.add(&quot;T&quot;) # 可以自己在这个停用词集合中添加词
mask &#x3D; np.array(Image.open(&quot;3.jpg&quot;)) #根据图片生成mask，实质是个数组
wc &#x3D; WordCloud(stopwords&#x3D;stopwords,font_path&#x3D;&#39;2.ttf&#39;, mask&#x3D;mask, mode&#x3D;&#39;RGBA&#39;, background_color&#x3D;None).generate(file)

# 让词云跟随图片色彩
image_colors &#x3D; ImageColorGenerator(mask) # 获取图片各个部分的颜色
wc.recolor(color_func&#x3D;image_colors) #将这些颜色设置给wordcloud对象



# 根据wordCloud对象绘图
plt.imshow(wc, interpolation&#x3D;&#39;bilinear&#39;) #绘制图片 interpolation是设置图片的效果
plt.axis(&quot;off&quot;) #关闭坐标轴
plt.show()	#展示结果图

# 将生成的wordcloud对象转化为图片文件存储
wc.to_file(&quot;wordcloud2.png&quot;)</code></pre>
<ul>
<li>对于中文，原理一样，但是需要自己去准备停用词表，<a target="_blank" rel="noopener" href="https://github.com/goto456/stopwords">下载链接</a>
<ul>
<li>没有停用词<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210613174516.png" alt="" /></li>
<li>有停用词<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210613185335.png" alt="" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">from wordcloud import WordCloud
import matplotlib.pyplot as plt
import jieba
import numpy as np
from PIL import Image
from wordcloud import ImageColorGenerator



# 打开要读的文档
file &#x3D; open(&#39;kyj.txt&#39;, encoding&#x3D;&#39;utf-8&#39;).read()

file &#x3D; &#39; &#39;.join(jieba.cut(file))
print(file)

# 生成wordcloud对象
# 停用词
stopwords &#x3D; set() #设为集合
content &#x3D; [line.strip() for line in open(&#39;cn_stopwords.txt&#39;,encoding&#x3D;&#39;utf-8&#39;).readlines()] #从停用词表中获取数据
stopwords.update(content) #将停用词表存入集合中
mask &#x3D; np.array(Image.open(&quot;3.jpg&quot;)) #根据图片生成mask，实质是个数组
wc &#x3D; WordCloud(stopwords&#x3D;stopwords,font_path&#x3D;&#39;2.ttf&#39;, mask&#x3D;mask, mode&#x3D;&#39;RGBA&#39;, background_color&#x3D;None).generate(file)

# 让词云跟随图片色彩
image_colors &#x3D; ImageColorGenerator(mask) # 获取图片各个部分的颜色
wc.recolor(color_func&#x3D;image_colors) #将这些颜色设置给wordcloud对象


# 根据wordCloud对象绘图
plt.imshow(wc, interpolation&#x3D;&#39;bilinear&#39;) #绘制图片 interpolation是设置图片的效果
plt.axis(&quot;off&quot;) #关闭坐标轴
plt.show()	#展示结果图

# 将生成的wordcloud对象转化为图片文件存储
wc.to_file(&quot;wordcloud2.png&quot;)</code></pre>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.zestaken.top/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/LeetCode-%E5%AD%97%E7%AC%A6%E4%B8%B2/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zestaken">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZestJourney">
      <meta itemprop="description" content="吾好梦中读书~">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZestJourney">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/LeetCode-%E5%AD%97%E7%AC%A6%E4%B8%B2/index.html" class="post-title-link" itemprop="url">Leetcode-字符串</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-11 19:49:16" itemprop="dateCreated datePublished" datetime="2021-06-11T19:49:16+08:00">2021-06-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-17 19:41:22" itemprop="dateModified" datetime="2022-09-17T19:41:22+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>20k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>19 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<h2 id="string类的charat与tochararray实现原理"><a class="markdownIt-Anchor" href="#string类的charat与tochararray实现原理"></a> String类的charAt()与toCharArray()实现原理</h2>
<ul>
<li>例题：<a href="#1-ip-%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96-1108">ip-地址无效化-1108</a></li>
<li>看一下charAt()的源码：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public char charAt(int index) &#123;
    if ((index &lt; 0) || (index &gt;&#x3D; value.length)) &#123;
        throw new StringIndexOutOfBoundsException(index);
    &#125;
    return value[index];
&#125;</code></pre>
<ul>
<li>这就是直接在数组中取值的方法。那么value是什么东西呢？</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** The value is used for character storage. *&#x2F;
private final char value[];

&#x2F;&#x2F;再看看构造方法
public String() &#123;
    this.value &#x3D; &quot;&quot;.value;
&#125;

public String(String original) &#123;
    this.value &#x3D; original.value;
    this.hash &#x3D; original.hash;
&#125;

&#x2F;&#x2F;这个体现得最好，直接就是字符数组之间的copy
public String(char value[]) &#123;
    this.value &#x3D; Arrays.copyOf(value, value.length);
&#125;</code></pre>
<ul>
<li><code>value</code>的声明为一个字符数组，而且构造方法中通过<code>original.value</code>的方法赋值，也是将这个String对象中的value字符数组，赋给新的这个String对象。所以说白了，String类，就是一个字符数组给它加上一大堆方法封装而成的。（倒和C语言本质差不多）。</li>
<li>String类的核心是字符数组，所以能轻易把它转换为字符数组也不奇怪了，toCharArray的实质就是把封装在String中的字符数组value取出来用：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public char[] toCharArray() &#123;
    &#x2F;&#x2F; Cannot use Arrays.copyOf because of class initialization order issues
    char result[] &#x3D; new char[value.length];
    System.arraycopy(value, 0, result, 0, value.length);
    return result;
&#125;</code></pre>
<h2 id="stringbuilder的append方法的参数"><a class="markdownIt-Anchor" href="#stringbuilder的append方法的参数"></a> StringBuilder的append()方法的参数</h2>
<ul>
<li>例题：<a href="#1-ip-%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96-1108">ip-地址无效化-1108</a></li>
<li>append方法既能传字符，也能直接传字符串。事实上，不仅是字符和字符串，基本上其它类型如int，long等都能传，因为它们都能转为字符啊。看一下append是如何实现的：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public AbstractStringBuilder append(char c) &#123;
    ensureCapacityInternal(count + 1);
    &#x2F;&#x2F;直接在字符数组最后一位后加一个字符
    value[count++] &#x3D; c;
    return this;
&#125;

public AbstractStringBuilder append(int i) &#123;
    if (i &#x3D;&#x3D; Integer.MIN_VALUE) &#123;
        append(&quot;-2147483648&quot;);
        return this;
    &#125;
    int appendedLength &#x3D; (i &lt; 0) ? Integer.stringSize(-i) + 1
                                 : Integer.stringSize(i);
    int spaceNeeded &#x3D; count + appendedLength;
    ensureCapacityInternal(spaceNeeded);
    &#x2F;&#x2F;将整型转化合适长度的字符存入value字符数组中
    Integer.getChars(i, spaceNeeded, value);
    count &#x3D; spaceNeeded;
    return this;
&#125;

public AbstractStringBuilder append(String str) &#123;
    if (str &#x3D;&#x3D; null)
        return appendNull();
    int len &#x3D; str.length();
    ensureCapacityInternal(count + len);
    str.getChars(0, len, value, count);
    count +&#x3D; len;
    return this;
&#125;</code></pre>
<ul>
<li>结合String的本质是字符数组这一点来看，这一切都十分简单：只要最后能转为char，什么都可以往字符数组里塞。</li>
</ul>
<h2 id="stringbuilder的insert方法使用"><a class="markdownIt-Anchor" href="#stringbuilder的insert方法使用"></a> StringBuilder的insert()方法使用</h2>
<ul>
<li>例题： <a href="#1-ip-%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96-1108">1-ip-地址无效化-1108</a></li>
<li>首先看一下insert方法插入字符的源码，了解它的主要实现逻辑：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public AbstractStringBuilder insert(int offset, char c) &#123;
    ensureCapacityInternal(count + 1);
    &#x2F;&#x2F;将当前位置字符及其后面的字符依次向后挪一位
    System.arraycopy(value, offset, value, offset + 1, count - offset);
    &#x2F;&#x2F;当前位置赋值为指定字符
    value[offset] &#x3D; c;
    &#x2F;&#x2F;字符串总长度加一
    count +&#x3D; 1;
    return this;
&#125;</code></pre>
<ul>
<li>根据insert方法的实现逻辑，insert方法是将当前位置及其以后的字符依次向后移一位，然后当前位置变为指定字符。所以插入一个字符后，原来字符的下标就变为了<code>offsetn + 1</code>（原来字符及其以后的字符的下标都加一）,原来字符之前的字符相对位置不变。</li>
<li>此外，类似append方法，insert方法也是可以直接插入字符串的（不仅字符串，还有许多其它的类型，如字符数组，浮点数（float），int，boolean等，只是最终效果都是添加成字符串）：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;举两个例子
    &#x2F;**
     * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;
     *&#x2F;
    @Override
    public StringBuilder insert(int dstOffset, CharSequence s,
                                int start, int end)
    &#123;
        super.insert(dstOffset, s, start, end);
        return this;
    &#125;

    &#x2F;**
     * @throws StringIndexOutOfBoundsException &#123;@inheritDoc&#125;
     *&#x2F;
    @Override
    public StringBuilder insert(int offset, Object obj) &#123;
            super.insert(offset, obj);
            return this;
    &#125;</code></pre>
<h2 id="string与stringbuilder"><a class="markdownIt-Anchor" href="#string与stringbuilder"></a> String与StringBuilder</h2>
<ul>
<li>要说String和StringBuilder有什么不同，最直观的使用体验就是，String是不能变的，初始化时是啥就是一直是啥，想要改String的内容，就只能重新初始化一个String在其中加上想要改的内容。而StringBuider呢，从它特有的append和insert方法就可以看出，这兄弟的内容和长短可以随便改。</li>
<li>String和StringBuilder的本质都是字符数组，但是其中又有不同：
<ul>
<li>String：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** The value is used for character storage. *&#x2F;
 private final char value[];</code></pre>
<ul>
<li>StringBuilder:继承自AbstractStringBuilder，我们大致看一下AbstractStringBuilder就可以了解情况了。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">
&#x2F;**
 * The value is used for character storage.
 *&#x2F;
char[] value;

&#x2F;&#x2F;再看一个在append和insert方法中都出现了的方法：用于实现动态扩容
private void ensureCapacityInternal(int minimumCapacity) &#123;
    &#x2F;&#x2F; overflow-conscious code
    if (minimumCapacity - value.length &gt; 0) &#123;
        value &#x3D; Arrays.copyOf(value,
                newCapacity(minimumCapacity));
    &#125;
&#125;</code></pre>
<ul>
<li>这下其实就很明显了，String核心是一个<code>final char[]</code>，而StringBuilder就是一个普通的<code>char[]</code>。final修饰的是初始化之后就不能改变的变量。而StringBuilder用着普通的字符数组，还为它配备了像ensureCapacityInternal这种动态扩容的方法以insert和append这种改变字符数组内容的方法，所以它可以随意变化值或长度。</li>
<li>不得不说，这就是，铁打的字符数组，流水的方法。。。</li>
</ul>
<h2 id="foreach循环的原理"><a class="markdownIt-Anchor" href="#foreach循环的原理"></a> foreach循环的原理</h2>
<ul>
<li>例题：<a href="#1-ip-%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96-1108">1-ip-地址无效化-1108</a></li>
<li>foreach循环可以用来遍历数组或者集合。虽然遍历这两者的用法相同，但是实现原理却不一样。</li>
<li>首先看看遍历数组时是什么情况,将我们遍历字符数组的代码编译后反编译一下：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;自己编写的源码
    &#x2F;&#x2F;将String转为字符数组，利用foreach循环遍历
    public String deFangIpaddr5 (String address) &#123;
        StringBuilder newAddress &#x3D; new StringBuilder();
        for(char temp : address.toCharArray()) &#123;
            if(temp &#x3D;&#x3D; &#39;.&#39;) &#123;
                newAddress.append(&quot;[.]&quot;);
            &#125; else &#123;
                newAddress.append(temp);
            &#125;
        &#125;
        return newAddress.toString();
    &#125;

&#x2F;&#x2F;编译后反编译得到的源码
   public String deFangIpaddr5(String address) &#123;
      StringBuilder newAddress &#x3D; new StringBuilder();
      char[] var3 &#x3D; address.toCharArray();
      int var4 &#x3D; var3.length;

      for(int var5 &#x3D; 0; var5 &lt; var4; ++var5) &#123;
         char temp &#x3D; var3[var5];
         if (temp &#x3D;&#x3D; &#39;.&#39;) &#123;
            newAddress.append(&quot;[.]&quot;);
         &#125; else &#123;
            newAddress.append(temp);
         &#125;
      &#125;

      return newAddress.toString();
   &#125;</code></pre>
<ul>
<li>二者对比一下，就可以看出，foreach循环做的事就是将我们以前遍历取值的的标准for循环封装了一下：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">for(int var5 &#x3D; 0; var5 &lt; var4; ++var5) &#123;
    char temp &#x3D; var3[var5];
    ...
&#125;

&#x2F;&#x2F;等价于

for(char temp : address.toCharArray()) &#123;
    ...
&#125;</code></pre>
<ul>
<li>这其中也要注意一个小细节，用于接收值的变量是每一次循环都要重新声明的，所以foreach循环中的临时变量只能现场声明，不能用之前声明好的。</li>
<li>遍历集合的情况，偷个懒，等遇到了再说。。。</li>
</ul>
<hr />
<h1 id="1-ip-地址无效化-1108"><a class="markdownIt-Anchor" href="#1-ip-地址无效化-1108"></a> 1. IP 地址无效化 1108</h1>
<ul>
<li>题目：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。
所谓无效化 IP 地址，其实就是用 &quot;[.]&quot; 代替了每个 &quot;.&quot;

示例 1：

输入：address &#x3D; &quot;1.1.1.1&quot;
输出：&quot;1[.]1[.]1[.]1&quot;
示例 2：

输入：address &#x3D; &quot;255.100.50.0&quot;
输出：&quot;255[.]100[.]50[.]0&quot;
 

提示：
给出的 address 是一个有效的 IPv4 地址</code></pre>
<h2 id="java解法"><a class="markdownIt-Anchor" href="#java解法"></a> java解法</h2>
<ul>
<li>法一：
<ul>
<li>遍历整个字符串，同时新建一个空的StringBuilder，遇到<code>.</code>的时候，加上<code>[]</code>使用<code>append()</code>添加进入StringBuilder中去。</li>
<li>评测结果：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210611201714.png" alt="" /></li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;解题代码
    public String deFangIpaddr1 (String address) &#123;
        StringBuilder newAddress &#x3D; new StringBuilder();
        for(int i &#x3D; 0; i &lt; address.length(); i++) &#123;
            char temp &#x3D; address.charAt(i);
            if(temp &#x3D;&#x3D; &#39;.&#39;) &#123;
                newAddress.append(&#39;[&#39;);
                newAddress.append(&#39;.&#39;);
                newAddress.append(&#39;]&#39;);
            &#125; else &#123;
                newAddress.append(temp);
            &#125;
        &#125;

        return newAddress.toString();
    &#125;

&#x2F;&#x2F;JUnit测试用例
    @Test
    public void testDeFangIpaddr1() &#123;
        DefangIPaddr test &#x3D; new DefangIPaddr();
        String res &#x3D; test.deFangIpaddr1(&quot;127.0.0.1&quot;);
        String expRes &#x3D; &quot;127[.]0[.]0[.]1&quot;;
        assert res.equals(expRes) : res;
    &#125;</code></pre>
<ul>
<li>法二
<ul>
<li>调用String的<code>replace()</code>方法，直接将<code>.</code>替换为<code>[.]</code></li>
<li>评测结果：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210611202515.png" alt="" /></li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;解题代码
    public String deFangIpaddr2(String address) &#123;
        return address.replace(&quot;.&quot;, &quot;[.]&quot;);
    &#125;

&#x2F;&#x2F;测试用例
    @Test
    public void testDeFangIpaddr2() &#123;
        DefangIPaddr test &#x3D; new DefangIPaddr();
        String res &#x3D; test.deFangIpaddr2(&quot;127.0.0.1&quot;);
        String expRes &#x3D; &quot;127[.]0[.]0[.]1&quot;;
        assert res.equals(expRes) : res;
    &#125;</code></pre>
<ul>
<li>法三：
<ul>
<li>创建StringBuilder对象，并把原字符串赋给它，调用其<code>insert</code>方法，在<code>.</code>的前后插入<code>[]</code>。</li>
<li>评测结果：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210611204856.png" alt="" /></li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;解题代码
    &#x2F;&#x2F;StringBuilder的insert
    public String deFangIpaddr3 (String address) &#123;
        StringBuilder newAddress &#x3D; new StringBuilder(address);
        for(int i &#x3D; 0; i &lt; newAddress.length(); i++) &#123;
            if(newAddress.charAt(i) &#x3D;&#x3D; &#39;.&#39;) &#123;
                &#x2F;&#x2F;insert是当前计数位变为指定字符，原来的字符到下一位
                newAddress.insert(i + 1, &#39;]&#39;); &#x2F;&#x2F;先插后面的括号，这样.的位置还未改变，方便添加前面的括号
                newAddress.insert(i, &#39;[&#39;);
                i +&#x3D; 3;
                continue;
            &#125;
        &#125;
        return newAddress.toString();
    &#125;
&#x2F;&#x2F;测试用例
    @Test
    public void testDeFangIpaddr3() &#123;
        DefangIPaddr test &#x3D; new DefangIPaddr();
        String res &#x3D; test.deFangIpaddr3(&quot;127.0.0.1&quot;);
        String expRes &#x3D; &quot;127[.]0[.]0[.]1&quot;;
        assert res.equals(expRes) : res;
    &#125;</code></pre>
<ul>
<li>法四：
<ul>
<li>同一一样，但是append方法可以直接添加字符串。。。</li>
<li>评测结果：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210611205634.png" alt="" /></li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;解题代码
    &#x2F;&#x2F;StringBuilder的append可以直接添加字符串。。。
    public String deFangIpaddr4 (String address) &#123;
        StringBuilder newAddress &#x3D; new StringBuilder();
        for(int i &#x3D; 0; i &lt; address.length(); i++) &#123;
            char temp &#x3D; address.charAt(i);
            if(temp &#x3D;&#x3D; &#39;.&#39;) &#123;
&#x2F;&#x2F;                newAddress.append(&#39;[&#39;);
&#x2F;&#x2F;                newAddress.append(&#39;.&#39;);
&#x2F;&#x2F;                newAddress.append(&#39;]&#39;);
                newAddress.append(&quot;[.]&quot;);
            &#125; else &#123;
                newAddress.append(temp);
            &#125;
        &#125;

        return newAddress.toString();
    &#125;
&#x2F;&#x2F;测试用例
    @Test
    public void testDeFangIpaddr4() &#123;
        DefangIPaddr test &#x3D; new DefangIPaddr();
        String res &#x3D; test.deFangIpaddr4(&quot;127.0.0.1&quot;);
        String expRes &#x3D; &quot;127[.]0[.]0[.]1&quot;;
        assert res.equals(expRes) : res;
    &#125;</code></pre>
<ul>
<li>法五：
<ul>
<li>将String转为字符数组，利用foreach循环遍历</li>
<li>评测结果：<br />
<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210611211051.png" alt="" /></li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;解题代码
    &#x2F;&#x2F;将String转为字符数组，利用foreach循环遍历
    public String deFangIpaddr5 (String address) &#123;
        StringBuilder newAddress &#x3D; new StringBuilder();
        for(char temp : address.toCharArray()) &#123;
            if(temp &#x3D;&#x3D; &#39;.&#39;) &#123;
                newAddress.append(&quot;[.]&quot;);
            &#125; else &#123;
                newAddress.append(temp);
            &#125;
        &#125;
        return newAddress.toString();
    &#125;
&#x2F;&#x2F;测试用例
    @Test
    public void testDeFangIpaddr5() &#123;
        DefangIPaddr test &#x3D; new DefangIPaddr();
        String res &#x3D; test.deFangIpaddr5(&quot;127.0.0.1&quot;);
        String expRes &#x3D; &quot;127[.]0[.]0[.]1&quot;;
        assert res.equals(expRes) : res;
    &#125;</code></pre>
<h1 id="2-有效的字母异位词-242"><a class="markdownIt-Anchor" href="#2-有效的字母异位词-242"></a> 2. 有效的字母异位词 242</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-anagram/">题目</a></li>
</ul>
<hr />
<p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。<br />
注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。<br />
示例 1:</p>
<pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;
输出: true</code></pre>
<p>示例 2:</p>
<pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;
输出: false</code></pre>
<p>提示:</p>
<pre class="line-numbers language-none"><code class="language-none">1 &lt;&#x3D; s.length, t.length &lt;&#x3D; 5 * 104
s 和 t 仅包含小写字母</code></pre>
<h2 id="java解法-2"><a class="markdownIt-Anchor" href="#java解法-2"></a> Java解法</h2>
<ul>
<li>法一：字母异位代表着相同字母的出现次数一样。用一个26位的数组存储字母出现的次数（下标对应字母），遍历一次第一个字符串，存储各个字母的次数，然后再遍历第二个字符串，减去各个字母的次数，最后的数组值全为0，则说明字母异位。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/BuLLAf.png" alt="BuLLAf" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ValidAnagram242 &#123;

    public boolean isAnagram(String s, String t) &#123;
        &#x2F;&#x2F;存储判断结果
        boolean res &#x3D; true;
        &#x2F;&#x2F;用长度为26的整数数组表示每个字母出现的次数（下标表示字母，值代表出现次数）
        int[] abc &#x3D; new int[26];
        &#x2F;&#x2F;将字符串转换为字符数组遍历，将字母转化为数字，存储出现次数
        for(char i : s.toCharArray()) &#123;
            abc[i - &#39;a&#39;]++;
        &#125;
        &#x2F;&#x2F;遍历第二个字符数组，出现一个字母则对应位置次数减一
        for(char i : t.toCharArray()) &#123;
            abc[i - &#39;a&#39;]--;
        &#125;

        &#x2F;&#x2F;遍历数组，如果有对应位置字母出现次数不同，则对应位置的值不为0，返回false
        for(int i &#x3D; 0; i &lt; 26; i++) &#123;
            if(abc[i] !&#x3D; 0) &#123;
                return res &#x3D; false;
            &#125;
        &#125;
        &#x2F;&#x2F;所有元素都相等
        return res;
    &#125;
&#125;</code></pre>
<h1 id="3-同构字符串-205"><a class="markdownIt-Anchor" href="#3-同构字符串-205"></a> 3. 同构字符串 205</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/isomorphic-strings/">题目</a></li>
</ul>
<hr />
<p>给定两个字符串 s 和 t，判断它们是否是同构的。<br />
如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。<br />
每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</p>
<pre class="line-numbers language-none"><code class="language-none">示例 1:

输入：s &#x3D; &quot;egg&quot;, t &#x3D; &quot;add&quot;
输出：true
示例 2：

输入：s &#x3D; &quot;foo&quot;, t &#x3D; &quot;bar&quot;
输出：false
示例 3：

输入：s &#x3D; &quot;paper&quot;, t &#x3D; &quot;title&quot;
输出：true</code></pre>
<p>提示：<br />
可以假设 s 和 t 长度相同。</p>
<h2 id="java解法-3"><a class="markdownIt-Anchor" href="#java解法-3"></a> Java解法</h2>
<ul>
<li>法一：关键在于确定字母之间的映射关系，然后检测这种关系是否矛盾。字母之间的映射关系是通过字母出现的位置来决定的，字母第一次出现时就与同样位置的另一个字符相映射，如果之后这个字母再次出现，则对应的位置应还是哪个字符，也就是说，那个字符第一次出现的位置应相同。（本题偷懒使用两个哈希表实现，这样还不如直接用一个哈希表中将字母映射关系存好，直接对比。其实用26位的字符数组用以上思路应该也能做出来）
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210907223838.png" alt="" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class IsomorphicStrings205 &#123;
    public boolean isIsomorphic(String s, String t) &#123;
        &#x2F;&#x2F;将字符串转化为字符数组，便于遍历
        char[] s1 &#x3D; s.toCharArray();
        char[] s2 &#x3D; t.toCharArray();
        &#x2F;&#x2F;创建两个哈希集合，存储字符串中字符值及其第一次出现的位置
        Map&lt;Character, Integer&gt; map1 &#x3D; new HashMap&lt;&gt;();
        Map&lt;Character, Integer&gt; map2 &#x3D; new HashMap&lt;&gt;();

        &#x2F;&#x2F;遍历两个字符数组，同时记录位置，如果对应位置的字符的第一次出现的位置不同，则不是同构字符串
        for(int i &#x3D; 0; i &lt; s1.length; i++) &#123;
            &#x2F;&#x2F;用两个变量记录对应位置字母第一次出现的位置
            int pos1 &#x3D; i;
            int pos2 &#x3D; i;
            &#x2F;&#x2F;如果当前位置的字母是第一次出现，则存入哈希表，如果不是，则取出第一次出现位置
            if(!map1.containsKey(s1[i])) &#123;
                map1.put(s1[i], i);
            &#125; else &#123;
               pos1 &#x3D; map1.get(s1[i]);
            &#125;

            if(!map2.containsKey(s2[i])) &#123;
                map2.put(s2[i], i);
            &#125; else &#123;
                pos2 &#x3D; map2.get(s2[i]);
            &#125;
            &#x2F;&#x2F;如果两个字母第一次出现的位置不同，则不是同构字符串
            if(pos1 !&#x3D; pos2) &#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;
&#125;</code></pre>
<h1 id="4-回文子串-647"><a class="markdownIt-Anchor" href="#4-回文子串-647"></a> 4. 回文子串 647</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindromic-substrings/">题目</a></li>
</ul>
<hr />
<p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。<br />
回文字符串 是正着读和倒过来读一样的字符串。<br />
子字符串 是字符串中的由连续字符组成的一个序列。<br />
具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<pre class="line-numbers language-none"><code class="language-none">示例 1：

输入：s &#x3D; &quot;abc&quot;
输出：3
解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;
示例 2：

输入：s &#x3D; &quot;aaa&quot;
输出：6
解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</code></pre>
<p>提示：</p>
<p>1 &lt;= s.length &lt;= 1000<br />
s 由小写英文字母组成</p>
<h2 id="java解法-4"><a class="markdownIt-Anchor" href="#java解法-4"></a> Java解法</h2>
<ul>
<li>法一：回文子串的本质就是前后对称，对称的关键就是对称轴。所以我们以每一个元素确认当前对称轴，然后找寻对称轴前后的元素是否相同，来判断是否是回文子串。需要注意的是，奇数个元素和偶数个元素的对称的对称轴情况不同，需要区别处理。（应该可以通过除法，取余等操作将两个遍历循环合并）
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210908095417.png" alt="" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class PalindromicSubstrings647 &#123;

    public int countSubstrings(String s) &#123;

        &#x2F;&#x2F;将字符串转化为字符数组
        char[] s1 &#x3D; s.toCharArray();
        int length &#x3D; s1.length;
        int count &#x3D; 0;

        &#x2F;&#x2F;遍历字符数组，用当前元素确认中轴，找寻前后元素，看是否对称
        for(int i &#x3D; 0; i &lt; length; i++) &#123;
            &#x2F;&#x2F;要区分回文子串是偶数个还是奇数个
            &#x2F;&#x2F;偶数个的中轴在当前元素和下一元素之间（或者说中轴是两个元素）
            &#x2F;&#x2F;奇数个的中轴就在当前元素上
            int l &#x3D; i;
            int r1 &#x3D; i;
            int r2 &#x3D; i + 1;
            &#x2F;&#x2F;查找奇数个数的回文子串
            while(l &gt;&#x3D; 0 &amp;&amp; r1 &lt; length &amp;&amp; s1[l] &#x3D;&#x3D; s1[r1]) &#123;
                count++;
                l--;
                r1++;
            &#125;
            &#x2F;&#x2F;复原l的值
            l &#x3D; i;
            &#x2F;&#x2F;查找偶数个的回文子串
            while(l &gt;&#x3D; 0 &amp;&amp; r2 &lt; length &amp;&amp; s1[l] &#x3D;&#x3D; s1[r2]) &#123;
                count++;
                l--;
                r2++;
            &#125;
        &#125;

        return count;
    &#125;
&#125;</code></pre>
<h1 id="5-计数二进制子串-696"><a class="markdownIt-Anchor" href="#5-计数二进制子串-696"></a> 5. 计数二进制子串 696</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-binary-substrings/">题目</a></li>
</ul>
<hr />
<p>给定一个字符串 s，计算具有相同数量 0 和 1 的非空（连续）子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是连续的。<br />
重复出现的子串要计算它们出现的次数。</p>
<pre class="line-numbers language-none"><code class="language-none">示例 1 :

输入: &quot;00110011&quot;
输出: 6
解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。

请注意，一些重复出现的子串要计算它们出现的次数。

另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。
示例 2 :

输入: &quot;10101&quot;
输出: 4
解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。</code></pre>
<p>提示：<br />
s.length 在1到50,000之间。<br />
s 只包含“0”或“1”字符。</p>
<h2 id="java解法-5"><a class="markdownIt-Anchor" href="#java解法-5"></a> Java解法</h2>
<ul>
<li>法一：利用如果满足条件，必须前后不同字符连续出现的次数相同，所以关键在于计算同一字符连续出现的次数，如果之前字符连续出现的次数不小于当前字符连续出现的次数，那么必然可以构成一组。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210909224120.png" alt="" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CountBinarySubstrings696 &#123;

    public int countBinarySubstrings2(String s) &#123;
        &#x2F;&#x2F;统计结果
        int count &#x3D; 0;
        &#x2F;&#x2F;将字符串转为字符数组，便于遍历
        char[] s1 &#x3D; s.toCharArray();
        &#x2F;&#x2F;记录当前字符和之前不同字符的连续出现次数
        int pre &#x3D; 0, cur &#x3D; 0;

        &#x2F;&#x2F;遍历字符数组，记录当前字符连续出现次数，以及之前相对当前字符不同的字符的连续出现次数
        &#x2F;&#x2F;temp标记当前字符是0还是1
        char temp &#x3D; &#39;0&#39;;
        for(char c : s1) &#123;

            if(c &#x3D;&#x3D; temp) &#123;
                &#x2F;&#x2F;如果字符没变，则计数加一
                cur++;
            &#125; else &#123;
                &#x2F;&#x2F;如果字符变化了，则将之前记录的字符连续次数，赋给统计之前次数的变量，重新开始计数
                pre &#x3D; cur;
                cur &#x3D; 1;
                &#x2F;&#x2F;修改当前字符种类
                temp &#x3D; c;
            &#125;
            &#x2F;&#x2F;当之前连续出现的字符的次数的不小于当前字符连续出现次数时，可以构成对称，计数一次
            if(pre &gt;&#x3D; cur) &#123;
                count++;
            &#125;
        &#125;

        return count;
    &#125;
&#125;</code></pre>
<h1 id="6-基本计算器-ii-227"><a class="markdownIt-Anchor" href="#6-基本计算器-ii-227"></a> 6. 基本计算器 II 227</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/basic-calculator-ii/">题目</a></li>
</ul>
<hr />
<p>给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。<br />
整数除法仅保留整数部分。</p>
<pre class="line-numbers language-none"><code class="language-none">示例 1：

输入：s &#x3D; &quot;3+2*2&quot;
输出：7
示例 2：

输入：s &#x3D; &quot; 3&#x2F;2 &quot;
输出：1
示例 3：

输入：s &#x3D; &quot; 3+5 &#x2F; 2 &quot;
输出：5</code></pre>
<p>提示：</p>
<pre class="line-numbers language-none"><code class="language-none">1 &lt;&#x3D; s.length &lt;&#x3D; 3 * 105
s 由整数和算符 (&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;&#x2F;&#39;) 组成，中间由一些空格隔开
s 表示一个 有效表达式
表达式中的所有整数都是非负整数，且在范围 [0, 231 - 1] 内
题目数据保证答案是一个 32-bit 整数</code></pre>
<h2 id="java解法-6"><a class="markdownIt-Anchor" href="#java解法-6"></a> Java解法</h2>
<ul>
<li>法一：用两个队列分别存储数值和运算符。遍历字符串时，从队列尾部插入，尾部读取，把队列当作栈使用，如果遇到比存入队列中的的运算符优先级高的运算符，则将该运算符前后的数值获取，计算出结果再存入数值队列中。遍历字符串结束后，需要从左到右计算，从队列头部读取，从队列头部插入，因为高优先级运算符已经转换为运算结果，所以运算时都是同级的运算符，只需从左到右运算即可。从左到右运算时，将每一次运算的结果插入队列头部，作为下一次运算的左运算数。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/dzELwI.png" alt="dzELwI" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BasicCalculatorII227 &#123;

    &#x2F;&#x2F;用于临时存储连续的数字以便计算数值
    ArrayList&lt;Integer&gt; tempNums &#x3D; new ArrayList&lt;&gt;();

    &#x2F;**
     * 主计算函数，遍历字符串，按序获取对应的数值以及运算符
     * @param s
     * @return 表达式计算结果
     *&#x2F;
    public int calculate(String s) &#123;
        &#x2F;&#x2F;将字符串转换为字符数组，便于遍历
        char[] s1 &#x3D; s.toCharArray();
        &#x2F;&#x2F;用两个双端队列，按序存储数值和运算符
        Deque&lt;Integer&gt; nums &#x3D; new LinkedList&lt;&gt;();
        Deque&lt;Character&gt; ops &#x3D; new LinkedList&lt;&gt;();
        &#x2F;&#x2F;存储运算结果
        int res &#x3D; 0;

        &#x2F;&#x2F;遍历整个字符数组
        for(int i &#x3D; 0; i &lt; s1.length;) &#123;
            &#x2F;&#x2F;获取当前位置的值
            char c &#x3D; s1[i];

            &#x2F;&#x2F;如果是数字，则获取接下来连续出现的数字，存储到动态数组中，并修改下标
            if(isNum(c)) &#123;
                i &#x3D; getNums(s1, i);
            &#125;
            &#x2F;&#x2F;如果是空格
            if(isSpace(c)) &#123;
                &#x2F;&#x2F;空格是连续数字的分隔符，计算数值，存入数值队列中
                if(!tempNums.isEmpty()) &#123;
                    nums.addLast(getNum(tempNums));
                &#125;
                &#x2F;&#x2F;下标前进到下一位，进入下一次循环
                i++;
                continue;
            &#125; else if(isOp(c)) &#123;
                &#x2F;&#x2F;如果是运算符
                if(!tempNums.isEmpty()) &#123;
                    &#x2F;&#x2F;运算符也是数字的分隔符，计算数值，存入数值队列
                    nums.addLast(getNum(tempNums));
                &#125;
                &#x2F;&#x2F;如果运算符队列为空，则直接存入运算符，进入下一次循环
                if(ops.isEmpty()) &#123;
                    ops.addLast(c);
                    i++;
                    continue;
                &#125;
                &#x2F;&#x2F;运算符队列不为空，获取队列尾运算符
               char temp &#x3D; ops.getLast();
                &#x2F;&#x2F;如果队列尾运算符是+或-
               if(temp &#x3D;&#x3D; &#39;+&#39; || temp &#x3D;&#x3D; &#39;-&#39; ) &#123;
                   &#x2F;&#x2F;* &#x2F; 的优先级比 + -高，先将乘除运算结束，将结果存入数值队列中
                   if (c &#x3D;&#x3D; &#39;*&#39; ) &#123;
                       &#x2F;&#x2F;获取数值队列末尾元素
                       int num1 &#x3D; nums.pollLast();
                       &#x2F;&#x2F;获取当前运算符之后的连续数字并得出其值
                       i &#x3D; getNums(s1, i + 1);
                       int num2 &#x3D; getNum(tempNums);
                       &#x2F;&#x2F;运算，结果存入数值队列尾
                       int num3;
                       num3 &#x3D; num2 * num1;
                       nums.addLast(num3);
                   &#125; else if (c &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;
                       int num1 &#x3D; nums.pollLast();
                       i &#x3D; getNums(s1, i + 1);
                       int num2 &#x3D; getNum(tempNums);
                       int num3;
                       num3 &#x3D; num1 &#x2F; num2;
                       nums.addLast(num3);
                   &#125; else &#123;
                       &#x2F;&#x2F;如果当前运算符是+ -，则直接存入运算符队列
                       i++;
                       ops.addLast(c);
                       continue;
                   &#125;
               &#125; else &#123;
                   &#x2F;&#x2F;没有比 * &#x2F;优先级高的运算，直接存入运算符队列
                   i++;
                   ops.addLast(c);
                   continue;
               &#125;

            &#125;
        &#125;
        &#x2F;&#x2F;因为以空格和运算符作为连续数字的分隔符，所以末尾的数字有可能没有存入数值队列
        if(!tempNums.isEmpty()) &#123;
            nums.addLast(getNum(tempNums));
        &#125;
        &#x2F;&#x2F;如果运算符队列为空，则说明数值队列只有一个数，无需运算，直接返回
        if(ops.isEmpty()) &#123;
            return nums.pollFirst();
        &#125;
        &#x2F;&#x2F;从队列头部取出数值和运算符进行运算
        &#x2F;&#x2F;运算规则是从左到右，如果还是用栈的思路，就是从右到左计算
        &#x2F;&#x2F;因为高优先级的运算符都已经计算为结果了，所以都是同一优先级的运算
        while(!nums.isEmpty() &amp;&amp; !ops.isEmpty()) &#123;
            int num1 &#x3D; nums.pollFirst();
            int num2 &#x3D; nums.pollFirst();
            char op &#x3D; ops.pollFirst();
            if(op &#x3D;&#x3D; &#39;+&#39;) &#123;
                res &#x3D; num1 + num2;
            &#125; else if (op &#x3D;&#x3D; &#39;-&#39;)&#123;
                res &#x3D; num1 - num2;
            &#125; else if (op &#x3D;&#x3D; &#39;*&#39;) &#123;
                res &#x3D; num1 * num2;
            &#125; else if(op &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;
                res &#x3D; num1 &#x2F; num2;
            &#125;
            &#x2F;&#x2F;每一次运算的结果是下一次运算的前一位运算数，重新存入数值队列头部
            nums.addFirst(res);
        &#125;

        return res;
    &#125;

    &#x2F;**
     * 判断字符是否是数字
     * @param c
     * @return
     *&#x2F;
    public boolean isNum(char c) &#123;
        if (c &gt;&#x3D; &#39;0&#39; &amp;&amp; c &lt;&#x3D; &#39;9&#39;) &#123;
            return true;
        &#125;
        return false;
    &#125;

    &#x2F;**
     * 判断字符是否是运算符
     * @param c
     * @return
     *&#x2F;
    public boolean isOp(char c) &#123;
        if(c &#x3D;&#x3D; &#39;+&#39; || c &#x3D;&#x3D; &#39;-&#39; || c &#x3D;&#x3D; &#39;*&#39; || c &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;
            return true;
        &#125;
        return false;
    &#125;

    &#x2F;**
     * 判断字符是否是空格
     * @param c
     * @return
     *&#x2F;
    public boolean isSpace(char c) &#123;
        if(c &#x3D;&#x3D; &#39; &#39;) &#123;
            return true;
        &#125;
        return false;
    &#125;

    &#x2F;**
     * 将连续的数字转换为值
     * @param list
     * @return
     *&#x2F;
    public int getNum(ArrayList&lt;Integer&gt; list) &#123;
        int length &#x3D; list.size();
        int i &#x3D; 0;
        int res &#x3D; 0;

        &#x2F;&#x2F;遍历数字，将每位数乘上其10的幂，加在最后的结果上
        for(int num : list) &#123;
            res +&#x3D; num * Math.pow(10, length - i - 1);
            i++;
        &#125;
        &#x2F;&#x2F;清空集合
        list.clear();

        return res;
    &#125;

    &#x2F;**
     * 获取连续数字，并依次存入集合中
     * @param s
     * @param start 开始位置
     * @return 返回下一个非数字字符位置
     *&#x2F;
    public int getNums(char[] s, int start) &#123;
        int i;
        int j;
        &#x2F;&#x2F;如果开始是连续的空格，则跳过，知道有数字出现为止
        for(i &#x3D; start; i &lt; s.length; i++) &#123;
            char c &#x3D; s[i];
            if(!isSpace(c)) &#123;
                break;
            &#125;
        &#125;
        &#x2F;&#x2F;从跳过空格后的位置开始读取数字
        for(j &#x3D; i; j &lt; s.length; j++) &#123;
            char c &#x3D; s[j];
            if(isNum(c)) &#123;
                tempNums.add(c - &#39;0&#39;);
            &#125; else &#123;
                break;
            &#125;
        &#125;
        return j;
    &#125;
&#125;</code></pre>
<h1 id="7-实现-strstr-28"><a class="markdownIt-Anchor" href="#7-实现-strstr-28"></a> 7. 实现 strStr() 28</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-strstr/">题目</a></li>
</ul>
<hr />
<p>实现 strStr() 函数。<br />
给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。<br />
说明：<br />
当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。<br />
对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。</p>
<pre class="line-numbers language-none"><code class="language-none">示例 1：

输入：haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;
输出：2
示例 2：

输入：haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;
输出：-1
示例 3：

输入：haystack &#x3D; &quot;&quot;, needle &#x3D; &quot;&quot;
输出：0

提示：

0 &lt;&#x3D; haystack.length, needle.length &lt;&#x3D; 5 * 104
haystack 和 needle 仅由小写英文字符组成</code></pre>
<h2 id="java解法-7"><a class="markdownIt-Anchor" href="#java解法-7"></a> Java解法</h2>
<ul>
<li>法一：双指针遍历两个字符串，直到找到匹配的子串或者余下的长度比子串长度还小时停止。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210911131211.png" alt="" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ImplementStrStr28 &#123;

    public int strStr(String haystack, String needle) &#123;
        &#x2F;&#x2F;将字符串转化为字符数组，方便遍历
        char[] s1 &#x3D; haystack.toCharArray();
        char[] s2 &#x3D; needle.toCharArray();
        int l1 &#x3D; s1.length;
        int l2 &#x3D; s2.length;
        &#x2F;&#x2F;如果子串为空字符串，返回0
        if(s2.length &#x3D;&#x3D; 0) &#123;
            return 0;
        &#125;
        &#x2F;&#x2F;结果默认为-1
        int res &#x3D; -1;

        &#x2F;&#x2F;遍历字符串，直到所剩长度比子串长度小
        for(int i &#x3D; 0; i + l2 &lt;&#x3D; l1; i++) &#123;
            &#x2F;&#x2F;如果当前字符与子串第一个字符相同，则继续比较之后的字符
            if(s1[i] &#x3D;&#x3D; s2[0]) &#123;
                int j &#x3D; i + 1;
                int t &#x3D; 1;
                &#x2F;&#x2F;当子串只有一位字符时，可以直接返回
                if(t &#x3D;&#x3D; l2) &#123;
                    return res &#x3D; i;
                &#125;
                &#x2F;&#x2F;双指针，遍历两个字符串，逐个比较字符是否相同，直到子串遍历完
                while (t &lt; l2) &#123;
                    if(s1[j] !&#x3D; s2[t]) &#123;
                        break;
                    &#125;
                    t++;
                    j++;
                &#125;
                &#x2F;&#x2F;如果子串被遍历完了，说明完全匹配，返回开始下标即可
                if(t &#x3D;&#x3D; l2) &#123;
                    return res &#x3D; i;
                &#125;
            &#125;
        &#125;
        &#x2F;&#x2F;到达这里，说明前面没有找到匹配子串，直接返回默认值-1
        return res;
    &#125;
&#125;</code></pre>
<ul>
<li>法二：KMP(字符串模式匹配算法)<a href="https://www.zestaken.top/post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%B2">KMP解析</a>:其中心思想是利用子串的对称性来在比较的时候跳过一些对称的部分，以起到加速匹配的效果。
<ul>
<li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211114114926.png" alt="" /></li>
<li>代码：</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public int strStr(String haystack, String needle) &#123;
    char[] s1 &#x3D; haystack.toCharArray();
    char[] s2 &#x3D; needle.toCharArray();
    int l1 &#x3D; s1.length;
    int l2 &#x3D; s2.length;
    int result &#x3D; -1; &#x2F;&#x2F;结果默认为-1
    &#x2F;&#x2F;子串为空串直接返回0
    if(l2 &#x3D;&#x3D; 0) &#123;
        result &#x3D; 0;
        return  result;
    &#125;

    &#x2F;&#x2F;求子串每一个元素的next数组（即当前元素之前对称的元素对数）
    int i &#x3D; 0, k &#x3D; -1;
    int[] next &#x3D; new int[l2];
    next[0] &#x3D; -1; &#x2F;&#x2F;第一个元素设为-1，因为它之前没有元素
    while(i &lt; l2 - 1) &#123; &#x2F;&#x2F;最后一个元素在倒数第二个元素遍历时已经记录
        if(k &#x3D;&#x3D; -1 || s2[i] &#x3D;&#x3D; s2[k]) &#123;
            i++; &#x2F;&#x2F;若之前有元素相等，则记在下一个元素的next值上
            k++; &#x2F;&#x2F;k值从-1开始，与i对应元素依此比过来，如果相等则k与i同时移位，如果不等k回溯到它的next值处再比较，i不变
            &#x2F;&#x2F;next值的求取实质是子串前半部分与后半部分比较，得元素对应相等个数；可以看成是两个串的匹配，又可以用next回溯的思想，有点递归的感觉
            next[i] &#x3D; k; &#x2F;&#x2F;k的值代表着对称相等的元素对数
        &#125; else &#123;
            k &#x3D; next[k];
        &#125;
    &#125;

    int j &#x3D; 0, m &#x3D; 0;
    while(j + l2 - m &lt;&#x3D; l1 &amp;&amp; m &lt; l2) &#123;
        if(m &#x3D;&#x3D; -1 || s2[m] &#x3D;&#x3D; s1[j]) &#123; &#x2F;&#x2F;m等于负一说明子串从头开始寻找，主串后移一位
            j++;
            m++;
        &#125; else &#123;
            m &#x3D; next[m];
        &#125;

        if(m  &#x3D;&#x3D; l2) &#123;
            result &#x3D; j - m; &#x2F;&#x2F;当前位置是子串最后一个元素对应的位置，减去子串长度即为开始匹配的位置
        &#125;

    &#125;

    return result;
&#125;</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">蜀ICP备2021022902号-1 </a>
      <img src="/images/beian_icon.png" alt=""><a href="https://beian.mps.gov.cn/#/query/webSearch?code=51010802032250" rel="noopener" target="_blank">川公网安备51010802032250号 </a>
  </div>
  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Zestaken</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">678k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:17</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js" integrity="sha256-4mJNT2bMXxcc1GCJaxBmMPdmah5ji0Ldnd79DKd1hoM=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha256-AjM0J5XIbiB590BrznLEgZGLnOQWrt62s3BEq65Q/I0=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha256-9cmf7tcLdXpKsPi/2AWE93PbZpTp4M4tqzFk+lWomjU=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
