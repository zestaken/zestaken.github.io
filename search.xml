<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深度学习四——线性回归</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9B%9B%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9B%9B%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="线性回归"><a class="markdownIt-Anchor" href="#线性回归"></a> 线性回归</h1><ul><li><em>回归</em>（regression）是指一类为一个或多个自变量与因变量之间关系建模的方法。在自然科学和社会科学领域，回归经常用来表示输入和输出之间的关系。</li><li>当我们想预测一个数值时，就会涉及到回归问题。常见的例子包括：预测价格（房屋、股票等）、预测住院时间（针对住院病人）、预测需求（零售销量）等。</li></ul><h2 id="线性回归的基本元素"><a class="markdownIt-Anchor" href="#线性回归的基本元素"></a> 线性回归的基本元素</h2><ul><li><em>线性回归</em>（linear regression）在回归的各种标准工具中最简单而且最流行。</li><li>线性回归基于几个简单的假设：首先，假设自变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">x</mi></mrow><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">x</span></span></span></span></span>和因变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>之间的关系是线性的，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>可以表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">x</mi></mrow><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">x</span></span></span></span></span>中元素的加权和，这里通常允许包含观测值的一些噪声；其次，我们假设任何噪声都比较正常，如噪声遵循正态分布。</li><li>为了解释<em>线性回归</em>，我们举一个实际的例子：<ul><li>问题：我们希望根据房屋的面积（平方英尺）和房龄（年）来估算房屋价格（美元）。</li><li>数据集：为了开发一个能预测房价的模型，我们需要收集一个真实的数据集。这个数据集包括了房屋的销售价格、面积和房龄。</li><li>训练集与样本：在机器学习的术语中，该数据集称为<em>训练数据集</em>（training data set）或<em>训练集</em>（training set），每行数据（在这个例子中是与一次房屋交易相对应的数据）称为<em>样本</em>（sample），也可以称为<em>数据点</em>（data point）或<em>数据样本</em>（data instance）。</li><li>目标：我们要试图预测的目标（在这个例子中是房屋价格）称为<em>标签</em>（label）或<em>目标</em>（target）。</li><li>特征：预测所依据的自变量（面积和房龄）称为<em>特征</em>（feature）或<em>协变量</em>（covariate）。</li></ul></li><li>通常，我们使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>来表示数据集中的样本数。对索引为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>的样本，其输入表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="bold">x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>=</mo><mo stretchy="false">[</mo><msubsup><mi>x</mi><mn>1</mn><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo separator="true">,</mo><msubsup><mi>x</mi><mn>2</mn><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><msup><mo stretchy="false">]</mo><mi mathvariant="normal">⊤</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{x}^{(i)} = [x_1^{(i)}, x_2^{(i)}]^\top</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">x</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.311108em;vertical-align:-0.26630799999999993em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.433692em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26630799999999993em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.433692em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26630799999999993em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span></span></span></span>，其对应的标签是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">y^{(i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0824399999999998em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>。</li></ul><h3 id="线性模型"><a class="markdownIt-Anchor" href="#线性模型"></a> 线性模型</h3><ul><li><p>线性假设是指目标（房屋价格）可以表示为特征（面积和房龄）的加权和（即线性函数），如下面的式子：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="normal">p</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">e</mi></mrow><mo>=</mo><msub><mi>w</mi><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">a</mi></mrow></msub><mo>⋅</mo><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">a</mi></mrow><mo>+</mo><msub><mi>w</mi><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">e</mi></mrow></msub><mo>⋅</mo><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">e</mi></mrow><mo>+</mo><mi>b</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathrm{price} = w_{\mathrm{area}} \cdot \mathrm{area} + w_{\mathrm{age}} \cdot \mathrm{age} + b.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8623000000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathrm">p</span><span class="mord mathrm">r</span><span class="mord mathrm">i</span><span class="mord mathrm">c</span><span class="mord mathrm">e</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.59445em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">a</span><span class="mord mathrm mtight">r</span><span class="mord mathrm mtight">e</span><span class="mord mathrm mtight">a</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathrm">a</span><span class="mord mathrm">r</span><span class="mord mathrm">e</span><span class="mord mathrm">a</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.730558em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">a</span><span class="mord mathrm mtight" style="margin-right:0.01389em;">g</span><span class="mord mathrm mtight">e</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathrm">a</span><span class="mord mathrm" style="margin-right:0.01389em;">g</span><span class="mord mathrm">e</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mord">.</span></span></span></span></span></p><ul><li>权重与偏移量：上式中的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">a</mi></mrow></msub></mrow><annotation encoding="application/x-tex">w_{\mathrm{area}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">a</span><span class="mord mathrm mtight">r</span><span class="mord mathrm mtight">e</span><span class="mord mathrm mtight">a</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">w_{\mathrm{age}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">a</span><span class="mord mathrm mtight" style="margin-right:0.01389em;">g</span><span class="mord mathrm mtight">e</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>称为<em>权重</em>（weight），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>称为<em>偏置</em>（bias），或称为<em>偏移量</em>（offset）、<em>截距</em>（intercept）。</li><li>权重决定了每个特征对我们预测值的影响。</li><li>偏置是指当所有特征都取值为0时，预测值应该为多少。即使现实中不会有任何房子的面积是0或房龄正好是0年，我们仍然需要偏置项。如果没有偏置项，我们模型的表达能力将受到限制。</li><li>仿射变换：上式也可以说是是输入特征的一个<em>仿射变换</em>（affine transformation）。仿射变换的特点是通过加权和对特征进行<em>线性变换</em>（linear transformation），并通过偏置项来进行<em>平移</em>（translation）。</li></ul></li><li><p>模型目标：给定一个数据集，我们的目标是寻找模型的权重<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">w</mi></mrow><annotation encoding="application/x-tex">\mathbf{w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span></span>和偏置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>，使得根据模型做出的预测大体符合数据里的真实价格。输出的预测值由输入特征通过<em>线性模型</em>的仿射变换决定，仿射变换由所选权重和偏置确定。</p></li><li><p>用向量表示线性函数：当关注有少量特征的数据集。在这些学科中，建模时经常像这样通过长形式显式地表达。而在机器学习领域，我们通常使用的是高维数据集，建模时采用线性代数表示法会比较方便。当我们的输入包含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">d</span></span></span></span>个特征时，我们将预测结果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>y</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span>（通常使用“尖角”符号表示估计值）表示为：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi>y</mi><mo>^</mo></mover><mo>=</mo><msub><mi>w</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>w</mi><mi>d</mi></msub><msub><mi>x</mi><mi>d</mi></msub><mo>+</mo><mi>b</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\hat{y} = w_1  x_1 + ... + w_d  x_d + b.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mord">.</span></span></span></span></span></p><ul><li>将所有<em>特征</em>放到向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">x</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mi>d</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{x} \in \mathbb{R}^d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathbf">x</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span></span></span></span>中，并将所有<em>权重</em>放到向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">w</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mi>d</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{w} \in \mathbb{R}^d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span></span></span></span>中，我们可以用点积形式来简洁地表达模型：</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi>y</mi><mo>^</mo></mover><mo>=</mo><msup><mi mathvariant="bold">w</mi><mi mathvariant="normal">⊤</mi></msup><mi mathvariant="bold">x</mi><mo>+</mo><mi>b</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\hat{y} = \mathbf{w}^\top \mathbf{x} + b.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9824379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">x</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mord">.</span></span></span></span></span></p><ul><li><p>在上式中，向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">x</mi></mrow><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">x</span></span></span></span></span>对应于单个数据样本的特征。用符号表示的矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">X</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>n</mi><mo>×</mo><mi>d</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{X} \in \mathbb{R}^{n \times d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72521em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathbf">X</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span></span></span></span></span>可以很方便地引用我们整个数据集的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>个样本。其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">X</mi></mrow><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">X</span></span></span></span></span>的每一行是一个样本，每一列是一种特征。</p></li><li><p>对于特征集合<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">X</mi></mrow><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">X</span></span></span></span></span>，预测值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi mathvariant="bold">y</mi><mo>^</mo></mover><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\hat{\mathbf{y}} \in \mathbb{R}^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.90232em;vertical-align:-0.19444em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.70788em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span></span></span><span style="top:-3.01344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>可以通过矩阵-向量乘法表示为：</p></li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi mathvariant="bold">y</mi><mo>^</mo></mover><mo>=</mo><mi mathvariant="bold">X</mi><mi mathvariant="bold">w</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">{\hat{\mathbf{y}}} = \mathbf{X} \mathbf{w} + b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.90232em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.70788em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span></span></span><span style="top:-3.01344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76944em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathbf">X</span></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span></span></p></li><li><p>给定训练数据特征<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">X</mi></mrow><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">X</span></span></span></span></span>和对应的已知标签<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">y</mi></mrow><annotation encoding="application/x-tex">\mathbf{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.63888em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span></span></span></span>，线性回归的目标是找到一组权重向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">w</mi></mrow><annotation encoding="application/x-tex">\mathbf{w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span></span>和偏置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>。当给定从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">X</mi></mrow><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">X</span></span></span></span></span>的同分布中取样的新样本特征时，找到的权重向量和偏置能够使得新样本预测标签的误差尽可能小。</p></li><li><p>在我们开始寻找最好的<em>模型参数</em>（model parameters）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">w</mi></mrow><annotation encoding="application/x-tex">\mathbf{w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>之前，我们还需要两个东西：（1）一种模型质量的度量方式；（2）一种能够更新模型以提高模型预测质量的方法。</p></li></ul><h3 id="损失函数"><a class="markdownIt-Anchor" href="#损失函数"></a> 损失函数</h3><ul><li><p><strong>拟合程度的度量</strong>：在我们开始考虑如何用模型<em>拟合</em>（fit）数据之前，我们需要确定一个拟合程度的度量。<em>损失函数</em>能够量化目标的<em>实际</em>值与<em>预测</em>值之间的差距,作为拟合程度的度量。</p></li><li><p>损失函数的实质就是<strong>自变量为模型的参数</strong>，函数值（因变量）为模型的误差值的函数。</p></li><li><p>通常我们会选择<em>非负数作为损失，且数值越小表示损失越小，完美预测时的损失为0</em>。回归问题中最常用的损失函数是平方误差(差的平方)函数。当样本<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>的预测值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mover accent="true"><mi>y</mi><mo>^</mo></mover><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">\hat{y}^{(i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0824399999999998em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>，其相应的真实标签为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">y^{(i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0824399999999998em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>时，平方误差可以定义为以下公式：</p><p>​$$l^{(i)}(\mathbf{w}, b) = \frac{1}{2} \left(\hat{y}^{(i)} - y<sup>{(i)}\right)</sup>2.$$</p><ul><li><p>常数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>不会带来本质的差别，但这样在形式上稍微简单一些，表现为当我们对损失函数求导后常数系数为1。</p></li><li><p>由于平方误差函数中的二次方项，估计值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mover accent="true"><mi>y</mi><mo>^</mo></mover><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">\hat{y}^{(i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0824399999999998em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>和观测值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">y^{(i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0824399999999998em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>之间较大的差异将贡献更大的损失。为了度量模型在整个数据集上的质量，我们需计算在训练集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>个样本上的<em>损失均值</em>（也等价于求和）。</p></li><li><p>损失函数度量单个样本的训练情况，损失均值（更多的时候是对全部损失函数进行专门计算的成本函数）度量整个样本集的训练情况。</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msup><mi>l</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mrow><mo fence="true">(</mo><msup><mi mathvariant="bold">w</mi><mi mathvariant="normal">⊤</mi></msup><msup><mi mathvariant="bold">x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>+</mo><mi>b</mi><mo>−</mo><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo fence="true">)</mo></mrow><mn>2</mn></msup><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">L(\mathbf{w}, b) =\frac{1}{n}\sum_{i=1}^n l^{(i)}(\mathbf{w}, b) =\frac{1}{n} \sum_{i=1}^n \frac{1}{2}\left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right)^2.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathbf">x</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.3540079999999999em;"><span style="top:-3.6029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span></span></span></span></span></p></li></ul></li><li><p>在训练模型时，我们希望寻找一组参数（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="bold">w</mi><mo>∗</mo></msup><mo separator="true">,</mo><msup><mi>b</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\mathbf{w}^*, b^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>），<strong>这组参数能最小化在所有训练样本上的总损失</strong>。如下式：</p></li></ul><p>​$$\mathbf{w}^<em>, b^</em> = \operatorname*{argmin}_{\mathbf{w}, b}\  L(\mathbf{w}, b).$$</p><h3 id="解析解"><a class="markdownIt-Anchor" href="#解析解"></a> 解析解</h3><ul><li>线性回归的解可以用一个公式简单地表达出来，这类解叫作<strong>解析解（analytical solution）</strong>。解析解就是直接解方程，将参数用自变量和因变量表示出来。不常用的原因就是因为，很多模型函数是无法直接解出参数的表示方程的。</li><li>首先，我们将偏置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>合并到参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">w</mi></mrow><annotation encoding="application/x-tex">\mathbf{w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span></span>中。合并方法是在包含所有参数的矩阵中附加一列。我们的预测问题是最小化<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∥</mi><mi mathvariant="bold">y</mi><mo>−</mo><mi mathvariant="bold">X</mi><mi mathvariant="bold">w</mi><msup><mi mathvariant="normal">∥</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\|\mathbf{y} - \mathbf{X}\mathbf{w}\|^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbf">X</span></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>。这在损失平面上只有一个临界点，这个临界点对应于整个区域的损失最小值。将损失关于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">w</mi></mrow><annotation encoding="application/x-tex">\mathbf{w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span></span>的导数设为0，得到解析解（闭合形式）：</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi mathvariant="bold">w</mi><mo>∗</mo></msup><mo>=</mo><mo stretchy="false">(</mo><msup><mi mathvariant="bold">X</mi><mi mathvariant="normal">⊤</mi></msup><mi mathvariant="bold">X</mi><msup><mo stretchy="false">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><msup><mi mathvariant="bold">X</mi><mi mathvariant="normal">⊤</mi></msup><mi mathvariant="bold">y</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathbf{w}^* = (\mathbf X^\top \mathbf X)^{-1}\mathbf X^\top \mathbf{y}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.738696em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.738696em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathbf">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord mathbf">X</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span><span class="mord">.</span></span></span></span></span></p><ul><li>像线性回归这样的简单问题存在解析解，但<strong>并不是所有的问题都存在解析解</strong>。解析解可以进行很好的数学分析，但解析解的限制很严格，导致它无法应用在深度学习里。</li></ul><h3 id="小批量随机梯度下降"><a class="markdownIt-Anchor" href="#小批量随机梯度下降"></a> 小批量随机梯度下降</h3><ul><li><p><a href="https://zhuanlan.zhihu.com/p/43452377">梯度下降解析</a>与<a href="https://zhuanlan.zhihu.com/p/277709879">小批量随机梯度下降解析</a></p></li><li><p>本书中我们用到一种名为**梯度下降（gradient descent）**的方法，这种方法几乎可以优化所有深度学习模型。它通过不断地在损失函数递减的方向上更新参数来降低误差。</p></li><li><p><strong>小批量随机梯度下降（minibatch stochastic gradient descent）</strong>:</p><ul><li>梯度下降：最简单的用法是<em>计算损失函数</em>（数据集中所有样本的损失均值）关于模型参数的<em>导数（在这里也可以称为梯度）</em>。梯度下降的实质就是根据函数的导数（梯度、偏导数）来求函数的最值，因为损失函数的自变量为模型的参数，所以就实际是找到使误差值最小的模型参数值。</li><li>小批量：但实际中的执行可能会非常慢：因为在每一次更新参数之前，我们必须遍历整个数据集。因此，我们通常会在每次需要计算更新的时候<em>随机抽取一小批样本</em>。</li></ul></li><li><p>计算方法：在每次迭代中，我们首先随机抽样一个小批量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">B</mi></mrow><annotation encoding="application/x-tex">\mathcal{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span></span></span></span>，它是由固定数量的训练样本组成的。然后，我们计算小批量的平均损失关于模型参数的导数（也可以称为梯度）。最后，我们将梯度乘以一个预先确定的正数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span>，并从当前参数的值中减掉。我们用下面的数学公式来表示这一更新过程（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∂</mi></mrow><annotation encoding="application/x-tex">\partial</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord" style="margin-right:0.05556em;">∂</span></span></span></span>表示偏导数）：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>←</mo><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>−</mo><mfrac><mi>η</mi><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="script">B</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi mathvariant="script">B</mi></mrow></munder><msub><mi mathvariant="normal">∂</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></msub><msup><mi>l</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">(\mathbf{w},b) \leftarrow (\mathbf{w},b) - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \partial_{(\mathbf{w},b)} l^{(i)}(\mathbf{w},b).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.429266em;vertical-align:-1.321706em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord"><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8556639999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.321706em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.05556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathbf mtight" style="margin-right:0.01597em;">w</span></span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mord">.</span></span></span></span></span></p><ul><li>算法的步骤如下：<ol><li>初始化模型参数的值，如随机初始化；</li><li>从数据集中随机抽取小批量样本且在负梯度的方向上更新参数，并不断迭代这一步骤。对于平方损失和仿射变换，我们可以明确地写成如下形式:</li></ol><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi mathvariant="bold">w</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>←</mo><mi mathvariant="bold">w</mi><mo>−</mo><mfrac><mi>η</mi><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="script">B</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi mathvariant="script">B</mi></mrow></munder><msub><mi mathvariant="normal">∂</mi><mi mathvariant="bold">w</mi></msub><msup><mi>l</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="bold">w</mi><mo>−</mo><mfrac><mi>η</mi><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="script">B</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi mathvariant="script">B</mi></mrow></munder><msup><mi mathvariant="bold">x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mrow><mo fence="true">(</mo><msup><mi mathvariant="bold">w</mi><mi mathvariant="normal">⊤</mi></msup><msup><mi mathvariant="bold">x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>+</mo><mi>b</mi><mo>−</mo><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo fence="true">)</mo></mrow><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>b</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>←</mo><mi>b</mi><mo>−</mo><mfrac><mi>η</mi><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="script">B</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi mathvariant="script">B</mi></mrow></munder><msub><mi mathvariant="normal">∂</mi><mi>b</mi></msub><msup><mi>l</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>b</mi><mo>−</mo><mfrac><mi>η</mi><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="script">B</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi mathvariant="script">B</mi></mrow></munder><mrow><mo fence="true">(</mo><msup><mi mathvariant="bold">w</mi><mi mathvariant="normal">⊤</mi></msup><msup><mi mathvariant="bold">x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>+</mo><mi>b</mi><mo>−</mo><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo fence="true">)</mo></mrow><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} \mathbf{w} &amp;\leftarrow \mathbf{w} -   \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \partial_{\mathbf{w}} l^{(i)}(\mathbf{w}, b) = \mathbf{w} - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \mathbf{x}^{(i)} \left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right),\\ b &amp;\leftarrow b -  \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \partial_b l^{(i)}(\mathbf{w}, b)  = b - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right). \end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.543412em;vertical-align:-2.521706em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.021706em;"><span style="top:-5.021706em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mord mathnormal">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.521706em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.021706em;"><span style="top:-5.021706em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord"><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8556639999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.321706em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.161108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathbf mtight" style="margin-right:0.01597em;">w</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord"><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8556639999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.321706em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">x</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathbf">x</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord"><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8556639999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.321706em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord"><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8556639999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.321706em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathbf">x</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.521706em;"><span></span></span></span></span></span></span></span></span></span></span></span></p></li></ul></li><li><p>超参数：上式中的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">w</mi></mrow><annotation encoding="application/x-tex">\mathbf{w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">x</mi></mrow><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">x</span></span></span></span></span>都是向量。在这里，更优雅的向量表示法比系数表示法（如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>w</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>w</mi><mi>d</mi></msub></mrow><annotation encoding="application/x-tex">w_1, w_2, \ldots, w_d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）更具可读性。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="script">B</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|\mathcal{B}|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span><span class="mord">∣</span></span></span></span>表示每个小批量中的样本数，这也称为<em>批量大小</em>（batch size）。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span>表示<em>学习率</em>（learning rate）。批量大小和学习率的值通常是手动预先指定，而不是通过模型训练得到的。这些可以调整但不在训练过程中更新的参数称为<em>超参数</em>（hyperparameter）。</p></li><li><p><em>调参</em>（hyperparameter tuning）：是选择超参数的过程。超参数通常是我们根据训练迭代结果来调整的，而训练迭代结果是在独立的<em>验证数据集</em>（validation dataset）上评估得到的。</p></li><li><p>获取模型参数估计值：在训练了预先确定的若干迭代次数后（或者直到满足某些其他停止条件后），我们记录下模型参数的估计值，表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi mathvariant="bold">w</mi><mo>^</mo></mover><mo separator="true">,</mo><mover accent="true"><mi>b</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{\mathbf{w}}, \hat{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1523199999999998em;vertical-align:-0.19444em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.70788em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span><span style="top:-3.01344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9578799999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">b</span></span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span>。但是，即使我们的函数确实是线性的且无噪声，这些估计值也不会使损失函数真正地达到最小值。因为算法会使得损失向<em>最小值缓慢收敛，但却不能在有限的步数内非常精确地达到最小值</em>。</p></li></ul><h3 id="用学习后模型进行预测"><a class="markdownIt-Anchor" href="#用学习后模型进行预测"></a> 用学习后模型进行预测</h3><ul><li>给定学习到的线性回归模型<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mover accent="true"><mi mathvariant="bold">w</mi><mo>^</mo></mover><mi mathvariant="normal">⊤</mi></msup><mi mathvariant="bold">x</mi><mo>+</mo><mover accent="true"><mi>b</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{\mathbf{w}}^\top \mathbf{x} + \hat{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.70788em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span><span style="top:-3.01344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">x</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9578799999999998em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9578799999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">b</span></span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span>，现在我们可以通过给定的房屋面积<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和房龄<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>来估计一个未包含在训练数据中的新房屋价格。</li><li>给定特征估计目标的过程通常称为<em>预测</em>（prediction）或<em>推断</em>（inference）。</li></ul><h2 id="矢量化加速"><a class="markdownIt-Anchor" href="#矢量化加速"></a> 矢量化加速</h2><ul><li>在训练我们的模型时，我们经常希望能够同时处理整个小批量的样本。为了实现这一点，需要(<strong>我们对计算进行矢量化，从而利用线性代数库，而不是在Python中编写开销高昂的for循环</strong>)。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">import mathimport timeimport numpy as npimport tensorflow as tfimport matplotlib.pyplot as plt</code></pre><ul><li>为了说明矢量化为什么如此重要，我们考虑(<strong>对向量相加的两种方法</strong>)。</li><li>我们实例化两个全1的10000维向量。在一种方法中，我们将使用Python的<em>for循环</em>遍历向量。在另一种方法中，我们将依赖对向量<code>+</code>运算的调用。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">n &#x3D; 10000a &#x3D; tf.ones(n)b &#x3D; tf.ones(n)</code></pre><ul><li>定义一个计时器：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Timer:  #@save    &quot;&quot;&quot;记录多次运行时间。&quot;&quot;&quot;    def __init__(self):        self.times &#x3D; []        self.start()    def start(self):        &quot;&quot;&quot;启动计时器。&quot;&quot;&quot;        self.tik &#x3D; time.time()    def stop(self):        &quot;&quot;&quot;停止计时器并将时间记录在列表中。&quot;&quot;&quot;        self.times.append(time.time() - self.tik)        return self.times[-1]    def avg(self):        &quot;&quot;&quot;返回平均时间。&quot;&quot;&quot;        return sum(self.times) &#x2F; len(self.times)    def sum(self):        &quot;&quot;&quot;返回时间总和。&quot;&quot;&quot;        return sum(self.times)    def cumsum(self):        &quot;&quot;&quot;返回累计时间。&quot;&quot;&quot;        return np.array(self.times).cumsum().tolist()</code></pre><ul><li>首先，[<strong>我们使用for循环，每次执行对应位相加的加法</strong>]。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">c &#x3D; tf.Variable(tf.zeros(n))timer &#x3D; Timer()for i in range(n):    c[i].assign(a[i] + b[i]) #assign函数用新计算的值替换当前的位置的值f&#39;&#123;timer.stop():.5f&#125; sec&#39; #转化为字符串显示</code></pre><pre><code>'5.68500 sec'</code></pre><ul><li><strong>或者，我们使用重载的<code>+</code>运算符来计算按元素的和</strong>。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">timer.start()d &#x3D; a + bf&#39;&#123;timer.stop():.5f&#125; sec&#39;</code></pre><pre><code>'0.00100 sec'</code></pre><ul><li>结果很明显，第二种方法比第一种方法快得多。矢量化代码通常会带来数量级的加速。另外，我们将更多的数学运算放到库中，而无须自己编写那么多的计算，从而减少了出错的可能性。</li></ul><h2 id="正态分布与平方损失"><a class="markdownIt-Anchor" href="#正态分布与平方损失"></a> 正态分布与平方损失</h2><ul><li>正态分布和线性回归之间的关系很密切。简单的说，若随机变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>具有均值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">μ</span></span></span></span>和方差<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>σ</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\sigma^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>（标准差<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>），其正态分布概率密度函数如下：</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><msqrt><mrow><mn>2</mn><mi>π</mi><msup><mi>σ</mi><mn>2</mn></msup></mrow></msqrt></mfrac><mi>exp</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mo>−</mo><mfrac><mn>1</mn><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo fence="true">)</mo></mrow><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">p(x) = \frac{1}{\sqrt{2 \pi \sigma^2}} \exp\left(-\frac{1}{2 \sigma^2} (x - \mu)^2\right).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.154946em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9550540000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.915054em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.08494599999999997em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">exp</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span></span></span></span></span></p><ul><li>下面[<strong>我们定义一个Python函数来计算正态分布</strong>]。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">def normal(x, mu, sigma):    p &#x3D; 1 &#x2F; math.sqrt(2 * math.pi * sigma**2)    return p * np.exp(-0.5 &#x2F; sigma**2 * (x - mu)**2)</code></pre><p>我们现在(<strong>可视化正态分布</strong>)。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 再次使用numpy进行可视化x &#x3D; np.arange(-7, 7, 0.01) # 从-7 到 7 以0.01为步频的一系列数字# 均值和标准差对params &#x3D; [(0, 1), (0, 2), (3, 1)] # 第一个为均值mu，第二个为标准差sigmays &#x3D; []for mu, sigma in params:    y &#x3D; normal(x, mu, sigma)     ys.append(y)plt.plot(x, ys[0], x, ys[1], x, ys[2])</code></pre><pre><code>[&lt;matplotlib.lines.Line2D at 0x2100287a550&gt;, &lt;matplotlib.lines.Line2D at 0x2100287a610&gt;, &lt;matplotlib.lines.Line2D at 0x2100287a6d0&gt;]</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/output_21_1.png" alt="output_21_1" /></p><ul><li><p>就像我们所看到的，改变均值会产生沿<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>轴的偏移，增加方差将会分散分布、降低其峰值。</p></li><li><p>均方误差损失函数（简称均方损失）可以用于线性回归的一个原因是：我们假设了观测中包含噪声，其中噪声服从正态分布。噪声正态分布如下式:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>y</mi><mo>=</mo><msup><mi mathvariant="bold">w</mi><mi mathvariant="normal">⊤</mi></msup><mi mathvariant="bold">x</mi><mo>+</mo><mi>b</mi><mo>+</mo><mi>ϵ</mi><mtext> where </mtext><mi>ϵ</mi><mo>∼</mo><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><msup><mi>σ</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">y = \mathbf{w}^\top \mathbf{x} + b + \epsilon \text{ where } \epsilon \sim \mathcal{N}(0, \sigma^2).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9824379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">x</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span><span class="mord text"><span class="mord"> where </span></span><span class="mord mathnormal">ϵ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14736em;">N</span></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">.</span></span></span></span></span></p></li><li><p>因此，我们现在可以写出通过给定的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">x</mi></mrow><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">x</span></span></span></span></span>观测到特定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>的<em>可能性</em>（likelihood）：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>y</mi><mo>∣</mo><mi mathvariant="bold">x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><msqrt><mrow><mn>2</mn><mi>π</mi><msup><mi>σ</mi><mn>2</mn></msup></mrow></msqrt></mfrac><mi>exp</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mo>−</mo><mfrac><mn>1</mn><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac><mo stretchy="false">(</mo><mi>y</mi><mo>−</mo><msup><mi mathvariant="bold">w</mi><mi mathvariant="normal">⊤</mi></msup><mi mathvariant="bold">x</mi><mo>−</mo><mi>b</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo fence="true">)</mo></mrow><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">P(y \mid \mathbf{x}) = \frac{1}{\sqrt{2 \pi \sigma^2}} \exp\left(-\frac{1}{2 \sigma^2} (y - \mathbf{w}^\top \mathbf{x} - b)^2\right).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbf">x</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.154946em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9550540000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.915054em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.08494599999999997em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">exp</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">x</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">b</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span></span></span></span></span></p></li><li><p>根据最大似然估计法，参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">w</mi></mrow><annotation encoding="application/x-tex">\mathbf{w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>的最优值是<em>使整个数据集的可能性</em>最大的值,根据最大似然估计法选择的估计量称为<em>最大似然估计量</em>:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi mathvariant="bold">y</mi><mo>∣</mo><mi mathvariant="bold">X</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>p</mi><mo stretchy="false">(</mo><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mi mathvariant="normal">∣</mi><msup><mi mathvariant="bold">x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">P(\mathbf y \mid \mathbf X) = \prod_{i=1}^{n} p(y^{(i)}|\mathbf{x}^{(i)}).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbf">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∏</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord"><span class="mord mathbf">x</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">.</span></span></span></span></span></p></li><li><p>虽然使许多指数函数的乘积最大化看起来很困难，但是我们可以在不改变目标的前提下，通过最大化似然对数来简化。由于历史原因，优化通常是说最小化而不是最大化。我们可以改为<em>最小化负对数似然</em><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi>log</mi><mo>⁡</mo><mi>P</mi><mo stretchy="false">(</mo><mi mathvariant="bold">y</mi><mo>∣</mo><mi mathvariant="bold">X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">-\log P(\mathbf y \mid \mathbf X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbf">X</span><span class="mclose">)</span></span></span></span>。由此可以得到的数学公式是：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>−</mo><mi>log</mi><mo>⁡</mo><mi>P</mi><mo stretchy="false">(</mo><mi mathvariant="bold">y</mi><mo>∣</mo><mi mathvariant="bold">X</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>2</mn><mi>π</mi><msup><mi>σ</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>+</mo><mfrac><mn>1</mn><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac><msup><mrow><mo fence="true">(</mo><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>−</mo><msup><mi mathvariant="bold">w</mi><mi mathvariant="normal">⊤</mi></msup><msup><mi mathvariant="bold">x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>−</mo><mi>b</mi><mo fence="true">)</mo></mrow><mn>2</mn></msup><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">-\log P(\mathbf y \mid \mathbf X) = \sum_{i=1}^n \frac{1}{2} \log(2 \pi \sigma^2) + \frac{1}{2 \sigma^2} \left(y^{(i)} - \mathbf{w}^\top \mathbf{x}^{(i)} - b\right)^2.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbf">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.040008em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathbf">x</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">b</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.3540079999999999em;"><span style="top:-3.6029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span></span></span></span></span></p></li><li><p>现在我们只需要假设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>是某个固定常数就可以忽略第一项，因为第一项不依赖于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">w</mi></mrow><annotation encoding="application/x-tex">\mathbf{w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>。现在第二项除了常数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><msup><mi>σ</mi><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{\sigma^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>外，其余部分和前面介绍的平方误差损失是一样的。幸运的是，上面式子的解并不依赖于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>。因此，在高斯噪声的假设下，最小化均方误差等价于对线性模型的最大似然估计。</p></li></ul><h2 id="从线性回归到深度网络"><a class="markdownIt-Anchor" href="#从线性回归到深度网络"></a> 从线性回归到深度网络</h2><ul><li>尽管神经网络涵盖了更多更为丰富的模型，我们依然可以用描述神经网络的方式来描述线性模型，从而把线性模型看作一个神经网络。</li><li>可以用“层”符号来重写这个模型。</li></ul><h3 id="神经网络图"><a class="markdownIt-Anchor" href="#神经网络图"></a> 神经网络图</h3><ul><li>在下图中，我们将线性回归模型描述为一个神经网络。需要注意的是，该图只显示连接模式，即只显示每个输入如何连接到输出，隐去了权重和偏置的值。</li></ul><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211104171145.png" alt="" /></p><ul><li><p>在如图所示的神经网络中，输入为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>d</mi></msub></mrow><annotation encoding="application/x-tex">x_1, \ldots, x_d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，因此输入层中的<em>输入数</em>（或称为<em>特征维度</em>，feature dimensionality）为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">d</span></span></span></span>。网络的输出为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>o</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">o_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，因此输出层中的<em>输出数</em>是1。需要注意的是，输入值都是已经给定的，并且只有一个<em>计算</em>神经元。由于模型重点在发生计算的地方，所以通常我们在<em>计算层数时不考虑输入层</em>。也就是说， 上图中神经网络的<em>层数</em>为1。我们可以将线性回归模型视为仅由单个人工神经元组成的神经网络，或称为单层神经网络。</p></li><li><p><strong>全连接层</strong>：对于线性回归，每个输入都与每个输出（在本例中只有一个输出）相连，我们将这种变换（ 上图中的输出层）称为<em>全连接层</em>（fully-connected layer），或称为<em>稠密层</em>（dense layer）。</p></li></ul><h1 id="线性回归的从零开始实现"><a class="markdownIt-Anchor" href="#线性回归的从零开始实现"></a> 线性回归的从零开始实现</h1><ul><li>在了解线性回归的关键思想之后，我们可以开始通过代码来动手实现线性回归了。<strong>我们将从零开始实现整个方法，包括数据流水线、模型、损失函数和小批量随机梯度下降优化器</strong>。虽然现代的深度学习框架几乎可以自动化地进行所有这些工作，但从零开始实现可以确保你真正知道自己在做什么。同时，了解更细致的工作原理将方便我们自定义模型、自定义层或自定义损失函数。我们将只使用张量和自动求导。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">import randomimport tensorflow as tfimport matplotlib.pyplot as plt</code></pre><h2 id="生成数据集"><a class="markdownIt-Anchor" href="#生成数据集"></a> 生成数据集</h2><ul><li><p>我们将[<strong>根据带有噪声的线性模型构造一个人造数据集。</strong>]我们的任务是使用这个有限样本的数据集来恢复这个模型的参数。我们将使用低维数据，这样可以很容易地将其可视化。</p></li><li><p>在下面的代码中，我们生成一个包含1000个样本的数据集，每个样本包含从标准正态分布中采样的2个特征。我们的合成数据集是一个矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">X</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mn>1000</mn><mo>×</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{X}\in \mathbb{R}^{1000 \times 2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72521em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathbf">X</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span><span class="mord mtight">0</span><span class="mbin mtight">×</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>。</p></li><li><p>使用线性模型参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">w</mi><mo>=</mo><mo stretchy="false">[</mo><mn>2</mn><mo separator="true">,</mo><mo>−</mo><mn>3.4</mn><msup><mo stretchy="false">]</mo><mi mathvariant="normal">⊤</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{w} = [2, -3.4]^\top</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord">3</span><span class="mord">.</span><span class="mord">4</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mn>4.2</mn></mrow><annotation encoding="application/x-tex">b = 4.2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">.</span><span class="mord">2</span></span></span></span>和噪声项<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>生成数据集及其标签：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="bold">y</mi><mo>=</mo><mi mathvariant="bold">X</mi><mi mathvariant="bold">w</mi><mo>+</mo><mi>b</mi><mo>+</mo><mi mathvariant="bold">ϵ</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathbf{y}= \mathbf{X} \mathbf{w} + b + \mathbf\epsilon.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.63888em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76944em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathbf">X</span></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span><span class="mord">.</span></span></span></span></span></p></li><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>可以视为捕获特征和标签时的潜在观测误差，加上误差使数据更加符合真实情况。在这里我们认为标准假设成立，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>服从均值为0的正态分布。为了简化问题，我们将标准差设为0.01。下面的代码生成合成数据集。</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">#根据数据集以及线性模型得出对应的y值向量def synthetic_data(w, b, num_examples):  # w为线性模型参数，b为偏移量，num_examples是数据集数据数量    &quot;&quot;&quot;生成 y &#x3D; Xw + b + 噪声。&quot;&quot;&quot;    X &#x3D; tf.zeros((num_examples, w.shape[0])) # 生成和w的列数一样，行数为num_examples的，值全为0矩阵    X +&#x3D; tf.random.normal(shape&#x3D;X.shape) # 用标准正态分布的数值为X矩阵的每个元素赋值     # 将w转换为2行1列（-1代表自动推断此处应该填的维数）的矩阵与X矩阵相乘再加上偏移量计算y    y &#x3D; tf.matmul(X, tf.reshape(w, (-1, 1))) + b    y +&#x3D; tf.random.normal(shape&#x3D;y.shape, stddev&#x3D;0.01) # 给y的值加上服从正态分布的误差    y &#x3D; tf.reshape(y, (-1, 1)) # 将y转换为1列的矩阵    return X, y</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">true_w &#x3D; tf.constant([2, -3.4]) # 生成值为2，-3.4的数组true_b &#x3D; 4.2features, labels &#x3D; synthetic_data(true_w, true_b, 1000) </code></pre><ul><li><code>features</code>是特征向量组，其中的每一行都包含一个二维数据样本，<code>labels</code>是标签向量组，其中的每一行都包含一维标签值（一个标量）。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 查看两个向量组的维数情况print(&#39;features:&#39;, features[0],&#39;\nlabel:&#39;, labels[0])</code></pre><pre><code>features: tf.Tensor([ 0.7173423  -0.87579876], shape=(2,), dtype=float32) label: tf.Tensor([8.623853], shape=(1,), dtype=float32)</code></pre><ul><li>通过生成第二个特征<code>features[:, 1]</code>和<code>labels</code>的散点图，可以直观地观察到两者之间的线性关系。 （<code>features[:,1]</code>指取矩阵第1列（0,1两列）的全部数值作为x轴的取值</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">plt.scatter(features[:, (1)].numpy(), labels.numpy(), 1)</code></pre><pre><code>&lt;matplotlib.collections.PathCollection at 0x1b336bab400&gt;</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/output_8_1.png" alt="output_8_1" /></p><h2 id="读取数据集"><a class="markdownIt-Anchor" href="#读取数据集"></a> 读取数据集</h2><ul><li>训练模型时要对数据集进行遍历，每次抽取一小批量样本，并使用它们来更新我们的模型。由于这个过程是训练机器学习算法的基础，所以有必要定义一个函数，该函数能打乱数据集中的样本并以小批量方式获取数据。</li><li>在下面的代码中，我们[<strong>定义一个<code>data_iter</code>函数，该函数接收批量大小、特征矩阵和标签向量作为输入，生成大小为<code>batch_size</code>的小批量</strong>]。每个小批量包含一组特征和标签。</li><li>注：<a href="https://www.runoob.com/w3cnote/python-yield-used-analysis.html">yield用法解析</a></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">def data_iter(batch_size, features, labels): # 将传入的特征值矩阵和标签矩阵每次取出一小批用来训练，直到取完    num_examples &#x3D; len(features)    indices &#x3D; list(range(num_examples))    # 这些样本是随机读取的，没有特定的顺序    random.shuffle(indices) # 打乱列表数字的顺序实现随机读取    for i in range(0, num_examples, batch_size): # 获取从0到numexamples的数字，以batch_size为步频        j &#x3D; tf.constant(indices[i: min(i + batch_size, num_examples)])#从indices中获取从i到i+batch_size的数字生成向量        # 使用yield迭代返回每一次提取的小批量向量        yield tf.gather(features, j), tf.gather(labels, j) # 将两个矩阵中下标对应j向量的的值取出来形成一个新向量</code></pre><ul><li>通常，我们使用合理大小的小批量来利用GPU硬件的优势，因为GPU在并行处理方面表现出色。每个样本都可以并行地进行模型计算，且每个样本损失函数的梯度也可以被并行地计算，GPU可以在处理几百个样本时，所花费的时间不比处理一个样本时多太多。</li><li>下面读取第一个小批量数据样本并打印：每个批量的特征维度说明了批量大小和输入特征数。同样的，批量的标签形状与<code>batch_size</code>相等。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">batch_size &#x3D; 10for X, y in data_iter(batch_size, features, labels):    print(X, &#39;\n&#39;, y)    break</code></pre><pre><code>tf.Tensor([[-0.92631394  0.5370933 ] [-0.563874    1.3515444 ] [-1.0858414   0.7342149 ] [-0.6196944   2.1207151 ] [ 0.25010496 -2.0217266 ] [-0.60749346 -0.30016303] [-0.14507185 -1.2292194 ] [ 0.00904182  1.0107433 ] [ 0.1355916   2.2240083 ] [ 2.351774    0.6235444 ]], shape=(10, 2), dtype=float32)  tf.Tensor([[ 0.518868  ] [-1.5353174 ] [-0.46222487] [-4.2567196 ] [11.557878  ] [ 4.0018907 ] [ 8.08824   ] [ 0.7906476 ] [-3.0673254 ] [ 6.7880654 ]], shape=(10, 1), dtype=float32)</code></pre><ul><li>当我们运行迭代时，我们会连续地获得不同的小批量，直至遍历完整个数据集。</li></ul><h2 id="初始化模型参数"><a class="markdownIt-Anchor" href="#初始化模型参数"></a> 初始化模型参数</h2><ul><li>在我们开始用小批量随机梯度下降优化我们的模型参数之前，我们需要先有一些参数。在下面的代码中，我们通过从均值为0、标准差为0.01的<em>正态分布</em>中采样随机数来初始化权重，并将偏移量初始化为0。</li><li>注：<a href="https://www.cnblogs.com/superxuezhazha/p/9528277.html">tf.Variable用法解析</a></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">w &#x3D; tf.Variable(tf.random.normal(shape&#x3D;(2, 1), mean&#x3D;0, stddev&#x3D;0.01),                trainable&#x3D;True)b &#x3D; tf.Variable(tf.zeros(1), trainable&#x3D;True)w,b</code></pre><pre><code>(&lt;tf.Variable 'Variable:0' shape=(2, 1) dtype=float32, numpy= array([[-0.00593151],        [ 0.00970709]], dtype=float32)&gt;, &lt;tf.Variable 'Variable:0' shape=(1,) dtype=float32, numpy=array([0.], dtype=float32)&gt;)</code></pre><ul><li>在初始化参数之后，我们的任务是<em>更新这些参数</em>，直到这些参数足够拟合我们的数据。</li><li>每次更新都需要计算损失函数关于模型参数的梯度。有了这个梯度，我们就可以向减小损失的方向更新每个参数。</li><li>我们使用<em>自动微分</em>来计算梯度。</li></ul><h2 id="定义模型"><a class="markdownIt-Anchor" href="#定义模型"></a> 定义模型</h2><ul><li>接下来，我们必须定义模型，将<em>模型的输入和参数同模型的输出关联起来</em>。所谓模型，就是将从输入通过与参数的元素得出结果的函数用程序表示出来。</li><li>要计算线性模型的输出，我们只需计算输入特征<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">X</mi></mrow><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">X</span></span></span></span></span>和模型权重<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">w</mi></mrow><annotation encoding="application/x-tex">\mathbf{w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span></span>的矩阵-向量乘法后加上偏移量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>。注意，上面的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">X</mi><mi mathvariant="bold">w</mi></mrow><annotation encoding="application/x-tex">\mathbf{Xw}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">X</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span></span>是一个向量，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>是一个标量。通过广播机制，当我们用一个向量加一个标量时，标量会被加到向量的每个分量上。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">def linreg(X, w, b):      &quot;&quot;&quot;线性回归模型。&quot;&quot;&quot;    return tf.matmul(X, w) + b</code></pre><h2 id="定义损失函数"><a class="markdownIt-Anchor" href="#定义损失函数"></a> 定义损失函数</h2><ul><li>因为要更新模型。需要计算损失函数的梯度，所以我们应该先定义损失函数。所谓损失函数就是计算通过模型得到的输出与实际的输出（标签值）之间的偏差程度。损失函数实质是<strong>以模型参数为自变量，误差值为因变量的函数</strong>，因为预测值中含有的变量就是模型参数。</li><li>这里我们使用<em>平方损失函数</em>。</li><li>在实现中，我们需要将真实值<code>y</code>的<em>形状转换</em>为和预测值<code>y_hat</code>的形状相同。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">def squared_loss(y_hat, y):     &quot;&quot;&quot;平方损失函数&quot;&quot;&quot;    return (y_hat - tf.reshape(y, y_hat.shape)) ** 2 &#x2F; 2</code></pre><h2 id="定义优化算法"><a class="markdownIt-Anchor" href="#定义优化算法"></a> 定义优化算法</h2><ul><li>在每一步中，使用从数据集中随机抽取的一个小批量，然后根据参数计算损失的梯度(即损失函数关于模型参数的导数)。接下来，朝着减少损失的方向<strong>更新我们的参数</strong>。<a href="https://zhuanlan.zhihu.com/p/43452377">梯度下降解析</a></li><li>下面的函数实现小批量随机梯度下降更新。该函数接受模型参数集合、学习速率和批量大小作为输入。每一步更新的大小由学习速率<code>lr</code>决定，学习率乘以导数就是沿梯度方向变化的幅度，模型参数减去这个幅度(步长）就实现了沿梯度下降方向的参数更新。<a href="https://zhuanlan.zhihu.com/p/39842768">梯度下降与学习率解析</a></li><li>因为我们计算的损失是一个批量样本的总和，所以我们用批量大小（<code>batch_size</code>）来归一化（就是除一下）步长，这样步长大小就不会取决于我们对批量大小的选择。（为什么需要归一化？）</li><li><a href="https://www.runoob.com/python/python-func-zip.html">python zip函数解析</a></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"> # params是元素类型为tf.Varible的列表，grads使参数对应的损失函数导数，lr是学习率def sgd(params, grads, lr, batch_size):     &quot;&quot;&quot;小批量随机梯度下降。&quot;&quot;&quot;    for param, grad in zip(params, grads): # zip函数将可迭代对象打包成一个个元组用于遍历        #tensorflow的assign_sub函数能够将param减去括号中参数的值再赋给param，实现更新参数        param.assign_sub(lr*grad&#x2F;batch_size) </code></pre><h2 id="训练"><a class="markdownIt-Anchor" href="#训练"></a> 训练</h2><ul><li>现在我们已经准备好了模型训练所有需要的要素，可以实现主要的[<strong>训练过程</strong>]部分了。在整个深度学习的职业生涯中，会一遍又一遍地看到几乎相同的训练过程。</li><li>在每次迭代中，我们读取一小批量训练样本，并通过我们的模型来获得一组<em>预测</em>。计算完损失后，我们开始<em>反向传播，存储每个参数的梯度</em>。最后，我们调用优化算法<code>sgd</code>来更新模型参数。</li></ul><p>概括一下，我们将执行以下循环：</p><ul><li>初始化参数</li><li>重复，直到完成<ul><li>计算梯度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">g</mi><mo>←</mo><msub><mi mathvariant="normal">∂</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></msub><mfrac><mn>1</mn><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="script">B</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><msub><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi mathvariant="script">B</mi></mrow></msub><mi>l</mi><mo stretchy="false">(</mo><msup><mi mathvariant="bold">x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo separator="true">,</mo><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo separator="true">,</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{g} \leftarrow \partial_{(\mathbf{w},b)} \frac{1}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} l(\mathbf{x}^{(i)}, y^{(i)}, \mathbf{w}, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.63888em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">g</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.408em;vertical-align:-0.52em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.05556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathbf mtight" style="margin-right:0.01597em;">w</span></span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span><span class="mord mtight">∣</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32708000000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathbf">x</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span></li><li>更新参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>←</mo><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>−</mo><mi>η</mi><mi mathvariant="bold">g</mi></mrow><annotation encoding="application/x-tex">(\mathbf{w}, b) \leftarrow (\mathbf{w}, b) - \eta \mathbf{g}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.63888em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">g</span></span></span></span></span></li></ul></li><li>在每个**迭代周期（epoch）**中，我们使用<code>data_iter</code>函数遍历整个数据集，并将训练数据集中所有样本都使用一次（假设样本数能够被批量大小整除）。这里的迭代周期个数<code>num_epochs</code>和学习率<code>lr</code>都是超参数，分别设为3和0.03。设置超参数很棘手，需要通过<em>反复试验</em>进行调整。（每个迭代周期都要使用完整个数据集，通过多次重复来找到最佳参数）。</li><li>注：<a href="https://zhuanlan.zhihu.com/p/102207302">tensorflow自动求导解析</a></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">lr &#x3D; 0.03 #学习率num_epochs &#x3D; 3 #迭代周期net &#x3D; linreg #线性回归模型函数loss &#x3D; squared_loss #平方损失函数</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">for epoch in range(num_epochs):    for X, y in data_iter(batch_size, features, labels):        with tf.GradientTape() as g: # 使用tensorflow的自动求导            l &#x3D; loss(net(X, w, b), y)  # &#96;X&#96;和&#96;y&#96;的小批量损失        # 计算l(损失函数)关于[&#96;w&#96;, &#96;b&#96;]的梯度        dw, db &#x3D; g.gradient(l, [w, b])        # 使用参数的梯度更新参数        sgd([w, b], [dw, db], lr, batch_size)    train_l &#x3D; loss(net(features, w, b), labels)    print(f&#39;epoch &#123;epoch + 1&#125;, loss &#123;float(tf.reduce_mean(train_l)):f&#125;&#39;)</code></pre><pre><code>epoch 1, loss 0.031377epoch 2, loss 0.000106epoch 3, loss 0.000048</code></pre><p>因为我们使用的是自己合成的数据集，所以我们知道真正的参数是什么。<br />因此，我们可以通过[<strong>比较真实参数和通过训练学到的参数来评估训练的成功程度</strong>]。事实上，真实参数和通过训练学到的参数确实非常接近。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(f&#39;w的估计误差: &#123;true_w - tf.reshape(w, true_w.shape)&#125;&#39;)print(f&#39;b的估计误差: &#123;true_b - b&#125;&#39;)</code></pre><pre><code>w的估计误差: [-0.00037241 -0.0001893 ]b的估计误差: [0.00096989]</code></pre><ul><li>注意，我们不应该想当然地认为我们能够完美地恢复参数。在机器学习中，我们通常<em>不太关心恢复真正的参数，而更关心那些能高度准确预测的参数</em>。幸运的是，即使是在复杂的优化问题上，随机梯度下降通常也能找到非常好的解。其中一个原因是，在深度网络中存在许多参数组合能够实现高度精确的预测。</li></ul><h1 id="线性回归的简洁实现"><a class="markdownIt-Anchor" href="#线性回归的简洁实现"></a> 线性回归的简洁实现</h1><ul><li>通过深度学习框架可以自动化实现基于梯度的学习算法中重复性的工作。</li><li>在从零开始的实现中，我们只依赖了：（1）通过张量来进行数据存储和线性代数；（2）通过自动微分来计算梯度。实际上，由于数据迭代器、损失函数、优化器和神经网络层很常用，现代深度学习库也为我们实现了这些组件。</li><li>接下来，我们将通过使用深度学习框架来简洁地实现线性回归模型。</li></ul><h2 id="生成数据集-2"><a class="markdownIt-Anchor" href="#生成数据集-2"></a> 生成数据集</h2><ul><li>我们首先[<strong>生成数据集</strong>]。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">import numpy as npimport tensorflow as tf#根据数据集以及线性模型得出对应的y值向量def synthetic_data(w, b, num_examples):  # w为线性模型参数，b为偏移量，num_examples是数据集数据数量    &quot;&quot;&quot;生成 y &#x3D; Xw + b + 噪声。&quot;&quot;&quot;    X &#x3D; tf.zeros((num_examples, w.shape[0])) # 生成和w的列数一样，行数为num_examples的，值全为0矩阵    X +&#x3D; tf.random.normal(shape&#x3D;X.shape) # 用标准正态分布的数值为X矩阵的每个元素赋值     # 将w转换为2行1列（-1代表自动推断此处应该填的维数）的矩阵与X矩阵相乘再加上偏移量计算y    y &#x3D; tf.matmul(X, tf.reshape(w, (-1, 1))) + b    y +&#x3D; tf.random.normal(shape&#x3D;y.shape, stddev&#x3D;0.01) # 给y的值加上服从正态分布的误差    y &#x3D; tf.reshape(y, (-1, 1)) # 将y转换为1列的矩阵    return X, y</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">true_w &#x3D; tf.constant([2, -3.4])true_b &#x3D; 4.2features, labels &#x3D; synthetic_data(true_w, true_b, 1000)</code></pre><h2 id="读取数据集-2"><a class="markdownIt-Anchor" href="#读取数据集-2"></a> 读取数据集</h2><ul><li>我们可以[<strong>调用框架中现有的API来读取数据</strong>]。我们将<code>features</code>和<code>labels</code>作为API的参数传递，并在实例化数据迭代器对象时指定<code>batch_size</code>。此外，布尔值<code>is_train</code>表示是否希望数据迭代器对象在每个迭代周期内打乱数据。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">def load_array(data_arrays, batch_size, is_train&#x3D;True):     &quot;&quot;&quot;构造一个TensorFlow数据迭代器。&quot;&quot;&quot;    # 使用tensorflow的API来读取特征值向量和标签向量生成数据集    dataset &#x3D; tf.data.Dataset.from_tensor_slices(data_arrays)     if is_train:        dataset &#x3D; dataset.shuffle(buffer_size&#x3D;1000) # 打乱数据    dataset &#x3D; dataset.batch(batch_size) # 得到批量随机数据迭代器    return dataset</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">batch_size &#x3D; 10data_iter &#x3D; load_array((features, labels), batch_size) </code></pre><ul><li><code>data_iter</code>是一个小批量样本迭代器（可以用于for…Iin 循环遍历)。为了验证是否正常工作，让我们读取并打印第一个小批量样本。</li><li>我们使用<code>iter</code>构造Python迭代器，并使用<code>next</code>从迭代器中获取第一项。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">next(iter(data_iter))</code></pre><pre><code>(&lt;tf.Tensor: shape=(10, 2), dtype=float32, numpy= array([[-1.0550611 , -0.82872546],        [-0.28267154, -0.25637326],        [-0.5144283 ,  0.44031686],        [-0.5526093 , -0.9219198 ],        [-0.1690998 ,  0.75760716],        [-0.9019597 , -1.2707379 ],        [-1.4669428 ,  1.035699  ],        [ 0.7166598 , -0.9520578 ],        [ 1.7674623 ,  0.872534  ],        [-0.48834816,  0.7471352 ]], dtype=float32)&gt;, &lt;tf.Tensor: shape=(10, 1), dtype=float32, numpy= array([[ 4.9053    ],        [ 4.495085  ],        [ 1.6844876 ],        [ 6.2230234 ],        [ 1.2832037 ],        [ 6.728463  ],        [-2.2450213 ],        [ 8.868936  ],        [ 4.7641516 ],        [ 0.68498605]], dtype=float32)&gt;)</code></pre><h2 id="定义模型-2"><a class="markdownIt-Anchor" href="#定义模型-2"></a> 定义模型</h2><ul><li><p>当我们从零实现线性回归时，我们明确定义了模型参数变量，并编写了计算的代码，这样通过基本的线性代数运算得到输出。但是，如果模型变得更加复杂，而且当你几乎每天都需要实现模型时，你会想简化这个过程。</p></li><li><p>对于标准操作，我们可以[<strong>使用框架的预定义好的层</strong>]。这使我们只需关注使用哪些层来构造模型，而不必关注层的实现细节。即，不用关心模型应该怎么表达，框架会自动根据数据来拟合一个模型函数，并且最后得到它的最佳参数。</p></li><li><p>我们首先定义一个模型变量<code>net</code>，它是一个<code>Sequential</code>类的实例。<code>Sequential</code>类为串联在一起的多个层定义了一个容器。当给定输入数据，<code>Sequential</code>实例将数据传入到第一层，然后将第一层的输出作为第二层的输入，依此类推。在下面的例子中，我们的模型只包含一个层，因此实际上不需要<code>Sequential</code>。但是由于以后几乎所有的模型都是多层的，在这里使用<code>Sequential</code>会让你熟悉标准的流水线。</p></li><li><p><em>全连接层</em>（fully-connected layer）：它的每一个输入都通过矩阵-向量乘法连接到它的每个输出。因为我们的数据实际是满足线性模型的，即标签值是通过自变量的一个线性函数运算得到，自变量与因变量（输入与输出）之间是一一对应的关系，所以满足全连接。</p></li><li><p>在Keras中，全连接层在<code>Dense</code>类中定义。由于我们只想得到一个<em>标量输出</em>，所以我们将该数字设置为1。</p></li><li><p>值得注意的是，为了方便使用，Keras<em>不要求我们为每个层指定输入形状</em>（即不知道数据到底有多少）。所以在这里，我们不需要告诉Keras有多少输入进入这一层。当我们第一次尝试通过我们的模型传递数据时，例如，当后面执行<code>net(X)</code>时，Keras会<em>自动推断每个层输入</em>的形状。我们稍后将详细介绍这种工作机制。</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"># &#96;keras&#96; 是TensorFlow的高级APInet &#x3D; tf.keras.Sequential()net.add(tf.keras.layers.Dense(1))</code></pre><h2 id="初始化模型参数-2"><a class="markdownIt-Anchor" href="#初始化模型参数-2"></a> 初始化模型参数</h2><ul><li><p>在使用<code>net</code>之前，我们需要初始化模型参数。如在线性回归模型中的权重和偏置。</p></li><li><p>深度学习框架通常有<em>预定义的方法</em>来初始化参数。在这里，我们指定每个权重参数应该从均值为0、标准差为0.01的正态分布中随机采样，偏置参数将默认初始化为零。</p></li><li><p>TensorFlow中的<code>initializers</code>模块提供了多种模型参数初始化方法。在Keras中最简单的指定初始化方法是在<em>创建层</em>时指定<code>kernel_initializer</code>。在这里，我们重新创建了<code>net</code>。</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">initializer &#x3D; tf.initializers.RandomNormal(stddev&#x3D;0.01)net &#x3D; tf.keras.Sequential()net.add(tf.keras.layers.Dense(1, kernel_initializer&#x3D;initializer))</code></pre><ul><li>初始化的推迟执行：上面的代码可能看起来很简单，但是你应该注意到这里的一个细节：我们正在为网络初始化参数，而Keras还不知道输入将有多少维!网络的输入可能有2维，也可能有2000维。Keras让我们避免了这个问题，在后端执行时，初始化实际上是<em>推迟</em>（deferred）执行的。只有在我们第一次尝试通过网络传递数据时才会进行真正的初始化。只是要记住，因为参数还没有初始化，所以我们不能访问或操作它们。</li></ul><h2 id="定义损失函数-2"><a class="markdownIt-Anchor" href="#定义损失函数-2"></a> 定义损失函数</h2><ul><li>计算均方误差使用的是<code>MeanSquaredError</code>类，也称为平方<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">L_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>范数。默认情况下，它返回所有样本损失的平均值。框架帮我们定义好了各种损失函数。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">loss &#x3D; tf.keras.losses.MeanSquaredError()</code></pre><h2 id="定义优化算法-2"><a class="markdownIt-Anchor" href="#定义优化算法-2"></a> 定义优化算法</h2><ul><li>小批量随机梯度下降算法是一种优化神经网络的标准工具，Keras在<code>optimizers</code>模块中实现了该算法的许多变种。小批量随机梯度下降只需要设置<code>learning_rate</code>值（学习率），这里设置为0.03。框架将我们更新参数的函数也内置定义好了。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">trainer &#x3D; tf.keras.optimizers.SGD(learning_rate&#x3D;0.03)</code></pre><h2 id="训练-2"><a class="markdownIt-Anchor" href="#训练-2"></a> 训练</h2><ul><li>通过深度学习框架的高级API来实现我们的模型只需要相对较少的代码。我们不必单独分配参数、不必定义我们的损失函数，也不必手动实现小批量随机梯度下降。</li><li><strong>在每个迭代周期里，我们将完整遍历一次数据集（<code>train_data</code>）</strong>，不停地从中获取一个小批量的输入和相应的标签。对于每一个小批量，我们会进行以下步骤:<ul><li>通过调用<code>net(X)</code>生成预测并计算损失<code>l</code>（正向传播）。</li><li>通过进行反向传播来计算梯度。</li><li>通过调用优化器来更新模型参数。</li></ul></li><li>为了更好的衡量训练效果，我们计算每个迭代周期后的损失，并打印它来监控训练过程。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">num_epochs &#x3D; 3for epoch in range(num_epochs):    for X, y in data_iter: # 迭代获取小批量数据样本        with tf.GradientTape() as tape:            l &#x3D; loss(net(X, training&#x3D;True), y) # 计算损失        grads &#x3D; tape.gradient(l, net.trainable_variables) # 计算损失函数关于训练的参数的导数        trainer.apply_gradients(zip(grads, net.trainable_variables)) # 根据计算的导数更新参数    l &#x3D; loss(net(features), labels) # 本次迭代结束后，利用更新后的参数来计算损失，用于监控训练进展    print(f&#39;epoch &#123;epoch + 1&#125;, loss &#123;l:f&#125;&#39;)</code></pre><pre><code>epoch 1, loss 0.000191epoch 2, loss 0.000098epoch 3, loss 0.000097</code></pre><ul><li>下面我们[<strong>比较生成数据集的真实参数和通过有限数据训练获得的模型参数</strong>]。</li><li>要访问参数，我们首先从<code>net</code>访问所需的层，然后读取该层的权重和偏置。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">w &#x3D; net.get_weights()[0]print(&#39;w的估计误差：&#39;, true_w - tf.reshape(w, true_w.shape))b &#x3D; net.get_weights()[1]print(&#39;b的估计误差：&#39;, true_b - b)</code></pre><pre><code>w的估计误差： tf.Tensor([-0.00038457 -0.00020194], shape=(2,), dtype=float32)b的估计误差： [-0.00032425]</code></pre><ul><li>可以看出，训练得出的参数和实际参数非常接近。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据可视化</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/Python%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/Python%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="matplotlib"><a class="markdownIt-Anchor" href="#matplotlib"></a> Matplotlib</h1><ul><li>Matplotlib来自于由John Hunter在2002年启动的一个用于创建图表的绘图项目，其目的是为Python构建一个与Matlab之间进行交互的绘图接口。是最著名Python绘图库， 主要用于二维绘图。具有画图质量高、方便快捷的绘图模块等特点。</li></ul><h2 id="matplotlib入门"><a class="markdownIt-Anchor" href="#matplotlib入门"></a> Matplotlib入门</h2><ul><li><p>绘图API：pyplot模块</p></li><li><p>集成库：pylab模块（包含NumPy和pyplot中的常用函数）</p></li><li><p>导入Matplotlib绘图包</p></li><li><p>pyplot对象相当于画笔，<code>plot()</code>函数在设置画笔绘制的对象，其它的类似函数在设置画笔的其它性质，最后通过<code>show()</code>函数使用画笔绘制出图像</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">import matplotlib.pyplot as pltimport numpy as np</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">t &#x3D; np.arange(0., 4.0, 0.1) # 从0到4，步频为0.1生成t数字序列plt.plot(t, t) # 前面一位是横坐标，后面对应的是纵坐标plt.show()t</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211103090642.png" alt="" /></p><pre><code>array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. , 1.1, 1.2,       1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2. , 2.1, 2.2, 2.3, 2.4, 2.5,       2.6, 2.7, 2.8, 2.9, 3. , 3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8,       3.9])</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">plt.plot(t, t**2)plt.show()</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211103090658.png" alt="" /></p><ul><li>可以将两个曲线绘制在一个图里</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">plt.plot(t, t, t, t**2)plt.show()</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211103090714.png" alt="" /></p><ul><li>通过<code>plot()</code>函数的<code>o</code>参数，将图像变为散点图</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">plt.plot(t, t**2, &#39;o&#39;)plt.show()</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211103090726.png" alt="" /></p><ul><li>使用<code>bar()</code>函数，绘制柱状图</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">t &#x3D; np.arange(0, 10, 1)plt.bar(t, t**2)plt.show()</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211103090742.png" alt="" /></p><h2 id="matplotlib图像属性控制"><a class="markdownIt-Anchor" href="#matplotlib图像属性控制"></a> Matplotlib图像属性控制</h2><h3 id="线条属性"><a class="markdownIt-Anchor" href="#线条属性"></a> 线条属性</h3><ul><li><p>色彩和样式通过在绘图函数如<code>plot()</code>中添加参数来控制，常用参数：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/MF7g00.png" alt="MF7g00" /></p></li><li><p>颜色修改示例：</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">t &#x3D; np.arange(0, 4, 0.1)plt.plot(t, t**2, &#39;g&#39;) # 设为绿色plt.show()</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211103090755.png" alt="" /></p><ul><li>修改线型示例：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">plt.plot(t, t**2,&#39;--&#39;) # 设为虚线plt.show()</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211103090806.png" alt="" /></p><ul><li>设置点的形状示例：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">t &#x3D; np.arange(0, 10, 1)plt.plot(t, t**2, &#39;v&#39;) #设置点的形状为三角形plt.show()</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211103090818.png" alt="" /></p><ul><li>多个参数同时使用,需要<strong>指明参数的名称</strong>才能同时生效：<ul><li>颜色：<code>color</code></li><li>样式：<code>linestyle</code></li><li>点形状：<code>marker</code></li><li>线条宽度：<code>linewidth</code></li><li>线条含义标识：<code>label</code></li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">t1 &#x3D; np.arange(0, 4, 0.1)t2 &#x3D; np.arange(0, 4, 0.5)# 先设置参数，再显示图像，才能生效（plt可以理解为画笔）plt.plot(t1, t1**2, linestyle&#x3D;&#39;--&#39;, color&#x3D;&#39;r&#39;,linewidth&#x3D;&#39;5&#39;, label&#x3D;&#39;Line1&#39;) plt.plot(t2, t2+2, color&#x3D;&#39;g&#39;, linewidth&#x3D;&#39;3&#39;, marker&#x3D;&#39;o&#39;, label&#x3D;&#39;Line2&#39;)plt.legend(loc&#x3D;&#39;upper left&#39;) # 设置线条含义标识显示位置（不设置显示不出来）plt.show()</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211103090829.png" alt="" /></p><h3 id="添加说明文字"><a class="markdownIt-Anchor" href="#添加说明文字"></a> 添加说明文字</h3><ul><li><p>可以设置整个图的名称、坐标轴的名称</p></li><li><p>设置图的名称</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">t &#x3D; np.arange(0, 4, 0.1)plt.plot(t, t**2) # 设为绿色plt.title(&quot;Hello!&quot;)plt.show()</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211103090848.png" alt="" /></p><ul><li>设置横纵坐标</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">plt.plot(t, t**2) # 设为绿色# 先设置参数，再显示图像，才能生效（plt可以理解为画笔）plt.title(&quot;Hello!&quot;)plt.xlabel(&quot;NumberX&quot;)plt.ylabel(&quot;NumberY&quot;)plt.show()</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211103090900.png" alt="" /></p><h2 id="子图"><a class="markdownIt-Anchor" href="#子图"></a> 子图</h2><ul><li><p>子图是指在一次绘制过程中绘制的多个坐标图，每一个被包含的的坐标图都是子图。</p></li><li><p>子图可以通过pyplot对象的<code>subplot()</code>函数来绘制</p></li><li><p>子图也可以通过设置坐标轴的长短和坐标原点的<code>axes()</code>方法来创建。</p></li><li><p>通过<code>subplot()</code>函数在一个图中绘制四个子图示例：</p></li><li><p>参数的意义：如221(也可写成2，2，1）的意思就是创建2行2列4个子图，当前子图在第一个位置</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"># t1 &#x3D; np.arange(0, 4, 0.1)# t2 &#x3D; np.arange(0, 4, 0.5)plt.subplot(221)plt.subplot(222)plt.subplot(223)plt.subplot(224)</code></pre><pre><code>&lt;AxesSubplot:&gt;</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211103090917.png" alt="" /></p><ul><li>在子图中绘制图像</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">t1 &#x3D; np.arange(0, 4, 0.1)t2 &#x3D; np.arange(0, 4, 0.5)#先创建子图plt.subplot(1,2,1)#再绘制图像plt.plot(t1, t1**2)plt.subplot(1,2,2)plt.plot(t2, 2*t2+3)plt.show()</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211103091023.png" alt="" /></p><ul><li>使用<code>axes()</code>函数设置坐标轴来创建2个子图</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">plt.axes([.1,.1,0.8,0.8]) #创建原点在（0.1，0.1），两个坐标轴的长度都为0.8的子图plt.plot(t1, t1**2) # 在上面创建的子图上绘制曲线plt.axes([.3,.5,0.3,0.3])plt.plot(t2, 2*t2+3)plt.show()</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211103091038.png" alt="" /></p><h1 id="pandas绘图"><a class="markdownIt-Anchor" href="#pandas绘图"></a> Pandas绘图</h1><ul><li><p>Pandas 对 Matplotlib 绘图软件包的基础上单独封装了一个plot()接口，通过调用该接口可以实现常用的绘图操作。</p></li><li><p>Pandas 之所以能够实现了数据可视化，主要利用了 Matplotlib 库的 plot() 方法，它对 plot() 方法做了简单的封装，因此您可以直接调用该接口。</p></li><li><p>示例：</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pandas as pdimport numpy as npdf &#x3D; pd.DataFrame(np.random.randn(8, 4), index &#x3D; pd.date_range(&#39;11&#x2F;2&#x2F;2021&#39;, periods&#x3D;8), columns&#x3D;list(&#39;ABCD&#39;)) #randn使数据具有正态分布df.plot(linestyle&#x3D;&#39;--&#39;) #调用plot（）方法绘图</code></pre><pre><code>&lt;AxesSubplot:&gt;</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211103091048.png" alt="" /></p><ul><li><p>除了默认的线形图，Pandas也可以绘制其它图形：</p><ul><li>柱状图：bar() 或 barh()</li><li>直方图：hist()</li><li>箱状箱：box()</li><li>区域图：area()</li><li>散点图：scatter()</li></ul></li><li><p>通过关键字参数kind可以把上述方法传递给 plot()。</p></li><li><p>绘制柱状图：</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">df.plot.bar()</code></pre><pre><code>&lt;AxesSubplot:&gt;</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211103091100.png" alt="" /></p><ul><li>绘制水平柱状图</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">df.plot(kind&#x3D;&#39;barh&#39;)</code></pre><pre><code>&lt;AxesSubplot:&gt;</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211103091111.png" alt="" /></p><ul><li>绘制柱状堆叠图（参数stacked设为True）</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">df.plot(kind&#x3D;&#39;bar&#39;, stacked&#x3D;&#39;True&#39;)</code></pre><pre><code>&lt;AxesSubplot:&gt;</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211103091121.png" alt="" /></p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习三——深度学习中的数学</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%89%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%89%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="线性代数"><a class="markdownIt-Anchor" href="#线性代数"></a> 线性代数</h1><p>下面我们将介绍线性代数中的基本数学对象、算术和运算，并用数学符号和相应的代码实现来表示它们。</p><h2 id="向量"><a class="markdownIt-Anchor" href="#向量"></a> 向量</h2><ul><li>[<strong>你可以将向量视为标量值组成的列表</strong>]。我们将这些标量值称为向量的<em>元素</em>（element）或<em>分量</em>（component）。当我们的向量表示数据集中的样本时，它们的值具有一定的现实意义。例如，如果我们正在训练一个模型来预测贷款违约风险，我们可能会将每个申请人与一个向量相关联，其分量与其收入、工作年限、过往违约次数和其他因素相对应。如果我们正在研究医院患者可能面临的心脏病发作风险，我们可能会用一个向量来表示每个患者，其分量为最近的生命体征、胆固醇水平、每天运动时间等。在数学表示法中，我们通常将向量记为粗体、小写的符号（例如，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">x</mi></mrow><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">x</span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">y</mi></mrow><annotation encoding="application/x-tex">\mathbf{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.63888em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{z})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbf">z</span></span><span class="mclose">)</span></span></span></span>）。</li><li>我们通过一维张量处理向量。一般来说，张量可以具有任意长度，取决于机器的内存限制。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">import tensorflow as tfx &#x3D; tf.range(4)x</code></pre><pre><code>&lt;tf.Tensor: shape=(4,), dtype=int32, numpy=array([0, 1, 2, 3], dtype=int32)&gt;</code></pre><ul><li>我们可以<em>使用下标来引用向量</em>的任一元素。例如，我们可以通过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>来引用第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>个元素。注意，元素<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是一个标量，所以我们在引用它时不会加粗。大量文献认为列向量是向量的默认方向。在数学中，向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">x</mi></mrow><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">x</span></span></span></span></span>可以写为：</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="bold">x</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>x</mi><mn>1</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>x</mi><mn>2</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>x</mi><mi>n</mi></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">\mathbf{x} =\begin{bmatrix}x_{1}  \\x_{2}  \\ \vdots  \\x_{n}\end{bmatrix},</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">x</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:5.459999999999999em;vertical-align:-2.4799999999999995em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.953995em;"><span style="top:-1.3499850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.4999850000000006em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.0959850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.6919850000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.712975em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.953995em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4500349999999997em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9799999999999995em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7674999999999996em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675000000000006em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4799999999999995em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.953995em;"><span style="top:-1.3499850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.4999850000000006em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.0959850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.6919850000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.712975em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.953995em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4500349999999997em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span></span></span></span></span></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x[3] #用下标来获取第4个元素值3</code></pre><pre><code>&lt;tf.Tensor: shape=(), dtype=int32, numpy=3&gt;</code></pre><h2 id="矩阵"><a class="markdownIt-Anchor" href="#矩阵"></a> 矩阵</h2><ul><li><p>正如向量将标量从零阶推广到一阶，矩阵将向量从一阶推广到二阶。矩阵，我们通常用粗体、大写字母来表示（例如，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">X</mi></mrow><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">X</span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">Y</mi></mrow><annotation encoding="application/x-tex">\mathbf{Y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.02875em;">Y</span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">Z</mi></mrow><annotation encoding="application/x-tex">\mathbf{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">Z</span></span></span></span></span>），在代码中表示为具有两个轴的张量。</p></li><li><p>在数学表示法中，我们使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{A} \in \mathbb{R}^{m \times n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72521em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathbf">A</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>来表示矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi></mrow><annotation encoding="application/x-tex">\mathbf{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">A</span></span></span></span></span>，其由<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>行和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>列的实值标量组成。直观地，我们可以将任意矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{A} \in \mathbb{R}^{m \times n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72521em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathbf">A</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>视为一个表格，其中每个元素<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>属于第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>行第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>列：</p></li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="bold">A</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>11</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>12</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mn>1</mn><mi>n</mi></mrow></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>21</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>22</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mn>2</mn><mi>n</mi></mrow></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋱</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mi>m</mi><mn>1</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mi>m</mi><mn>2</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mi>m</mi><mi>n</mi></mrow></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathbf{A}=\begin{bmatrix} a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\ a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn} \\ \end{bmatrix}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">A</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:5.459999999999999em;vertical-align:-2.4799999999999995em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.953995em;"><span style="top:-1.3499850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.4999850000000006em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.0959850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.6919850000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.712975em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.953995em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4500349999999997em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9799999999999995em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7674999999999996em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675000000000006em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4799999999999995em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9799999999999995em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7674999999999996em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675000000000006em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4799999999999995em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9799999999999995em;"><span style="top:-5.64em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span><span style="top:-4.44em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span><span style="top:-2.5799999999999996em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋱</span></span></span><span style="top:-1.3800000000000006em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4799999999999995em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9799999999999995em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7674999999999996em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675000000000006em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4799999999999995em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.953995em;"><span style="top:-1.3499850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.4999850000000006em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.0959850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.6919850000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.712975em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.953995em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4500349999999997em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span></span></span></span></span></p><ul><li>对于任意<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{A} \in \mathbb{R}^{m \times n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72521em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathbf">A</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi></mrow><annotation encoding="application/x-tex">\mathbf{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">A</span></span></span></span></span>的形状是（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>）或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>。当矩阵具有相同数量的行和列时，其形状将变为正方形；因此，它被称为<em>方矩阵</em>（square matrix）。</li><li>当调用函数来实例化张量时，我们可以[<strong>通过指定两个分量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>来创建一个形状为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>的矩阵</strong>]。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">A &#x3D; tf.reshape(tf.range(20), (5, 4))A</code></pre><pre><code>&lt;tf.Tensor: shape=(5, 4), dtype=int32, numpy=array([[ 0,  1,  2,  3],       [ 4,  5,  6,  7],       [ 8,  9, 10, 11],       [12, 13, 14, 15],       [16, 17, 18, 19]], dtype=int32)&gt;</code></pre><ul><li><strong>矩阵的转置</strong>：有时候，我们想翻转轴。当我们交换矩阵的行和列时，结果称为矩阵的<em>转置</em>（transpose）。我们用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="bold">a</mi><mi mathvariant="normal">⊤</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{a}^\top</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span></span></span></span>来表示矩阵的转置，如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">B</mi><mo>=</mo><msup><mi mathvariant="bold">A</mi><mi mathvariant="normal">⊤</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{B}=\mathbf{A}^\top</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">B</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">A</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span></span></span></span>，则对于任意<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>，都有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>a</mi><mrow><mi>j</mi><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">b_{ij}=a_{ji}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>。因此，上面矩阵中的转置是一个形状为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>的矩阵：</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi mathvariant="bold">A</mi><mi mathvariant="normal">⊤</mi></msup><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>11</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>21</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">…</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mi>m</mi><mn>1</mn></mrow></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>12</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>22</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">…</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mi>m</mi><mn>2</mn></mrow></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋱</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mn>1</mn><mi>n</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mn>2</mn><mi>n</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">…</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mi>m</mi><mi>n</mi></mrow></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathbf{A}^\top =\begin{bmatrix}    a_{11} &amp; a_{21} &amp; \dots  &amp; a_{m1} \\    a_{12} &amp; a_{22} &amp; \dots  &amp; a_{m2} \\    \vdots &amp; \vdots &amp; \ddots  &amp; \vdots \\    a_{1n} &amp; a_{2n} &amp; \dots  &amp; a_{mn}\end{bmatrix}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8991079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">A</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:5.459999999999999em;vertical-align:-2.4799999999999995em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.953995em;"><span style="top:-1.3499850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.4999850000000006em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.0959850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.6919850000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.712975em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.953995em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4500349999999997em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9799999999999995em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7674999999999996em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675000000000006em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4799999999999995em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9799999999999995em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7674999999999996em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675000000000006em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4799999999999995em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9799999999999995em;"><span style="top:-5.64em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">…</span></span></span><span style="top:-4.44em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">…</span></span></span><span style="top:-2.5799999999999996em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋱</span></span></span><span style="top:-1.3800000000000006em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">…</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4799999999999995em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9799999999999995em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7674999999999996em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675000000000006em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4799999999999995em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.953995em;"><span style="top:-1.3499850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.4999850000000006em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.0959850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.6919850000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.712975em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.953995em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4500349999999997em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span></span></span></span></span></p><ul><li>现在我们在代码中访问(<strong>矩阵的转置</strong>)。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">tf.transpose(A)</code></pre><pre><code>&lt;tf.Tensor: shape=(4, 5), dtype=int32, numpy=array([[ 0,  4,  8, 12, 16],       [ 1,  5,  9, 13, 17],       [ 2,  6, 10, 14, 18],       [ 3,  7, 11, 15, 19]], dtype=int32)&gt;</code></pre><ul><li>矩阵的作用：矩阵允许我们组织具有不同变化模式的数据。例如，我们矩阵中的行可能对应于不同的房屋（数据样本），而列可能对应于不同的属性。如果你曾经使用过电子表格软件。因此，尽管单个向量的默认方向是列向量，但在表示表格数据集的矩阵中，将每个数据样本作为矩阵中的行向量更为常见。这种约定将支持常见的深度学习实践。</li></ul><h2 id="张量"><a class="markdownIt-Anchor" href="#张量"></a> 张量</h2><ul><li><p>[<strong>就像向量是标量的推广，矩阵是向量的推广一样，我们可以构建具有更多轴的数据结构</strong>]。张量（本小节中的“张量”指代数对象）为我们提供了描述具有任意数量轴的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>维数组的通用方法。例如，向量是一阶张量，矩阵是二阶张量。张量用特殊字体的大写字母（例如，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">X</mi></mrow><annotation encoding="application/x-tex">\mathsf{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">X</span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">Y</mi></mrow><annotation encoding="application/x-tex">\mathsf{Y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf" style="margin-right:0.025em;">Y</span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">Z</mi></mrow><annotation encoding="application/x-tex">\mathsf{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathsf">Z</span></span></span></span></span>）表示，它们的索引机制（例如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mi>j</mi><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">x_{ijk}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="sans-serif">X</mi><msub><mo stretchy="false">]</mo><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>3</mn></mrow></msub></mrow><annotation encoding="application/x-tex">[\mathsf{X}]_{1,2i-1,3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathsf">X</span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>）与矩阵类似。</p></li><li><p>当我们开始处理图像时，张量将变得更加重要，图像以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>维数组形式出现，其中3个轴对应于高度、宽度，以及一个<em>通道</em>（channel）轴，用于堆叠颜色通道（红色、绿色和蓝色）。</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">X &#x3D; tf.reshape(tf.range(24), (2, 3, 4))X</code></pre><pre><code>&lt;tf.Tensor: shape=(2, 3, 4), dtype=int32, numpy=array([[[ 0,  1,  2,  3],        [ 4,  5,  6,  7],        [ 8,  9, 10, 11]],       [[12, 13, 14, 15],        [16, 17, 18, 19],        [20, 21, 22, 23]]], dtype=int32)&gt;</code></pre><h2 id="降维"><a class="markdownIt-Anchor" href="#降维"></a> 降维</h2><ul><li>我们可以对任意张量进行的一个有用的操作是[<strong>计算其元素的和</strong>]。在数学表示法中，我们使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span>符号表示求和。为了表示长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">d</span></span></span></span>的向量中元素的总和，可以记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>d</mi></msubsup><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\sum_{i=1}^dx_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2887179999999998em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。在代码中，我们可以调用计算求和的函数：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; tf.range(4, dtype&#x3D;tf.float32)x, tf.reduce_sum(x)</code></pre><pre><code>(&lt;tf.Tensor: shape=(4,), dtype=float32, numpy=array([0., 1., 2., 3.], dtype=float32)&gt;, &lt;tf.Tensor: shape=(), dtype=float32, numpy=6.0&gt;)</code></pre><ul><li>我们可以(<strong>表示任意形状张量的元素和</strong>)。例如，矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi></mrow><annotation encoding="application/x-tex">\mathbf{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">A</span></span></span></span></span>中元素的和可以记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></msubsup><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\sum_{i=1}^{m} \sum_{j=1}^{n} a_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.24011em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">A.shape, tf.reduce_sum(A)</code></pre><pre><code>(TensorShape([5, 4]), &lt;tf.Tensor: shape=(), dtype=float32, numpy=190.0&gt;)</code></pre><ul><li>默认情况下，调用求和函数会沿所有的轴降低张量的维度，使它变为一个标量。我们还可以[<strong>指定张量沿哪一个轴来通过求和降低维度</strong>]。</li><li>以矩阵为例，为了通过求和所有行的元素来降维（轴0），我们可以在调用函数时指定<code>axis=0</code>。由于输入矩阵沿0轴降维以生成输出向量，因此输入的轴0的维数在输出形状中丢失。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">A_sum_axis0 &#x3D; tf.reduce_sum(A, axis&#x3D;0)A_sum_axis0, A_sum_axis0.shape</code></pre><pre><code>(&lt;tf.Tensor: shape=(4,), dtype=int32, numpy=array([40, 45, 50, 55], dtype=int32)&gt;, TensorShape([4]))</code></pre><ul><li>指定<code>axis=1</code>将通过汇总所有列的元素降维（轴1）。因此，输入的轴1的维数在输出形状中消失。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">A_sum_axis1 &#x3D; tf.reduce_sum(A, axis&#x3D;1)A_sum_axis1, A_sum_axis1.shape</code></pre><pre><code>(&lt;tf.Tensor: shape=(5,), dtype=float32, numpy=array([ 6., 22., 38., 54., 70.], dtype=float32)&gt;, TensorShape([5]))</code></pre><ul><li>沿着行和列对矩阵求和，等价于对矩阵的所有元素进行求和。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">tf.reduce_sum(A, axis&#x3D;[0, 1])  # Same as &#96;tf.reduce_sum(A)&#96;</code></pre><pre><code>&lt;tf.Tensor: shape=(), dtype=int32, numpy=190&gt;</code></pre><ul><li>[<strong>一个与求和相关的量是<em>平均值</em>（mean或average）</strong>]。我们通过将总和除以元素总数来计算平均值。在代码中，我们可以调用函数来计算任意形状张量的平均值。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">tf.reduce_mean(A), tf.reduce_sum(A) &#x2F; tf.size(A).numpy()</code></pre><pre><code>(&lt;tf.Tensor: shape=(), dtype=float32, numpy=9.5&gt;, &lt;tf.Tensor: shape=(), dtype=float32, numpy=9.5&gt;)</code></pre><ul><li>同样，计算平均值的函数也可以沿指定轴降低张量的维度。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">tf.reduce_mean(A, axis&#x3D;0), tf.reduce_sum(A, axis&#x3D;0) &#x2F; A.shape[0]</code></pre><pre><code>(&lt;tf.Tensor: shape=(4,), dtype=float32, numpy=array([ 8.,  9., 10., 11.], dtype=float32)&gt;, &lt;tf.Tensor: shape=(4,), dtype=float32, numpy=array([ 8.,  9., 10., 11.], dtype=float32)&gt;)</code></pre><h3 id="非降维求和"><a class="markdownIt-Anchor" href="#非降维求和"></a> 非降维求和</h3><ul><li>但是，有时在调用函数来[<strong>计算总和或均值时保持轴数不变</strong>]会很有用。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">sum_A &#x3D; tf.reduce_sum(A, axis&#x3D;1, keepdims&#x3D;True)sum_A</code></pre><pre><code>&lt;tf.Tensor: shape=(5, 1), dtype=float32, numpy=array([[ 6.],       [22.],       [38.],       [54.],       [70.]], dtype=float32)&gt;</code></pre><ul><li>例如，由于<code>sum_A</code>在对每行进行求和后仍保持两个轴，我们可以(<strong>通过广播将<code>A</code>除以<code>sum_A</code></strong>)。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">A &#x2F; sum_A</code></pre><pre><code>&lt;tf.Tensor: shape=(5, 4), dtype=float32, numpy=array([[0.        , 0.16666667, 0.33333334, 0.5       ],       [0.18181819, 0.22727273, 0.27272728, 0.3181818 ],       [0.21052632, 0.23684211, 0.2631579 , 0.28947368],       [0.22222222, 0.24074075, 0.25925925, 0.2777778 ],       [0.22857143, 0.24285714, 0.25714287, 0.27142859]], dtype=float32)&gt;</code></pre><ul><li>如果我们想沿[<strong>某个轴计算<code>A</code>元素的累积总和</strong>]，比如<code>axis=0</code>（按行计算），我们可以调用<code>cumsum</code>函数。此函数不会沿任何轴降低输入张量的维度。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">tf.cumsum(A, axis&#x3D;0) # 最后一行是前面的和</code></pre><pre><code>&lt;tf.Tensor: shape=(5, 4), dtype=int32, numpy=array([[ 0,  1,  2,  3],       [ 4,  6,  8, 10],       [12, 15, 18, 21],       [24, 28, 32, 36],       [40, 45, 50, 55]], dtype=int32)&gt;</code></pre><h2 id="点积dot-product"><a class="markdownIt-Anchor" href="#点积dot-product"></a> 点积（Dot Product）</h2><ul><li>到目前为止，我们只执行了按元素操作、求和及平均值。如果这就是我们所能做的，那么线性代数可能就不需要单独一节了。但是，最基本的操作之一是点积。给定两个向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">x</mi><mo separator="true">,</mo><mi mathvariant="bold">y</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mi>d</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{x},\mathbf{y}\in\mathbb{R}^d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathbf">x</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span></span></span></span>，它们的<em>点积</em>（dotproduct）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="bold">x</mi><mi mathvariant="normal">⊤</mi></msup><mi mathvariant="bold">y</mi></mrow><annotation encoding="application/x-tex">\mathbf{x}^\top\mathbf{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.043548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">x</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span></span></span></span>(转置、相乘再累加)是相同位置的按元素乘积的和：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="bold">x</mi><mi mathvariant="normal">⊤</mi></msup><mi mathvariant="bold">y</mi><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>d</mi></msubsup><msub><mi>x</mi><mi>i</mi></msub><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\mathbf{x}^\top \mathbf{y} = \sum_{i=1}^{d} x_i y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.043548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">x</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2887179999999998em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。<ul><li>使用矩阵的<code>tensordot</code>函数进行矩阵乘法。</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">y &#x3D; tf.ones(4, dtype&#x3D;tf.float32)x, y, tf.tensordot(x, y, axes&#x3D;1)</code></pre><pre><code>(&lt;tf.Tensor: shape=(4,), dtype=float32, numpy=array([0., 1., 2., 3.], dtype=float32)&gt;, &lt;tf.Tensor: shape=(4,), dtype=float32, numpy=array([1., 1., 1., 1.], dtype=float32)&gt;, &lt;tf.Tensor: shape=(), dtype=float32, numpy=6.0&gt;)</code></pre><ul><li>注意，(<strong>我们可以通过执行按元素乘法，然后进行求和来表示两个向量的点积</strong>)：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">tf.reduce_sum(x * y)</code></pre><pre><code>&lt;tf.Tensor: shape=(), dtype=float32, numpy=6.0&gt;</code></pre><h2 id="矩阵-向量积"><a class="markdownIt-Anchor" href="#矩阵-向量积"></a> 矩阵-向量积</h2><ul><li>现在我们知道如何计算点积，我们可以开始理解<em>矩阵-向量积</em>（matrix-vector product）。定义矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{A} \in \mathbb{R}^{m \times n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72521em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathbf">A</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>和向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">x</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{x} \in \mathbb{R}^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathbf">x</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>。让我们将矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi></mrow><annotation encoding="application/x-tex">\mathbf{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">A</span></span></span></span></span>用它的行向量表示</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="bold">A</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msubsup><mi mathvariant="bold">a</mi><mn>1</mn><mi mathvariant="normal">⊤</mi></msubsup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msubsup><mi mathvariant="bold">a</mi><mn>2</mn><mi mathvariant="normal">⊤</mi></msubsup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msubsup><mi mathvariant="bold">a</mi><mi>m</mi><mi mathvariant="normal">⊤</mi></msubsup></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">\mathbf{A}=\begin{bmatrix}\mathbf{a}^\top_{1} \\\mathbf{a}^\top_{2} \\\vdots \\\mathbf{a}^\top_m \\\end{bmatrix},</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">A</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:5.487324em;vertical-align:-2.4936619999999996em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.953995em;"><span style="top:-1.3499850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.4999850000000006em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.0959850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.6919850000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.712975em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.953995em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4500349999999997em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9936620000000005em;"><span style="top:-5.832054em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4518920000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.622946000000001em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4518920000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7629460000000003em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5538380000000005em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4936619999999996em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.953995em;"><span style="top:-1.3499850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.4999850000000006em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.0959850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.6919850000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.712975em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.953995em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4500349999999997em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span></span></span></span></span></p><ul><li>其中每个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="bold">a</mi><mi>i</mi><mi mathvariant="normal">⊤</mi></msubsup><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{a}^\top_{i} \in \mathbb{R}^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.107772em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.441336em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>都是行向量，表示矩阵的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>行。[<strong>矩阵向量积<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">x</mi></mrow><annotation encoding="application/x-tex">\mathbf{A}\mathbf{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">A</span></span><span class="mord"><span class="mord mathbf">x</span></span></span></span></span>是一个长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>的列向量，其第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>个元素是点积<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="bold">a</mi><mi>i</mi><mi mathvariant="normal">⊤</mi></msubsup><mi mathvariant="bold">x</mi></mrow><annotation encoding="application/x-tex">\mathbf{a}^\top_i \mathbf{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.107772em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.441336em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">x</span></span></span></span></span></strong>]：</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">x</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msubsup><mi mathvariant="bold">a</mi><mn>1</mn><mi mathvariant="normal">⊤</mi></msubsup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msubsup><mi mathvariant="bold">a</mi><mn>2</mn><mi mathvariant="normal">⊤</mi></msubsup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msubsup><mi mathvariant="bold">a</mi><mi>m</mi><mi mathvariant="normal">⊤</mi></msubsup></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mi mathvariant="bold">x</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi mathvariant="bold">a</mi><mn>1</mn><mi mathvariant="normal">⊤</mi></msubsup><mi mathvariant="bold">x</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi mathvariant="bold">a</mi><mn>2</mn><mi mathvariant="normal">⊤</mi></msubsup><mi mathvariant="bold">x</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi mathvariant="bold">a</mi><mi>m</mi><mi mathvariant="normal">⊤</mi></msubsup><mi mathvariant="bold">x</mi></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathbf{A}\mathbf{x}= \begin{bmatrix}\mathbf{a}^\top_{1} \\\mathbf{a}^\top_{2} \\\vdots \\\mathbf{a}^\top_m \\\end{bmatrix}\mathbf{x}= \begin{bmatrix} \mathbf{a}^\top_{1} \mathbf{x}  \\ \mathbf{a}^\top_{2} \mathbf{x} \\\vdots\\ \mathbf{a}^\top_{m} \mathbf{x}\\\end{bmatrix}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">A</span></span><span class="mord"><span class="mord mathbf">x</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:5.487324em;vertical-align:-2.4936619999999996em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.953995em;"><span style="top:-1.3499850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.4999850000000006em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.0959850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.6919850000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.712975em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.953995em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4500349999999997em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9936620000000005em;"><span style="top:-5.832054em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4518920000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.622946000000001em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4518920000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7629460000000003em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5538380000000005em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4936619999999996em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.953995em;"><span style="top:-1.3499850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.4999850000000006em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.0959850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.6919850000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.712975em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.953995em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4500349999999997em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathbf">x</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:5.487324em;vertical-align:-2.4936619999999996em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.953995em;"><span style="top:-1.3499850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.4999850000000006em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.0959850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.6919850000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.712975em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.953995em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4500349999999997em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9936620000000005em;"><span style="top:-5.832054em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4518920000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">x</span></span></span></span><span style="top:-4.622946000000001em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4518920000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">x</span></span></span></span><span style="top:-2.7629460000000003em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5538380000000005em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4936619999999996em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.953995em;"><span style="top:-1.3499850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.4999850000000006em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.0959850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.6919850000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.712975em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.953995em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4500349999999997em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span></span></span></span></span></p><ul><li>我们可以把一个矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{A} \in \mathbb{R}^{m \times n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72521em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathbf">A</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>乘法看作是一个从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span></span>向量的转换。这些转换证明是非常有用的。例如，我们可以用方阵的乘法来表示旋转。</li><li>在代码中使用张量表示矩阵-向量积，我们使用与点积相同的<code>dot</code>函数。当我们为矩阵<code>A</code>和向量<code>x</code>调用<code>np.dot(A,x)</code>时，会执行矩阵-向量积。注意，<code>A</code>的列维数（沿轴1的长度）必须与<code>x</code>的维数（其长度）相同。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; tf.range(4)A, x</code></pre><pre><code>(&lt;tf.Tensor: shape=(5, 4), dtype=int32, numpy= array([[ 0,  1,  2,  3],        [ 4,  5,  6,  7],        [ 8,  9, 10, 11],        [12, 13, 14, 15],        [16, 17, 18, 19]], dtype=int32)&gt;, &lt;tf.Tensor: shape=(4,), dtype=int32, numpy=array([0, 1, 2, 3], dtype=int32)&gt;)</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">tf.linalg.matvec(A, x) # 计算矩阵A和一维向量x（一维向量是行的方式展示，但实质是列向量）的乘积</code></pre><pre><code>&lt;tf.Tensor: shape=(5,), dtype=int32, numpy=array([ 14,  38,  62,  86, 110], dtype=int32)&gt;</code></pre><h2 id="矩阵-矩阵乘法"><a class="markdownIt-Anchor" href="#矩阵-矩阵乘法"></a> 矩阵-矩阵乘法</h2><ul><li>假设我们有两个矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>n</mi><mo>×</mo><mi>k</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{A} \in \mathbb{R}^{n \times k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72521em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathbf">A</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">B</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>k</mi><mo>×</mo><mi>m</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{B} \in \mathbb{R}^{k \times m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72521em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathbf">B</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span></span>：</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="bold">A</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>11</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>12</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mn>1</mn><mi>k</mi></mrow></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>21</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>22</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mn>2</mn><mi>k</mi></mrow></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋱</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mi>n</mi><mn>1</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mi>n</mi><mn>2</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mi>n</mi><mi>k</mi></mrow></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo separator="true">,</mo><mspace width="1em"/><mi mathvariant="bold">B</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>b</mi><mn>11</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>b</mi><mn>12</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>b</mi><mrow><mn>1</mn><mi>m</mi></mrow></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>b</mi><mn>21</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>b</mi><mn>22</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>b</mi><mrow><mn>2</mn><mi>m</mi></mrow></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋱</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>b</mi><mrow><mi>k</mi><mn>1</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>b</mi><mrow><mi>k</mi><mn>2</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>b</mi><mrow><mi>k</mi><mi>m</mi></mrow></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathbf{A}=\begin{bmatrix} a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1k} \\ a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2k} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nk} \\\end{bmatrix},\quad\mathbf{B}=\begin{bmatrix} b_{11} &amp; b_{12} &amp; \cdots &amp; b_{1m} \\ b_{21} &amp; b_{22} &amp; \cdots &amp; b_{2m} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ b_{k1} &amp; b_{k2} &amp; \cdots &amp; b_{km} \\\end{bmatrix}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">A</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:5.459999999999999em;vertical-align:-2.4799999999999995em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.953995em;"><span style="top:-1.3499850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.4999850000000006em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.0959850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.6919850000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.712975em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.953995em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4500349999999997em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9799999999999995em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7674999999999996em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675000000000006em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4799999999999995em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9799999999999995em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7674999999999996em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675000000000006em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4799999999999995em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9799999999999995em;"><span style="top:-5.64em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span><span style="top:-4.44em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span><span style="top:-2.5799999999999996em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋱</span></span></span><span style="top:-1.3800000000000006em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4799999999999995em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9799999999999995em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7674999999999996em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675000000000006em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4799999999999995em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.953995em;"><span style="top:-1.3499850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.4999850000000006em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.0959850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.6919850000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.712975em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.953995em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4500349999999997em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathbf">B</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:5.459999999999999em;vertical-align:-2.4799999999999995em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.953995em;"><span style="top:-1.3499850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.4999850000000006em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.0959850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.6919850000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.712975em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.953995em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4500349999999997em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9799999999999995em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7674999999999996em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675000000000006em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4799999999999995em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9799999999999995em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7674999999999996em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675000000000006em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4799999999999995em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9799999999999995em;"><span style="top:-5.64em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span><span style="top:-4.44em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span><span style="top:-2.5799999999999996em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋱</span></span></span><span style="top:-1.3800000000000006em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4799999999999995em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9799999999999995em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7674999999999996em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675000000000006em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4799999999999995em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.953995em;"><span style="top:-1.3499850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.4999850000000006em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.0959850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.6919850000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.712975em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.953995em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4500349999999997em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span></span></span></span></span></p><ul><li>用行向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="bold">a</mi><mi>i</mi><mi mathvariant="normal">⊤</mi></msubsup><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{a}^\top_{i} \in \mathbb{R}^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.107772em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.441336em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>表示矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi></mrow><annotation encoding="application/x-tex">\mathbf{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">A</span></span></span></span></span>的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>行，并让列向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">b</mi><mi>j</mi></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{b}_{j} \in \mathbb{R}^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">b</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>作为矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">B</mi></mrow><annotation encoding="application/x-tex">\mathbf{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">B</span></span></span></span></span>的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>列。要生成矩阵积<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">C</mi><mo>=</mo><mi mathvariant="bold">A</mi><mi mathvariant="bold">B</mi></mrow><annotation encoding="application/x-tex">\mathbf{C} = \mathbf{A}\mathbf{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">C</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">A</span></span><span class="mord"><span class="mord mathbf">B</span></span></span></span></span>，最简单的方法是考虑<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi></mrow><annotation encoding="application/x-tex">\mathbf{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">A</span></span></span></span></span>的行向量和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">B</mi></mrow><annotation encoding="application/x-tex">\mathbf{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">B</span></span></span></span></span>的列向量:</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="bold">A</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msubsup><mi mathvariant="bold">a</mi><mn>1</mn><mi mathvariant="normal">⊤</mi></msubsup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msubsup><mi mathvariant="bold">a</mi><mn>2</mn><mi mathvariant="normal">⊤</mi></msubsup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msubsup><mi mathvariant="bold">a</mi><mi>n</mi><mi mathvariant="normal">⊤</mi></msubsup></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo separator="true">,</mo><mspace width="1em"/><mi mathvariant="bold">B</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi mathvariant="bold">b</mi><mn>1</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi mathvariant="bold">b</mi><mn>2</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi mathvariant="bold">b</mi><mi>m</mi></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathbf{A}=\begin{bmatrix}\mathbf{a}^\top_{1} \\\mathbf{a}^\top_{2} \\\vdots \\\mathbf{a}^\top_n \\\end{bmatrix},\quad \mathbf{B}=\begin{bmatrix} \mathbf{b}_{1} &amp; \mathbf{b}_{2} &amp; \cdots &amp; \mathbf{b}_{m} \\\end{bmatrix}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">A</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:5.487324em;vertical-align:-2.4936619999999996em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.953995em;"><span style="top:-1.3499850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.4999850000000006em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.0959850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.6919850000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.712975em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.953995em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4500349999999997em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9936620000000005em;"><span style="top:-5.832054em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4518920000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.622946000000001em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4518920000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7629460000000003em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5538380000000005em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4936619999999996em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.953995em;"><span style="top:-1.3499850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.4999850000000006em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.0959850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.6919850000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.712975em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.953995em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4500349999999997em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathbf">B</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">b</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">b</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner">⋯</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">b</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span></span></span></span></span></p><ul><li>当我们简单地将每个元素<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">c_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>计算为点积<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="bold">a</mi><mi>i</mi><mi mathvariant="normal">⊤</mi></msubsup><msub><mi mathvariant="bold">b</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">\mathbf{a}^\top_i \mathbf{b}_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.135216em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.441336em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathbf">b</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>:</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="bold">C</mi><mo>=</mo><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">B</mi></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msubsup><mi mathvariant="bold">a</mi><mn>1</mn><mi mathvariant="normal">⊤</mi></msubsup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msubsup><mi mathvariant="bold">a</mi><mn>2</mn><mi mathvariant="normal">⊤</mi></msubsup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msubsup><mi mathvariant="bold">a</mi><mi>n</mi><mi mathvariant="normal">⊤</mi></msubsup></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi mathvariant="bold">b</mi><mn>1</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi mathvariant="bold">b</mi><mn>2</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi mathvariant="bold">b</mi><mi>m</mi></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi mathvariant="bold">a</mi><mn>1</mn><mi mathvariant="normal">⊤</mi></msubsup><msub><mi mathvariant="bold">b</mi><mn>1</mn></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi mathvariant="bold">a</mi><mn>1</mn><mi mathvariant="normal">⊤</mi></msubsup><msub><mi mathvariant="bold">b</mi><mn>2</mn></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi mathvariant="bold">a</mi><mn>1</mn><mi mathvariant="normal">⊤</mi></msubsup><msub><mi mathvariant="bold">b</mi><mi>m</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi mathvariant="bold">a</mi><mn>2</mn><mi mathvariant="normal">⊤</mi></msubsup><msub><mi mathvariant="bold">b</mi><mn>1</mn></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi mathvariant="bold">a</mi><mn>2</mn><mi mathvariant="normal">⊤</mi></msubsup><msub><mi mathvariant="bold">b</mi><mn>2</mn></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi mathvariant="bold">a</mi><mn>2</mn><mi mathvariant="normal">⊤</mi></msubsup><msub><mi mathvariant="bold">b</mi><mi>m</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋱</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi mathvariant="bold">a</mi><mi>n</mi><mi mathvariant="normal">⊤</mi></msubsup><msub><mi mathvariant="bold">b</mi><mn>1</mn></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi mathvariant="bold">a</mi><mi>n</mi><mi mathvariant="normal">⊤</mi></msubsup><msub><mi mathvariant="bold">b</mi><mn>2</mn></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msubsup><mi mathvariant="bold">a</mi><mi>n</mi><mi mathvariant="normal">⊤</mi></msubsup><msub><mi mathvariant="bold">b</mi><mi>m</mi></msub></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathbf{C} = \mathbf{AB} = \begin{bmatrix}\mathbf{a}^\top_{1} \\\mathbf{a}^\top_{2} \\\vdots \\\mathbf{a}^\top_n \\\end{bmatrix}\begin{bmatrix} \mathbf{b}_{1} &amp; \mathbf{b}_{2} &amp; \cdots &amp; \mathbf{b}_{m} \\\end{bmatrix}= \begin{bmatrix}\mathbf{a}^\top_{1} \mathbf{b}_1 &amp; \mathbf{a}^\top_{1}\mathbf{b}_2&amp; \cdots &amp; \mathbf{a}^\top_{1} \mathbf{b}_m \\ \mathbf{a}^\top_{2}\mathbf{b}_1 &amp; \mathbf{a}^\top_{2} \mathbf{b}_2 &amp; \cdots &amp; \mathbf{a}^\top_{2} \mathbf{b}_m \\ \vdots &amp; \vdots &amp; \ddots &amp;\vdots\\\mathbf{a}^\top_{n} \mathbf{b}_1 &amp; \mathbf{a}^\top_{n}\mathbf{b}_2&amp; \cdots&amp; \mathbf{a}^\top_{n} \mathbf{b}_m\end{bmatrix}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">C</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">A</span><span class="mord mathbf">B</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:5.487324em;vertical-align:-2.4936619999999996em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.953995em;"><span style="top:-1.3499850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.4999850000000006em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.0959850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.6919850000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.712975em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.953995em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4500349999999997em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9936620000000005em;"><span style="top:-5.832054em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4518920000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.622946000000001em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4518920000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7629460000000003em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5538380000000005em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4936619999999996em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.953995em;"><span style="top:-1.3499850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.4999850000000006em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.0959850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.6919850000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.712975em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.953995em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4500349999999997em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">b</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">b</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner">⋯</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">b</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:5.487324em;vertical-align:-2.4936619999999996em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.953995em;"><span style="top:-1.3499850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.4999850000000006em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.0959850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.6919850000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.712975em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.953995em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4500349999999997em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9936620000000005em;"><span style="top:-5.832054em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4518920000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathbf">b</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.622946000000001em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4518920000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathbf">b</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7629460000000003em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5538380000000005em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathbf">b</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4936619999999996em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9936620000000005em;"><span style="top:-5.832054em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4518920000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathbf">b</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.622946000000001em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4518920000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathbf">b</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7629460000000003em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5538380000000005em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathbf">b</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4936619999999996em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9936620000000005em;"><span style="top:-5.644554em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span><span style="top:-4.435446000000001em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span><span style="top:-2.5754460000000003em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋱</span></span></span><span style="top:-1.3663380000000005em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4936619999999996em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9936620000000005em;"><span style="top:-5.832054em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4518920000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathbf">b</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.622946000000001em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4518920000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathbf">b</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7629460000000003em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5538380000000005em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathbf">a</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathbf">b</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4936619999999996em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.953995em;"><span style="top:-1.3499850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.4999850000000006em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.0959850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.6919850000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.712975em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.953995em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4500349999999997em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span></span></span></span></span></p><ul><li>[<strong>我们可以将矩阵-矩阵乘法<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">B</mi></mrow><annotation encoding="application/x-tex">\mathbf{AB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">A</span><span class="mord mathbf">B</span></span></span></span></span>看作是简单地执行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>次矩阵-向量积，并将结果拼接在一起，形成一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>矩阵</strong>]。在下面的代码中，我们在<code>A</code>和<code>B</code>上执行矩阵乘法。这里的<code>A</code>是一个5行4列的矩阵，<code>B</code>是一个4行3列的矩阵。相乘后，我们得到了一个5行3列的矩阵。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">B &#x3D; tf.ones((4, 3), dtype&#x3D;tf.int32)C &#x3D; tf.matmul(A, B)A, B, C</code></pre><pre><code>(&lt;tf.Tensor: shape=(5, 4), dtype=int32, numpy= array([[ 0,  1,  2,  3],        [ 4,  5,  6,  7],        [ 8,  9, 10, 11],        [12, 13, 14, 15],        [16, 17, 18, 19]], dtype=int32)&gt;, &lt;tf.Tensor: shape=(4, 3), dtype=int32, numpy= array([[1, 1, 1],        [1, 1, 1],        [1, 1, 1],        [1, 1, 1]], dtype=int32)&gt;, &lt;tf.Tensor: shape=(5, 3), dtype=int32, numpy= array([[ 6,  6,  6],        [22, 22, 22],        [38, 38, 38],        [54, 54, 54],        [70, 70, 70]], dtype=int32)&gt;)</code></pre><ul><li>矩阵-矩阵乘法可以简单地称为<strong>矩阵乘法</strong>，不应与元素分别对应相乘混淆。</li></ul><h2 id="范数"><a class="markdownIt-Anchor" href="#范数"></a> 范数</h2><ul><li>在线性代数中，向量范数是将向量映射到标量的函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>。向量范数要满足一些属性。</li><li>给定任意向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">x</mi></mrow><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">x</span></span></span></span></span>，第一个性质说，如果我们按常数因子<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>缩放向量的所有元素，其范数也会按相同常数因子的<em>绝对值</em>缩放：</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>α</mi><mi mathvariant="bold">x</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">∣</mi><mi>α</mi><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">f(\alpha \mathbf{x}) = |\alpha| f(\mathbf{x}).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord"><span class="mord mathbf">x</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathbf">x</span></span><span class="mclose">)</span><span class="mord">.</span></span></span></span></span></p><ul><li>第二个性质是我们熟悉的三角不等式:</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo>+</mo><mi mathvariant="bold">y</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>f</mi><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi mathvariant="bold">y</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">f(\mathbf{x} + \mathbf{y}) \leq f(\mathbf{x}) + f(\mathbf{y}).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathbf">x</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathbf">x</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span><span class="mclose">)</span><span class="mord">.</span></span></span></span></span></p><ul><li>第三个性质简单地说范数必须是非负的:</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo stretchy="false">)</mo><mo>≥</mo><mn>0.</mn></mrow><annotation encoding="application/x-tex">f(\mathbf{x}) \geq 0.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathbf">x</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span></span></span></span></span></p><ul><li>最后一个性质要求范数最小为0，当且仅当向量全由0组成。</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>i</mi><mo separator="true">,</mo><mo stretchy="false">[</mo><mi mathvariant="bold">x</mi><msub><mo stretchy="false">]</mo><mi>i</mi></msub><mo>=</mo><mn>0</mn><mo>⇔</mo><mi>f</mi><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0.</mn></mrow><annotation encoding="application/x-tex">\forall i, [\mathbf{x}]_i = 0 \Leftrightarrow f(\mathbf{x})=0.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∀</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathbf">x</span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathbf">x</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span></span></span></span></span></p><ul><li><p><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">L_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>范数</strong>：欧几里得距离（两点之间的距离）是一个范数：具体而言，它是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">L_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>范数。假设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>维向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">x</mi></mrow><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">x</span></span></span></span></span>中的元素是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_1,\ldots,x_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其[<strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">L_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><em>范数</em>是向量元素平方和的平方根：</strong>]</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∥</mi><mi mathvariant="bold">x</mi><msub><mi mathvariant="normal">∥</mi><mn>2</mn></msub><mo>=</mo><msqrt><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msubsup><mi>x</mi><mi>i</mi><mn>2</mn></msubsup></mrow></msqrt><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">\|\mathbf{x}\|_2 = \sqrt{\sum_{i=1}^n x_i^2},</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord"><span class="mord mathbf">x</span></span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.1568160000000005em;vertical-align:-1.277669em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8791470000000006em;"><span class="svg-align" style="top:-5.116816em;"><span class="pstrut" style="height:5.116816em;"></span><span class="mord" style="padding-left:1.056em;"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7959080000000001em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.0448000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.27686399999999994em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.8391470000000005em;"><span class="pstrut" style="height:5.116816em;"></span><span class="hide-tail" style="min-width:0.742em;height:3.196816em;"><svg width='400em' height='3.196816em' viewBox='0 0 400000 3196' preserveAspectRatio='xMinYMin slice'><path d='M702 80H40000040H742v3062l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667219 661 l218 661zM702 80H400000v40H742z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mpunct">,</span></span></span></span></span></p></li><li><p>其中，在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">L_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>范数中常常省略下标<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>，也就是说，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∥</mi><mi mathvariant="bold">x</mi><mi mathvariant="normal">∥</mi></mrow><annotation encoding="application/x-tex">\|\mathbf{x}\|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord"><span class="mord mathbf">x</span></span><span class="mord">∥</span></span></span></span>等同于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∥</mi><mi mathvariant="bold">x</mi><msub><mi mathvariant="normal">∥</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\|\mathbf{x}\|_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord"><span class="mord mathbf">x</span></span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。在代码中，我们可以按如下方式计算向量的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">L_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>范数。</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">u &#x3D; tf.constant([3.0, -4.0])tf.norm(u) # 勾股定理3， 4， 5</code></pre><pre><code>&lt;tf.Tensor: shape=(), dtype=float32, numpy=5.0&gt;</code></pre><ul><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">L_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>范数：在深度学习中，我们更经常地使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">L_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>范数的平方。你还会经常遇到[<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">L_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>范数，它表示为向量元素的绝对值之和.与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">L_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>范数相比，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">L_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>范数受异常值的影响较小.</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∥</mi><mi mathvariant="bold">x</mi><msub><mi mathvariant="normal">∥</mi><mn>1</mn></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><mo fence="true">∣</mo><msub><mi>x</mi><mi>i</mi></msub><mo fence="true">∣</mo></mrow><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\|\mathbf{x}\|_1 = \sum_{i=1}^n \left|x_i \right|.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord"><span class="mord mathbf">x</span></span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span></span></span></span></span></p></li><li><p>为了计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">L_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>范数，我们将绝对值函数和按元素求和组合起来。</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; tf.abs(u)b &#x3D; tf.reduce_sum(a) # 按0轴求和b</code></pre><pre><code>&lt;tf.Tensor: shape=(), dtype=float32, numpy=7.0&gt;</code></pre><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">L_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>范数: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">L_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>范数和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">L_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>范数都是更一般的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">L_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>范数的特例：</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∥</mi><mi mathvariant="bold">x</mi><msub><mi mathvariant="normal">∥</mi><mi>p</mi></msub><mo>=</mo><msup><mrow><mo fence="true">(</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msup><mrow><mo fence="true">∣</mo><msub><mi>x</mi><mi>i</mi></msub><mo fence="true">∣</mo></mrow><mi>p</mi></msup><mo fence="true">)</mo></mrow><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mi>p</mi></mrow></msup><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\|\mathbf{x}\|_p = \left(\sum_{i=1}^n \left|x_i \right|^p \right)^{1/p}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord">∥</span><span class="mord"><span class="mord mathbf">x</span></span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.3055689999999998em;vertical-align:-1.277669em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">(</span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-3.2029000000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size4">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:2.0279em;"><span style="top:-4.2029000000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">/</span><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span></span></span></span></span></p><ul><li><p><strong>弗罗贝尼乌斯范数</strong>: 类似于向量的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">L_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>范数，[<strong>矩阵</strong>]<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">X</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{X} \in \mathbb{R}^{m \times n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72521em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathbf">X</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>(<strong>的<em>弗罗贝尼乌斯范数</em>（Frobenius norm）是矩阵元素平方和的平方根：</strong>)</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∥</mi><mi mathvariant="bold">X</mi><msub><mi mathvariant="normal">∥</mi><mi>F</mi></msub><mo>=</mo><msqrt><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msubsup><mi>x</mi><mrow><mi>i</mi><mi>j</mi></mrow><mn>2</mn></msubsup></mrow></msqrt><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\|\mathbf{X}\|_F = \sqrt{\sum_{i=1}^m \sum_{j=1}^n x_{ij}^2}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord"><span class="mord mathbf">X</span></span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.2929240000000006em;vertical-align:-1.4137769999999998em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8791470000000008em;"><span class="svg-align" style="top:-5.252924em;"><span class="pstrut" style="height:5.252924em;"></span><span class="mord" style="padding-left:1.056em;"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000007em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.795908em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.0448000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4129719999999999em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.8391470000000005em;"><span class="pstrut" style="height:5.252924em;"></span><span class="hide-tail" style="min-width:0.742em;height:3.3329240000000007em;"><svg width='400em' height='3.3329240000000007em' viewBox='0 0 400000 3332' preserveAspectRatio='xMinYMin slice'><path d='M702 80H40000040H742v3198l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667219 661 l218 661zM702 80H400000v40H742z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mord">.</span></span></span></span></span></p></li><li><p>弗罗贝尼乌斯范数满足向量范数的所有性质，它就像是矩阵形向量的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">L_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>范数。调用<code>norm</code>函数将计算矩阵的弗罗贝尼乌斯范数。</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">tf.norm(tf.ones((4, 9))) # 每个元素都为1，有36个1，36个1的平方为36再开方为6</code></pre><pre><code>&lt;tf.Tensor: shape=(), dtype=float32, numpy=6.0&gt;</code></pre><h1 id="微分"><a class="markdownIt-Anchor" href="#微分"></a> 微分</h1><h2 id="导数和微分"><a class="markdownIt-Anchor" href="#导数和微分"></a> 导数和微分</h2><ul><li>导数概念：假设我们有一个函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup><mo>→</mo><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">f: \mathbb{R}^n \rightarrow \mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span>，其输入和输出都是标量。(<strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>的<em>导数</em>被定义为</strong>)</li></ul><p>(<strong>$$f’(x) = \lim_{h \rightarrow 0} \frac{f(x+h) - f(x)}{h},$$</strong>)</p><ul><li><p>如果这个极限存在。如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f&#x27;(a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span>存在，则称<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span>处是<em>可微</em>（differentiable）的。如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>在一个区间内的每个数上都是可微的，则此函数在此区间中是可微的。我们可以将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f&#x27;(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>解释为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>相对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>的<em>瞬时</em>（instantaneous）变化率。所谓的瞬时变化率是基于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>中的变化<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span>，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span>接近<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</p></li><li><p>为了更好地解释导数，让我们用一个例子来做实验。(<strong>定义<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>3</mn><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mn>4</mn><mi>x</mi></mrow><annotation encoding="application/x-tex">u=f(x)=3x^2-4x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathnormal">x</span></span></span></span>.</strong>)</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">%matplotlib inlineimport numpy as npfrom IPython import displayimport tensorflow as tffrom matplotlib import pyplot as plt# 定义基础函数def f(x):    return 3 * x ** 2 - 4 * x</code></pre><ul><li>[<strong>通过令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>并让<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span>接近<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，</strong>], (<strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>h</mi><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mi>h</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{f(x+h)-f(x)}{h}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">h</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>的数值结果接近<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></strong>，函数在1处的导数值)。虽然这个实验不是一个数学证明，但我们稍后会看到，当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时，导数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>u</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">u&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 定义计算变化率的函数def numerical_lim(f, x, h):    return (f(x + h) - f(x)) &#x2F; hh &#x3D; 0.1for i in range(5):    print(f&#39;h&#x3D;&#123;h:.5f&#125;, numerical limit&#x3D;&#123;numerical_lim(f, 1, h):.5f&#125;&#39;)    h *&#x3D; 0.1</code></pre><pre><code>h=0.10000, numerical limit=2.30000h=0.01000, numerical limit=2.03000h=0.00100, numerical limit=2.00300h=0.00010, numerical limit=2.00030h=0.00001, numerical limit=2.00003</code></pre><ul><li><p>计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>u</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>3</mn><mfrac><mi>d</mi><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mn>4</mn><mfrac><mi>d</mi><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mi>x</mi><mo>=</mo><mn>6</mn><mi>x</mi><mo>−</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">u&#x27;=f&#x27;(x)=3\frac{d}{dx}x^2-4\frac{d}{dx}x=6x-4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord">3</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord">4</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>。因此，通过令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，我们有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>u</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">u&#x27;=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>：这一点得到了我们在本节前面的实验的支持，在这个实验中，数值结果接近<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>。当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时，此导数也是曲线<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">u=f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>切线的斜率。</p></li><li><p>[<strong>为了对导数的这种解释进行可视化，</strong>]我们将使用<code>matplotlib</code>，这是一个Python中流行的绘图库。要配置<code>matplotlib</code>生成图形的属性，我们需要(<strong>定义几个函数</strong>)。</p><ul><li>在下面，<code>use_svg_display</code>函数指定<code>matplotlib</code>软件包输出svg图表以获得更清晰的图像。</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">def use_svg_display():      &quot;&quot;&quot;使用svg格式在Jupyter中显示绘图。&quot;&quot;&quot;    display.set_matplotlib_formats(&#39;svg&#39;)</code></pre><ul><li>我们定义<code>set_figsize</code>函数来设置图表大小。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">def set_figsize(figsize&#x3D;(3.5, 2.5)):      &quot;&quot;&quot;设置matplotlib的图表大小。&quot;&quot;&quot;    use_svg_display()    plt.rcParams[&#39;figure.figsize&#39;] &#x3D; figsize</code></pre><ul><li>下面的<code>set_axes</code>函数用于设置由<code>matplotlib</code>生成图表的轴的属性。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">def set_axes(axes, xlabel, ylabel, xlim, ylim, xscale, yscale, legend):    &quot;&quot;&quot;设置matplotlib的轴。&quot;&quot;&quot;    axes.set_xlabel(xlabel)    axes.set_ylabel(ylabel)    axes.set_xscale(xscale)    axes.set_yscale(yscale)    axes.set_xlim(xlim)    axes.set_ylim(ylim)    if legend:        axes.legend(legend)    axes.grid()</code></pre><ul><li>通过这三个用于图形配置的函数，我们定义了<code>plot</code>函数来简洁地绘制多条曲线。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">def plot(X, Y&#x3D;None, xlabel&#x3D;None, ylabel&#x3D;None, legend&#x3D;None, xlim&#x3D;None,         ylim&#x3D;None, xscale&#x3D;&#39;linear&#39;, yscale&#x3D;&#39;linear&#39;,         fmts&#x3D;(&#39;-&#39;, &#39;m--&#39;, &#39;g-.&#39;, &#39;r:&#39;), figsize&#x3D;(3.5, 2.5), axes&#x3D;None):    &quot;&quot;&quot;绘制数据点。&quot;&quot;&quot;    if legend is None:        legend &#x3D; []    set_figsize(figsize)    axes &#x3D; axes if axes else plt.gca()    # 如果 &#96;X&#96; 有一个轴，输出True    def has_one_axis(X):        return (hasattr(X, &quot;ndim&quot;) and X.ndim &#x3D;&#x3D; 1 or isinstance(X, list)                and not hasattr(X[0], &quot;__len__&quot;))    if has_one_axis(X):        X &#x3D; [X]    if Y is None:        X, Y &#x3D; [[]] * len(X), X    elif has_one_axis(Y):        Y &#x3D; [Y]    if len(X) !&#x3D; len(Y):        X &#x3D; X * len(Y)    axes.cla()    for x, y, fmt in zip(X, Y, fmts):        if len(x):            axes.plot(x, y, fmt)        else:            axes.plot(y, fmt)    set_axes(axes, xlabel, ylabel, xlim, ylim, xscale, yscale, legend)</code></pre><ul><li>现在我们可以[<strong>绘制函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">u=f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>及其在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>处的切线<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mn>2</mn><mi>x</mi><mo>−</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">y=2x-3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span></strong>]，其中系数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>是切线的斜率。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; np.arange(0, 3, 0.1)plot(x, [f(x), 2 * x - 3], &#39;x&#39;, &#39;f(x)&#39;, legend&#x3D;[&#39;f(x)&#39;, &#39;Tangent line (x&#x3D;1)&#39;])</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/P6CkVt.png" alt="P6CkVt" /></p><h2 id="偏导数"><a class="markdownIt-Anchor" href="#偏导数"></a> 偏导数</h2><p>在深度学习中，函数通常依赖于许多变量。因此，我们需要将微分的思想推广到这些<em>多元函数</em>（multivariate function）上。</p><p>设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y = f(x_1, x_2, \ldots, x_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>是一个具有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>个变量的函数。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>关于第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>个参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的<em>偏导数</em>（partial derivative）为：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mi>x</mi><mi>i</mi></msub></mrow></mfrac><mo>=</mo><munder><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>h</mi><mo>→</mo><mn>0</mn></mrow></munder><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>x</mi><mi>i</mi></msub><mo>+</mo><mi>h</mi><mo separator="true">,</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><mi>h</mi></mfrac><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\frac{\partial y}{\partial x_i} = \lim_{h \rightarrow 0} \frac{f(x_1, \ldots, x_{i-1}, x_i+h, x_{i+1}, \ldots, x_n) - f(x_1, \ldots, x_i, \ldots, x_n)}{h}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.20744em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.179108em;vertical-align:-0.7521079999999999em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-2.347892em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mrel mtight">→</span><span class="mord mtight">0</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">lim</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7521079999999999em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">h</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">.</span></span></span></span></span></p><p>为了计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mi>x</mi><mi>i</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\partial y}{\partial x_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.377316em;vertical-align:-0.44509999999999994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，我们可以简单地将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_1, \ldots, x_{i-1}, x_{i+1}, \ldots, x_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>看作常数，并计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>关于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的导数。对于偏导数的表示，以下是等价的：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mi>x</mi><mi>i</mi></msub></mrow></mfrac><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>f</mi></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mi>x</mi><mi>i</mi></msub></mrow></mfrac><mo>=</mo><msub><mi>f</mi><msub><mi>x</mi><mi>i</mi></msub></msub><mo>=</mo><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><msub><mi>D</mi><mi>i</mi></msub><mi>f</mi><mo>=</mo><msub><mi>D</mi><msub><mi>x</mi><mi>i</mi></msub></msub><mi>f</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\frac{\partial y}{\partial x_i} = \frac{\partial f}{\partial x_i} = f_{x_i} = f_i = D_i f = D_{x_i} f.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.20744em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.20744em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9445399999999999em;vertical-align:-0.2501em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139199999999997em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9445399999999999em;vertical-align:-0.2501em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139199999999997em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord">.</span></span></span></span></span></p><h2 id="梯度"><a class="markdownIt-Anchor" href="#梯度"></a> 梯度</h2><p>我们可以连结<strong>一个多元函数对其所有变量的偏导数</strong>，以得到该函数的<em>梯度</em>（gradient）向量。设函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi mathvariant="double-struck">R</mi><mi>n</mi></msup><mo>→</mo><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">f:\mathbb{R}^n\rightarrow\mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span>的输入是一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>维向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">x</mi><mo>=</mo><mo stretchy="false">[</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><msup><mo stretchy="false">]</mo><mi mathvariant="normal">⊤</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{x}=[x_1,x_2,\ldots,x_n]^\top</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">x</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span></span></span></span>，并且输出是一个标量。<br />函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(\mathbf{x})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathbf">x</span></span><span class="mclose">)</span></span></span></span>相对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">x</mi></mrow><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">x</span></span></span></span></span>的梯度是一个包含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>个偏导数的向量:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="normal">∇</mi><mi mathvariant="bold">x</mi></msub><mi>f</mi><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo stretchy="false">)</mo><mo>=</mo><mo fence="false">[</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>f</mi><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo stretchy="false">)</mo></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mi>x</mi><mn>1</mn></msub></mrow></mfrac><mo separator="true">,</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>f</mi><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo stretchy="false">)</mo></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mi>x</mi><mn>2</mn></msub></mrow></mfrac><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>f</mi><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo stretchy="false">)</mo></mrow><mrow><mi mathvariant="normal">∂</mi><msub><mi>x</mi><mi>n</mi></msub></mrow></mfrac><msup><mo fence="false">]</mo><mi mathvariant="normal">⊤</mi></msup><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">\nabla_{\mathbf{x}} f(\mathbf{x}) = \bigg[\frac{\partial f(\mathbf{x})}{\partial x_1}, \frac{\partial f(\mathbf{x})}{\partial x_2}, \ldots, \frac{\partial f(\mathbf{x})}{\partial x_n}\bigg]^\top,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">∇</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.161108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathbf mtight">x</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathbf">x</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.639038em;vertical-align:-0.95003em;"></span><span class="mord"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathbf">x</span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathbf">x</span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathbf">x</span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord"><span class="delimsizing size3">]</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.689008em;"><span style="top:-3.9029000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mpunct">,</span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">∇</mi><mi mathvariant="bold">x</mi></msub><mi>f</mi><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\nabla_{\mathbf{x}} f(\mathbf{x})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">∇</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.161108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathbf mtight">x</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathbf">x</span></span><span class="mclose">)</span></span></span></span>通常在没有歧义时被<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∇</mi><mi>f</mi><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\nabla f(\mathbf{x})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∇</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathbf">x</span></span><span class="mclose">)</span></span></span></span>取代。</p><p>同样，对于任何矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">X</mi></mrow><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">X</span></span></span></span></span>，我们都有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">∇</mi><mi mathvariant="bold">X</mi></msub><mi mathvariant="normal">∥</mi><mi mathvariant="bold">X</mi><msubsup><mi mathvariant="normal">∥</mi><mi>F</mi><mn>2</mn></msubsup><mo>=</mo><mn>2</mn><mi mathvariant="bold">X</mi></mrow><annotation encoding="application/x-tex">\nabla_{\mathbf{X}} \|\mathbf{X} \|_F^2 = 2\mathbf{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.089439em;vertical-align:-0.275331em;"></span><span class="mord"><span class="mord">∇</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33027699999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathbf mtight">X</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∥</span><span class="mord"><span class="mord mathbf">X</span></span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.424669em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.275331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathbf">X</span></span></span></span></span>。正如我们之后将看到的，梯度对于设计深度学习中的优化算法有很大用处。</p><h2 id="链式法则"><a class="markdownIt-Anchor" href="#链式法则"></a> 链式法则</h2><p>然而，上面方法可能很难找到梯度。<br />这是因为在深度学习中，多元函数通常是<em>复合</em>（composite）的，所以我们可能没法应用上述任何规则来微分这些函数。<br />幸运的是，链式法则使我们能够微分复合函数。</p><p>让我们先考虑单变量函数。假设函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y=f(u)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">u=g(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>都是可微的，根据链式法则：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>d</mi><mi>u</mi></mrow></mfrac><mfrac><mrow><mi>d</mi><mi>u</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\frac{dy}{dx} = \frac{dy}{du} \frac{du}{dx}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0574399999999997em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">u</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">.</span></span></span></span></span></p><p>现在让我们把注意力转向一个更一般的场景，即函数具有任意数量的变量的情况。假设可微分函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>有变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>u</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>u</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">u_1, u_2, \ldots, u_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其中每个可微分函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">u_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>都有变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_1, x_2, \ldots, x_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。注意，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mtext>，</mtext><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_1, x_2， \ldots, x_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的函数。对于任意<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">i = 1, 2, \ldots, n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span></span></span></span>，链式法则给出：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>d</mi><msub><mi>x</mi><mi>i</mi></msub></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>d</mi><msub><mi>u</mi><mn>1</mn></msub></mrow></mfrac><mfrac><mrow><mi>d</mi><msub><mi>u</mi><mn>1</mn></msub></mrow><mrow><mi>d</mi><msub><mi>x</mi><mi>i</mi></msub></mrow></mfrac><mo>+</mo><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>d</mi><msub><mi>u</mi><mn>2</mn></msub></mrow></mfrac><mfrac><mrow><mi>d</mi><msub><mi>u</mi><mn>2</mn></msub></mrow><mrow><mi>d</mi><msub><mi>x</mi><mi>i</mi></msub></mrow></mfrac><mo>+</mo><mo>⋯</mo><mo>+</mo><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>d</mi><msub><mi>u</mi><mi>m</mi></msub></mrow></mfrac><mfrac><mrow><mi>d</mi><msub><mi>u</mi><mi>m</mi></msub></mrow><mrow><mi>d</mi><msub><mi>x</mi><mi>i</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{dy}{dx_i} = \frac{dy}{du_1} \frac{du_1}{dx_i} + \frac{dy}{du_2} \frac{du_2}{dx_i} + \cdots + \frac{dy}{du_m} \frac{du_m}{dx_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.20744em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.20744em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.20744em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.20744em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h1 id="自动求导"><a class="markdownIt-Anchor" href="#自动求导"></a> 自动求导</h1><ul><li>深度学习框架通过自动计算导数，即<em>自动求导</em>（automatic differentiation），来加快这项工作。实际中，根据我们设计的模型，系统会构建一个<em>计算图</em>（computational graph），来跟踪计算是哪些数据通过哪些操作组合起来产生输出。自动求导使系统能够随后反向传播梯度。这里，<em>反向传播</em>（backpropagate）只是意味着跟踪整个计算图，填充关于每个参数的偏导数。</li></ul><h2 id="标量变量的反向传播"><a class="markdownIt-Anchor" href="#标量变量的反向传播"></a> 标量变量的反向传播</h2><p>作为一个演示例子，(<strong>假设我们想对函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mn>2</mn><msup><mi mathvariant="bold">x</mi><mi mathvariant="normal">⊤</mi></msup><mi mathvariant="bold">x</mi></mrow><annotation encoding="application/x-tex">y=2\mathbf{x}^{\top}\mathbf{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord"><span class="mord"><span class="mord mathbf">x</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">x</span></span></span></span></span>关于列向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">x</mi></mrow><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">x</span></span></span></span></span>求导</strong>)。首先，我们创建变量<code>x</code>并为其分配一个初始值。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import tensorflow as tfx &#x3D; tf.range(4, dtype&#x3D;tf.float32)x</code></pre><pre><code>&lt;tf.Tensor: shape=(4,), dtype=float32, numpy=array([0., 1., 2., 3.], dtype=float32)&gt;</code></pre><p>[<strong>在我们计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>关于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">x</mi></mrow><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">x</span></span></span></span></span>的梯度之前，我们需要一个地方来存储梯度。</strong>]<br />重要的是，我们不会在每次对一个参数求导时都分配新的内存。因为我们经常会成千上万次地更新相同的参数，每次都分配新的内存可能很快就会将内存耗尽。注意，标量函数关于向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">x</mi></mrow><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">x</span></span></span></span></span>的梯度是向量，并且与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">x</mi></mrow><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">x</span></span></span></span></span>具有相同的形状。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; tf.Variable(x) # Variable是持久存储的特殊张量</code></pre><p>(<strong>现在让我们计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>。</strong>)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 把所有计算记录在磁带上(实质是一个上下文管理器，自动监测Variable变量)with tf.GradientTape() as t:    y &#x3D; 2 * tf.tensordot(x, x, axes&#x3D;1) # 计算x的内积，实质就是X的转置和X相乘，得出yy</code></pre><pre><code>&lt;tf.Tensor: shape=(), dtype=float32, numpy=28.0&gt;</code></pre><p><code>x</code>是一个长度为4的向量，计算<code>x</code>和<code>x</code>的内积，得到了我们赋值给<code>y</code>的标量输出。接下来，我们可以[<strong>通过调用反向传播函数来自动计算<code>y</code>关于<code>x</code>每个分量的梯度</strong>]，并打印这些梯度。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x_grad &#x3D; t.gradient(y, x) # 方向传播函数求y关于x每个分量的梯度x_grad</code></pre><pre><code>&lt;tf.Tensor: shape=(4,), dtype=float32, numpy=array([ 0.,  4.,  8., 12.], dtype=float32)&gt;</code></pre><p>函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mn>2</mn><msup><mi mathvariant="bold">x</mi><mi mathvariant="normal">⊤</mi></msup><mi mathvariant="bold">x</mi></mrow><annotation encoding="application/x-tex">y=2\mathbf{x}^{\top}\mathbf{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord"><span class="mord"><span class="mord mathbf">x</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">x</span></span></span></span></span>关于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">x</mi></mrow><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">x</span></span></span></span></span>的梯度应为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi mathvariant="bold">x</mi></mrow><annotation encoding="application/x-tex">4\mathbf{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord"><span class="mord mathbf">x</span></span></span></span></span>。让我们快速验证我们想要的梯度是否正确计算。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x_grad &#x3D;&#x3D; 4 * x</code></pre><pre><code>&lt;tf.Tensor: shape=(4,), dtype=bool, numpy=array([ True,  True,  True,  True])&gt;</code></pre><p>[<strong>现在让我们计算<code>x</code>的另一个函数。</strong>]</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">with tf.GradientTape() as t:    y &#x3D; tf.reduce_sum(x) #将所有元素求和得到结果赋值给yt.gradient(y, x)  # 因为有上下文管理器，所以上次计算的梯度被保存，重新调用会使原来的梯度被新计算的梯度覆盖</code></pre><pre><code>&lt;tf.Tensor: shape=(4,), dtype=float32, numpy=array([1., 1., 1., 1.], dtype=float32)&gt;</code></pre><h2 id="非标量变量的反向传播"><a class="markdownIt-Anchor" href="#非标量变量的反向传播"></a> 非标量变量的反向传播</h2><p>当<code>y</code>不是标量时，向量<code>y</code>关于向量<code>x</code>的导数的最自然解释是一个矩阵。对于高阶和高维的<code>y</code>和<code>x</code>，求导的结果可以是一个高阶张量。</p><p>然而，虽然这些更奇特的对象确实出现在高级机器学习中（包括[<strong>深度学习中</strong>]），但当我们调用向量的反向计算时，我们通常会试图计算一批训练样本中每个组成部分的损失函数的导数。这里(<strong>，我们的目的不是计算微分矩阵，而是批量中每个样本单独计算的偏导数之和。</strong>)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">with tf.GradientTape() as t:    y &#x3D; x * xx, y# y是一个向量</code></pre><pre><code>(&lt;tf.Variable 'Variable:0' shape=(4,) dtype=float32, numpy=array([0., 1., 2., 3.], dtype=float32)&gt;, &lt;tf.Tensor: shape=(4,), dtype=float32, numpy=array([0., 1., 4., 9.], dtype=float32)&gt;)</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 反向传播，计算梯度#t.gradient(y, x)  # 等价于 &#96;y &#x3D; tf.reduce_sum(x * x)&#96;y &#x3D; tf.reduce_sum(x * x)y</code></pre><pre><code>&lt;tf.Tensor: shape=(), dtype=float32, numpy=14.0&gt;</code></pre><h2 id="分离计算"><a class="markdownIt-Anchor" href="#分离计算"></a> 分离计算</h2><p>有时，我们希望[<strong>将某些计算移动到记录的计算图之外</strong>]。<br />例如，假设<code>y</code>是作为<code>x</code>的函数计算的，而<code>z</code>则是作为<code>y</code>和<code>x</code>的函数计算的。<br />现在，想象一下，我们想计算<code>z</code>关于<code>x</code>的梯度，但由于某种原因，我们希望将<code>y</code>视为一个常数，并且只考虑到<code>x</code>在<code>y</code>被计算后发挥的作用。</p><p>在这里，我们可以分离<code>y</code>来返回一个新变量<code>u</code>，该变量与<code>y</code>具有相同的值，但丢弃计算图中如何计算<code>y</code>的任何信息。换句话说，梯度不会向后流经<code>u</code>到<code>x</code>。因此，下面的反向传播函数计算<code>z=u*x</code>关于<code>x</code>的偏导数，同时将<code>u</code>作为常数处理，而不是<code>z=x*x*x</code>关于<code>x</code>的偏导数。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 设置 &#96;persistent&#x3D;True&#96; 来运行 &#96;t.gradient&#96;多次with tf.GradientTape(persistent&#x3D;True) as t:    y &#x3D; x * x    u &#x3D; tf.stop_gradient(y)    z &#x3D; u * xx_grad &#x3D; t.gradient(z, x)x_grad &#x3D;&#x3D; u</code></pre><pre><code>&lt;tf.Tensor: shape=(4,), dtype=bool, numpy=array([ True,  True,  True,  True])&gt;</code></pre><p>由于记录了<code>y</code>的计算结果，我们可以随后在<code>y</code>上调用反向传播，得到<code>y=x*x</code>关于的<code>x</code>的导数，这里是<code>2*x</code>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">t.gradient(y, x) &#x3D;&#x3D; 2 * x</code></pre><pre><code>&lt;tf.Tensor: shape=(4,), dtype=bool, numpy=array([ True,  True,  True,  True])&gt;</code></pre><h2 id="python控制流的梯度计算"><a class="markdownIt-Anchor" href="#python控制流的梯度计算"></a> Python控制流的梯度计算</h2><p>使用自动求导的一个好处是，[<strong>即使构建函数的计算图需要通过Python控制流（例如，条件、循环或任意函数调用），我们仍然可以计算得到的变量的梯度</strong>]。在下面的代码中，<code>while</code>循环的迭代次数和<code>if</code>语句的结果都取决于输入<code>a</code>的值。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def f(a):    b &#x3D; a * 2    while tf.norm(b) &lt; 1000:        b &#x3D; b * 2    if tf.reduce_sum(b) &gt; 0:        c &#x3D; b    else:        c &#x3D; 100 * b    return c</code></pre><p>让我们计算梯度。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; tf.Variable(tf.random.normal(shape&#x3D;()))with tf.GradientTape() as t:    d &#x3D; f(a)d_grad &#x3D; t.gradient(d, a)d_grad</code></pre><pre><code>&lt;tf.Tensor: shape=(), dtype=float32, numpy=204800.0&gt;</code></pre><p>我们现在可以分析上面定义的<code>f</code>函数。请注意，它在其输入<code>a</code>中是分段线性的。换言之，对于任何<code>a</code>，存在某个常量标量<code>k</code>，使得<code>f(a)=k*a</code>，其中<code>k</code>的值取决于输入<code>a</code>。因此，<code>d/a</code>允许我们验证梯度是否正确。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">d_grad &#x3D;&#x3D; d &#x2F; a</code></pre><pre><code>&lt;tf.Tensor: shape=(), dtype=bool, numpy=True&gt;</code></pre><h1 id="概率"><a class="markdownIt-Anchor" href="#概率"></a> 概率</h1><h2 id="编程中的概率论"><a class="markdownIt-Anchor" href="#编程中的概率论"></a> 编程中的概率论</h2><p>首先，让我们导入必要的软件包。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import numpy as npimport tensorflow as tfimport tensorflow_probability as tfp</code></pre><p>接下来，我们将希望能够投掷骰子。在统计学中，我们把从概率分布中抽取样本的过程称为<em>抽样</em>（sampling）。<br />将概率分配给一些离散选择的分布称为<em>多项分布</em>（multinomial distribution）。稍后我们将给出<em>分布</em>（distribution）的更正式定义。</p><p>为了抽取一个样本，我们只需传入一个概率向量。<br />输出是另一个相同长度的向量：它在索引<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>处的值是采样结果中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>出现的次数，由采样函数模拟真实情况分配。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">fair_probs &#x3D; tf.ones(6) &#x2F; 6 # 概率向量，每一个元素代表一个事件，值为这个事件的真实概率tfp.distributions.Multinomial(1, fair_probs).sample() # 该函数模拟真实情况对6个事件进行采样结果分配（传入的6个元素的向量）# 参数1表示只抽取一次样本</code></pre><pre><code>&lt;tf.Tensor: shape=(6,), dtype=float32, numpy=array([0., 0., 0., 0., 1., 0.], dtype=float32)&gt;</code></pre><p><strong>同时抽取多个样本</strong>: 如果你运行采样器很多次，你会发现每次你都得到随机的值。在估计一个骰子的公平性时，我们经常希望从同一分布中生成多个样本。如果用Python的for循环来完成这个任务，速度会慢得令人难以忍受，因此我们使用的函数支持同时抽取多个样本，返回我们想要的任意形状的独立样本数组。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">tfp.distributions.Multinomial(10, fair_probs).sample() # 参数10表示一次抽取10个样本</code></pre><pre><code>&lt;tf.Tensor: shape=(6,), dtype=float32, numpy=array([1., 1., 1., 0., 4., 3.], dtype=float32)&gt;</code></pre><p>现在我们知道如何对骰子进行采样，我们可以模拟1000次投掷。然后，我们可以统计1000次投掷后,每个数字被投中了多少次。具体来说，我们计算相对频率作为真实概率的估计。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">counts &#x3D; tfp.distributions.Multinomial(1000, fair_probs).sample()counts &#x2F; 1000 #根据频率计算概率</code></pre><pre><code>&lt;tf.Tensor: shape=(6,), dtype=float32, numpy=array([0.149, 0.17 , 0.175, 0.179, 0.158, 0.169], dtype=float32)&gt;</code></pre><p>因为我们是从一个公平的骰子中生成的数据，我们知道每个结果都有真实的概率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>6</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，大约是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.167</mn></mrow><annotation encoding="application/x-tex">0.167</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span><span class="mord">6</span><span class="mord">7</span></span></span></span>，所以上面输出的估计值看起来不错。</p><h2 id="概率论基本原理"><a class="markdownIt-Anchor" href="#概率论基本原理"></a> 概率论基本原理</h2><h3 id="条件概率"><a class="markdownIt-Anchor" href="#条件概率"></a> 条件概率</h3><p>这给我们带来了一个有趣的比率：<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mfrac><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo>=</mo><mi>a</mi><mo separator="true">,</mo><mi>B</mi><mo>=</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo>=</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \leq \frac{P(A=a, B=b)}{P(A=a)} \leq 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">A</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight">a</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">A</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight">b</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。我们称这个比率为<em>条件概率</em>（conditional probability），并用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo>=</mo><mi>b</mi><mo>∣</mo><mi>A</mi><mo>=</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(B=b \mid A=a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span>表示它：它是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">B=b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>的概率，前提是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">A=a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span>已发生。</p><h3 id="贝叶斯定理"><a class="markdownIt-Anchor" href="#贝叶斯定理"></a> 贝叶斯定理</h3><p>使用条件概率的定义，我们可以得出统计学中最有用和最著名的方程之一：<em>Bayes定理</em>（Bayes’ theorem）。它如下所示。通过构造，我们有<em>乘法规则</em>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo>∣</mo><mi>A</mi><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A, B) = P(B \mid A) P(A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span>。根据对称性，这也适用于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo>∣</mo><mi>B</mi><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A, B) = P(A \mid B) P(B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>。假设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">P(B)&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，求解其中一个条件变量，我们得到</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo>∣</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo>∣</mo><mi>A</mi><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></mfrac><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">P(A \mid B) = \frac{P(B \mid A) P(A)}{P(B)}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">.</span></span></span></span></span></p><p>请注意，在这里我们使用更紧凑的表示法，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A, B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>是一个<em>联合分布</em>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo>∣</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A \mid B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>是一个<em>条件分布</em>。这种分布可以在给定值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mi>a</mi><mo separator="true">,</mo><mi>B</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">A = a, B=b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>上进行求值。</p><h3 id="边际化"><a class="markdownIt-Anchor" href="#边际化"></a> 边际化</h3><p>如果我们想从另一件事中推断一件事，但我们只知道相反方向的属性，比如因和果的时候，Bayes定理是非常有用的，正如我们将在本节后面看到的那样。为了能进行这项工作，我们需要的一个重要操作是<em>边际化</em>。这项操作是从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A, B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>中确定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>的操作。我们可以看到，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>的概率相当于计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>的所有可能选择，并将所有选择的联合概率聚合在一起：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∑</mo><mi>A</mi></munder><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">P(B) = \sum_{A} P(A, B),</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.344341em;vertical-align:-1.294336em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0500050000000003em;"><span style="top:-1.855664em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.294336em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mpunct">,</span></span></span></span></span></p><p>这也称为<em>求和规则</em>。边际化结果的概率或分布称为<em>边际概率</em>或<em>边际分布</em>。</p><h3 id="独立性"><a class="markdownIt-Anchor" href="#独立性"></a> 独立性</h3><p>另一个要检查的有用属性是<em>依赖</em>与<em>独立</em>。两个随机变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>是独立的，意味着事件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>的发生不会透露有关<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>事件的发生情况的任何信息。在这种情况下，统计学家通常将这一点表述为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊥</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \perp  B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>。根据贝叶斯定理，马上就能同样得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo>∣</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A \mid B) = P(A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span>。在所有其他情况下，我们称<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>依赖。比如，一个骰子的两次连续抛出是独立的。相比之下，灯开关的位置和房间的亮度并不是（尽管它们不是具有确定性的，因为总是可能存在灯泡坏掉，电源故障，或者开关故障）。</p><p>由于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo>∣</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A \mid B) = \frac{P(A, B)}{P(B)} = P(A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">A</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span>等价于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A, B) = P(A)P(B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>，因此两个随机变量是独立的当且仅当两个随机变量的联合分布是其各自分布的乘积。同样地，给定另一个随机变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>时，两个随机变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>是<em>条件独立的</em>，当且仅当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo>∣</mo><mi>C</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo>∣</mo><mi>C</mi><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo>∣</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A, B \mid C) = P(A \mid C)P(B \mid C)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span>。这个情况表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊥</mo><mi>B</mi><mo>∣</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A \perp B \mid C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>。</p><h3 id="期望和差异"><a class="markdownIt-Anchor" href="#期望和差异"></a> 期望和差异</h3><p>为了概括概率分布的关键特征，我们需要一些测量方法。随机变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>的<em>期望</em>（或平均值）表示为</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>E</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo><mo>=</mo><munder><mo>∑</mo><mi>x</mi></munder><mi>x</mi><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo>=</mo><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">E[X] = \sum_{x} x P(X = x).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.3000100000000003em;vertical-align:-1.250005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8999949999999999em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord">.</span></span></span></span></span></p><p>当函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>的输入是从分布<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>中抽取的随机变量时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>的期望值为</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>E</mi><mrow><mi>x</mi><mo>∼</mo><mi>P</mi></mrow></msub><mo stretchy="false">[</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>=</mo><munder><mo>∑</mo><mi>x</mi></munder><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">E_{x \sim P}[f(x)] = \sum_x f(x) P(x).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mrel mtight">∼</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.3000100000000003em;vertical-align:-1.250005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8999949999999999em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord">.</span></span></span></span></span></p><p>在许多情况下，我们希望衡量随机变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>与其期望值的偏置。这可以通过方差来量化</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="normal">V</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo><mo>=</mo><mi>E</mi><mrow><mo fence="true">[</mo><mo stretchy="false">(</mo><mi>X</mi><mo>−</mo><mi>E</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo fence="true">]</mo></mrow><mo>=</mo><mi>E</mi><mo stretchy="false">[</mo><msup><mi>X</mi><mn>2</mn></msup><mo stretchy="false">]</mo><mo>−</mo><mi>E</mi><mo stretchy="false">[</mo><mi>X</mi><msup><mo stretchy="false">]</mo><mn>2</mn></msup><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathrm{Var}[X] = E\left[(X - E[X])^2\right] =E[X^2] - E[X]^2.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">V</span><span class="mord mathrm">a</span><span class="mord mathrm">r</span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2141179999999998em;vertical-align:-0.35001em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">[</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">.</span></span></span></span></span></p><p>它的平方根被称为<em>标准差</em>（standared deviation）。随机变量函数的方差衡量的是，当从该随机变量分布中采样不同值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>时，函数值偏离该函数的期望的程度：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="normal">V</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mo stretchy="false">[</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>=</mo><mi>E</mi><mrow><mo fence="true">[</mo><msup><mrow><mo fence="true">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>−</mo><mi>E</mi><mo stretchy="false">[</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo fence="true">)</mo></mrow><mn>2</mn></msup><mo fence="true">]</mo></mrow><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathrm{Var}[f(x)] = E\left[\left(f(x) - E[f(x)]\right)^2\right].</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">V</span><span class="mord mathrm">a</span><span class="mord mathrm">r</span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.80002em;vertical-align:-0.65002em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">[</span></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mclose">]</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.954008em;"><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">]</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span></span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习二——Tensorflow基础</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%BA%8C%E2%80%94%E2%80%94Tensorflow%E5%9F%BA%E7%A1%80/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%BA%8C%E2%80%94%E2%80%94Tensorflow%E5%9F%BA%E7%A1%80/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="tensorflow基础数据操作"><a class="markdownIt-Anchor" href="#tensorflow基础数据操作"></a> Tensorflow基础数据操作</h1><ul><li>为了能够完成各种操作，我们需要某种方法来存储和操作数据。一般来说，我们需要做两件重要的事情：<ol><li>获取数据；</li><li>在将数据读入计算机后对其进行处理。如果没有某种方法来存储数据，那么获取数据是没有意义的。</li></ol></li><li>数据存储对象：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>维数组，也称为<em>张量</em>（tensor）。</li><li>无论使用哪个深度学习框架，它的<em>张量类</em>（在PyTorch和TensorFlow中为<code>Tensor</code>）都与Numpy的<code>ndarray</code>类似，但又比Numpy的<code>ndarray</code>多一些重要功能：<ol><li>深度学习框架很好地支持GPU加速计算，而NumPy仅支持CPU计算；</li><li>张量类支持自动微分。这些功能使得张量类更适合深度学习。</li></ol></li></ul><h1 id="tensorflow数组对象"><a class="markdownIt-Anchor" href="#tensorflow数组对象"></a> Tensorflow数组对象</h1><ul><li>首先，我们导入<code>tensorflow</code>。由于名称有点长，我们经常使用短别名<code>tf</code>导入它。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">import tensorflow as tf</code></pre><ul><li>**张量（tensor）**表示由一个数值组成的数组，这个数组可能有多个维度。具有一个轴的张量对应数学上的<em>向量</em>（vector）。具有两个轴的张量对应数学上的<em>矩阵</em>（matrix）。具有两个轴以上的张量没有特殊的数学名称。</li><li>可以使用<code>arange</code>创建一个行向量<code>x</code>。这个行向量包含从0开始的前12个整数，它们被默认创建为浮点数。张量中的每个值都称为张量的<em>元素</em>（element）。例如，张量<code>x</code>中有12个元素。<ul><li>除非额外指定，否则新的张量将存储在内存中，并采用基于CPU的计算。</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; tf.range(12)x</code></pre><pre><code>&lt;tf.Tensor: shape=(12,), dtype=int32, numpy=array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11], dtype=int32)&gt;</code></pre><ul><li><code>shape</code>属性可以通过张量的<code>shape</code>属性来访问张量的<em>形状</em>（沿每个轴的长度）。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">x.shape</code></pre><pre><code>TensorShape([12])</code></pre><ul><li>如果只想知道张量中元素的总数，即形状的所有元素乘积，可以检查它的大小（size）。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">tf.size(x)</code></pre><pre><code>&lt;tf.Tensor: shape=(), dtype=int32, numpy=12&gt;</code></pre><ul><li>要改变一个张量的形状而不改变元素数量和元素值，可以调用<code>reshape</code>函数。例如，可以把张量<code>x</code>从形状为（12,）的行向量转换为形状为（3,4）的矩阵。<ul><li>这个新的张量包含与转换前相同的值，但是它被看成一个3行4列的矩阵。要重点说明一下，虽然张量的形状发生了改变，但其元素值并没有变。注意，通过改变张量的形状，张量的大小不会改变。</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">X &#x3D; tf.reshape(x, (3, 4))X</code></pre><pre><code>&lt;tf.Tensor: shape=(3, 4), dtype=int32, numpy=array([[ 0,  1,  2,  3],       [ 4,  5,  6,  7],       [ 8,  9, 10, 11]], dtype=int32)&gt;</code></pre><ul><li>不需要通过手动指定每个维度来改变形状。也就是说，如果我们的目标形状是（高度,宽度），那么在知道宽度后，高度应当会隐式得出，我们不必自己做除法。在上面的例子中，为了获得一个3行的矩阵，我们手动指定了它有3行和4列。<ul><li>幸运的是，张量在给出其他部分后可以自动计算出一个维度。我们可以通过在希望张量自动推断的维度放置<code>-1</code>来调用此功能。在上面的例子中，我们可以用<code>x.reshape(-1,4)</code>或<code>x.reshape(3,-1)</code>来取代<code>x.reshape(3,4)</code>。</li></ul></li><li>有时，我们希望[<strong>使用全0、全1、其他常量或者从特定分布中随机采样的数字</strong>]来初始化矩阵。我们可以创建一个形状为（2,3,4）的张量，其中所有元素都设置为0。代码如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">tf.zeros((2, 3, 4))</code></pre><pre><code>&lt;tf.Tensor: shape=(2, 3, 4), dtype=float32, numpy=array([[[0., 0., 0., 0.],        [0., 0., 0., 0.],        [0., 0., 0., 0.]],       [[0., 0., 0., 0.],        [0., 0., 0., 0.],        [0., 0., 0., 0.]]], dtype=float32)&gt;</code></pre><ul><li>同样，我们可以创建一个形状为<code>(2,3,4)</code>的张量，其中所有元素都设置为1。代码如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">tf.ones((2, 3, 4))</code></pre><pre><code>&lt;tf.Tensor: shape=(2, 3, 4), dtype=float32, numpy=array([[[1., 1., 1., 1.],        [1., 1., 1., 1.],        [1., 1., 1., 1.]],       [[1., 1., 1., 1.],        [1., 1., 1., 1.],        [1., 1., 1., 1.]]], dtype=float32)&gt;</code></pre><ul><li>有时我们想通过<strong>从某个特定的概率分布中随机采样来得到张量中每个元素的值</strong>。例如，当我们构造数组来作为神经网络中的参数时，我们通常会随机初始化参数的值。以下代码创建一个形状为（3,4）的张量。其中的每个元素都从均值为0、标准差为1的标准高斯（正态）分布中随机采样。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">tf.random.normal(shape&#x3D;[3, 4])</code></pre><pre><code>&lt;tf.Tensor: shape=(3, 4), dtype=float32, numpy=array([[ 1.3451171 ,  1.8505315 , -0.36672395, -0.5327307 ],       [-1.9183167 , -1.1994293 ,  0.37904397,  0.8061889 ],       [-0.3106889 ,  0.22559305, -0.96131563, -0.30276218]],      dtype=float32)&gt;</code></pre><ul><li>我们还可以[<strong>通过提供包含数值的Python列表（或嵌套列表）来为所需张量中的每个元素赋予确定值</strong>]。在这里，最外层的列表对应于轴0，内层的列表对应于轴1。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">tf.constant([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])</code></pre><pre><code>&lt;tf.Tensor: shape=(3, 4), dtype=int32, numpy=array([[2, 1, 4, 3],       [1, 2, 3, 4],       [4, 3, 2, 1]], dtype=int32)&gt;</code></pre><h1 id="tensorflow的数组基本运算"><a class="markdownIt-Anchor" href="#tensorflow的数组基本运算"></a> Tensorflow的数组基本运算</h1><ul><li>对数组一些最简单且最有用的操作是<em>按元素</em>（elementwise）操作。它们将标准标量运算符应用于数组的每个元素。</li><li>对于将两个数组作为输入的函数，按元素运算将二元运算符应用于两个数组中的<em>每对位置对应</em>的元素。我们可以基于任何从标量到标量的函数来创建按元素函数。</li><li>对于任意具有相同形状的张量，[<strong>常见的标准算术运算符（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>和<code>**</code>）都可以被升级为按元素运算</strong>]。我们可以在同一形状的任意两个张量上调用按元素操作。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; tf.constant([1.0, 2, 4, 8])y &#x3D; tf.constant([2.0, 2, 2, 2])x + y, x - y, x * y, x &#x2F; y, x ** y  # **运算符是求幂运算</code></pre><pre><code>(&lt;tf.Tensor: shape=(4,), dtype=float32, numpy=array([ 3.,  4.,  6., 10.], dtype=float32)&gt;, &lt;tf.Tensor: shape=(4,), dtype=float32, numpy=array([-1.,  0.,  2.,  6.], dtype=float32)&gt;, &lt;tf.Tensor: shape=(4,), dtype=float32, numpy=array([ 2.,  4.,  8., 16.], dtype=float32)&gt;, &lt;tf.Tensor: shape=(4,), dtype=float32, numpy=array([0.5, 1. , 2. , 4. ], dtype=float32)&gt;, &lt;tf.Tensor: shape=(4,), dtype=float32, numpy=array([ 1.,  4., 16., 64.], dtype=float32)&gt;)</code></pre><ul><li>可以(<strong>按按元素方式应用更多的计算</strong>)，包括像求指数幂这样的一元运算符。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">tf.exp(x)</code></pre><pre><code>&lt;tf.Tensor: shape=(4,), dtype=float32, numpy=array([2.7182817e+00, 7.3890562e+00, 5.4598148e+01, 2.9809580e+03],      dtype=float32)&gt;</code></pre><ul><li>除了按元素计算外，我们还可以执行线性代数运算，包括向量点积和矩阵乘法。</li><li>[<strong>我们也可以把多个张量<em>连结</em>（concatenate）在一起</strong>]，把它们端对端地叠起来形成一个更大的张量。我们只需要提供张量列表，并给出沿哪个轴连结。</li><li>下面的例子分别演示了当我们沿行（轴-0，形状的第一个元素）和按列（轴-1，形状的第二个元素）连结两个矩阵时会发生什么情况。我们可以看到，第一个输出张量的轴-0长度（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>）是两个输入张量轴-0长度的总和（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>+</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3 + 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>）；第二个输出张量的轴-1长度（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span>）是两个输入张量轴-1长度的总和（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>+</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">4 + 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>）。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">X &#x3D; tf.reshape(tf.range(12, dtype&#x3D;tf.float32), (3, 4))Y &#x3D; tf.constant([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])tf.concat([X, Y], axis&#x3D;0), tf.concat([X, Y], axis&#x3D;1)</code></pre><pre><code>(&lt;tf.Tensor: shape=(6, 4), dtype=float32, numpy= array([[ 0.,  1.,  2.,  3.],        [ 4.,  5.,  6.,  7.],        [ 8.,  9., 10., 11.],        [ 2.,  1.,  4.,  3.],        [ 1.,  2.,  3.,  4.],        [ 4.,  3.,  2.,  1.]], dtype=float32)&gt;, &lt;tf.Tensor: shape=(3, 8), dtype=float32, numpy= array([[ 0.,  1.,  2.,  3.,  2.,  1.,  4.,  3.],        [ 4.,  5.,  6.,  7.,  1.,  2.,  3.,  4.],        [ 8.,  9., 10., 11.,  4.,  3.,  2.,  1.]], dtype=float32)&gt;)</code></pre><ul><li>[<strong>通过<em>逻辑运算符</em>构建二元张量</strong>]。以<code>X == Y</code>为例子。对于每个位置，如果<code>X</code>和<code>Y</code>在该位置相等，则新张量中相应项的值为1，这意味着逻辑语句<code>X == Y</code>在该位置处为真，否则该位置为0。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">X &#x3D;&#x3D; Y</code></pre><pre><code>&lt;tf.Tensor: shape=(3, 4), dtype=bool, numpy=array([[False,  True, False,  True],       [False, False, False, False],       [False, False, False, False]])&gt;</code></pre><ul><li>[<strong>对张量中的所有元素进行求和会产生一个只有一个元素的张量。</strong>]</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">tf.reduce_sum(X)</code></pre><pre><code>&lt;tf.Tensor: shape=(), dtype=float32, numpy=66.0&gt;</code></pre><h2 id="广播机制"><a class="markdownIt-Anchor" href="#广播机制"></a> 广播机制</h2><ul><li>在上面的部分中，我们看到了如何在相同形状的两个张量上执行按元素操作。在某些情况下，[<strong>即使形状不同，我们仍然可以通过调用<em>广播机制</em>（broadcasting mechanism）来执行按元素操作</strong>]。</li><li>这是Tensorflow的自动机制，这种机制的工作方式如下：首先，通过适当复制元素来扩展一个或两个数组，以便在转换之后，两个张量具有相同的形状。其次，对生成的数组执行按元素操作。在大多数情况下，我们将沿着数组中长度为1的轴进行广播，如下例子：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; tf.reshape(tf.range(3), (3, 1))b &#x3D; tf.reshape(tf.range(2), (1, 2))a, b</code></pre><pre><code>(&lt;tf.Tensor: shape=(3, 1), dtype=int32, numpy= array([[0],        [1],        [2]], dtype=int32)&gt;, &lt;tf.Tensor: shape=(1, 2), dtype=int32, numpy=array([[0, 1]], dtype=int32)&gt;)</code></pre><ul><li>由于<code>a</code>和<code>b</code>分别是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">3\times1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">1\times2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>矩阵，如果我们让它们相加，它们的形状不匹配。我们将两个矩阵<em>广播</em>为一个更大的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">3\times2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>矩阵，如下所示：矩阵<code>a</code>将复制列，矩阵<code>b</code>将复制行，然后再按元素相加。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a + b</code></pre><pre><code>&lt;tf.Tensor: shape=(3, 2), dtype=int32, numpy=array([[0, 1],       [1, 2],       [2, 3]], dtype=int32)&gt;</code></pre><h2 id="索引和切片"><a class="markdownIt-Anchor" href="#索引和切片"></a> 索引和切片</h2><ul><li>就像在任何其他Python数组中一样，张量中的元素可以通过索引访问。与任何Python数组一样：第一个元素的索引是0；可以指定范围以包含第一个元素和最后一个之前的元素。与标准Python列表一样，我们可以通过<em>使用负索引根据元素到列表尾部的相对位置访问元素</em>。</li><li>因此，我们[可以用<code>[-1]</code>选择最后一个元素，可以用<code>[1:3]</code>选择第二个和第三个元素（从1， 2 ,索引3是右开边界）]，如下所示：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">X[-1], X[1:3]</code></pre><pre><code>(&lt;tf.Tensor: shape=(4,), dtype=float32, numpy=array([ 8.,  9., 10., 11.], dtype=float32)&gt;, &lt;tf.Tensor: shape=(2, 4), dtype=float32, numpy= array([[ 4.,  5.,  6.,  7.],        [ 8.,  9., 10., 11.]], dtype=float32)&gt;)</code></pre><ul><li>TensorFlow中的<code>Tensors</code>对象是不可变的，也不能被赋值。TensorFlow中的<code>Variables</code>是支持赋值的可变容器。请记住，TensorFlow中的梯度不会通过<code>Variable</code>反向传播。</li><li>除了为整个<code>Variable</code>分配一个值之外，我们还可以通过索引来写入<code>Variable</code>的元素。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">X_var &#x3D; tf.Variable(X)X_var[1, 2].assign(-100) # 将索引为(1, 2)的元素修改为-100X_var</code></pre><pre><code>&lt;tf.Variable 'Variable:0' shape=(3, 4) dtype=float32, numpy=array([[   0.,    1.,    2.,    3.],       [   4.,    5., -100.,    7.],       [   8.,    9.,   10.,   11.]], dtype=float32)&gt;</code></pre><ul><li>如果我们想[<strong>为多个元素赋值相同的值，我们只需要索引所有元素，然后为它们赋值。</strong>]。例如，<code>[0:2, :]</code>访问第1行和第2行，其中“:”代表沿轴1（列）的所有元素。虽然我们讨论的是矩阵的索引，但这也适用于向量和超过2个维度的张量。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">X_var &#x3D; tf.Variable(X)X_var[0:2, :].assign(tf.ones(X_var[0:2,:].shape, dtype &#x3D; tf.float32) * 12) # 将第一行和第二行元素全部修改为12X_var</code></pre><pre><code>&lt;tf.Variable 'Variable:0' shape=(3, 4) dtype=float32, numpy=array([[12., 12., 12., 12.],       [12., 12., 12., 12.],       [ 8.,  9., 10., 11.]], dtype=float32)&gt;</code></pre><h2 id="节省内存"><a class="markdownIt-Anchor" href="#节省内存"></a> 节省内存</h2><ul><li>[<strong>运行一些操作可能会导致为新结果分配内存</strong>]。例如，如果我们用<code>Y = X + Y</code>，我们将取消引用<code>Y</code>指向的张量，而是指向新分配的内存处的张量。</li><li>在下面的例子中，我们用Python的<code>id()</code>函数演示了这一点，它给我们提供了内存中引用对象的确切地址。运行<code>Y = Y + X</code>后，我们会发现<code>id(Y)</code>指向另一个位置。这是因为Python首先计算<code>Y + X</code>，为结果分配新的内存，然后使<code>Y</code>指向内存中的这个新位置。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">before &#x3D; id(Y)Y &#x3D; Y + Xid(Y) &#x3D;&#x3D; before</code></pre><pre><code>False</code></pre><ul><li><p>在机器学习中，我们可能有数百兆的参数，并且在一秒内多次更新所有参数。通常情况下，我们希望原地执行这些更新。其次，我们可能通过多个变量指向相同参数。如果我们不原地更新，其他引用仍然会指向旧的内存位置，这样我们的某些代码可能会无意中引用旧的参数。</p></li><li><p><code>Variables</code>是TensorFlow中的可变容器。它们提供了一种存储模型参数的方法。我们可以通过<code>assign</code>将一个操作的结果分配给一个<code>Variable</code>。为了说明这一点，我们创建了一个与另一个张量<code>Y</code>相同的形状的<code>Z</code>，使用<code>zeros_like</code>来分配一个全<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的块。</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">Z &#x3D; tf.Variable(tf.zeros_like(Y))print(&#39;id(Z):&#39;, id(Z))Z.assign(X + Y)print(&#39;id(Z):&#39;, id(Z))</code></pre><pre><code>id(Z): 140470903098192id(Z): 140470903098192</code></pre><ul><li>即使你将状态持久存储在<code>Variable</code>中，你也可能希望避免为不是模型参数的张量过度分配内存，从而进一步减少内存使用量。由于TensorFlow的<code>Tensors</code>是不可变的，而且梯度不会通过<code>Variable</code>流动，因此TensorFlow没有提供一种明确的方式来原地运行单个操作。<ul><li>但是，TensorFlow提供了<code>tf.function</code>修饰符，将计算封装在TensorFlow图中，该图在运行前经过编译和优化。这允许TensorFlow删除未使用的值，并复用先前分配的且不再需要的值。这样可以最大限度地减少TensorFlow计算的内存开销。</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">@tf.functiondef computation(X, Y):    Z &#x3D; tf.zeros_like(Y)  # 这个未使用的值将被删除    A &#x3D; X + Y  # 当不再需要时，分配将被复用    B &#x3D; A + Y    C &#x3D; B + Y    return C + Ycomputation(X, Y)</code></pre><pre><code>&lt;tf.Tensor: shape=(3, 4), dtype=float32, numpy=array([[ 8.,  9., 26., 27.],       [24., 33., 42., 51.],       [56., 57., 58., 59.]], dtype=float32)&gt;</code></pre><h2 id="与其他-python-对象转化"><a class="markdownIt-Anchor" href="#与其他-python-对象转化"></a> 与其他 Python 对象转化</h2><ul><li><code>tensor</code>对象[<strong>转换为NumPy张量</strong>]很容易，反之也很容易。<ul><li>转换后的结果不共享内存。这个小的不便实际上是非常重要的：当你在CPU或GPU上执行操作的时候，如果Python的NumPy包也希望使用相同的内存块执行其他操作，你不希望停下计算来等它。</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">A &#x3D; X.numpy()B &#x3D; tf.constant(A)type(A), type(B)</code></pre><pre><code>(numpy.ndarray, tensorflow.python.framework.ops.EagerTensor)</code></pre><ul><li>要(<strong>将大小为1的张量转换为Python标量</strong>)，我们可以调用<code>item</code>函数或Python的内置函数。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; tf.constant([3.5]).numpy()a, a.item(), float(a), int(a)</code></pre><pre><code>(array([3.5], dtype=float32), 3.5, 3.5, 3)</code></pre><ul><li>将Pandas对象转化为Tensorflow的tensor张量对象。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pandas as pdinputs &#x3D; pd.DataFrame(range(5))inputs</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>0</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>0</td>    </tr>    <tr>      <th>1</th>      <td>1</td>    </tr>    <tr>      <th>2</th>      <td>2</td>    </tr>    <tr>      <th>3</th>      <td>3</td>    </tr>    <tr>      <th>4</th>      <td>4</td>    </tr>  </tbody></table></div><pre class="line-numbers language-python" data-language="python"><code class="language-python">tensor &#x3D; tf.constant(inputs.values)tensor</code></pre><pre><code>&lt;tf.Tensor: shape=(5, 1), dtype=int64, numpy=array([[0],       [1],       [2],       [3],       [4]])&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> Tensorflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习一——机器学习与深度学习概述</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%80%E2%80%94%E2%80%94%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%80%E2%80%94%E2%80%94%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习与深度学习概述"><a class="markdownIt-Anchor" href="#机器学习与深度学习概述"></a> 机器学习与深度学习概述</h1><ul><li>**机器学习（machine learning，ML）**是强大的可以从经验中学习的技术。通常采用观测数据或与环境交互的形式，机器学习算法会积累更多的经验，其性能也会逐步提高。</li><li>**深度学习(deep learning)**是机器学习中的一种，是一套强大的技术，它可以推动计算机视觉、自然语言处理、医疗保健和基因组学等不同领域的创新。</li><li><strong>学习(learning)</strong>: 在机器学习中，<em>学习</em>（learning）是一个模型的训练过程。通过这个过程，我们可以发现正确的参数集，从而从使模型强制执行所需的行为。换句话说，我们用数据<em>训练</em>（train）我们的模型。训练过程通常包含如下步骤：<ol><li>从一个随机初始化参数的模型开始，这个模型基本毫不“智能”。</li><li>获取一些数据样本（例如，音频片段以及对应的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mtext>是</mtext><mo separator="true">,</mo><mtext>否</mtext><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{\text{是}, \text{否}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord text"><span class="mord cjk_fallback">是</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord cjk_fallback">否</span></span><span class="mclose">}</span></span></span></span>标签）。</li><li>调整参数，使模型在这些样本中表现得更好。</li><li>重复第2步和第3步，直到模型在任务中的表现令你满意。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/GU8YZA.png" alt="GU8YZA" /></li></ol></li><li>用数据编程：将机器学习这种“通过用数据集来确定程序行为”的方法看作是“用数据编程”（programming with data）。比如，我们可以通过向机器学习系统提供许多猫和狗的图片来设计一个“猫图检测器”。</li></ul><h1 id="机器学习的关键组件"><a class="markdownIt-Anchor" href="#机器学习的关键组件"></a> 机器学习的关键组件</h1><ul><li><strong>数据(data)</strong>: 我们可以学习的<em>数据</em>（data）。</li><li><strong>模型(model)</strong>: 如何转换数据的<em>模型</em>（model）。</li><li><strong>目标函数objective function）</strong>: 一个<em>目标函数</em>，用来量化模型的有效性。</li><li><strong>优化算法</strong>：调整模型参数以优化目标函数的算法。</li></ul><h2 id="数据"><a class="markdownIt-Anchor" href="#数据"></a> 数据</h2><ul><li><strong>样本(example)</strong>: 每个数据集由一个个<em>样本</em>（example）组成，大多时候，它们遵循独立同分布(independently and identically distributed, i.i.d.)。样本有时也叫做<em>数据点</em>（data point）或者<em>数据实例</em>（data instance），通常每个样本由一组称为<em>特征</em>（features，或<em>协变量</em>（covariates））的属性组成。机器学习模型会根据这些属性进行预测。在监督学习问题中，要预测的是一个特殊的属性，它被称为<em>标签</em>（label），或<em>目标</em>（target））。<ul><li>假设我们处理的是图像数据，每一张单独的照片即为一个样本，它的特征由每个像素数值的有序列表表示。比如，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>200</mn><mo>×</mo><mn>200</mn></mrow><annotation encoding="application/x-tex">200\times 200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span></span></span></span>彩色照片由<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>200</mn><mo>×</mo><mn>200</mn><mo>×</mo><mn>3</mn><mo>=</mo><mn>120000</mn></mrow><annotation encoding="application/x-tex">200\times200\times3=120000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>个数值组成，其中的“3”对应于每个空间位置的红、绿、蓝通道的强度。</li></ul></li><li><strong>维数（dimensionality）</strong>：当每个样本的特征类别数量都是相同的，所以其特征向量是固定长度的，这个长度被称为数据的<em>维数</em>。固定长度的特征向量是一个方便的属性，它有助于我们量化学习大量样本。然而，并不是所有的数据都可以用“固定长度”的向量表示。例如，文本数据就不符合“固定长度”的要求。与传统机器学习方法相比，<em>深度学习的一个主要优势是可以处理不同长度的数据</em>。</li><li>大量且正确的数据：在没有大数据集的情况下，许多令人兴奋的深度学习模型黯然失色。就算一些深度学习模型在小数据集上能够工作，但其效能并不比传统方法高。但是，仅仅拥有海量的数据是不够的，我们还需要正确的数据。如果数据中充满了错误，或者如果数据的特征不能预测任务目标，那么模型很可能无效。</li></ul><h2 id="模型"><a class="markdownIt-Anchor" href="#模型"></a> 模型</h2><ul><li>深度学习与经典方法的区别主要在于：前者关注的功能强大的模型，这些模型由神经网络错综复杂的交织在一起，包含层层数据转换，因此被称为<em>深度学习</em>（deep learning）。</li></ul><h2 id="目标函数"><a class="markdownIt-Anchor" href="#目标函数"></a> 目标函数</h2><ul><li>在机器学习中，我们需要定义模型的优劣程度的度量，这个度量在大多数情况是“可优化”的，我们称之为<em>目标函数</em>（objective function）。</li><li>我们通常定义一个目标函数，并希望优化它到最低点。因为越低越好，所以这些函数有时又被称为<em>损失函数</em>（loss function, 或cost function）。</li><li>通常，损失函数是根据模型参数定义的，并取决于数据集。在一个数据集上，我们通过最小化总损失来学习模型参数的最佳值。<ul><li>该数据集由一些为训练而收集的样本组成，称为<em>训练数据集</em>（training dataset，或称为<em>训练集</em>（training set））。</li><li>然而，在训练数据上表现良好的模型，并不一定在“新数据集”上有同样的效能，这里的“新数据集”通常称为<em>测试数据集</em>（test dataset，或称为<em>测试集</em>（test set））。</li></ul></li><li>我们通常将可用数据集分成两部分：训练数据集用于拟合模型参数，测试数据集用于评估拟合的模型。</li><li><strong>“过拟合”（overfitting）</strong>：当一个模型在训练集上表现良好，但不能推广到测试集时，我们说这个模型是“过拟合”（overfitting）的。</li></ul><h2 id="优化算法"><a class="markdownIt-Anchor" href="#优化算法"></a> 优化算法</h2><ul><li>一旦我们获得了一些数据源及其表示、一个模型和一个合适的损失函数，我们接下来就需要一种算法，它能够搜索出最佳参数，以最小化损失函数。</li><li><strong>梯度下降（gradient descent）</strong>：深度学习中，大多流行的优化算法通常基于一种基本方法–梯度下降。<ul><li>简而言之，在每个步骤中，梯度下降法都会检查每个参数，看看如果你仅对该参数进行少量变动，训练集损失会朝哪个方向移动。然后，它在可以减少损失的方向上优化参数。</li></ul></li></ul><h1 id="机器学习基本类型"><a class="markdownIt-Anchor" href="#机器学习基本类型"></a> 机器学习基本类型</h1><h2 id="监督学习"><a class="markdownIt-Anchor" href="#监督学习"></a> 监督学习</h2><ul><li><strong>监督学习（supervised learning）</strong>：擅长在“给定输入特征”的情况下预测标签。<ul><li>每个“特征-标签”对都称为一个<em>样本</em>（example）。有时，即使标签是未知的，样本也可以指代输入特征。</li><li>我们的目标是生成一个模型，能够将任何输入特征映射到标签，即预测。</li></ul></li><li>监督学习之所以发挥作用，是因为在训练参数时，我们为模型提供了一个数据集，其中每个样本都有真实的标签。用概率论术语来说，我们希望预测“估计给定输入特征的标签”的条件概率。因为在一定程度上，许多重要的任务可以清晰地描述为：在给定一组特定的可用数据的情况下，估计未知事物的概率。</li><li>监督学习的学习过程如下所示。<ol><li>从已知大量数据样本中随机选取一个子集，为每个样本获取基本的真实标签。</li><li>有时，这些样本已有标签（例如，患者是否在下一年内康复？）；有时，我们可能需要人工标记数据（例如，将图像分类）。</li><li>这些输入和相应的标签一起构成了训练数据集。随后，我们选择有监督的学习算法，它将训练数据集作为输入，并输出一个“完成学习模型”。</li><li>我们将之前没见过的样本特征放到这个“完成学习模型”中，使用模型的输出作为相应标签的预测。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211023193740.png" alt="" /></li></ol></li><li>即使使用简单的描述“给定输入特征的预测标签”，监督学习也可以采取多种形式的模型，并且需要大量不同的建模决策，这取决于输入和输出的类型、大小和数量。下面介绍一些监督学习的类型。</li></ul><h3 id="回归"><a class="markdownIt-Anchor" href="#回归"></a> 回归</h3><ul><li><em>回归</em>（regression）是最简单的监督学习任务之一。当标签取任意数值时，我们称之为<em>回归</em>问题。我们的目标是生成一个模型，它的预测非常接近实际标签值。</li><li>判断回归问题的一个很好的经验法则是，任何有关“多少”的问题很可能就是回归问题。比如，预测用户对一部电影的评分可以被认为是一个回归问题。再比如，预测病人在医院的住院时间也是一个回归问题。</li></ul><h3 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h3><ul><li>“哪一个？”的问题叫做<em>分类</em>（classification）问题。虽然回归模型可以很好地解决“有多少？”的问题，但是很多问题并非如此。</li><li>在<em>分类</em>问题中，我们希望模型能够预测样本属于哪个<em>类别</em>（category，正式称为<em>类</em>（class））。例如，对于手写数字，我们可能有10类，分别数字0到9。</li><li><strong>二元分类</strong>：最简单的分类问题是只有两类，我们称之为“二元分类”。</li><li><strong>分类器</strong>：在分类中，我们训练一个分类器，它的输出即为预测的类别。</li><li><strong>多类分类</strong>：当我们有两个以上的类别时，我们把这个问题称为<em>多类分类</em>（multiclass classification）问题。常见的例子包括手写字符识别 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mn>9</mn><mo separator="true">,</mo><mi mathvariant="normal">a</mi><mo separator="true">,</mo><mi mathvariant="normal">b</mi><mo separator="true">,</mo><mi mathvariant="normal">c</mi><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\mathrm{\{0, 1, 2, ... 9, a, b, c, ...\}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">{</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathrm">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathrm">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathrm">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathrm">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mclose">}</span></span></span></span></span>。</li><li><strong>交叉熵（cross-entropy）</strong>: 与解决回归问题不同，分类问题的常见损失函数被称为<em>交叉熵</em>（cross-entropy）。</li></ul><h3 id="标记问题"><a class="markdownIt-Anchor" href="#标记问题"></a> 标记问题</h3><ul><li><strong>多标签分类（multilabel classification）</strong>: 学习预测不相互排斥的类别的问题称为<em>多标签分类</em>。举个例子，人们在技术博客上贴的标签，比如“机器学习”、“技术”、“小工具”、“编程语言”、“Linux”、“云计算”、“AWS”。</li></ul><h3 id="搜索"><a class="markdownIt-Anchor" href="#搜索"></a> 搜索</h3><ul><li>在信息检索领域，我们希望对一组项目进行排序。以网络搜索为例，我们的目标不是简单的“查询（query）-网页（page）”分类，而是在海量搜索结果中找到用户最需要的那部分。</li><li>搜索结果的排序也十分重要，我们的学习算法需要输出有序的元素子集。即使结果集是相同的，集内的顺序有时却很重要。</li><li>该问题的一种可能的解决方案：首先为集合中的每个元素分配相应的相关性分数，然后检索评级最高的元素。</li><li>搜索引擎使用机器学习和用户行为模型来获取网页相关性得分。</li></ul><h3 id="推荐系统"><a class="markdownIt-Anchor" href="#推荐系统"></a> 推荐系统</h3><ul><li>另一类与搜索和排名相关的问题是<em>推荐系统</em>（recommender system），它的目标是向给特定用户进行“个性化”推荐。</li><li>对于任何给定的用户，推荐系统都可以检索得分最高的对象集，然后将其推荐给用户。</li><li>推荐系统算法经过调整，可以捕捉一个人的偏好。</li></ul><h3 id="序列学习"><a class="markdownIt-Anchor" href="#序列学习"></a> 序列学习</h3><ul><li>序列学习需要摄取输入序列或预测输出序列，或两者兼而有之。具体来说，输入和输出都是可变长度的序列，例如机器翻译和从语音中转录文本。</li><li><strong>标记和解析</strong>。这涉及到用属性注释文本序列。换句话说，输入和输出的数量基本上是相同的。目标是基于结构和语法假设对文本进行分解和注释，以获得一些注释。<ul><li>下面是一个非常简单的示例，它使用标记来注释一个句子，该标记指示哪些单词引用命名实体(标记为“Ent”，是<em>实体</em>（entity）的简写)。</li></ul></li></ul><pre class="line-numbers language-text" data-language="text"><code class="language-text">Tom has dinner in Washington with SallyEnt  -    -    -     Ent      -    Ent</code></pre><ul><li><strong>自动语音识别</strong>。在语音识别中，输入序列是说话人的录音，输出序列是说话人所说内容的文本记录。它的挑战在于，与文本相比，音频帧多得多（声音通常以8kHz或16kHz采样）。也就是说，音频和文本之间没有1:1的对应关系，因为数千个样本可能对应于一个单独的单词。这也是“序列到序列”的学习问题，其中输出比输入短得多。</li><li><strong>文本到语音</strong>。这与自动语音识别相反。换句话说，输入是文本，输出是音频文件。在这种情况下，输出比输入长得多。</li><li><strong>机器翻译</strong>。在语音识别中，输入和输出的出现顺序基本相同。而在机器翻译中，颠倒输入和输出的顺序非常重要。换句话说，虽然我们仍将一个序列转换成另一个序列，但是输入和输出的数量以及相应序列的顺序大都不会相同。</li></ul><h2 id="无监督学习"><a class="markdownIt-Anchor" href="#无监督学习"></a> 无监督学习</h2><ul><li>我们称这类数据中不含有“目标”的机器学习问题为<em>无监督学习</em>（unsupervised learning），</li><li>**聚类（clustering）**问题：没有标签的情况下，我们是否能给数据分类呢？比如，给定一组照片，我们能把它们分成风景照片、狗、婴儿、猫和山峰的照片吗？同样，给定一组用户的网页浏览记录，我们能否将具有相似行为的用户聚类吗？</li><li>**主成分分析（principal component analysis）**问题：我们能否找到少量的参数来准确地捕捉数据的线性相关属性？比如，一个球的运动轨迹可以用球的速度、直径和质量来描述。再比如，裁缝们已经开发出了一小部分参数，这些参数相当准确地描述了人体的形状，以适应衣服的需要。</li><li>**因果关系（causality）<strong>和</strong>概率图模型（probabilistic graphical models）**问题：我们能否描述观察到的许多数据的根本原因？例如，如果我们有关于房价、污染、犯罪、地理位置、教育和工资的人口统计数据，我们能否简单地根据经验数据发现它们之间的关系？</li><li><em><em>生成对抗性网络</em>（generative adversarial networks）</em>*：为我们提供一种合成数据的方法，甚至像图像和音频这样复杂的结构化数据。潜在的统计机制是检查真实和虚假数据是否相同的测试，它是无监督学习的另一个重要而令人兴奋的领域。</li></ul><h2 id="强化学习"><a class="markdownIt-Anchor" href="#强化学习"></a> 强化学习</h2><ul><li>如果你对使用机器学习开发与环境交互并采取行动感兴趣，那么你最终可能会专注于<em>强化学习</em>（reinforcement learning）。这可能包括应用到机器人、对话系统，甚至开发视频游戏的人工智能（AI）。</li><li><strong>深度强化学习（deep reinforcement learning）</strong>:将深度学习应用于强化学习的问题，是非常热门的研究领域。</li><li>AlphaGo 程序在棋盘游戏围棋中击败了世界冠军，是两个突出强化学习的例子。</li><li>在强化学习问题中，agent 在一系列的时间步骤上与环境交互。在每个特定时间点，agent 从环境接收一些<em>观察</em>（observation），并且必须选择一个<em>动作</em>（action），然后通过某种机制（有时称为执行器）将其传输回环境，最后 agent 从环境中获得 <em>奖励</em>（reward）。此后新一轮循环开始，agent 接收后续观察，并选择后续操作，依此类推。请注意，强化学习的目标是产生一个好的<em>策略</em>（policy）。强化学习 agent 的选择的“动作”受策略控制，即一个从环境观察映射到行动的功能。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/SHgSpK.png" alt="SHgSpK" /></li><li>我们可以将任何监督学习问题转化为强化学习问题。假设我们有一个分类问题，我们可以创建一个强化学习agent，每个分类对应一个“动作”。然后，我们可以创建一个环境，该环境给予agent的奖励。这个奖励与原始监督学习问题的损失函数是一致的。</li><li>强化学习还可以解决许多监督学习无法解决的问题。例如，在监督学习中，我们总是希望输入与正确的标签相关联。但在强化学习中，我们并不假设环境告诉agent每个观测的最优动作。一般来说，agent只是得到一些奖励。</li><li>强化学习者必须处理<em>学分分配</em>（credit assignment）问题：决定哪些行为是值得奖励的，哪些行为是需要惩罚的。</li><li>强化学习可能还必须处理部分可观测性问题。也就是说，当前的观察结果可能无法阐述有关当前状态的所有信息。</li><li>当环境可被完全观察到时，我们将强化学习问题称为<em>马尔可夫决策过程</em>（markov decision process）。</li><li>当状态不依赖于之前的操作时，我们称该问题为<em>上下文赌博机</em>（contextual bandit problem）。</li><li>当没有状态，只有一组最初未知回报的可用动作时，这个问题就是经典的<em>多臂赌博机</em>（multi-armed bandit problem）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scikit-Learn工具包</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/Scikit-Learn%E5%B7%A5%E5%85%B7%E5%8C%85/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/Scikit-Learn%E5%B7%A5%E5%85%B7%E5%8C%85/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="scikit-learn概述"><a class="markdownIt-Anchor" href="#scikit-learn概述"></a> Scikit-Learn概述</h1><ul><li><p>Scikit-Learn是由DavidCournapeau 在2007 年发起的项目，是一种基于python的机器学习模块。</p></li><li><p>Scikit-Learn库已经实现了几乎所有常用的机器学习算法</p></li><li><p>通过conda安装Scikit-Learn库</p></li><li><p>Scikit-Learn库包含的算法：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211021085145.png" alt="" /></p></li></ul><h2 id="scikit-learn实现决策树算法"><a class="markdownIt-Anchor" href="#scikit-learn实现决策树算法"></a> Scikit-Learn实现决策树算法</h2><ul><li><p>决策树是直观运用概率分析的一种图解法。由于这种决策分支画成图形很像一棵树的枝干，故称决策树。决策树代表一类算法，C4.5是其中比较典型的一种算法。C4.5算法采用熵来选择属性，以构成决策分支；并采用后剪枝以抑制不必要的决策分支的生长。</p></li><li><p>conda安装pydotplus和python-graphviz两个包</p></li><li><p>scikit-learn库包含了可以使用的鸢尾花数据集iris</p></li><li><p>载入支持库</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">from sklearn import treefrom sklearn.datasets import load_irisfrom sklearn.metrics import accuracy_scorefrom sklearn.model_selection import train_test_splitimport pydotplus</code></pre><ul><li>准备数据</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">iris&#x3D;load_iris()# 特征iris_feature &#x3D; iris.data# 分类标签iris_label &#x3D; iris.target# 随机数据集划分，为了验证算法的正确性，需要将数据分成训练数据和测试数据X_train,X_test,Y_train,Y_test &#x3D; train_test_split(iris_feature,iris_label,test_size&#x3D;0.3,random_state&#x3D;30)</code></pre><ul><li>训练与测试</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 生成决策树clf&#x3D;tree.DecisionTreeClassifier()# 训练clf&#x3D;clf.fit(X_train,Y_train)# 预测predict&#x3D;clf.predict(X_test)</code></pre><ul><li>统计结果</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 查看测试数据的预测值与真实值print(predict)print(Y_test)# 获得预测准确率，本例是97.78%print(accuracy_score(predict,Y_test))</code></pre><pre><code>[0 0 0 2 1 1 2 2 1 2 0 2 1 1 0 1 0 0 0 1 2 0 0 0 2 2 2 2 0 1 2 1 2 2 2 2 1 2 1 2 2 2 0 1 2][0 0 0 2 1 1 2 2 1 2 0 2 1 1 0 1 0 0 0 1 2 0 0 0 2 2 1 2 0 1 2 1 2 2 2 2 1 2 1 2 2 2 0 1 2]0.9777777777777777</code></pre><ul><li>输出决策树图</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 输出结果图dot_data &#x3D; tree.export_graphviz(clf, out_file&#x3D;None,                          feature_names&#x3D;iris.feature_names,                           class_names&#x3D;iris.target_names,                           filled&#x3D;True, rounded&#x3D;True,                           special_characters&#x3D;True)graph &#x3D; pydotplus.graph_from_dot_data(dot_data)# 以pdf文件形式输出决策树图graph.write_pdf(&quot;irisresult.pdf&quot;)</code></pre><pre><code>True</code></pre><ul><li>决策树图：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211021090412.png" alt="" /></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 大数据 </tag>
            
            <tag> Scikit-Learn </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas工具包</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/Pandas%E5%B7%A5%E5%85%B7%E5%8C%85/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/Pandas%E5%B7%A5%E5%85%B7%E5%8C%85/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="pandas基本概念"><a class="markdownIt-Anchor" href="#pandas基本概念"></a> Pandas基本概念</h1><ul><li><p>Pandas工具包的数据结构可以按轴自动地或显式地对齐数据。</p></li><li><p>导入Pandas工具包。通常来说，但我们在一段代码中看到pd这一关键字时，就要考虑使用了Pandas这个工具包。</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pandas as pd</code></pre><ul><li>pandas主要的两个数据结构<code>Series</code>和<code>DataFrame</code></li></ul><h1 id="series"><a class="markdownIt-Anchor" href="#series"></a> Series</h1><ul><li><p>Series类似于一维数组，它由一组数据以及对应的数据标签（即索引）组成。</p></li><li><p>Series的字符串由两部分组成：左边是字符串的索引，右边是字符串的值。如果我们没有指定数据索引，Series就会自动地创建一个从0到N-1（N为数据的长度）的整型索引。</p></li><li><p>创建Series对象</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">series &#x3D; pd.Series([1, 2, 3, 4])series</code></pre><pre><code>0    11    22    33    4dtype: int64</code></pre><ul><li>左边的自动生成的索引，右边是值，可以分别查看Series对象的值和索引</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">series.values # 查看值</code></pre><pre><code>array([1, 2, 3, 4])</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">series.index # 查看索引</code></pre><pre><code>RangeIndex(start=0, stop=4, step=1)</code></pre><ul><li>可以手动设置索引</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">series2 &#x3D; pd.Series([1, 2, 3, 4], index&#x3D;[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])series2</code></pre><pre><code>a    1b    2c    3d    4dtype: int64</code></pre><ul><li>获取或者某个索引的对应的值</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(&quot;a: &quot;)print(series2[&#39;a&#39;])series2[&#39;b&#39;] &#x3D; -1print(&quot;b: &quot;)print(series2[&#39;b&#39;])</code></pre><pre><code>a: 1b: -1</code></pre><h1 id="dataframe"><a class="markdownIt-Anchor" href="#dataframe"></a> DataFrame</h1><ul><li><p>DataFrame是一种表格类型的数据结构，它含有一组有序的列。</p></li><li><p><strong>每一列可以是不同类型的值</strong>（例如数值、字符串、布尔值等）。</p></li><li><p>DataFrame既可以按行索引，也可以按列索引，因而可以被视为由Series组成的字典。与其他数据结构相比，DataFrame中对行操作和对列操作基本上是平衡的。</p></li><li><p>DataFrame可以自动加上索引（跟Series一样），且全部的列都会进行有序地排列</p></li><li><p>传入一个字典（元素是键值对）构建DataFrame</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">data &#x3D; &#123;&#39;state&#39;:[&#39;Zhang&#39;, &#39;Jie&#39;], &#39;year&#39;:[2000, 2001], &#39;pop&#39;:[1.1, 2.3]&#125;dataFrame &#x3D; pd.DataFrame(data)dataFrame</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>state</th>      <th>year</th>      <th>pop</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>Zhang</td>      <td>2000</td>      <td>1.1</td>    </tr>    <tr>      <th>1</th>      <td>Jie</td>      <td>2001</td>      <td>2.3</td>    </tr>  </tbody></table></div><ul><li>可以通过columns参数指定列的顺序</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">dataFrame2 &#x3D; pd.DataFrame(data, columns&#x3D;[&#39;pop&#39;, &#39;state&#39;, &#39;year&#39;])dataFrame2</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>pop</th>      <th>state</th>      <th>year</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>1.1</td>      <td>Zhang</td>      <td>2000</td>    </tr>    <tr>      <th>1</th>      <td>2.3</td>      <td>Jie</td>      <td>2001</td>    </tr>  </tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 大数据 </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy工具包</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/Numpy%E5%B7%A5%E5%85%B7%E5%8C%85/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/Numpy%E5%B7%A5%E5%85%B7%E5%8C%85/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="主要对象与其属性"><a class="markdownIt-Anchor" href="#主要对象与其属性"></a> 主要对象与其属性</h1><ul><li><p>NumPy的主要对象<code>ndarray</code>是同种元素的多维数组。在多维数组中，所有的元素都是一种类型的元素表格，且通过一个正整数下标进行索引。</p></li><li><p>创建一个ndarray对象，查看各个属性</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">from numpy import *a &#x3D; arange(15).reshape(3, 5)a</code></pre><pre><code>array([[ 0,  1,  2,  3,  4],       [ 5,  6,  7,  8,  9],       [10, 11, 12, 13, 14]])</code></pre><ul><li><code>ndarray.ndim</code>：该属性表示数组轴的个数。而在python语言中，轴的个数被称作秩。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a.ndim #有横纵两个轴，所以ndim属性为2</code></pre><pre><code>2</code></pre><ul><li><code>ndarray.shape</code>：该属性表示数组的维度，用来表示一个数组中各个维度上的大小。对于一个n行m列的矩阵，该属性的值为(n,m)。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a.shape # 3行5列的数组，结果应为(3, 5)</code></pre><pre><code>(3, 5)</code></pre><ul><li><code>ndarray.size</code>：该属性表示数组元素的总个数，等于属性中每个维度上元素个数的乘积。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a.size #总共有3*5&#x3D;15个元素</code></pre><pre><code>15</code></pre><ul><li><code>ndarray.dtype</code>：该属性表示数组中的元素类型，可以通过dtype来指定使用哪一种Python类型。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a.dtype # 该数组中元素的类型为int型</code></pre><pre><code>dtype('int32')</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">a.dtype.name # 直接显示类型</code></pre><pre><code>'int32'</code></pre><ul><li><code>ndarray.itemsize</code>：该属性表示数组每个元素的字节大小。例如，当一个元素的类型为float64时，数组itemsize的属性值即为8。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a.itemsize # 元素为int64型，itemsize属性值应为8</code></pre><pre><code>4</code></pre><h1 id="创建数组"><a class="markdownIt-Anchor" href="#创建数组"></a> 创建数组</h1><ul><li>通过<code>array</code>函数创建数组</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; array([2, 3, 4])a</code></pre><pre><code>array([2, 3, 4])</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">a.dtype</code></pre><pre><code>dtype('int32')</code></pre><ul><li>除此之外，我们还可以在创建数组类型时，可以将元素设置为特定的类型。例如，下面的例子中，数组可以设置为复数格式：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; array([[1, 2], [3, 4]], dtype&#x3D;complex)a</code></pre><pre><code>array([[1.+0.j, 2.+0.j],       [3.+0.j, 4.+0.j]])</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">a.dtype</code></pre><pre><code>dtype('complex128')</code></pre><ul><li>用<code>zeros()</code>函数创建一个全0的数组</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">z &#x3D; zeros((3, 4))z</code></pre><pre><code>array([[0., 0., 0., 0.],       [0., 0., 0., 0.],       [0., 0., 0., 0.]])</code></pre><ul><li>用函数<code>ones()</code>创建全1的数组</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">o &#x3D; ones((1, 2, 3), dtype&#x3D;int16)o</code></pre><pre><code>array([[[1, 1, 1],        [1, 1, 1]]], dtype=int16)</code></pre><ul><li>用<code>empty()</code>函数创建一个内容随机的数组</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">e &#x3D; empty((1, 2))e</code></pre><pre><code>array([[-2.74665012e-188,  1.34073553e-078]])</code></pre><ul><li>用<code>arange()</code>函数可以创建按照一定规则排列的数组，前两个参数是左闭右开的范围区间，第三个参数是步频(如果不设置则默认为1）,如果只有一个参数，则以这个参数为右边界，从0开始以1为步频。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; arange(10, 30, 5)a</code></pre><pre><code>array([10, 15, 20, 25])</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; arange(10, 15)a</code></pre><pre><code>array([10, 11, 12, 13, 14])</code></pre><h1 id="打印数组"><a class="markdownIt-Anchor" href="#打印数组"></a> 打印数组</h1><ul><li><p>在打印一个数组时，NumPy的展示形式类似于嵌套列表，但呈现出以下特点的布局：</p><ul><li>从左到右打印最后的轴</li><li>从顶向下打印次后的轴</li><li>从顶向下打印剩下的轴，每个切片通过一个空行与下一个切片隔开</li></ul></li><li><p>一维数组以行的形式打印出来，二维数组以矩阵的形式打印出来，三维数以矩阵列表的形式打印出来。</p></li><li><p>一维数组</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; arange(6)print(a)</code></pre><pre><code>[0 1 2 3 4 5]</code></pre><ul><li>二维数组</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; arange(6).reshape(2, 3)print(a)</code></pre><pre><code>[[0 1 2] [3 4 5]]</code></pre><ul><li>三维数组</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; arange(24).reshape(2, 3, 4) # 最后一个轴有4个元素，从左到右打印；次后的轴上有3个元素，从顶向下打印；之后的轴有2个元素，从顶向下打印print(a)</code></pre><pre><code>[[[ 0  1  2  3]  [ 4  5  6  7]  [ 8  9 10 11]] [[12 13 14 15]  [16 17 18 19]  [20 21 22 23]]]</code></pre><h1 id="数组的操作"><a class="markdownIt-Anchor" href="#数组的操作"></a> 数组的操作</h1><h2 id="数组的基本运算"><a class="markdownIt-Anchor" href="#数组的基本运算"></a> 数组的基本运算</h2><ul><li>数组可以直接进行加减乘除等操作，但是数组的元素是元素之间一一对应进行运算的，所以进行运算的数组的形状必须是一样的。</li><li>一般运算并不改变数组本身，而是创建了一个新的数组</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; array([1, 2, 3, 4, 5])b &#x3D; arange(5)c &#x3D; a - bprint(a)print(b)print(c)</code></pre><pre><code>[1 2 3 4 5][0 1 2 3 4][1 1 1 1 1]</code></pre><ul><li>假如数组形状不一样进行运算，会直接报错</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; array([1, 2])b &#x3D; arange(4)c &#x3D; a - b</code></pre><pre><code>---------------------------------------------------------------------------ValueError                                Traceback (most recent call last)&lt;ipython-input-21-8e1e5c30d648&gt; in &lt;module&gt;      1 a = array([1, 2])      2 b = arange(4)----&gt; 3 c = a - bValueError: operands could not be broadcast together with shapes (2,) (4,) </code></pre><ul><li>进行乘法运算</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; arange(3)b &#x3D; a * 2print(a)print(b)</code></pre><pre><code>[0 1 2][0 2 4]</code></pre><ul><li>进行三角运算</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; arange(2)b &#x3D; 10 * sin(a)print(a)print(b)</code></pre><pre><code>[0 1][0.         8.41470985]</code></pre><ul><li>进行比较运算</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; arange(5, 20, 5)b &#x3D; a &lt; 15print(a)print(b)</code></pre><pre><code>[ 5 10 15][ True  True False]</code></pre><ul><li>矩阵乘积：因为数组之间的乘积是通过元素对应相乘完成的，所以矩阵乘积需要使用特殊的函数<code>dot()</code>来实现</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; array([[1, 1], [0, 1]])b &#x3D; array([[2, 0], [3, 4]])c &#x3D; dot(a, b)print(a)print(b)print(c)</code></pre><pre><code>[[1 1] [0 1]][[2 0] [3 4]][[5 4] [3 4]]</code></pre><ul><li>当多种类型数组进行计算时，结果得到的数组通常采用更精确的值，这种行为叫做upcast。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; ones(3, dtype&#x3D;int32)b &#x3D; arange(0, 0.3, 0.1)c &#x3D; a - bprint(a)print(b)print(c)</code></pre><pre><code>[1 1 1][0.  0.1 0.2][1.  0.9 0.8]</code></pre><ul><li>可以改变数组自身的运算，如<code>+=</code>、<code>*=</code>等</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; ones((2, 3))print(a)</code></pre><pre><code>[[1. 1. 1.] [1. 1. 1.]]</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">a *&#x3D; 3print(a)</code></pre><pre><code>[[3. 3. 3.] [3. 3. 3.]]</code></pre><h2 id="数组的复制和视图"><a class="markdownIt-Anchor" href="#数组的复制和视图"></a> 数组的复制和视图</h2><ul><li><p>数组的复制有三种情况：</p><ul><li>完全不拷贝：简单的对数组对象进行赋值，就像引用赋值一样</li><li>视图（浅复制）：视图对象使用数组对象的数据（不拷贝数据），可以对数据的表现形式进行组织，如果通过视图修改数据，则原数组的数据也会改变（数据还是使用的原来的， 没有拷贝），通过数组对象ndarray的<code>view()</code>方法生成一个数组的视图</li><li>深复制：完全复制一个数组的数据，创建一个相同数据的数组、通过数组对象ndarray的<code>copy()</code>方法来完全拷贝一个数组的数据生成一个新的数组对象</li></ul></li><li><p>完全不拷贝示例：</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; arange(12)b &#x3D; a # 没有创建新的数组对象而直接赋值b is a # a b就是相同数组对象的两个名字，是完全等价的</code></pre><pre><code>True</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">b.shape&#x3D;3, 4 # 对b进行形状改变，a的形状也会改变，因为二者指向同一个对象a</code></pre><pre><code>array([[ 0,  1,  2,  3],       [ 4,  5,  6,  7],       [ 8,  9, 10, 11]])</code></pre><ul><li>视图（浅复制）示例：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; arange(12)c &#x3D; a.view() # 创建a数组的视图对象c is a # c 与 a 不是同一个对象的两个名字</code></pre><pre><code>False</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">c.base is a # 通过base参数来获知c是a的一个视图</code></pre><pre><code>True</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">c.shape &#x3D; 3, 4 # 修改的c的形状不会影响到原数组aa</code></pre><pre><code>array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">c[0,1] &#x3D; -1 # 修改c的数据会影响原数组的a的数据a</code></pre><pre><code>array([ 0, -1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</code></pre><ul><li>深复制示例：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; arange(4)d &#x3D; a.copy()d is a</code></pre><pre><code>False</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">d.shape &#x3D; 2, 2 # a和d是完全不相关的两个对象，修改d的形状或者数据都对a毫无影响d[0,0] &#x3D; -1print(&quot;d:&quot;)print(d)print(&quot;a:&quot;)print(a)</code></pre><pre><code>d:[[-1  1] [ 2  3]]a:[0 1 2 3]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 大数据 </tag>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据处理技术</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/Python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/Python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="合并数据集"><a class="markdownIt-Anchor" href="#合并数据集"></a> 合并数据集</h1><h2 id="索引上的合并"><a class="markdownIt-Anchor" href="#索引上的合并"></a> 索引上的合并</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pandas as pdimport numpy as np</code></pre><ul><li>连接的方法：<ul><li>通过列与索引合并</li><li>通过索引和索引合并</li><li>复合索引和多个列来合并</li></ul></li></ul><h3 id="生成索引的两种方式"><a class="markdownIt-Anchor" href="#生成索引的两种方式"></a> 生成索引的两种方式</h3><ul><li>构建数据表（DataFrame）自动生成索引：使用pandas库的DataFrame对象，花括号中以键值对的形式，给出列名和值，索引会自动按序生成</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">left1 &#x3D; pd.DataFrame(&#123;&#39;key&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;,&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], &#39;value&#39;: range(6)&#125;)left1</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>key</th>      <th>value</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>a</td>      <td>0</td>    </tr>    <tr>      <th>1</th>      <td>b</td>      <td>1</td>    </tr>    <tr>      <th>2</th>      <td>a</td>      <td>2</td>    </tr>    <tr>      <th>3</th>      <td>a</td>      <td>3</td>    </tr>    <tr>      <th>4</th>      <td>b</td>      <td>4</td>    </tr>    <tr>      <th>5</th>      <td>c</td>      <td>5</td>    </tr>  </tbody></table></div><ul><li>可以通过设置index参数来指定索引创造DataFrame对象</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">right1 &#x3D; pd.DataFrame(&#123;&#39;group_val&#39;:[3.5, 7]&#125;, index&#x3D;[&#39;a&#39;, &#39;b&#39;])right1</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>group_val</th>    </tr>  </thead>  <tbody>    <tr>      <th>a</th>      <td>3.5</td>    </tr>    <tr>      <th>b</th>      <td>7.0</td>    </tr>  </tbody></table></div><h3 id="连接的模式"><a class="markdownIt-Anchor" href="#连接的模式"></a> 连接的模式</h3><ul><li>根据索引和列来合并两个表，使用<code>merge()</code>函数，参数依次为：左表（DataFrame对象)，右表，left_on参数指定左表的某一列用于合并，right_index参数指定使用右表的索引来合并（因为索引是唯一的，所以直接设置True或false即可），同理也有right_on和left_index参数，只是left_on和left_index参数不能同时使用</li><li>内连接：<code>merge()</code>函数的默认方式，求两张表的交集</li><li>外连接：求两种表的并集，如果有的元素，一个表有而另一个表没有，则在代表另一个表值的列使用<code>NaN</code>填充</li></ul><h4 id="内连接"><a class="markdownIt-Anchor" href="#内连接"></a> 内连接</h4><ul><li>内连接的使用示例：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">merge1 &#x3D; pd.merge(left1, right1, left_on&#x3D;&#39;key&#39;, right_index&#x3D;True)merge1</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>key</th>      <th>value</th>      <th>group_val</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>a</td>      <td>0</td>      <td>3.5</td>    </tr>    <tr>      <th>2</th>      <td>a</td>      <td>2</td>      <td>3.5</td>    </tr>    <tr>      <th>3</th>      <td>a</td>      <td>3</td>      <td>3.5</td>    </tr>    <tr>      <th>1</th>      <td>b</td>      <td>1</td>      <td>7.0</td>    </tr>    <tr>      <th>4</th>      <td>b</td>      <td>4</td>      <td>7.0</td>    </tr>  </tbody></table></div><h4 id="外连接"><a class="markdownIt-Anchor" href="#外连接"></a> 外连接</h4><ul><li>外连接：求两张表的并集,<code>merge()</code>函数需要设置<code>how</code>参数来启动外连接模式</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">merge2 &#x3D; pd.merge(left1, right1, left_on&#x3D;&#39;key&#39;, right_index&#x3D;True,how&#x3D;&#39;outer&#39;)merge2</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>key</th>      <th>value</th>      <th>group_val</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>a</td>      <td>0</td>      <td>3.5</td>    </tr>    <tr>      <th>2</th>      <td>a</td>      <td>2</td>      <td>3.5</td>    </tr>    <tr>      <th>3</th>      <td>a</td>      <td>3</td>      <td>3.5</td>    </tr>    <tr>      <th>1</th>      <td>b</td>      <td>1</td>      <td>7.0</td>    </tr>    <tr>      <th>4</th>      <td>b</td>      <td>4</td>      <td>7.0</td>    </tr>    <tr>      <th>5</th>      <td>c</td>      <td>5</td>      <td>NaN</td>    </tr>  </tbody></table></div><h4 id="通过复合索引合并"><a class="markdownIt-Anchor" href="#通过复合索引合并"></a> 通过复合索引合并</h4><ul><li><p>通过复合索引和两个列来合并</p><ul><li>通过自动生成索引创建左表</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">lefth &#x3D; pd.DataFrame(&#123;&#39;key1&#39;: [&#39;Ohio&#39;, &#39;Ohio&#39;, &#39;Ohio&#39;, &#39;Nevada&#39;, &#39;Nevada&#39;], &#39;key2&#39;: [2000, 2001, 2002, 2001, 2002],                       &#39;data&#39;: np.arange(5a)&#125;)lefth</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>key1</th>      <th>key2</th>      <th>data</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>Ohio</td>      <td>2000</td>      <td>0</td>    </tr>    <tr>      <th>1</th>      <td>Ohio</td>      <td>2001</td>      <td>1</td>    </tr>    <tr>      <th>2</th>      <td>Ohio</td>      <td>2002</td>      <td>2</td>    </tr>    <tr>      <th>3</th>      <td>Nevada</td>      <td>2001</td>      <td>3</td>    </tr>    <tr>      <th>4</th>      <td>Nevada</td>      <td>2002</td>      <td>4</td>    </tr>  </tbody></table></div><ul><li>​指定两个列作为复合索引</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">righth &#x3D; pd.DataFrame(np.arange(6*2).reshape(6, 2), index &#x3D; [[&#39;Nevada&#39;, &#39;Nevada&#39;, &#39;Ohio&#39;, &#39;Ohio&#39;, &#39;Ohio&#39;, &#39;Ohio&#39;],                                                             [2001, 2000, 2000, 2000, 2001, 2002]],                     columns&#x3D;[&#39;event1&#39;, &#39;event2&#39;])righth</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th></th>      <th>event1</th>      <th>event2</th>    </tr>  </thead>  <tbody>    <tr>      <th rowspan="2" valign="top">Nevada</th>      <th>2001</th>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>2000</th>      <td>2</td>      <td>3</td>    </tr>    <tr>      <th rowspan="4" valign="top">Ohio</th>      <th>2000</th>      <td>4</td>      <td>5</td>    </tr>    <tr>      <th>2000</th>      <td>6</td>      <td>7</td>    </tr>    <tr>      <th>2001</th>      <td>8</td>      <td>9</td>    </tr>    <tr>      <th>2002</th>      <td>10</td>      <td>11</td>    </tr>  </tbody></table></div><ul><li>使用<code>merge()</code>函数内连接两个表</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">merge3 &#x3D; pd.merge(lefth, righth, left_on&#x3D;[&#39;key1&#39;, &#39;key2&#39;], right_index&#x3D;True)merge3</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>key1</th>      <th>key2</th>      <th>data</th>      <th>event1</th>      <th>event2</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>Ohio</td>      <td>2000</td>      <td>0</td>      <td>4</td>      <td>5</td>    </tr>    <tr>      <th>0</th>      <td>Ohio</td>      <td>2000</td>      <td>0</td>      <td>6</td>      <td>7</td>    </tr>    <tr>      <th>1</th>      <td>Ohio</td>      <td>2001</td>      <td>1</td>      <td>8</td>      <td>9</td>    </tr>    <tr>      <th>2</th>      <td>Ohio</td>      <td>2002</td>      <td>2</td>      <td>10</td>      <td>11</td>    </tr>    <tr>      <th>3</th>      <td>Nevada</td>      <td>2001</td>      <td>3</td>      <td>0</td>      <td>1</td>    </tr>  </tbody></table></div><ul><li>结果分析：因为Nevada 2000这个组合在左表中存在而在右表中不存在，所以在合并表中并没有出现</li></ul><hr /><ul><li>让两个表都使用索引来合并</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">left2 &#x3D; pd.DataFrame([[1., 2.,], [3., 4.], [5., 6.]], index&#x3D;[&#39;a&#39;, &#39;c&#39;, &#39;e&#39;],                      columns&#x3D;[&#39;Ohio&#39;, &#39;Nevada&#39;])left2</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Ohio</th>      <th>Nevada</th>    </tr>  </thead>  <tbody>    <tr>      <th>a</th>      <td>1.0</td>      <td>2.0</td>    </tr>    <tr>      <th>c</th>      <td>3.0</td>      <td>4.0</td>    </tr>    <tr>      <th>e</th>      <td>5.0</td>      <td>6.0</td>    </tr>  </tbody></table></div><pre class="line-numbers language-python" data-language="python"><code class="language-python">right2 &#x3D; pd.DataFrame([[7., 8.], [9., 10.], [11., 12.], [13., 14.]], index&#x3D;[&#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;],                       columns&#x3D;[&#39;Missouri&#39;, &#39;Alabama&#39;])right2</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Missouri</th>      <th>Alabama</th>    </tr>  </thead>  <tbody>    <tr>      <th>b</th>      <td>7.0</td>      <td>8.0</td>    </tr>    <tr>      <th>c</th>      <td>9.0</td>      <td>10.0</td>    </tr>    <tr>      <th>d</th>      <td>11.0</td>      <td>12.0</td>    </tr>    <tr>      <th>e</th>      <td>13.0</td>      <td>14.0</td>    </tr>  </tbody></table></div><pre class="line-numbers language-python" data-language="python"><code class="language-python">merge4 &#x3D; pd.merge(left2, right2, left_index &#x3D; True, right_index &#x3D; True)merge4</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Ohio</th>      <th>Nevada</th>      <th>Missouri</th>      <th>Alabama</th>    </tr>  </thead>  <tbody>    <tr>      <th>c</th>      <td>3.0</td>      <td>4.0</td>      <td>9.0</td>      <td>10.0</td>    </tr>    <tr>      <th>e</th>      <td>5.0</td>      <td>6.0</td>      <td>13.0</td>      <td>14.0</td>    </tr>  </tbody></table></div><hr /><h4 id="通过join函数连接"><a class="markdownIt-Anchor" href="#通过join函数连接"></a> 通过join函数连接</h4><ul><li>通过<code>join</code>函数来合并：<ul><li>有主表：左表-&gt;所以默认左连接（左表的都保留，右表和左表相同索引的才保留，右表不存在的用<code>NaN</code>填充）</li><li>同样可以通过<code>how</code>参数来设置连接方式</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">merge5 &#x3D; left2.join(right2)merge5</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Ohio</th>      <th>Nevada</th>      <th>Missouri</th>      <th>Alabama</th>    </tr>  </thead>  <tbody>    <tr>      <th>a</th>      <td>1.0</td>      <td>2.0</td>      <td>NaN</td>      <td>NaN</td>    </tr>    <tr>      <th>c</th>      <td>3.0</td>      <td>4.0</td>      <td>9.0</td>      <td>10.0</td>    </tr>    <tr>      <th>e</th>      <td>5.0</td>      <td>6.0</td>      <td>13.0</td>      <td>14.0</td>    </tr>  </tbody></table></div><ul><li>可以通过<code>on</code>参数来使用左表的特定列来合并</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">merge6 &#x3D; lefth.join(righth, on&#x3D;[&#39;key1&#39;, &#39;key2&#39;])merge6</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>key1</th>      <th>key2</th>      <th>data</th>      <th>event1</th>      <th>event2</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>Ohio</td>      <td>2000</td>      <td>0</td>      <td>4.0</td>      <td>5.0</td>    </tr>    <tr>      <th>0</th>      <td>Ohio</td>      <td>2000</td>      <td>0</td>      <td>6.0</td>      <td>7.0</td>    </tr>    <tr>      <th>1</th>      <td>Ohio</td>      <td>2001</td>      <td>1</td>      <td>8.0</td>      <td>9.0</td>    </tr>    <tr>      <th>2</th>      <td>Ohio</td>      <td>2002</td>      <td>2</td>      <td>10.0</td>      <td>11.0</td>    </tr>    <tr>      <th>3</th>      <td>Nevada</td>      <td>2001</td>      <td>3</td>      <td>0.0</td>      <td>1.0</td>    </tr>    <tr>      <th>4</th>      <td>Nevada</td>      <td>2002</td>      <td>4</td>      <td>NaN</td>      <td>NaN</td>    </tr>  </tbody></table></div><hr /><h4 id="轴向连接"><a class="markdownIt-Anchor" href="#轴向连接"></a> 轴向连接</h4><ul><li>轴向连接：将多个同样的表合并为一个表（增加行数）concatennation<ul><li>使用Numpy的函数<code>concatenate()</code></li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">arr &#x3D; np.arange(12).reshape(3, 4)arr</code></pre><pre><code>array([[ 0,  1,  2,  3],       [ 4,  5,  6,  7],       [ 8,  9, 10, 11]])</code></pre><ul><li>使用<code>concatenate()</code>函数横向或纵向合并两个arr</li><li>通过<code>axis</code>参数来控制合并的方向</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">arr1 &#x3D; np.concatenate([arr, arr], axis&#x3D;1) # 横向合并arr1</code></pre><pre><code>array([[ 0,  1,  2,  3,  0,  1,  2,  3],       [ 4,  5,  6,  7,  4,  5,  6,  7],       [ 8,  9, 10, 11,  8,  9, 10, 11]])</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">arr2 &#x3D; np.concatenate([arr, arr], axis&#x3D;0) # 纵向合并arr2</code></pre><pre><code>array([[ 0,  1,  2,  3],       [ 4,  5,  6,  7],       [ 8,  9, 10, 11],       [ 0,  1,  2,  3],       [ 4,  5,  6,  7],       [ 8,  9, 10, 11]])</code></pre><h3 id="合并重叠数据"><a class="markdownIt-Anchor" href="#合并重叠数据"></a> 合并重叠数据</h3><ul><li>创建两个列一致，部分数据一致的一位序列Series</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; pd.Series([np.nan, 2.5, np.nan, 3.5, 4.5, np.nan], index&#x3D;[&#39;f&#39;, &#39;e&#39;, &#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;])a</code></pre><pre><code>f    NaNe    2.5d    NaNc    3.5b    4.5a    NaNdtype: float64</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">b &#x3D; pd.Series(np.arange(len(a), dtype&#x3D;np.float64), index&#x3D;[&#39;f&#39;, &#39;e&#39;, &#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;])b[-1] &#x3D; np.nan #-1下标指代序列的最后一位元素b</code></pre><pre><code>f    0.0e    1.0d    2.0c    3.0b    4.0a    NaNdtype: float64</code></pre><ul><li>合并两个数据集，以a表为标准，a表中存在的数据保持原样，a表中不存在（NaN）的数据从b中合并过来</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">c &#x3D; np.where(pd.isnull(a), b, a) # 当a为空时取b的值，否则取a的值c</code></pre><pre><code>array([0. , 2.5, 2. , 3.5, 4.5, nan])</code></pre><h1 id="数据转换"><a class="markdownIt-Anchor" href="#数据转换"></a> 数据转换</h1><h2 id="移除重复数据"><a class="markdownIt-Anchor" href="#移除重复数据"></a> 移除重复数据</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">data &#x3D; pd.DataFrame(&#123;&#39;k1&#39;:[&#39;one&#39;]*3+[&#39;two&#39;]*4, &#39;k2&#39;:[1,1,2,3,3,4,4]&#125;)data</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>k1</th>      <th>k2</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>one</td>      <td>1</td>    </tr>    <tr>      <th>1</th>      <td>one</td>      <td>1</td>    </tr>    <tr>      <th>2</th>      <td>one</td>      <td>2</td>    </tr>    <tr>      <th>3</th>      <td>two</td>      <td>3</td>    </tr>    <tr>      <th>4</th>      <td>two</td>      <td>3</td>    </tr>    <tr>      <th>5</th>      <td>two</td>      <td>4</td>    </tr>    <tr>      <th>6</th>      <td>two</td>      <td>4</td>    </tr>  </tbody></table></div><ul><li>使用DataFrame对象的<code>duplicated()</code>函数检测是否重复行（是为true），返回一个Series对象</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">dup &#x3D; data.duplicated()dup</code></pre><pre><code>0    False1     True2    False3    False4     True5    False6     Truedtype: bool</code></pre><ul><li><code>drop_duplicates()</code>方法去重, 可以指定用于比较是否相同的某一(或多）列（不一定完全重复),默认保留index最小的行，可以通过设置<code>keep='last'</code>参数保留index最大的数据</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">nodup &#x3D; data.drop_duplicates(keep&#x3D;&#39;last&#39;)nodup</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>k1</th>      <th>k2</th>    </tr>  </thead>  <tbody>    <tr>      <th>1</th>      <td>one</td>      <td>1</td>    </tr>    <tr>      <th>2</th>      <td>one</td>      <td>2</td>    </tr>    <tr>      <th>4</th>      <td>two</td>      <td>3</td>    </tr>    <tr>      <th>6</th>      <td>two</td>      <td>4</td>    </tr>  </tbody></table></div><ul><li>给data添加一列</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">data[&#39;v1&#39;] &#x3D; range(7)data</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>k1</th>      <th>k2</th>      <th>v1</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>one</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>1</th>      <td>one</td>      <td>1</td>      <td>1</td>    </tr>    <tr>      <th>2</th>      <td>one</td>      <td>2</td>      <td>2</td>    </tr>    <tr>      <th>3</th>      <td>two</td>      <td>3</td>      <td>3</td>    </tr>    <tr>      <th>4</th>      <td>two</td>      <td>3</td>      <td>4</td>    </tr>    <tr>      <th>5</th>      <td>two</td>      <td>4</td>      <td>5</td>    </tr>    <tr>      <th>6</th>      <td>two</td>      <td>4</td>      <td>6</td>    </tr>  </tbody></table></div><ul><li>可以指定通过具体哪些列来判断是否重复</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">nodup2 &#x3D; data.drop_duplicates([&#39;k1&#39;, &#39;k2&#39;], keep&#x3D;&#39;last&#39;)nodup2</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>k1</th>      <th>k2</th>      <th>v1</th>    </tr>  </thead>  <tbody>    <tr>      <th>1</th>      <td>one</td>      <td>1</td>      <td>1</td>    </tr>    <tr>      <th>2</th>      <td>one</td>      <td>2</td>      <td>2</td>    </tr>    <tr>      <th>4</th>      <td>two</td>      <td>3</td>      <td>4</td>    </tr>    <tr>      <th>6</th>      <td>two</td>      <td>4</td>      <td>6</td>    </tr>  </tbody></table></div><h2 id="数据替换"><a class="markdownIt-Anchor" href="#数据替换"></a> 数据替换</h2><ul><li>定义一个series</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">data &#x3D; pd.Series([1., -999, 2., -1000, 3.])data</code></pre><pre><code>0       1.01    -999.02       2.03   -1000.04       3.0dtype: float64</code></pre><ul><li>通过<code>replace()</code>方法将-999替换为NaN</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">data.replace(-999, np.nan)</code></pre><pre><code>0       1.01       NaN2       2.03   -1000.04       3.0dtype: float64</code></pre><ul><li>可以同时替换多个值，例如将-999和-1000同时替换为NaN</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">data.replace([-999, -1000], np.nan)</code></pre><pre><code>0    1.01    NaN2    2.03    NaN4    3.0dtype: float64</code></pre><ul><li>可以实现不同的值对应替换替换为不同的值,例如将-999替换为NaN，-1000替换为0</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">data.replace([-999, -1000], [np.nan, 0])</code></pre><pre><code>0    1.01    NaN2    2.03    0.04    3.0dtype: float64</code></pre><h2 id="检测异常值"><a class="markdownIt-Anchor" href="#检测异常值"></a> 检测异常值</h2><ul><li>创建一个含有正态分布数据的DataFrame, 通过DataFrame对象的<code>describe()</code>方法来获取统计特征值</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">data &#x3D; pd.DataFrame(np.random.randn(1000, 4))data.describe()</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>0</th>      <th>1</th>      <th>2</th>      <th>3</th>    </tr>  </thead>  <tbody>    <tr>      <th>count</th>      <td>1000.000000</td>      <td>1000.000000</td>      <td>1000.000000</td>      <td>1000.000000</td>    </tr>    <tr>      <th>mean</th>      <td>0.013166</td>      <td>-0.000481</td>      <td>-0.030189</td>      <td>-0.009518</td>    </tr>    <tr>      <th>std</th>      <td>0.976413</td>      <td>1.016713</td>      <td>0.997048</td>      <td>1.008174</td>    </tr>    <tr>      <th>min</th>      <td>-3.016676</td>      <td>-3.162513</td>      <td>-3.282324</td>      <td>-3.535175</td>    </tr>    <tr>      <th>25%</th>      <td>-0.649836</td>      <td>-0.688303</td>      <td>-0.703782</td>      <td>-0.698088</td>    </tr>    <tr>      <th>50%</th>      <td>0.004212</td>      <td>0.011474</td>      <td>0.009120</td>      <td>-0.001872</td>    </tr>    <tr>      <th>75%</th>      <td>0.695183</td>      <td>0.679623</td>      <td>0.639148</td>      <td>0.649286</td>    </tr>    <tr>      <th>max</th>      <td>4.407439</td>      <td>4.139005</td>      <td>2.763371</td>      <td>3.721676</td>    </tr>  </tbody></table></div><ul><li>选出含有大于3或者小于-3的值的行</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">data[(np.abs(data) &gt;3).any(1)]</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>0</th>      <th>1</th>      <th>2</th>      <th>3</th>    </tr>  </thead>  <tbody>    <tr>      <th>38</th>      <td>-0.795664</td>      <td>-0.330065</td>      <td>-3.016717</td>      <td>2.120561</td>    </tr>    <tr>      <th>50</th>      <td>-0.629000</td>      <td>0.860827</td>      <td>-0.125433</td>      <td>-3.535175</td>    </tr>    <tr>      <th>79</th>      <td>-0.544495</td>      <td>-1.288971</td>      <td>-3.029938</td>      <td>0.279044</td>    </tr>    <tr>      <th>113</th>      <td>-3.016676</td>      <td>0.869205</td>      <td>-1.010988</td>      <td>-0.573853</td>    </tr>    <tr>      <th>254</th>      <td>4.407439</td>      <td>1.526187</td>      <td>-1.255663</td>      <td>-0.069301</td>    </tr>    <tr>      <th>276</th>      <td>-0.646509</td>      <td>-2.390895</td>      <td>1.456119</td>      <td>-3.337455</td>    </tr>    <tr>      <th>308</th>      <td>1.139149</td>      <td>4.139005</td>      <td>-1.131373</td>      <td>0.575723</td>    </tr>    <tr>      <th>493</th>      <td>3.189728</td>      <td>0.442730</td>      <td>-1.561426</td>      <td>0.402213</td>    </tr>    <tr>      <th>509</th>      <td>0.267529</td>      <td>-3.162513</td>      <td>1.107551</td>      <td>-1.028598</td>    </tr>    <tr>      <th>535</th>      <td>-0.679389</td>      <td>3.022345</td>      <td>-0.983833</td>      <td>0.965855</td>    </tr>    <tr>      <th>758</th>      <td>-0.182049</td>      <td>0.552248</td>      <td>1.448889</td>      <td>3.721676</td>    </tr>    <tr>      <th>841</th>      <td>1.724263</td>      <td>1.075039</td>      <td>-3.282324</td>      <td>1.537926</td>    </tr>    <tr>      <th>895</th>      <td>-1.313186</td>      <td>3.063947</td>      <td>0.154505</td>      <td>1.813358</td>    </tr>    <tr>      <th>931</th>      <td>1.180028</td>      <td>3.300766</td>      <td>-0.809880</td>      <td>-1.084533</td>    </tr>    <tr>      <th>933</th>      <td>-0.037565</td>      <td>0.175728</td>      <td>-3.255756</td>      <td>1.189677</td>    </tr>  </tbody></table></div><ul><li>将选出的行的异常值用3或者-3替换</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">data[np.abs(data) &gt; 3] &#x3D; np.sign(data) * 3data.describe()</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>0</th>      <th>1</th>      <th>2</th>      <th>3</th>    </tr>  </thead>  <tbody>    <tr>      <th>count</th>      <td>1000.000000</td>      <td>1000.000000</td>      <td>1000.000000</td>      <td>1000.000000</td>    </tr>    <tr>      <th>mean</th>      <td>0.011585</td>      <td>-0.001845</td>      <td>-0.029604</td>      <td>-0.009367</td>    </tr>    <tr>      <th>std</th>      <td>0.970417</td>      <td>1.011010</td>      <td>0.995229</td>      <td>1.002956</td>    </tr>    <tr>      <th>min</th>      <td>-3.000000</td>      <td>-3.000000</td>      <td>-3.000000</td>      <td>-3.000000</td>    </tr>    <tr>      <th>25%</th>      <td>-0.649836</td>      <td>-0.688303</td>      <td>-0.703782</td>      <td>-0.698088</td>    </tr>    <tr>      <th>50%</th>      <td>0.004212</td>      <td>0.011474</td>      <td>0.009120</td>      <td>-0.001872</td>    </tr>    <tr>      <th>75%</th>      <td>0.695183</td>      <td>0.679623</td>      <td>0.639148</td>      <td>0.649286</td>    </tr>    <tr>      <th>max</th>      <td>3.000000</td>      <td>3.000000</td>      <td>2.763371</td>      <td>3.000000</td>    </tr>  </tbody></table></div><h1 id="排列和随机采样"><a class="markdownIt-Anchor" href="#排列和随机采样"></a> 排列和随机采样</h1><ul><li><p>使用<code>permutation()</code>函数可以实现对series或者DataFreame对象的随机排列工作。</p></li><li><p>先生成一个五行4列的矩阵</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">df &#x3D; pd.DataFrame(np.arange(5 * 4).reshape(5, 4))df</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>0</th>      <th>1</th>      <th>2</th>      <th>3</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>0</td>      <td>1</td>      <td>2</td>      <td>3</td>    </tr>    <tr>      <th>1</th>      <td>4</td>      <td>5</td>      <td>6</td>      <td>7</td>    </tr>    <tr>      <th>2</th>      <td>8</td>      <td>9</td>      <td>10</td>      <td>11</td>    </tr>    <tr>      <th>3</th>      <td>12</td>      <td>13</td>      <td>14</td>      <td>15</td>    </tr>    <tr>      <th>4</th>      <td>16</td>      <td>17</td>      <td>18</td>      <td>19</td>    </tr>  </tbody></table></div><ul><li>再生成一个随机排列的5位数组，用于按这个顺序打乱矩阵</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">sampler &#x3D; np.random.permutation(5)sampler</code></pre><pre><code>array([3, 2, 0, 4, 1])</code></pre><ul><li>按照sampler排列的顺序排列矩阵，因为sampler是随机排列的，所以实现了打乱矩阵，随机采样的效果</li><li><code>take()</code>函数可以实现按照特定序列实现矩阵的行调换的功能</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">df.take(sampler)</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>0</th>      <th>1</th>      <th>2</th>      <th>3</th>    </tr>  </thead>  <tbody>    <tr>      <th>3</th>      <td>12</td>      <td>13</td>      <td>14</td>      <td>15</td>    </tr>    <tr>      <th>2</th>      <td>8</td>      <td>9</td>      <td>10</td>      <td>11</td>    </tr>    <tr>      <th>0</th>      <td>0</td>      <td>1</td>      <td>2</td>      <td>3</td>    </tr>    <tr>      <th>4</th>      <td>16</td>      <td>17</td>      <td>18</td>      <td>19</td>    </tr>    <tr>      <th>1</th>      <td>4</td>      <td>5</td>      <td>6</td>      <td>7</td>    </tr>  </tbody></table></div><ul><li>合并实现，并只取出3行数据</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">df.take(np.random.permutation(len(df))[:3])</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>0</th>      <th>1</th>      <th>2</th>      <th>3</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>0</td>      <td>1</td>      <td>2</td>      <td>3</td>    </tr>    <tr>      <th>3</th>      <td>12</td>      <td>13</td>      <td>14</td>      <td>15</td>    </tr>    <tr>      <th>4</th>      <td>16</td>      <td>17</td>      <td>18</td>      <td>19</td>    </tr>  </tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据库连接与操作</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/Python%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E4%B8%8E%E6%93%8D%E4%BD%9C/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/Python%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E4%B8%8E%E6%93%8D%E4%BD%9C/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据库的连接"><a class="markdownIt-Anchor" href="#数据库的连接"></a> 数据库的连接</h1><ul><li>引入数据库连接库pymysql</li><li>python3以后只能使用pymysql库</li><li>python3以前使用MySQLdb库连接数据库</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pymysql</code></pre><ul><li>连接数据库, 连接时需要提供主机地址，用户名，数据库管理系统的密码，数据库名，端口</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">db &#x3D; pymysql.connect(host&#x3D;&quot;localhost&quot;, user&#x3D;&quot;root&quot;, password&#x3D;&quot;root&quot;, database&#x3D;&quot;mirror&quot;, port&#x3D;3306)</code></pre><h1 id="sql语句的执行"><a class="markdownIt-Anchor" href="#sql语句的执行"></a> SQL语句的执行</h1><ul><li>使用cursor()方法创建一个游标对象</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">cursor &#x3D; db.cursor()</code></pre><ul><li><p>查询的表的数据内容：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/j05IIX.png" alt="j05IIX" /></p></li><li><p>cursor对象通过execute()方法执行sql语句，sql语句以字符串的形式传入</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">sql &#x3D; &quot;select * from user&quot;cursor.execute(sql) #查询语句的返回值是该语句影响的行数</code></pre><pre><code>5</code></pre><ul><li>通过执行查询语句后，游标已经移到我们查询的表上来，之后的操作都是对于我们之前查询过的表</li><li>痛殴<code>cursor</code>对象的<code>fetchone()</code>函数可以获取对应数据库表的一行的数据，获取这一行数据之后，相当于游标已经移动到了下一行，再次调用fetch系列函数都是从下一行开始获取数据。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">data &#x3D; cursor.fetchone()print(data)</code></pre><pre><code>(18, 'zestaken', 'zestaken')</code></pre><ul><li>通过<code>fetchmany(count)</code>函数可以获取从当前行开始传入参数行的数据</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">datas1 &#x3D; cursor.fetchmany(2)for data in datas1:    print(data)</code></pre><pre><code>(19, 'admin', 'admin')(20, 'admin1', 'admin1')</code></pre><ul><li>通过<code>fetchall()</code>函数可以获取从当前行开始所有行的数据</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">datas2 &#x3D; cursor.fetchall()for data in datas2:    print(data)</code></pre><pre><code>(21, '123456', '123456')(22, '12345', '12345')</code></pre><ul><li>通过cursor对象的rowcount参数可以知道当前游标指向的数据库表的数据行的总数</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(cursor.rowcount)</code></pre><pre><code>5</code></pre><ul><li>db对象close函数可以关闭连接的数据库</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">db.close()</code></pre><ul><li>一种规范的访问数据库并操作的方式：通过try except块来保证sql正常执行提交事务，异常则回滚事务</li><li>提交和回滚通过数据库对象db的<code>commit()</code>方法和<code>rollback()</code>方法来实现</li><li>没有提交的事务（操作）是没有实际对数据库生效的，特别是进行对数据库数据修改的操作时要注意</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pymysqldb &#x3D; pymysql.connect(host&#x3D;&quot;localhost&quot;, user&#x3D;&quot;root&quot;, password&#x3D;&quot;root&quot;, database&#x3D;&quot;mirror&quot;, port&#x3D;3306)cursor &#x3D; db.cursor()sql &#x3D; &quot;select * from user&quot;# 使用try except块来使sql语句执行出错的时候不提交操作，而回滚try:    cursor.execute(sql)    datas &#x3D; cursor.fetchall()    for data in datas:        print(data)    db.commit()except:    db.rollback()db.close()</code></pre><pre><code>(18, 'zestaken', 'zestaken')(19, 'admin', 'admin')(20, 'admin1', 'admin1')(21, '123456', '123456')(22, '12345', '12345')</code></pre><h1 id="数据的插入与更新"><a class="markdownIt-Anchor" href="#数据的插入与更新"></a> 数据的插入与更新</h1><ul><li>静态插入（没有参数传递)</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">db &#x3D; pymysql.connect(host&#x3D;&quot;localhost&quot;, user&#x3D;&quot;root&quot;, password&#x3D;&quot;root&quot;, database&#x3D;&quot;mirror&quot;, port&#x3D;3306)cursor &#x3D; db.cursor()sql1&#x3D; &quot;insert into user values(30, &#39;test1&#39;, &#39;test1&#39;)&quot;cursor.execute(sql1)db.commit()</code></pre><ul><li>动态插入（有参数传递）：通过占位符实现</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">sql2 &#x3D; &quot;insert into user values(31, &#39;%s&#39;, &#39;%s&#39;)&quot;cursor.execute(sql2%(&#39;test2&#39;, &#39;test2&#39;))db.commit()</code></pre><ul><li>查询数据库表看数据是否成功插入</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">cursor.execute(&quot;select * from user&quot;);datas &#x3D; cursor.fetchall()for data in datas:    print(data)</code></pre><pre><code>(18, 'zestaken', 'zestaken')(19, 'admin', 'admin')(20, 'admin1', 'admin1')(21, '123456', '123456')(22, '12345', '12345')(30, 'test1', 'test1')(31, 'test2', 'test2')</code></pre><ul><li>更新（update）数据库的操作，也同样有静态和动态更新，动态更新和动态插入类似，都通过占位符来实现</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">sql3 &#x3D; &quot;update user set username &#x3D; &#39;%s&#39; where id &#x3D; &#39;%d&#39;&quot;try:    cursor.execute(sql3%(&#39;test2-update&#39;, 31))    db.commit()except:    db.rollback()</code></pre><ul><li>查询修改是否成功</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">cursor.execute(&quot;select * from user&quot;);datas &#x3D; cursor.fetchall()for data in datas:    print(data)</code></pre><pre><code>(18, 'zestaken', 'zestaken')(19, 'admin', 'admin')(20, 'admin1', 'admin1')(21, '123456', '123456')(22, '12345', '12345')(30, 'test1', 'test1')(31, 'test2-update', 'test2')</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python文件读写</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/Python%E6%96%87%E6%9C%AC%E8%AF%BB%E5%86%99/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/Python%E6%96%87%E6%9C%AC%E8%AF%BB%E5%86%99/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="读取文本文件"><a class="markdownIt-Anchor" href="#读取文本文件"></a> 读取文本文件</h1><h2 id="读取文本文件的基本函数"><a class="markdownIt-Anchor" href="#读取文本文件的基本函数"></a> 读取文本文件的基本函数</h2><ul><li>以只读模式打开文件：r代表读取模式，若文件不存在则会报错。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">fp &#x3D; open(&quot;iris.txt&quot;, &quot;r&quot;)print(file)</code></pre><pre><code>out: &lt;_io.TextIOWrapper name='iris.txt' mode='r' encoding='UTF-8'&gt;</code></pre><ul><li>一次读入文件的一行，然后“游标&quot;自动转到文件的下一行首</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">fp.readline() # 读取一行</code></pre><pre><code>'150\t4\tsetosa\tversicolor\tvirginica\n'</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">fp.readline() #再一次调用，则已经读到下一行</code></pre><pre><code>'5.1\t3.5\t1.4\t0.2\t0\n'</code></pre><ul><li>一次读取到文件末尾</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">fp.readlines()</code></pre><pre><code>['4.9\t3\t1.4\t0.2\t0\n', '4.7\t3.2\t1.3\t0.2\t0\n', '4.6\t3.1\t1.5\t0.2\t0\n',...... '6.5\t3\t5.2\t2\t2\n', '6.2\t3.4\t5.4\t2.3\t2\n', '5.9\t3\t5.1\t1.8\t2\n']</code></pre><ul><li>将游标跳到文件开始位置</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">fp.seek(0) # 将游标跳到第一行再读取一行，则又读到了文件的第一行fp.readline()</code></pre><pre><code>'150\t4\tsetosa\tversicolor\tvirginica\n' </code></pre><ul><li>close关闭文件</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">fp.close() # 关闭文件后再次读取就会报错：在关闭的文件上进行IO操作fp.readline()</code></pre><pre><code>---------------------------------------------------------------------------ValueError                                Traceback (most recent call last)&lt;ipython-input-9-f83b4d936024&gt; in &lt;module&gt;      1 fp.close()----&gt; 2 fp.readline()ValueError: I/O operation on closed file.</code></pre><h2 id="三种读取文本文件全部数据的方法"><a class="markdownIt-Anchor" href="#三种读取文本文件全部数据的方法"></a> 三种读取文本文件全部数据的方法</h2><ul><li><ol><li>打开文件，利用while循环，一行行的readline</li></ol></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">fp &#x3D; open(&quot;iris.txt&quot;, &quot;r&quot;)line &#x3D; fp.readline()while line:    print(line) #因为是使用print打印输出，\n等转义符号都已转义后输出，不再保持原样    line &#x3D; fp.readline()fp.close()</code></pre><pre><code>1504setosaversicolorvirginica5.13.51.40.204.931.40.20......5.935.11.82</code></pre><ul><li><ol start="2"><li>打开文件，通过for in循环来遍历文件指针来获取文件的每一行</li></ol></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">fp &#x3D; open(&quot;iris.txt&quot;)for line2 in fp: # 遍历的是文件指针，能够自动获得每一行的内容    print(line2)fp.close()</code></pre><pre><code>1504setosaversicolorvirginica5.13.51.40.204.931.40.204.73.21.30.20.......5.935.11.82</code></pre><ul><li><ol start="3"><li>打开文件，先读取文件的全部内容（readlines）存入一个对象中，然后通过for in循环遍历这个对象，获取每一行的内容</li></ol></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">fp &#x3D; open(&quot;iris.txt&quot;)lines &#x3D; fp.readlines()for line in lines: #遍历的是存储所有文件内容的对象    print(line)fp.close()</code></pre><pre><code>1504setosaversicolorvirginica5.13.51.40.204.931.40.20.......5.935.11.82</code></pre><h1 id="读取csv文件"><a class="markdownIt-Anchor" href="#读取csv文件"></a> 读取CSV文件</h1><h2 id="读取csv文件的基本函数"><a class="markdownIt-Anchor" href="#读取csv文件的基本函数"></a> 读取CSV文件的基本函数</h2><ul><li>导入Pandas包（需要提前安装好，我是使用Anaconda管理这些包）</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pandas as pd</code></pre><ul><li>采用pandas中的函数将csv表格形式文件直接读取到一个Pyhton的<strong>DataFrame</strong>对象中，常用的函数有read_csv和read_table函数</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">df &#x3D; pd.read_csv(&#39;iris.csv&#39;) # 结果存储在DataFrame对象中df # 直接查看DataFrame对象中内容</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>150</th>      <th>4</th>      <th>setosa</th>      <th>versicolor</th>      <th>virginica</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>5.1</td>      <td>3.5</td>      <td>1.4</td>      <td>0.2</td>      <td>0</td>    </tr>    <tr>      <th>1</th>      <td>4.9</td>      <td>3.0</td>      <td>1.4</td>      <td>0.2</td>      <td>0</td>    </tr>    <tr>      <th>2</th>      <td>4.7</td>      <td>3.2</td>      <td>1.3</td>      <td>0.2</td>      <td>0</td>    </tr>    <tr>      <th>3</th>      <td>4.6</td>      <td>3.1</td>      <td>1.5</td>      <td>0.2</td>      <td>0</td>    </tr>    <tr>      <th>4</th>      <td>5.0</td>      <td>3.6</td>      <td>1.4</td>      <td>0.2</td>      <td>0</td>    </tr>    <tr>      <th>...</th>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>    </tr>    <tr>      <th>145</th>      <td>6.7</td>      <td>3.0</td>      <td>5.2</td>      <td>2.3</td>      <td>2</td>    </tr>    <tr>      <th>146</th>      <td>6.3</td>      <td>2.5</td>      <td>5.0</td>      <td>1.9</td>      <td>2</td>    </tr>    <tr>      <th>147</th>      <td>6.5</td>      <td>3.0</td>      <td>5.2</td>      <td>2.0</td>      <td>2</td>    </tr>    <tr>      <th>148</th>      <td>6.2</td>      <td>3.4</td>      <td>5.4</td>      <td>2.3</td>      <td>2</td>    </tr>    <tr>      <th>149</th>      <td>5.9</td>      <td>3.0</td>      <td>5.1</td>      <td>1.8</td>      <td>2</td>    </tr>  </tbody></table><p>150 rows × 5 columns</p></div><ul><li><p>最左列为自动生成的索引</p></li><li><p>DataFrame对象非常适合处理表格数据</p></li><li><p><code>read_table</code>不仅可以读取csv文件（以,分隔的表格型文件),还可以读取以其它方式分隔的表格，所以需要设置分隔符</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">df &#x3D; pd.read_table(&quot;iris.csv&quot;, sep &#x3D; &#39;,&#39;) # 设置分隔符为,，才能处理csv文件df</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>150</th>      <th>4</th>      <th>setosa</th>      <th>versicolor</th>      <th>virginica</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>5.1</td>      <td>3.5</td>      <td>1.4</td>      <td>0.2</td>      <td>0</td>    </tr>    <tr>      <th>1</th>      <td>4.9</td>      <td>3.0</td>      <td>1.4</td>      <td>0.2</td>      <td>0</td>    </tr>    <tr>      <th>2</th>      <td>4.7</td>      <td>3.2</td>      <td>1.3</td>      <td>0.2</td>      <td>0</td>    </tr>    <tr>      <th>3</th>      <td>4.6</td>      <td>3.1</td>      <td>1.5</td>      <td>0.2</td>      <td>0</td>    </tr>    <tr>      <th>4</th>      <td>5.0</td>      <td>3.6</td>      <td>1.4</td>      <td>0.2</td>      <td>0</td>    </tr>    <tr>      <th>...</th>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>    </tr>    <tr>      <th>145</th>      <td>6.7</td>      <td>3.0</td>      <td>5.2</td>      <td>2.3</td>      <td>2</td>    </tr>    <tr>      <th>146</th>      <td>6.3</td>      <td>2.5</td>      <td>5.0</td>      <td>1.9</td>      <td>2</td>    </tr>    <tr>      <th>147</th>      <td>6.5</td>      <td>3.0</td>      <td>5.2</td>      <td>2.0</td>      <td>2</td>    </tr>    <tr>      <th>148</th>      <td>6.2</td>      <td>3.4</td>      <td>5.4</td>      <td>2.3</td>      <td>2</td>    </tr>    <tr>      <th>149</th>      <td>5.9</td>      <td>3.0</td>      <td>5.1</td>      <td>1.8</td>      <td>2</td>    </tr>  </tbody></table><p>150 rows × 5 columns</p></div><h2 id="逐块的读取文件一次读取其中几行"><a class="markdownIt-Anchor" href="#逐块的读取文件一次读取其中几行"></a> 逐块的读取文件（一次读取其中几行):</h2><ul><li>逐块读取文件的两种方法<ul><li>设置nrows参数</li><li>或者chunksize参数,但是将文件按块存储在一个TextParser对象中</li></ul></li><li><code>read_table</code>设置nrows参数</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">df5 &#x3D; pd.read_table(&#39;iris.csv&#39;, sep &#x3D; &#39;,&#39;, nrows&#x3D;5)df5</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>150</th>      <th>4</th>      <th>setosa</th>      <th>versicolor</th>      <th>virginica</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>5.1</td>      <td>3.5</td>      <td>1.4</td>      <td>0.2</td>      <td>0</td>    </tr>    <tr>      <th>1</th>      <td>4.9</td>      <td>3.0</td>      <td>1.4</td>      <td>0.2</td>      <td>0</td>    </tr>    <tr>      <th>2</th>      <td>4.7</td>      <td>3.2</td>      <td>1.3</td>      <td>0.2</td>      <td>0</td>    </tr>    <tr>      <th>3</th>      <td>4.6</td>      <td>3.1</td>      <td>1.5</td>      <td>0.2</td>      <td>0</td>    </tr>    <tr>      <th>4</th>      <td>5.0</td>      <td>3.6</td>      <td>1.4</td>      <td>0.2</td>      <td>0</td>    </tr>  </tbody></table></div><ul><li><code>read-_csv</code>设置nrows参数</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">df5 &#x3D; pd.read_csv(&quot;iris.csv&quot;, nrows&#x3D;5)df5</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre></style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>150</th>      <th>4</th>      <th>setosa</th>      <th>versicolor</th>      <th>virginica</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>5.1</td>      <td>3.5</td>      <td>1.4</td>      <td>0.2</td>      <td>0</td>    </tr>    <tr>      <th>1</th>      <td>4.9</td>      <td>3.0</td>      <td>1.4</td>      <td>0.2</td>      <td>0</td>    </tr>    <tr>      <th>2</th>      <td>4.7</td>      <td>3.2</td>      <td>1.3</td>      <td>0.2</td>      <td>0</td>    </tr>    <tr>      <th>3</th>      <td>4.6</td>      <td>3.1</td>      <td>1.5</td>      <td>0.2</td>      <td>0</td>    </tr>    <tr>      <th>4</th>      <td>5.0</td>      <td>3.6</td>      <td>1.4</td>      <td>0.2</td>      <td>0</td>    </tr>  </tbody></table></div><ul><li><code>read_csv</code>函数设置chunksize参数</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">chunk &#x3D; pd.read_csv(&quot;iris.csv&quot;, chunksize&#x3D;5)chunk</code></pre><pre><code>&lt;pandas.io.parsers.TextFileReader at 0x7f824f359cd0&gt;</code></pre><ul><li>使用设置chuncksize参数生成的textparser对象对文件进行逐块迭代</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">tot &#x3D; 0for piece in chunk:    tot &#x3D; tot + 1    print(piece)    print(&quot;-------&quot;)print(tot) # 总共有150行，每5行一块有30块，存储在这些块存储在chunk对象中</code></pre><pre><code>   150    4  setosa  versicolor  virginica0  5.1  3.5     1.4         0.2          01  4.9  3.0     1.4         0.2          02  4.7  3.2     1.3         0.2          03  4.6  3.1     1.5         0.2          04  5.0  3.6     1.4         0.2          0-------   150    4  setosa  versicolor  virginica5  5.4  3.9     1.7         0.4          06  4.6  3.4     1.4         0.3          07  5.0  3.4     1.5         0.2          08  4.4  2.9     1.4         0.2          09  4.9  3.1     1.5         0.1          0-------.......     150    4  setosa  versicolor  virginica145  6.7  3.0     5.2         2.3          2146  6.3  2.5     5.0         1.9          2147  6.5  3.0     5.2         2.0          2148  6.2  3.4     5.4         2.3          2149  5.9  3.0     5.1         1.8          2-------30</code></pre><h1 id="写入文本文件"><a class="markdownIt-Anchor" href="#写入文本文件"></a> 写入文本文件</h1><ul><li>创建文件对象，使用w模式写入,w模式是覆盖式写入，一旦用w模式打开文件，文件中之前的内容全都删除了，若文件不存在则会先创建再写入。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">myData &#x3D; [&#39;Date&#39;, &#39;Time&#39;] #创建测试的数据</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">myfile &#x3D; open(&quot;test.txt&quot;,&#39;w&#39;) #用w模式打开文件for line in myData:    myfile.write(line+&#39;\n&#39;)myfile.close()</code></pre><ul><li>以r模式打开文件，检查写入文件是否成功</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">myfile &#x3D; open(&quot;test.txt&quot;, &#39;r&#39;)print(myfile.read())</code></pre><pre><code>DateTime</code></pre><ul><li>使用a模式可以追加写</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(&quot;写之前输出：&quot;)myfile1 &#x3D; open(&quot;test.txt&quot;, &#39;r&#39;)print(myfile1.read())myfile2 &#x3D; open(&quot;test.txt&quot;, &#39;a&#39;)myfile2.write(&quot;a&quot;)print(&quot;写之后输出：&quot;)myfile3 &#x3D; open(&quot;test.txt&quot;, &#39;r&#39;)print(myfile3.read())</code></pre><pre><code>写之前输出：DateTime写之后输出：DateTimea</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-树</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/LeetCode-%E6%A0%91/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/LeetCode-%E6%A0%91/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-二叉树的最大深度-104"><a class="markdownIt-Anchor" href="#1-二叉树的最大深度-104"></a> 1. 二叉树的最大深度 104</h1><ul><li><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">题目</a></li></ul><hr /><p>给定一个二叉树，找出其最大深度。<br />二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br />说明: 叶子节点是指没有子节点的节点。<br />示例：<br />给定二叉树 <code>[3,9,20,null,null,15,7]</code><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/hKwQG4.png" alt="hKwQG4" /><br />返回它的最大深度 3 。</p><h2 id="java解法"><a class="markdownIt-Anchor" href="#java解法"></a> Java解法</h2><ul><li>法一：递归进行深度优先搜索：将一一颗二叉树划为三个部分：根节点，左子树，右子树，子树的高度加上根节点的高度（1）就是整颗二叉树的高度。<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/Su4uv1.png" alt="Su4uv1" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MaximumDepthOfBinaryTree104 &#123;    public int maxDepth(TreeNode root) &#123;        &#x2F;&#x2F;利用递归的思想来求解        &#x2F;&#x2F;将一一颗二叉树划为三个部分：根节点，左子树，右子树，子树的高度加上根节点的高度（1）就是整颗二叉树的高度        &#x2F;&#x2F;实质是深度优先搜索        if(root !&#x3D; null) &#123;            &#x2F;&#x2F;注意要加上代表根节点的1            int depth &#x3D; 1 + Math.max(maxDepth(root.left), maxDepth(root.right));            return depth;        &#125; else &#123;            &#x2F;&#x2F;当当前二叉树的根节点为null时返回0，也是递归到底返回的条件            return 0;        &#125;    &#125;&#125;&#x2F;&#x2F;根据一个数组构造二叉树的方法    &#x2F;**     * 输入值的数组，生成二叉树（null用-1替代）     * @param nums     * @return     *&#x2F;    public static TreeNode mkBT(int[] nums) &#123;        &#x2F;&#x2F;当数组长度为0时，直接返回空         if(nums.length &#x3D;&#x3D; 0) &#123;             return null;         &#125;        &#x2F;&#x2F;先根据数组依次生成节点，存储到集合中        ArrayList&lt;TreeNode&gt; treeNodes &#x3D; new ArrayList&lt;&gt;();        for(int i : nums) &#123;            if(i &#x3D;&#x3D; -1) &#123;                treeNodes.add(null);            &#125; else &#123;                treeNodes.add(new TreeNode(i));            &#125;         &#125;        &#x2F;&#x2F;遍历前一半的节点（因为只有这些节点不是叶子节点）        &#x2F;&#x2F; 根据子节点与根节点的下标对应关系，找到每一个非叶子节点的左右子节点并连接         for(int i &#x3D; 0; i &lt; nums.length &#x2F; 2; i++) &#123;             TreeNode cur &#x3D; treeNodes.get(i);             cur.left &#x3D; treeNodes.get(2 * (i + 1) - 1);             cur.right &#x3D; treeNodes.get(2 * (i + 1) + 1 - 1);         &#125;        &#x2F;&#x2F;返回总的根节点（就是集合中的第一个节点）         return treeNodes.get(0);    &#125;</code></pre><h1 id="2-平衡二叉树-110"><a class="markdownIt-Anchor" href="#2-平衡二叉树-110"></a> 2. 平衡二叉树 110</h1><ul><li><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">题目</a></li></ul><hr /><p>给定一个二叉树，判断它是否是高度平衡的二叉树。<br />本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。<br />示例 1：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/IGtDFV.jpg" alt="IGtDFV" /></p><pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [3,9,20,null,null,15,7]输出：true</code></pre><p>示例2:<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/JRslxu.jpg" alt="JRslxu" /></p><pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [1,2,2,3,3,null,null,4,4]输出：false</code></pre><p>示例3:</p><pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; []输出：true</code></pre><p>提示：<br />树中的节点数在范围 [0, 5000] 内<br />-104 &lt;= Node.val &lt;= 104</p><h2 id="java解法-2"><a class="markdownIt-Anchor" href="#java解法-2"></a> Java解法</h2><ul><li>法一：递归获取左右子树的高度，并比较，如果高度差不大于1，则正常返回左右子树中最大高度，否则返回-1。<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/V0Yg9H.png" alt="V0Yg9H" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BalancedBinaryTree110 &#123;    public boolean isBalanced(TreeNode root) &#123;        if (getDepth(root) !&#x3D; -1) &#123;            return true;        &#125;        return false;    &#125;    &#x2F;**     * 递归获取左右子树的高度并比较，如果高度差大于1，则返回-1     * @param root     * @return     *&#x2F;    int getDepth(TreeNode root) &#123;        &#x2F;&#x2F;当root为null，说明已遍历到底部，返回0        if(root &#x3D;&#x3D; null) &#123;            return 0;        &#125;        &#x2F;&#x2F;获取左右子树的高度，并比较        int left &#x3D; getDepth(root.left);        int right &#x3D; getDepth(root.right);        &#x2F;&#x2F;如果左右子树高度返回为-1，说明左右子树内部高度差超过了1        if(left &#x3D;&#x3D; -1 || right &#x3D;&#x3D; -1 ||Math.abs(left - right) &gt; 1) &#123;            return -1;        &#125;        &#x2F;&#x2F;如果正常，返回左右子树中的最大高度        return 1 + Math.max(left, right);    &#125;&#125;</code></pre><h1 id="3-二叉树的直径-543"><a class="markdownIt-Anchor" href="#3-二叉树的直径-543"></a> 3. 二叉树的直径 543</h1><ul><li><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">题目</a></li></ul><hr /><p>示例 :<br />给定二叉树<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/JuYUaG.png" alt="JuYUaG" /><br />返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。<br />注意：两结点之间的路径长度是以它们之间边的数目表示。</p><h2 id="java解法-3"><a class="markdownIt-Anchor" href="#java解法-3"></a> Java解法</h2><ul><li>法一：递归获取左右子树的节点数，每层相对根节点都根据左右子树节点数计算直径，最后选择最大的直径。<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/lGTZ2E.png" alt="lGTZ2E" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DiameterOfBinaryTree543 &#123;    &#x2F;&#x2F;记录直径值，设为类属性便于在方法间传递    int diameter;    public int diameterOfBinaryTree(TreeNode root) &#123;        &#x2F;&#x2F;将初始直径设置为0        diameter &#x3D; 0;        &#x2F;&#x2F;获取二叉树的深度的同时修改最长直径值        getDepth(root);        return diameter;    &#125;    &#x2F;**     * 递归获取二叉树的深度的同时修改最长直径值     * @param root     * @return     *&#x2F;    int getDepth(TreeNode root) &#123;        &#x2F;&#x2F;当当前根节点为null，说明已经递归到了叶子节点，触底返回        if(root &#x3D;&#x3D; null) &#123;            return 0;        &#125;        &#x2F;&#x2F;获取左右子树的节点数（不加一是除去了根节点，以防计算直径的时候重复计算）        int left &#x3D; getDepth(root.left);        int right &#x3D; getDepth(root.right);        &#x2F;&#x2F;当前节点为根节点时的最长直径是左右子树的节点数相加        &#x2F;&#x2F;每次比较当前节点下的最长直径与前面直径，取最大值（因为最长直径必然经过某个相对根节点）        diameter &#x3D; Math.max(left + right, diameter);        &#x2F;&#x2F;返回左右子树的深度（加一算上当前根节点）        return Math.max(left, right) + 1;    &#125;&#125;</code></pre><h1 id="4-路径总和-iii-437"><a class="markdownIt-Anchor" href="#4-路径总和-iii-437"></a> 4. 路径总和 III 437</h1><ul><li><a href="https://leetcode-cn.com/problems/path-sum-iii/">题目</a></li></ul><hr /><p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。<br />示例 1：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/n1g3RH.jpg" alt="n1g3RH" /></p><pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], targetSum &#x3D; 8输出：3解释：和等于 8 的路径有 3 条，如图所示。</code></pre><p>示例2:</p><pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22输出：3</code></pre><p>提示:</p><pre class="line-numbers language-none"><code class="language-none">二叉树的节点个数的范围是 [0,1000]-109 &lt;&#x3D; Node.val &lt;&#x3D; 109 -1000 &lt;&#x3D; targetSum &lt;&#x3D; 1000 </code></pre><h2 id="java解法-4"><a class="markdownIt-Anchor" href="#java解法-4"></a> Java解法</h2><ul><li>法一：<ul><li>结果：</li><li>代码：</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-哈希表</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/LeetCode-%E5%93%88%E5%B8%8C%E8%A1%A8/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/LeetCode-%E5%93%88%E5%B8%8C%E8%A1%A8/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码地址"><a class="markdownIt-Anchor" href="#代码地址"></a> 代码地址</h1><p><a href="https://github.com/zestaken/newblog/tree/master/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/Code/src/main/java/hashTable">Github</a></p><h1 id="1-两数之和-1"><a class="markdownIt-Anchor" href="#1-两数之和-1"></a> 1. 两数之和 1</h1><ul><li><a href="https://leetcode-cn.com/problems/two-sum/">题目</a></li></ul><hr /><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。<br />你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br />你可以按任意顺序返回答案。</p><pre class="line-numbers language-none"><code class="language-none">示例 1：输入：nums &#x3D; [2,7,11,15], target &#x3D; 9输出：[0,1]解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。示例 2：输入：nums &#x3D; [3,2,4], target &#x3D; 6输出：[1,2]示例 3：输入：nums &#x3D; [3,3], target &#x3D; 6输出：[0,1] 提示：2 &lt;&#x3D; nums.length &lt;&#x3D; 104-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109-109 &lt;&#x3D; target &lt;&#x3D; 109只会存在一个有效答案进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？</code></pre><h2 id="java解法"><a class="markdownIt-Anchor" href="#java解法"></a> Java解法</h2><ul><li>法一: 首先遍历一次数组，将数组每个元素的值和下标以键值对的形式存入哈希表中，然后再次遍历数组，将目标值减去当前数组元素值得到一个结果，然后查询这个结果是否在哈希表中存在（注意避免查到自身的情况，如3 + 3 = 6）<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210831215434.png" alt="" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TwoSum1 &#123;    public int[] twoSum(int[] nums, int target) &#123;        &#x2F;&#x2F;创建哈希表，键为数组元素值，值为数组元素下标        Map&lt;Integer, Integer&gt; hashtable &#x3D; new HashMap&lt;Integer, Integer&gt;();        &#x2F;&#x2F;将数组元素的值和下标存入哈希表中        for(int i &#x3D; 0; i &lt; nums.length; i++) &#123;            hashtable.put(nums[i], i);        &#125;        &#x2F;&#x2F;存储结果的数组        int[] res &#x3D; new int[2];        &#x2F;&#x2F;遍历数组，将目标值减去数组元素值得到结果，然后查找哈希表中是否存在这个结果        for(int i &#x3D; 0; i &lt; nums.length; i++) &#123;            int temp &#x3D; target - nums[i];            &#x2F;&#x2F;当在哈希表中查找到不是自身的数时，确认结果返回            if(hashtable.containsKey(temp) &amp;&amp; hashtable.get(temp) !&#x3D; i) &#123;                res[0] &#x3D; i;                res[1] &#x3D; hashtable.get(temp);                return res;            &#125;        &#125;        return res;    &#125;&#125;</code></pre><h1 id="2-最长连续序列-128"><a class="markdownIt-Anchor" href="#2-最长连续序列-128"></a> 2. 最长连续序列 128</h1><ul><li><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">题目</a></li></ul><hr /><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。<br />请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><pre class="line-numbers language-none"><code class="language-none">示例 1：输入：nums &#x3D; [100,4,200,1,3,2]输出：4解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。示例 2：输入：nums &#x3D; [0,3,7,2,5,8,4,6,0,1]输出：9 提示：0 &lt;&#x3D; nums.length &lt;&#x3D; 105-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</code></pre><h2 id="java解法-2"><a class="markdownIt-Anchor" href="#java解法-2"></a> Java解法</h2><ul><li>法一：用一个哈希集合存储数组元素（方便查找，同时去除重复的元素），然后遍历数组元素，已当前数组元素为中心向前和向后枚举与其连续的整数并在集合中查找，如果找到则在集合中删除该元素并且计数，如果没有找到则中断该方向的查找。每一次查找都能将一堆连续的数找到并清除出集合，在集合被清空时则确认得到了最长的连续整数长度。<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210831231239.png" alt="" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class LongestConsecutiveSequence128 &#123;    public int longestConsecutive(int[] nums) &#123;        &#x2F;&#x2F;创建一个集合        &#x2F;&#x2F;使用集合便于直接查找元素,并且利用集合的唯一性去除重复出现的元素        Set&lt;Integer&gt; hashTable &#x3D; new HashSet&lt;&gt;();        &#x2F;&#x2F;将数组中的值全部存入集合        for(int i : nums) &#123;            hashTable.add(i);        &#125;        &#x2F;&#x2F;最长长度        int longestLength &#x3D; 0;        &#x2F;&#x2F;遍历数组，在集合中找每一个数组元素的前后连续元素，然后将这些元素都删除并记录数量        for(int num : nums) &#123;            &#x2F;&#x2F;当集合已空则停止寻找连续元素            if(!hashTable.isEmpty()) &#123;                &#x2F;&#x2F;临时存储连续元素个数                int tempRes &#x3D; 0;                &#x2F;&#x2F;向左寻找当前元素的连续元素                for(int i &#x3D; 0;  hashTable.contains(num - i); i++) &#123;                    hashTable.contains(num - i);                    hashTable.remove(num - i);                    tempRes++;                &#125;                &#x2F;&#x2F;向右寻找当前元素的连续元素（不包含自身)                for(int i &#x3D; 1; hashTable.contains(num + i); i++) &#123;                    hashTable.contains(num + i);                    hashTable.remove(num + i);                    tempRes++;                &#125;                &#x2F;&#x2F;比较长短                if(tempRes &gt; longestLength) &#123;                    longestLength &#x3D; tempRes;                &#125;            &#125; else &#123;                break;            &#125;        &#125;        return longestLength;    &#125;&#125;</code></pre><h1 id="3-直线上最多的点数-149"><a class="markdownIt-Anchor" href="#3-直线上最多的点数-149"></a> 3. 直线上最多的点数 149</h1><ul><li><a href="https://leetcode-cn.com/problems/max-points-on-a-line/">题目</a></li></ul><hr /><p>给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。求最多有多少个点在同一条直线上。<br />示例1：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210831232314.png" alt="" /></p><pre class="line-numbers language-none"><code class="language-none">输入：points &#x3D; [[1,1],[2,2],[3,3]]输出：3</code></pre><p>示例2：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210831232354.png" alt="" /></p><pre class="line-numbers language-none"><code class="language-none">输入：points &#x3D; [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]输出：4</code></pre><p>提示：</p><pre class="line-numbers language-none"><code class="language-none">1 &lt;&#x3D; points.length &lt;&#x3D; 300points[i].length &#x3D;&#x3D; 2-104 &lt;&#x3D; xi, yi &lt;&#x3D; 104points 中的所有点 互不相同</code></pre><h2 id="java解法-3"><a class="markdownIt-Anchor" href="#java解法-3"></a> Java解法</h2><ul><li>法一：因为一条直线有一个点和斜率确定，所以我们遍历数组取出点，然后计算这个点与其它点的斜率，将这个斜率和其出现的次数存入哈希表中，在一个点与其它点的关系计算结束后，取出哈希表中出现次数最多的斜率，然后清空哈希表，进行下一轮的计算。因为一旦与前面的点能构成直线，在前面点计算时已经包含，所以只用计算当前点之后的点（按照在数组中出现的次序而言）。这个解法虽然通过了，但是有缺陷：如果计算的斜率超出了double的小数范围，就有可能不准确。<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210901134149.png" alt="" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MaxPointsOnALine149 &#123;    public int maxPoints(int[][] points) &#123;        &#x2F;&#x2F;如果少于三个点则无需计算        if(points.length &lt; 2) &#123;            return points.length;        &#125;        &#x2F;&#x2F;创建哈希表，键为斜率，值为斜率出现的次数        Map&lt;Double, Integer&gt; hashMap &#x3D; new HashMap&lt;&gt;();        &#x2F;&#x2F;记录构成直线的最多点数        int res &#x3D; 0;        &#x2F;&#x2F;遍历点数组，计算之后的点与自己构成直线的次数（因为一旦与前面的点能构成直线，在前面点计算时已经包含，所以只用计算当前点之后的点）        for(int i &#x3D; 0; i &lt; points.length; i++) &#123;                &#x2F;&#x2F;斜率不存在的情况单独存储                int sameX &#x3D; 1;                &#x2F;&#x2F;遍历当前点之后的数组，将与当前点的斜率以及出现次数存入哈希表                 for(int j &#x3D; i + 1; j &lt; points.length; j++) &#123;                    &#x2F;&#x2F;当斜率存在时才计算                    if((points[i][0] - points[j][0]) !&#x3D; 0) &#123;                        &#x2F;&#x2F;计算斜率                        double k &#x3D; ((double)(points[i][1] - points[j][1]))&#x2F;((double)(points[i][0] - points[j][0]));                        &#x2F;&#x2F;因为哈希表判断键时将0 和 -0看作两个不同的数，所以需要处理一下                        if(k &#x3D;&#x3D; -0) &#123;                            k &#x3D; 0;                        &#125;                        &#x2F;&#x2F;查询哈希表中是否存在该斜率，如果存在则取出，如果不存在则初始为1（因为要包含自身，一旦构成直线就是两个点）                        int count &#x3D; hashMap.getOrDefault(k, 1);                        &#x2F;&#x2F;将该斜率的计数加一再存入哈希表中                        count++;                        hashMap.remove(k);                        hashMap.put(k, count);                    &#125; else &#123;                        sameX++;                    &#125;                &#125;                &#x2F;&#x2F;获取经过当前点构成直线的最多点数                int temp &#x3D; 0;                for(int count : hashMap.values()) &#123;                    if(count &gt; temp) &#123;                        temp &#x3D; count;                    &#125;                &#125;                if(temp &lt; sameX) &#123;                    temp &#x3D; sameX;                &#125;                &#x2F;&#x2F;如果经过当前点的构成直线的最多点数比以及统计的要多则赋给最后的结果                if(temp &gt; res) &#123;                    res &#x3D; temp;                &#125;                &#x2F;&#x2F;清空当前点构成的哈希表，进入下一个点的统计                hashMap.clear();        &#125;        return res;    &#125;&#125;</code></pre><h1 id="4-重新安排行程-332"><a class="markdownIt-Anchor" href="#4-重新安排行程-332"></a> 4. 重新安排行程 332</h1><ul><li><a href="https://leetcode-cn.com/problems/reconstruct-itinerary/">题目</a></li></ul><hr /><p>给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。<br />所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。<br />例如，行程 <code>[&quot;JFK&quot;, &quot;LGA&quot;] 与 [&quot;JFK&quot;, &quot;LGB&quot;]</code> 相比就更小，排序更靠前。<br />假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。<br />示例1:<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/pz0dhe.jpg" alt="pz0dhe" /></p><pre class="line-numbers language-none"><code class="language-none">输入：tickets &#x3D; [[&quot;MUC&quot;,&quot;LHR&quot;],[&quot;JFK&quot;,&quot;MUC&quot;],[&quot;SFO&quot;,&quot;SJC&quot;],[&quot;LHR&quot;,&quot;SFO&quot;]]输出：[&quot;JFK&quot;,&quot;MUC&quot;,&quot;LHR&quot;,&quot;SFO&quot;,&quot;SJC&quot;]</code></pre><p>示例2:<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/SIHzdm.jpg" alt="SIHzdm" /></p><pre class="line-numbers language-none"><code class="language-none">输入：tickets &#x3D; [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]输出：[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]解释：另一种有效的行程是 [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;] ，但是它字典排序更大更靠后。</code></pre><p>提示：</p><pre class="line-numbers language-none"><code class="language-none">1 &lt;&#x3D; tickets.length &lt;&#x3D; 300tickets[i].length &#x3D;&#x3D; 2fromi.length &#x3D;&#x3D; 3toi.length &#x3D;&#x3D; 3fromi 和 toi 由大写英文字母组成fromi !&#x3D; toi</code></pre><h2 id="java解法-4"><a class="markdownIt-Anchor" href="#java解法-4"></a> Java解法</h2><ul><li>法一：<ul><li>结果：</li><li>代码：</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-队列</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/LeetCode-%E9%98%9F%E5%88%97/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/LeetCode-%E9%98%9F%E5%88%97/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码地址"><a class="markdownIt-Anchor" href="#代码地址"></a> 代码地址</h1><p><a href="https://github.com/zestaken/newblog/tree/master/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/Code/src/main/java/queue">github</a></p><h1 id="1-合并k个升序链表-23"><a class="markdownIt-Anchor" href="#1-合并k个升序链表-23"></a> 1. 合并k个升序链表 23</h1><ul><li><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">题目</a></li></ul><hr /><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p></p><p>示例 1：</p><pre class="line-numbers language-none"><code class="language-none">输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[  1-&gt;4-&gt;5,  1-&gt;3-&gt;4,  2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6示例 2：输入：lists &#x3D; []输出：[]示例 3：输入：lists &#x3D; [[]]输出：[]</code></pre><p>提示：</p><pre class="line-numbers language-none"><code class="language-none">k &#x3D;&#x3D; lists.length0 &lt;&#x3D; k &lt;&#x3D; 10^40 &lt;&#x3D; lists[i].length &lt;&#x3D; 500-10^4 &lt;&#x3D; lists[i][j] &lt;&#x3D; 10^4lists[i] 按 升序 排列lists[i].length 的总和不超过 10^4</code></pre><h2 id="java解法"><a class="markdownIt-Anchor" href="#java解法"></a> Java解法</h2><ul><li>法一：使用<a href="https://www.apiref.com/java11-zh/java.base/java/util/PriorityQueue.html">优先队列</a>，开始将各个链表的头节点加入优先队列中，优先队列会自动按值大小顺序添加到队列中，之后弹出队列元素，因为链表自身是有序的，弹出的一定是当前最小的元素，之后将弹出元素的下一节点添加到优先队列中，则又会自动排序，直到队列为空时，所有链表的元素都已经添加完了。<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/KM82lW.png" alt="KM82lW" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MergeKLists23 &#123;    &#x2F;**     * 创建一个实现Comparable接口的ListNode，作为优先队列的元素     * 使用优先队列PriorityQueue需要实现Comparable接口     *&#x2F;    class Status implements Comparable&lt;Status&gt;&#123;        int val;        ListNode node;        Status(int val, ListNode node) &#123;            this.val &#x3D; val;            this.node &#x3D; node;        &#125;        &#x2F;**         * 新添加进优先队列的元素通过这个方法获得优先级，较小的元素优先级高放在队列前面         * @param status2         * @return         *&#x2F;        @Override        public int compareTo(Status status2) &#123;            return this.val - status2.val;        &#125;    &#125;    public ListNode mergeKLists(ListNode[] lists) &#123;        &#x2F;&#x2F;创建以Status作为元素的优先队列        PriorityQueue&lt;Status&gt; queue &#x3D; new PriorityQueue&lt;&gt;();        &#x2F;&#x2F;首先将每个链表的头节点放入优先队列中        for(ListNode node : lists) &#123;            if(node !&#x3D; null) &#123;                queue.offer(new Status(node.val, node));            &#125;        &#125;        &#x2F;&#x2F;创建一个不存值的头节点便于返回结果        ListNode head &#x3D; new ListNode();        &#x2F;&#x2F;使用tail指针便于尾插法        ListNode tail &#x3D; head;        &#x2F;&#x2F;逐步弹出优先队列中元素，直到队列为空        while(!queue.isEmpty()) &#123;            &#x2F;&#x2F;弹出队列头部节点并插入结果链表尾部            Status temp &#x3D; queue.poll();            tail.next &#x3D; temp.node;            tail &#x3D; temp.node;            &#x2F;&#x2F;将当前被弹出节点的下一节点加入优先队列中            if(temp.node.next !&#x3D; null) &#123;                queue.offer(new Status(temp.node.next.val, temp.node.next));            &#125;        &#125;        tail.next &#x3D; null;        return head.next;    &#125;&#125;</code></pre><h1 id="2-天际线问题-218"><a class="markdownIt-Anchor" href="#2-天际线问题-218"></a> 2. 天际线问题 218</h1><ul><li><a href="https://leetcode-cn.com/problems/the-skyline-problem/">题目</a></li></ul><hr /><p>城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回由这些建筑物形成的 天际线 。</p><p>每个建筑物的几何信息由数组 buildings 表示，其中三元组 buildings[i] = [lefti, righti, heighti] 表示：</p><p>lefti 是第 i 座建筑物左边缘的 x 坐标。<br />righti 是第 i 座建筑物右边缘的 x 坐标。<br />heighti 是第 i 座建筑物的高度。<br />天际线 应该表示为由 “关键点” 组成的列表，格式 [[x1,y1],[x2,y2],…] ，并按 x 坐标 进行 排序 。关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，y 坐标始终为 0 ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</p><p>注意：输出天际线中不得有连续的相同高度的水平线。例如 […[2 3], [4 5], [7 5], [11 5], [12 7]…] 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：[…[2 3], [4 5], [12 7], …]</p><p>示例1:<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/AIl1gT.jpg" alt="AIl1gT" /></p><pre class="line-numbers language-none"><code class="language-none">输入：buildings &#x3D; [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]输出：[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]解释：图 A 显示输入的所有建筑物的位置和高度，图 B 显示由这些建筑物形成的天际线。图 B 中的红点表示输出列表中的关键点。示例 2：输入：buildings &#x3D; [[0,2,3],[2,5,3]]输出：[[0,3],[5,0]] 提示：1 &lt;&#x3D; buildings.length &lt;&#x3D; 1040 &lt;&#x3D; lefti &lt; righti &lt;&#x3D; 231 - 11 &lt;&#x3D; heighti &lt;&#x3D; 231 - 1buildings 按 lefti 非递减排序</code></pre><h2 id="java解法-2"><a class="markdownIt-Anchor" href="#java解法-2"></a> Java解法</h2><ul><li>法一：首先先要观察出关键点出现的规律：1 关键点的横坐标必然在建筑物的左右边界上 2 处于建筑物左边界上的关键点的高度就是该建筑的高度，右边界上的则不然，得出建筑包含关键点的概念：大于等于建筑左坐标，小于建筑右坐标；之后使用<strong>扫描线法</strong>，逐个遍历所有的建筑的边界横坐标，并找出包含该边界的建筑物，将该建筑物信息存储。然后在所有包含该边界的建筑物中（遍历）选出最高的高度就是关键点的坐标。在基本思路清晰后，使用<strong>优先队列</strong>减少遍历包含边界的建筑物信息得出最大高度的过程：以高度为比较变量，高度最高的放在队列最前，每次只要确保队列最前的建筑包含边界即可使用其高度作为关键点高度（如果不包含，说明边界已经超过了该建筑所在区域，因为边界是从左到右遍历的，所以该建筑在确定关键点上已经失效（之后的边界它必然也不会包含），可以从队列中移除）。最后要注意每次得到新的关键点时都要确定是否<strong>与以前的关键点高度相同</strong>，如果相同则丢弃这个关键点。<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210830084011.png" alt="" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SkyLine218 &#123;    public List&lt;List&lt;Integer&gt;&gt; getSkyline(int[][] buildings) &#123;        &#x2F;&#x2F;创建优先队列，        PriorityQueue&lt;int[]&gt; priorityQueue &#x3D; new PriorityQueue&lt;int[]&gt;((a, b)-&gt;b[1] - a[1]);        &#x2F;&#x2F;存储建筑物的边界的集合(建筑物的左右横坐标)        List&lt;Integer&gt; boundaries &#x3D; new ArrayList&lt;&gt;();        for(int[] building : buildings) &#123;            boundaries.add(building[0]);            boundaries.add(building[1]);        &#125;        &#x2F;&#x2F;对边界进行排序(从小到大)        Collections.sort(boundaries);        &#x2F;&#x2F;存储结果天际线的集合        List&lt;List&lt;Integer&gt;&gt; result &#x3D; new ArrayList&lt;&gt;();        int n &#x3D; buildings.length;        int index &#x3D; 0;        &#x2F;&#x2F;遍历边界一个个地找到天际线关键点        for(int boundary : boundaries) &#123;            &#x2F;&#x2F;从左到右遍历并找到包含该边界的建筑物，并添加到优先队列中去            &#x2F;&#x2F;已经添加了的建筑不会再遍历            while(index &lt; n &amp;&amp; buildings[index][0] &lt;&#x3D; boundary) &#123;                &#x2F;&#x2F;将建筑物的右边界和高度整体存入优先队列中                priorityQueue.offer(new int[] &#123;buildings[index][1], buildings[index][2]&#125;);                index++;            &#125;            &#x2F;&#x2F;确保优先队列首部的元素包含该边界（即右横坐标大于边界坐标）            while(!priorityQueue.isEmpty() &amp;&amp; priorityQueue.peek()[0] &lt;&#x3D; boundary) &#123;                priorityQueue.poll();            &#125;            &#x2F;&#x2F;获取优先队列首部的元素（建筑物）的高度，即最大高度（同时这个高度对应的建筑包含该边界）            int maxHeight &#x3D; priorityQueue.isEmpty() ? 0 : priorityQueue.peek()[1];            &#x2F;&#x2F;如果这个高度没有与前面的高度相同，则和边界一起存入结果集合中            if(result.size() &#x3D;&#x3D; 0 || maxHeight !&#x3D; result.get(result.size() - 1).get(1)) &#123;                result.add(Arrays.asList(boundary, maxHeight));            &#125;        &#125;        return result;    &#125;&#125;</code></pre><h1 id="3-滑动窗口最大值-239"><a class="markdownIt-Anchor" href="#3-滑动窗口最大值-239"></a> 3. 滑动窗口最大值 239</h1><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> *<a href="https://leetcode-cn.com/problems/sliding-window-maximum/">题目</a></h2><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><pre class="line-numbers language-none"><code class="language-none">示例 1：输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3输出：[3,3,5,5,6,7]解释：滑动窗口的位置                最大值---------------               -----[1  3  -1] -3  5  3  6  7       3 1 [3  -1  -3] 5  3  6  7       3 1  3 [-1  -3  5] 3  6  7       5 1  3  -1 [-3  5  3] 6  7       5 1  3  -1  -3 [5  3  6] 7       6 1  3  -1  -3  5 [3  6  7]      7示例 2：输入：nums &#x3D; [1], k &#x3D; 1输出：[1]示例 3：输入：nums &#x3D; [1,-1], k &#x3D; 1输出：[1,-1]示例 4：输入：nums &#x3D; [9,11], k &#x3D; 2输出：[11]示例 5：输入：nums &#x3D; [4,-2], k &#x3D; 2输出：[4]提示：1 &lt;&#x3D; nums.length &lt;&#x3D; 105-104 &lt;&#x3D; nums[i] &lt;&#x3D; 1041 &lt;&#x3D; k &lt;&#x3D; nums.length</code></pre><h2 id="java解法-3"><a class="markdownIt-Anchor" href="#java解法-3"></a> Java解法</h2><ul><li>法一：使用双端队列存储窗口内容，每次移动窗口就是将双端队列的最前面去掉在尾部加入新元素。将双端队列中的新元素加入优先队列中去，并且记录每个元素对应的下标。每次移动窗口后，获取优先队列的顶部元素，并根据下标判断他是否是窗口中的元素，如果不是则弹出，再取出新的顶部元素，直到属于窗口中为止，这个顶部元素就是当前窗口最大的元素，将其加入结果数组中。<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/M6GE8z.png" alt="M6GE8z" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SlidingWindowMaximum239 &#123;    public int[] maxSlidingWindow(int[] nums, int k) &#123;        &#x2F;&#x2F;创建存储结果的数组        int length  &#x3D; nums.length;        int[] res &#x3D; new int[length - k + 1];        &#x2F;&#x2F;创建双端队列        Deque deque &#x3D; new LinkedList();        &#x2F;&#x2F;初始化队列，将数组最前面的k位数装入队列        for(int i &#x3D; 0; i &lt; k; i++) &#123;            deque.offerLast(nums[i]);        &#125;        &#x2F;&#x2F;用于比较的栈        Stack stack &#x3D; new Stack();        &#x2F;&#x2F;用优先队列来比较大小,优先队列元素：&#123;num, index&#125;,数以及它对应的下标来感知最大值是否已经超出窗口        PriorityQueue&lt;int[]&gt; priorityQueue &#x3D; new PriorityQueue&lt;int[]&gt;((a, b)-&gt;b[0] - a[0]);        &#x2F;&#x2F;先计算出队列中的最大值        for(int j &#x3D; 0; j &lt; k; j++) &#123;            int temp &#x3D; (int) deque.pollLast();            priorityQueue.offer(new int[]&#123;temp, k - j - 1&#125;);            &#x2F;&#x2F;用栈来保存，以便复原双端队列            stack.push(temp);        &#125;        &#x2F;&#x2F;复原双端队列        while (!stack.isEmpty()) &#123;            int temp &#x3D; (int) stack.pop();            deque.offerLast(temp);        &#125;        for(int i &#x3D; 0; k + i &lt;&#x3D; length; i++) &#123;            &#x2F;&#x2F;获取在当前窗口的最大值            boolean flag &#x3D; false; &#x2F;&#x2F;是否获取到当前窗口最大值的标志            while(!flag) &#123;                if(i &lt;&#x3D; priorityQueue.peek()[1] &amp;&amp; priorityQueue.peek()[1]  &lt; k + i) &#123;                    res[i] &#x3D; priorityQueue.peek()[0];                    flag &#x3D; true;                &#125; else &#123;                    priorityQueue.poll();                &#125;            &#125;            &#x2F;&#x2F;移动窗口            if(k + i &lt; length) &#123;                deque.pollFirst();                deque.offerLast(nums[k + i]);            &#125;            &#x2F;&#x2F;将最新加入窗口的元素加入优先队列            int temp &#x3D; (int) deque.getLast();            priorityQueue.offer(new int[]&#123;temp, k + i&#125;);        &#125;        return res;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python深度学习环境</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/Python%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/Python%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="anaconda"><a class="markdownIt-Anchor" href="#anaconda"></a> Anaconda</h1><ul><li>简介：<ul><li>Anaconda包括Conda、Python以及一大堆安装好的180多个科学包及其依赖项，比如：numpy、pandas等。</li><li>Anaconda 是在 conda（一个包管理器和环境管理器）上发展出来的。</li><li>conda是一个开源的包、环境管理器，可以用于在同一个机器上安装不同版本的软件包及其依赖，并能够在不同的环境之间切换。</li><li>如果计算机上已经安装了 Python，安装Anaconda不会对你有任何影响。实际上，脚本和程序使用的默认 Python 是 Anaconda 附带的 Python，所以安装完Anaconda已经自带安装好了Python，不需要你再安装Python了。</li></ul></li><li>安装 Anaconda:<ol><li>Anaconda 可用于多个平台（ Windows、Mac OS X 和 Linux）。你可以在<a href="https://docs.anaconda.com/anaconda/install/">官网</a>上找到安装程序和安装说明。根据你的操作系统是32位还是64位选择对应的版本下载。</li><li>启动下载的Anaconda安装器(如果是windows 10系统，注意在安装Anaconda软件的时候，右击安装软件→选择以管理员的身份运行。)</li></ol></li><li>最终效果：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210613111434.png" alt="" /></li><li>不知道为什么，在我的vpn开着的时候，Anaconda的界面启动不了。。。</li><li>在Windows上使用与Anaconda相关的功能（如启动Jupyter，安装包等）尽量都先用管理员身份启动Anaconda Navigator页，然后再在这里面启动相关的功能，不然会有很多奇怪的问题。</li></ul><h1 id="jupyter-notebook"><a class="markdownIt-Anchor" href="#jupyter-notebook"></a> Jupyter notebook</h1><ul><li>Jupyter notebook（<a href="http://jupyter.org/%EF%BC%89">http://jupyter.org/）</a> 是一种 Web 应用，能让用户将说明文本、数学方程、代码和可视化内容全部组合到一个易于共享的文档中。</li><li>安装Jupyter notebook：安装 Jupyter 的最简单方法是使用 Anaconda。该发行版附带了 Jupyter notebook。你能够在默认环境下使用 notebook。所以在安装好了Anaconda之后，我们已经有了Jupyter。</li></ul><h1 id="pycharm"><a class="markdownIt-Anchor" href="#pycharm"></a> Pycharm</h1><ul><li>PyCharm是一种Python IDE（Integrated Development Environment，集成开发环境），带有一整套可以帮助用户在使用Python语言开发时提高其效率的工具，比如调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制。做一个项目还是需要Pycharm。</li><li><a href="https://www.jetbrains.com/zh-cn/pycharm/">官网</a>下载安装，用学生邮箱白嫖专业版。</li><li>直接使用Pycharm时还是Pycharm自己去下载各种包，与Anaconda无关，要想在Pycharm中使用Anaconda中安装好的包，需要Pycharm使用Anaconda的解释器来运行程序。</li></ul><h1 id="tensorflow"><a class="markdownIt-Anchor" href="#tensorflow"></a> tensorflow</h1><ul><li><a href="https://tensorflow.google.cn/">tensorflow官网</a></li><li>简介：TensorFlow 是由 Google Brain 团队为深度神经网络（DNN）开发的功能强大的开源软件库，它在图形分类、音频处理、推荐系统和自然语言处理等场景下有着丰富的应用，除了 Python，TensorFlow 也提供了 C/C++、Java、Go、R 等其它编程语言的接口。</li><li>安装：<code>pip install tensorflow-gpu</code>，因为电脑有一张Nvidia的GTX 1660 ti的显卡，所以使用GPU版本的tensorflow。</li><li>因为要使用NVIDA的显卡，所以得安装CUDA和CUDNN：<a href="https://developer.nvidia.com/cuda-downloads">官网</a><ul><li>CUDA(ComputeUnified Device Architecture)，是显卡厂商NVIDIA推出的运算平台。 CUDA是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题.<ul><li>CUDA可以在官网获得一个安装程序，运行安装即可。</li></ul></li><li>NVIDIA cuDNN是用于深度神经网络的GPU加速库。它强调性能、易用性和低内存开销。NVIDIA cuDNN可以集成到更高级别的机器学习框架中，如谷歌的Tensorflow、加州大学伯克利分校的流行caffe软件。<a href="https://developer.nvidia.com/cudnn-download-survey">下载CUDNN</a><ul><li>CUDNN下载获得一个压缩文件，解压缩后将CUDNN中的文件复制到CUDA对应的目录中去。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210613132548.png" alt="" /></li></ul></li><li>将<code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.3\lib\x64</code>添加到环境变量</li></ul></li><li>使用<code>import tensorflow as tf</code>检查tensorflow是否安装好。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-字符串</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/LeetCode-%E5%AD%97%E7%AC%A6%E4%B8%B2/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/LeetCode-%E5%AD%97%E7%AC%A6%E4%B8%B2/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><h2 id="string类的charat与tochararray实现原理"><a class="markdownIt-Anchor" href="#string类的charat与tochararray实现原理"></a> String类的charAt()与toCharArray()实现原理</h2><ul><li>例题：<a href="#1-ip-%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96-1108">ip-地址无效化-1108</a></li><li>看一下charAt()的源码：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public char charAt(int index) &#123;    if ((index &lt; 0) || (index &gt;&#x3D; value.length)) &#123;        throw new StringIndexOutOfBoundsException(index);    &#125;    return value[index];&#125;</code></pre><ul><li>这就是直接在数组中取值的方法。那么value是什么东西呢？</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** The value is used for character storage. *&#x2F;private final char value[];&#x2F;&#x2F;再看看构造方法public String() &#123;    this.value &#x3D; &quot;&quot;.value;&#125;public String(String original) &#123;    this.value &#x3D; original.value;    this.hash &#x3D; original.hash;&#125;&#x2F;&#x2F;这个体现得最好，直接就是字符数组之间的copypublic String(char value[]) &#123;    this.value &#x3D; Arrays.copyOf(value, value.length);&#125;</code></pre><ul><li><code>value</code>的声明为一个字符数组，而且构造方法中通过<code>original.value</code>的方法赋值，也是将这个String对象中的value字符数组，赋给新的这个String对象。所以说白了，String类，就是一个字符数组给它加上一大堆方法封装而成的。（倒和C语言本质差不多）。</li><li>String类的核心是字符数组，所以能轻易把它转换为字符数组也不奇怪了，toCharArray的实质就是把封装在String中的字符数组value取出来用：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public char[] toCharArray() &#123;    &#x2F;&#x2F; Cannot use Arrays.copyOf because of class initialization order issues    char result[] &#x3D; new char[value.length];    System.arraycopy(value, 0, result, 0, value.length);    return result;&#125;</code></pre><h2 id="stringbuilder的append方法的参数"><a class="markdownIt-Anchor" href="#stringbuilder的append方法的参数"></a> StringBuilder的append()方法的参数</h2><ul><li>例题：<a href="#1-ip-%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96-1108">ip-地址无效化-1108</a></li><li>append方法既能传字符，也能直接传字符串。事实上，不仅是字符和字符串，基本上其它类型如int，long等都能传，因为它们都能转为字符啊。看一下append是如何实现的：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public AbstractStringBuilder append(char c) &#123;    ensureCapacityInternal(count + 1);    &#x2F;&#x2F;直接在字符数组最后一位后加一个字符    value[count++] &#x3D; c;    return this;&#125;public AbstractStringBuilder append(int i) &#123;    if (i &#x3D;&#x3D; Integer.MIN_VALUE) &#123;        append(&quot;-2147483648&quot;);        return this;    &#125;    int appendedLength &#x3D; (i &lt; 0) ? Integer.stringSize(-i) + 1                                 : Integer.stringSize(i);    int spaceNeeded &#x3D; count + appendedLength;    ensureCapacityInternal(spaceNeeded);    &#x2F;&#x2F;将整型转化合适长度的字符存入value字符数组中    Integer.getChars(i, spaceNeeded, value);    count &#x3D; spaceNeeded;    return this;&#125;public AbstractStringBuilder append(String str) &#123;    if (str &#x3D;&#x3D; null)        return appendNull();    int len &#x3D; str.length();    ensureCapacityInternal(count + len);    str.getChars(0, len, value, count);    count +&#x3D; len;    return this;&#125;</code></pre><ul><li>结合String的本质是字符数组这一点来看，这一切都十分简单：只要最后能转为char，什么都可以往字符数组里塞。</li></ul><h2 id="stringbuilder的insert方法使用"><a class="markdownIt-Anchor" href="#stringbuilder的insert方法使用"></a> StringBuilder的insert()方法使用</h2><ul><li>例题： <a href="#1-ip-%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96-1108">1-ip-地址无效化-1108</a></li><li>首先看一下insert方法插入字符的源码，了解它的主要实现逻辑：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public AbstractStringBuilder insert(int offset, char c) &#123;    ensureCapacityInternal(count + 1);    &#x2F;&#x2F;将当前位置字符及其后面的字符依次向后挪一位    System.arraycopy(value, offset, value, offset + 1, count - offset);    &#x2F;&#x2F;当前位置赋值为指定字符    value[offset] &#x3D; c;    &#x2F;&#x2F;字符串总长度加一    count +&#x3D; 1;    return this;&#125;</code></pre><ul><li>根据insert方法的实现逻辑，insert方法是将当前位置及其以后的字符依次向后移一位，然后当前位置变为指定字符。所以插入一个字符后，原来字符的下标就变为了<code>offsetn + 1</code>（原来字符及其以后的字符的下标都加一）,原来字符之前的字符相对位置不变。</li><li>此外，类似append方法，insert方法也是可以直接插入字符串的（不仅字符串，还有许多其它的类型，如字符数组，浮点数（float），int，boolean等，只是最终效果都是添加成字符串）：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;举两个例子    &#x2F;**     * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;     *&#x2F;    @Override    public StringBuilder insert(int dstOffset, CharSequence s,                                int start, int end)    &#123;        super.insert(dstOffset, s, start, end);        return this;    &#125;    &#x2F;**     * @throws StringIndexOutOfBoundsException &#123;@inheritDoc&#125;     *&#x2F;    @Override    public StringBuilder insert(int offset, Object obj) &#123;            super.insert(offset, obj);            return this;    &#125;</code></pre><h2 id="string与stringbuilder"><a class="markdownIt-Anchor" href="#string与stringbuilder"></a> String与StringBuilder</h2><ul><li>要说String和StringBuilder有什么不同，最直观的使用体验就是，String是不能变的，初始化时是啥就是一直是啥，想要改String的内容，就只能重新初始化一个String在其中加上想要改的内容。而StringBuider呢，从它特有的append和insert方法就可以看出，这兄弟的内容和长短可以随便改。</li><li>String和StringBuilder的本质都是字符数组，但是其中又有不同：<ul><li>String：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** The value is used for character storage. *&#x2F; private final char value[];</code></pre><ul><li>StringBuilder:继承自AbstractStringBuilder，我们大致看一下AbstractStringBuilder就可以了解情况了。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * The value is used for character storage. *&#x2F;char[] value;&#x2F;&#x2F;再看一个在append和insert方法中都出现了的方法：用于实现动态扩容private void ensureCapacityInternal(int minimumCapacity) &#123;    &#x2F;&#x2F; overflow-conscious code    if (minimumCapacity - value.length &gt; 0) &#123;        value &#x3D; Arrays.copyOf(value,                newCapacity(minimumCapacity));    &#125;&#125;</code></pre><ul><li>这下其实就很明显了，String核心是一个<code>final char[]</code>，而StringBuilder就是一个普通的<code>char[]</code>。final修饰的是初始化之后就不能改变的变量。而StringBuilder用着普通的字符数组，还为它配备了像ensureCapacityInternal这种动态扩容的方法以insert和append这种改变字符数组内容的方法，所以它可以随意变化值或长度。</li><li>不得不说，这就是，铁打的字符数组，流水的方法。。。</li></ul><h2 id="foreach循环的原理"><a class="markdownIt-Anchor" href="#foreach循环的原理"></a> foreach循环的原理</h2><ul><li>例题：<a href="#1-ip-%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96-1108">1-ip-地址无效化-1108</a></li><li>foreach循环可以用来遍历数组或者集合。虽然遍历这两者的用法相同，但是实现原理却不一样。</li><li>首先看看遍历数组时是什么情况,将我们遍历字符数组的代码编译后反编译一下：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;自己编写的源码    &#x2F;&#x2F;将String转为字符数组，利用foreach循环遍历    public String deFangIpaddr5 (String address) &#123;        StringBuilder newAddress &#x3D; new StringBuilder();        for(char temp : address.toCharArray()) &#123;            if(temp &#x3D;&#x3D; &#39;.&#39;) &#123;                newAddress.append(&quot;[.]&quot;);            &#125; else &#123;                newAddress.append(temp);            &#125;        &#125;        return newAddress.toString();    &#125;&#x2F;&#x2F;编译后反编译得到的源码   public String deFangIpaddr5(String address) &#123;      StringBuilder newAddress &#x3D; new StringBuilder();      char[] var3 &#x3D; address.toCharArray();      int var4 &#x3D; var3.length;      for(int var5 &#x3D; 0; var5 &lt; var4; ++var5) &#123;         char temp &#x3D; var3[var5];         if (temp &#x3D;&#x3D; &#39;.&#39;) &#123;            newAddress.append(&quot;[.]&quot;);         &#125; else &#123;            newAddress.append(temp);         &#125;      &#125;      return newAddress.toString();   &#125;</code></pre><ul><li>二者对比一下，就可以看出，foreach循环做的事就是将我们以前遍历取值的的标准for循环封装了一下：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">for(int var5 &#x3D; 0; var5 &lt; var4; ++var5) &#123;    char temp &#x3D; var3[var5];    ...&#125;&#x2F;&#x2F;等价于for(char temp : address.toCharArray()) &#123;    ...&#125;</code></pre><ul><li>这其中也要注意一个小细节，用于接收值的变量是每一次循环都要重新声明的，所以foreach循环中的临时变量只能现场声明，不能用之前声明好的。</li><li>遍历集合的情况，偷个懒，等遇到了再说。。。</li></ul><hr /><h1 id="1-ip-地址无效化-1108"><a class="markdownIt-Anchor" href="#1-ip-地址无效化-1108"></a> 1. IP 地址无效化 1108</h1><ul><li>题目：</li></ul><pre class="line-numbers language-none"><code class="language-none">给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。所谓无效化 IP 地址，其实就是用 &quot;[.]&quot; 代替了每个 &quot;.&quot;示例 1：输入：address &#x3D; &quot;1.1.1.1&quot;输出：&quot;1[.]1[.]1[.]1&quot;示例 2：输入：address &#x3D; &quot;255.100.50.0&quot;输出：&quot;255[.]100[.]50[.]0&quot; 提示：给出的 address 是一个有效的 IPv4 地址</code></pre><h2 id="java解法"><a class="markdownIt-Anchor" href="#java解法"></a> java解法</h2><ul><li>法一：<ul><li>遍历整个字符串，同时新建一个空的StringBuilder，遇到<code>.</code>的时候，加上<code>[]</code>使用<code>append()</code>添加进入StringBuilder中去。</li><li>评测结果：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210611201714.png" alt="" /></li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;解题代码    public String deFangIpaddr1 (String address) &#123;        StringBuilder newAddress &#x3D; new StringBuilder();        for(int i &#x3D; 0; i &lt; address.length(); i++) &#123;            char temp &#x3D; address.charAt(i);            if(temp &#x3D;&#x3D; &#39;.&#39;) &#123;                newAddress.append(&#39;[&#39;);                newAddress.append(&#39;.&#39;);                newAddress.append(&#39;]&#39;);            &#125; else &#123;                newAddress.append(temp);            &#125;        &#125;        return newAddress.toString();    &#125;&#x2F;&#x2F;JUnit测试用例    @Test    public void testDeFangIpaddr1() &#123;        DefangIPaddr test &#x3D; new DefangIPaddr();        String res &#x3D; test.deFangIpaddr1(&quot;127.0.0.1&quot;);        String expRes &#x3D; &quot;127[.]0[.]0[.]1&quot;;        assert res.equals(expRes) : res;    &#125;</code></pre><ul><li>法二<ul><li>调用String的<code>replace()</code>方法，直接将<code>.</code>替换为<code>[.]</code></li><li>评测结果：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210611202515.png" alt="" /></li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;解题代码    public String deFangIpaddr2(String address) &#123;        return address.replace(&quot;.&quot;, &quot;[.]&quot;);    &#125;&#x2F;&#x2F;测试用例    @Test    public void testDeFangIpaddr2() &#123;        DefangIPaddr test &#x3D; new DefangIPaddr();        String res &#x3D; test.deFangIpaddr2(&quot;127.0.0.1&quot;);        String expRes &#x3D; &quot;127[.]0[.]0[.]1&quot;;        assert res.equals(expRes) : res;    &#125;</code></pre><ul><li>法三：<ul><li>创建StringBuilder对象，并把原字符串赋给它，调用其<code>insert</code>方法，在<code>.</code>的前后插入<code>[]</code>。</li><li>评测结果：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210611204856.png" alt="" /></li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;解题代码    &#x2F;&#x2F;StringBuilder的insert    public String deFangIpaddr3 (String address) &#123;        StringBuilder newAddress &#x3D; new StringBuilder(address);        for(int i &#x3D; 0; i &lt; newAddress.length(); i++) &#123;            if(newAddress.charAt(i) &#x3D;&#x3D; &#39;.&#39;) &#123;                &#x2F;&#x2F;insert是当前计数位变为指定字符，原来的字符到下一位                newAddress.insert(i + 1, &#39;]&#39;); &#x2F;&#x2F;先插后面的括号，这样.的位置还未改变，方便添加前面的括号                newAddress.insert(i, &#39;[&#39;);                i +&#x3D; 3;                continue;            &#125;        &#125;        return newAddress.toString();    &#125;&#x2F;&#x2F;测试用例    @Test    public void testDeFangIpaddr3() &#123;        DefangIPaddr test &#x3D; new DefangIPaddr();        String res &#x3D; test.deFangIpaddr3(&quot;127.0.0.1&quot;);        String expRes &#x3D; &quot;127[.]0[.]0[.]1&quot;;        assert res.equals(expRes) : res;    &#125;</code></pre><ul><li>法四：<ul><li>同一一样，但是append方法可以直接添加字符串。。。</li><li>评测结果：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210611205634.png" alt="" /></li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;解题代码    &#x2F;&#x2F;StringBuilder的append可以直接添加字符串。。。    public String deFangIpaddr4 (String address) &#123;        StringBuilder newAddress &#x3D; new StringBuilder();        for(int i &#x3D; 0; i &lt; address.length(); i++) &#123;            char temp &#x3D; address.charAt(i);            if(temp &#x3D;&#x3D; &#39;.&#39;) &#123;&#x2F;&#x2F;                newAddress.append(&#39;[&#39;);&#x2F;&#x2F;                newAddress.append(&#39;.&#39;);&#x2F;&#x2F;                newAddress.append(&#39;]&#39;);                newAddress.append(&quot;[.]&quot;);            &#125; else &#123;                newAddress.append(temp);            &#125;        &#125;        return newAddress.toString();    &#125;&#x2F;&#x2F;测试用例    @Test    public void testDeFangIpaddr4() &#123;        DefangIPaddr test &#x3D; new DefangIPaddr();        String res &#x3D; test.deFangIpaddr4(&quot;127.0.0.1&quot;);        String expRes &#x3D; &quot;127[.]0[.]0[.]1&quot;;        assert res.equals(expRes) : res;    &#125;</code></pre><ul><li>法五：<ul><li>将String转为字符数组，利用foreach循环遍历</li><li>评测结果：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210611211051.png" alt="" /></li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;解题代码    &#x2F;&#x2F;将String转为字符数组，利用foreach循环遍历    public String deFangIpaddr5 (String address) &#123;        StringBuilder newAddress &#x3D; new StringBuilder();        for(char temp : address.toCharArray()) &#123;            if(temp &#x3D;&#x3D; &#39;.&#39;) &#123;                newAddress.append(&quot;[.]&quot;);            &#125; else &#123;                newAddress.append(temp);            &#125;        &#125;        return newAddress.toString();    &#125;&#x2F;&#x2F;测试用例    @Test    public void testDeFangIpaddr5() &#123;        DefangIPaddr test &#x3D; new DefangIPaddr();        String res &#x3D; test.deFangIpaddr5(&quot;127.0.0.1&quot;);        String expRes &#x3D; &quot;127[.]0[.]0[.]1&quot;;        assert res.equals(expRes) : res;    &#125;</code></pre><h1 id="2-有效的字母异位词-242"><a class="markdownIt-Anchor" href="#2-有效的字母异位词-242"></a> 2. 有效的字母异位词 242</h1><ul><li><a href="https://leetcode-cn.com/problems/valid-anagram/">题目</a></li></ul><hr /><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。<br />注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。<br />示例 1:</p><pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;输出: true</code></pre><p>示例 2:</p><pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;输出: false</code></pre><p>提示:</p><pre class="line-numbers language-none"><code class="language-none">1 &lt;&#x3D; s.length, t.length &lt;&#x3D; 5 * 104s 和 t 仅包含小写字母</code></pre><h2 id="java解法-2"><a class="markdownIt-Anchor" href="#java解法-2"></a> Java解法</h2><ul><li>法一：字母异位代表着相同字母的出现次数一样。用一个26位的数组存储字母出现的次数（下标对应字母），遍历一次第一个字符串，存储各个字母的次数，然后再遍历第二个字符串，减去各个字母的次数，最后的数组值全为0，则说明字母异位。<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/BuLLAf.png" alt="BuLLAf" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ValidAnagram242 &#123;    public boolean isAnagram(String s, String t) &#123;        &#x2F;&#x2F;存储判断结果        boolean res &#x3D; true;        &#x2F;&#x2F;用长度为26的整数数组表示每个字母出现的次数（下标表示字母，值代表出现次数）        int[] abc &#x3D; new int[26];        &#x2F;&#x2F;将字符串转换为字符数组遍历，将字母转化为数字，存储出现次数        for(char i : s.toCharArray()) &#123;            abc[i - &#39;a&#39;]++;        &#125;        &#x2F;&#x2F;遍历第二个字符数组，出现一个字母则对应位置次数减一        for(char i : t.toCharArray()) &#123;            abc[i - &#39;a&#39;]--;        &#125;        &#x2F;&#x2F;遍历数组，如果有对应位置字母出现次数不同，则对应位置的值不为0，返回false        for(int i &#x3D; 0; i &lt; 26; i++) &#123;            if(abc[i] !&#x3D; 0) &#123;                return res &#x3D; false;            &#125;        &#125;        &#x2F;&#x2F;所有元素都相等        return res;    &#125;&#125;</code></pre><h1 id="3-同构字符串-205"><a class="markdownIt-Anchor" href="#3-同构字符串-205"></a> 3. 同构字符串 205</h1><ul><li><a href="https://leetcode-cn.com/problems/isomorphic-strings/">题目</a></li></ul><hr /><p>给定两个字符串 s 和 t，判断它们是否是同构的。<br />如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。<br />每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</p><pre class="line-numbers language-none"><code class="language-none">示例 1:输入：s &#x3D; &quot;egg&quot;, t &#x3D; &quot;add&quot;输出：true示例 2：输入：s &#x3D; &quot;foo&quot;, t &#x3D; &quot;bar&quot;输出：false示例 3：输入：s &#x3D; &quot;paper&quot;, t &#x3D; &quot;title&quot;输出：true</code></pre><p>提示：<br />可以假设 s 和 t 长度相同。</p><h2 id="java解法-3"><a class="markdownIt-Anchor" href="#java解法-3"></a> Java解法</h2><ul><li>法一：关键在于确定字母之间的映射关系，然后检测这种关系是否矛盾。字母之间的映射关系是通过字母出现的位置来决定的，字母第一次出现时就与同样位置的另一个字符相映射，如果之后这个字母再次出现，则对应的位置应还是哪个字符，也就是说，那个字符第一次出现的位置应相同。（本题偷懒使用两个哈希表实现，这样还不如直接用一个哈希表中将字母映射关系存好，直接对比。其实用26位的字符数组用以上思路应该也能做出来）<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210907223838.png" alt="" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class IsomorphicStrings205 &#123;    public boolean isIsomorphic(String s, String t) &#123;        &#x2F;&#x2F;将字符串转化为字符数组，便于遍历        char[] s1 &#x3D; s.toCharArray();        char[] s2 &#x3D; t.toCharArray();        &#x2F;&#x2F;创建两个哈希集合，存储字符串中字符值及其第一次出现的位置        Map&lt;Character, Integer&gt; map1 &#x3D; new HashMap&lt;&gt;();        Map&lt;Character, Integer&gt; map2 &#x3D; new HashMap&lt;&gt;();        &#x2F;&#x2F;遍历两个字符数组，同时记录位置，如果对应位置的字符的第一次出现的位置不同，则不是同构字符串        for(int i &#x3D; 0; i &lt; s1.length; i++) &#123;            &#x2F;&#x2F;用两个变量记录对应位置字母第一次出现的位置            int pos1 &#x3D; i;            int pos2 &#x3D; i;            &#x2F;&#x2F;如果当前位置的字母是第一次出现，则存入哈希表，如果不是，则取出第一次出现位置            if(!map1.containsKey(s1[i])) &#123;                map1.put(s1[i], i);            &#125; else &#123;               pos1 &#x3D; map1.get(s1[i]);            &#125;            if(!map2.containsKey(s2[i])) &#123;                map2.put(s2[i], i);            &#125; else &#123;                pos2 &#x3D; map2.get(s2[i]);            &#125;            &#x2F;&#x2F;如果两个字母第一次出现的位置不同，则不是同构字符串            if(pos1 !&#x3D; pos2) &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;</code></pre><h1 id="4-回文子串-647"><a class="markdownIt-Anchor" href="#4-回文子串-647"></a> 4. 回文子串 647</h1><ul><li><a href="https://leetcode-cn.com/problems/palindromic-substrings/">题目</a></li></ul><hr /><p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。<br />回文字符串 是正着读和倒过来读一样的字符串。<br />子字符串 是字符串中的由连续字符组成的一个序列。<br />具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><pre class="line-numbers language-none"><code class="language-none">示例 1：输入：s &#x3D; &quot;abc&quot;输出：3解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;示例 2：输入：s &#x3D; &quot;aaa&quot;输出：6解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</code></pre><p>提示：</p><p>1 &lt;= s.length &lt;= 1000<br />s 由小写英文字母组成</p><h2 id="java解法-4"><a class="markdownIt-Anchor" href="#java解法-4"></a> Java解法</h2><ul><li>法一：回文子串的本质就是前后对称，对称的关键就是对称轴。所以我们以每一个元素确认当前对称轴，然后找寻对称轴前后的元素是否相同，来判断是否是回文子串。需要注意的是，奇数个元素和偶数个元素的对称的对称轴情况不同，需要区别处理。（应该可以通过除法，取余等操作将两个遍历循环合并）<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210908095417.png" alt="" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class PalindromicSubstrings647 &#123;    public int countSubstrings(String s) &#123;        &#x2F;&#x2F;将字符串转化为字符数组        char[] s1 &#x3D; s.toCharArray();        int length &#x3D; s1.length;        int count &#x3D; 0;        &#x2F;&#x2F;遍历字符数组，用当前元素确认中轴，找寻前后元素，看是否对称        for(int i &#x3D; 0; i &lt; length; i++) &#123;            &#x2F;&#x2F;要区分回文子串是偶数个还是奇数个            &#x2F;&#x2F;偶数个的中轴在当前元素和下一元素之间（或者说中轴是两个元素）            &#x2F;&#x2F;奇数个的中轴就在当前元素上            int l &#x3D; i;            int r1 &#x3D; i;            int r2 &#x3D; i + 1;            &#x2F;&#x2F;查找奇数个数的回文子串            while(l &gt;&#x3D; 0 &amp;&amp; r1 &lt; length &amp;&amp; s1[l] &#x3D;&#x3D; s1[r1]) &#123;                count++;                l--;                r1++;            &#125;            &#x2F;&#x2F;复原l的值            l &#x3D; i;            &#x2F;&#x2F;查找偶数个的回文子串            while(l &gt;&#x3D; 0 &amp;&amp; r2 &lt; length &amp;&amp; s1[l] &#x3D;&#x3D; s1[r2]) &#123;                count++;                l--;                r2++;            &#125;        &#125;        return count;    &#125;&#125;</code></pre><h1 id="5-计数二进制子串-696"><a class="markdownIt-Anchor" href="#5-计数二进制子串-696"></a> 5. 计数二进制子串 696</h1><ul><li><a href="https://leetcode-cn.com/problems/count-binary-substrings/">题目</a></li></ul><hr /><p>给定一个字符串 s，计算具有相同数量 0 和 1 的非空（连续）子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是连续的。<br />重复出现的子串要计算它们出现的次数。</p><pre class="line-numbers language-none"><code class="language-none">示例 1 :输入: &quot;00110011&quot;输出: 6解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。请注意，一些重复出现的子串要计算它们出现的次数。另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。示例 2 :输入: &quot;10101&quot;输出: 4解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。</code></pre><p>提示：<br />s.length 在1到50,000之间。<br />s 只包含“0”或“1”字符。</p><h2 id="java解法-5"><a class="markdownIt-Anchor" href="#java解法-5"></a> Java解法</h2><ul><li>法一：利用如果满足条件，必须前后不同字符连续出现的次数相同，所以关键在于计算同一字符连续出现的次数，如果之前字符连续出现的次数不小于当前字符连续出现的次数，那么必然可以构成一组。<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210909224120.png" alt="" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CountBinarySubstrings696 &#123;    public int countBinarySubstrings2(String s) &#123;        &#x2F;&#x2F;统计结果        int count &#x3D; 0;        &#x2F;&#x2F;将字符串转为字符数组，便于遍历        char[] s1 &#x3D; s.toCharArray();        &#x2F;&#x2F;记录当前字符和之前不同字符的连续出现次数        int pre &#x3D; 0, cur &#x3D; 0;        &#x2F;&#x2F;遍历字符数组，记录当前字符连续出现次数，以及之前相对当前字符不同的字符的连续出现次数        &#x2F;&#x2F;temp标记当前字符是0还是1        char temp &#x3D; &#39;0&#39;;        for(char c : s1) &#123;            if(c &#x3D;&#x3D; temp) &#123;                &#x2F;&#x2F;如果字符没变，则计数加一                cur++;            &#125; else &#123;                &#x2F;&#x2F;如果字符变化了，则将之前记录的字符连续次数，赋给统计之前次数的变量，重新开始计数                pre &#x3D; cur;                cur &#x3D; 1;                &#x2F;&#x2F;修改当前字符种类                temp &#x3D; c;            &#125;            &#x2F;&#x2F;当之前连续出现的字符的次数的不小于当前字符连续出现次数时，可以构成对称，计数一次            if(pre &gt;&#x3D; cur) &#123;                count++;            &#125;        &#125;        return count;    &#125;&#125;</code></pre><h1 id="6-基本计算器-ii-227"><a class="markdownIt-Anchor" href="#6-基本计算器-ii-227"></a> 6. 基本计算器 II 227</h1><ul><li><a href="https://leetcode-cn.com/problems/basic-calculator-ii/">题目</a></li></ul><hr /><p>给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。<br />整数除法仅保留整数部分。</p><pre class="line-numbers language-none"><code class="language-none">示例 1：输入：s &#x3D; &quot;3+2*2&quot;输出：7示例 2：输入：s &#x3D; &quot; 3&#x2F;2 &quot;输出：1示例 3：输入：s &#x3D; &quot; 3+5 &#x2F; 2 &quot;输出：5</code></pre><p>提示：</p><pre class="line-numbers language-none"><code class="language-none">1 &lt;&#x3D; s.length &lt;&#x3D; 3 * 105s 由整数和算符 (&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;&#x2F;&#39;) 组成，中间由一些空格隔开s 表示一个 有效表达式表达式中的所有整数都是非负整数，且在范围 [0, 231 - 1] 内题目数据保证答案是一个 32-bit 整数</code></pre><h2 id="java解法-6"><a class="markdownIt-Anchor" href="#java解法-6"></a> Java解法</h2><ul><li>法一：用两个队列分别存储数值和运算符。遍历字符串时，从队列尾部插入，尾部读取，把队列当作栈使用，如果遇到比存入队列中的的运算符优先级高的运算符，则将该运算符前后的数值获取，计算出结果再存入数值队列中。遍历字符串结束后，需要从左到右计算，从队列头部读取，从队列头部插入，因为高优先级运算符已经转换为运算结果，所以运算时都是同级的运算符，只需从左到右运算即可。从左到右运算时，将每一次运算的结果插入队列头部，作为下一次运算的左运算数。<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/dzELwI.png" alt="dzELwI" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BasicCalculatorII227 &#123;    &#x2F;&#x2F;用于临时存储连续的数字以便计算数值    ArrayList&lt;Integer&gt; tempNums &#x3D; new ArrayList&lt;&gt;();    &#x2F;**     * 主计算函数，遍历字符串，按序获取对应的数值以及运算符     * @param s     * @return 表达式计算结果     *&#x2F;    public int calculate(String s) &#123;        &#x2F;&#x2F;将字符串转换为字符数组，便于遍历        char[] s1 &#x3D; s.toCharArray();        &#x2F;&#x2F;用两个双端队列，按序存储数值和运算符        Deque&lt;Integer&gt; nums &#x3D; new LinkedList&lt;&gt;();        Deque&lt;Character&gt; ops &#x3D; new LinkedList&lt;&gt;();        &#x2F;&#x2F;存储运算结果        int res &#x3D; 0;        &#x2F;&#x2F;遍历整个字符数组        for(int i &#x3D; 0; i &lt; s1.length;) &#123;            &#x2F;&#x2F;获取当前位置的值            char c &#x3D; s1[i];            &#x2F;&#x2F;如果是数字，则获取接下来连续出现的数字，存储到动态数组中，并修改下标            if(isNum(c)) &#123;                i &#x3D; getNums(s1, i);            &#125;            &#x2F;&#x2F;如果是空格            if(isSpace(c)) &#123;                &#x2F;&#x2F;空格是连续数字的分隔符，计算数值，存入数值队列中                if(!tempNums.isEmpty()) &#123;                    nums.addLast(getNum(tempNums));                &#125;                &#x2F;&#x2F;下标前进到下一位，进入下一次循环                i++;                continue;            &#125; else if(isOp(c)) &#123;                &#x2F;&#x2F;如果是运算符                if(!tempNums.isEmpty()) &#123;                    &#x2F;&#x2F;运算符也是数字的分隔符，计算数值，存入数值队列                    nums.addLast(getNum(tempNums));                &#125;                &#x2F;&#x2F;如果运算符队列为空，则直接存入运算符，进入下一次循环                if(ops.isEmpty()) &#123;                    ops.addLast(c);                    i++;                    continue;                &#125;                &#x2F;&#x2F;运算符队列不为空，获取队列尾运算符               char temp &#x3D; ops.getLast();                &#x2F;&#x2F;如果队列尾运算符是+或-               if(temp &#x3D;&#x3D; &#39;+&#39; || temp &#x3D;&#x3D; &#39;-&#39; ) &#123;                   &#x2F;&#x2F;* &#x2F; 的优先级比 + -高，先将乘除运算结束，将结果存入数值队列中                   if (c &#x3D;&#x3D; &#39;*&#39; ) &#123;                       &#x2F;&#x2F;获取数值队列末尾元素                       int num1 &#x3D; nums.pollLast();                       &#x2F;&#x2F;获取当前运算符之后的连续数字并得出其值                       i &#x3D; getNums(s1, i + 1);                       int num2 &#x3D; getNum(tempNums);                       &#x2F;&#x2F;运算，结果存入数值队列尾                       int num3;                       num3 &#x3D; num2 * num1;                       nums.addLast(num3);                   &#125; else if (c &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;                       int num1 &#x3D; nums.pollLast();                       i &#x3D; getNums(s1, i + 1);                       int num2 &#x3D; getNum(tempNums);                       int num3;                       num3 &#x3D; num1 &#x2F; num2;                       nums.addLast(num3);                   &#125; else &#123;                       &#x2F;&#x2F;如果当前运算符是+ -，则直接存入运算符队列                       i++;                       ops.addLast(c);                       continue;                   &#125;               &#125; else &#123;                   &#x2F;&#x2F;没有比 * &#x2F;优先级高的运算，直接存入运算符队列                   i++;                   ops.addLast(c);                   continue;               &#125;            &#125;        &#125;        &#x2F;&#x2F;因为以空格和运算符作为连续数字的分隔符，所以末尾的数字有可能没有存入数值队列        if(!tempNums.isEmpty()) &#123;            nums.addLast(getNum(tempNums));        &#125;        &#x2F;&#x2F;如果运算符队列为空，则说明数值队列只有一个数，无需运算，直接返回        if(ops.isEmpty()) &#123;            return nums.pollFirst();        &#125;        &#x2F;&#x2F;从队列头部取出数值和运算符进行运算        &#x2F;&#x2F;运算规则是从左到右，如果还是用栈的思路，就是从右到左计算        &#x2F;&#x2F;因为高优先级的运算符都已经计算为结果了，所以都是同一优先级的运算        while(!nums.isEmpty() &amp;&amp; !ops.isEmpty()) &#123;            int num1 &#x3D; nums.pollFirst();            int num2 &#x3D; nums.pollFirst();            char op &#x3D; ops.pollFirst();            if(op &#x3D;&#x3D; &#39;+&#39;) &#123;                res &#x3D; num1 + num2;            &#125; else if (op &#x3D;&#x3D; &#39;-&#39;)&#123;                res &#x3D; num1 - num2;            &#125; else if (op &#x3D;&#x3D; &#39;*&#39;) &#123;                res &#x3D; num1 * num2;            &#125; else if(op &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;                res &#x3D; num1 &#x2F; num2;            &#125;            &#x2F;&#x2F;每一次运算的结果是下一次运算的前一位运算数，重新存入数值队列头部            nums.addFirst(res);        &#125;        return res;    &#125;    &#x2F;**     * 判断字符是否是数字     * @param c     * @return     *&#x2F;    public boolean isNum(char c) &#123;        if (c &gt;&#x3D; &#39;0&#39; &amp;&amp; c &lt;&#x3D; &#39;9&#39;) &#123;            return true;        &#125;        return false;    &#125;    &#x2F;**     * 判断字符是否是运算符     * @param c     * @return     *&#x2F;    public boolean isOp(char c) &#123;        if(c &#x3D;&#x3D; &#39;+&#39; || c &#x3D;&#x3D; &#39;-&#39; || c &#x3D;&#x3D; &#39;*&#39; || c &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;            return true;        &#125;        return false;    &#125;    &#x2F;**     * 判断字符是否是空格     * @param c     * @return     *&#x2F;    public boolean isSpace(char c) &#123;        if(c &#x3D;&#x3D; &#39; &#39;) &#123;            return true;        &#125;        return false;    &#125;    &#x2F;**     * 将连续的数字转换为值     * @param list     * @return     *&#x2F;    public int getNum(ArrayList&lt;Integer&gt; list) &#123;        int length &#x3D; list.size();        int i &#x3D; 0;        int res &#x3D; 0;        &#x2F;&#x2F;遍历数字，将每位数乘上其10的幂，加在最后的结果上        for(int num : list) &#123;            res +&#x3D; num * Math.pow(10, length - i - 1);            i++;        &#125;        &#x2F;&#x2F;清空集合        list.clear();        return res;    &#125;    &#x2F;**     * 获取连续数字，并依次存入集合中     * @param s     * @param start 开始位置     * @return 返回下一个非数字字符位置     *&#x2F;    public int getNums(char[] s, int start) &#123;        int i;        int j;        &#x2F;&#x2F;如果开始是连续的空格，则跳过，知道有数字出现为止        for(i &#x3D; start; i &lt; s.length; i++) &#123;            char c &#x3D; s[i];            if(!isSpace(c)) &#123;                break;            &#125;        &#125;        &#x2F;&#x2F;从跳过空格后的位置开始读取数字        for(j &#x3D; i; j &lt; s.length; j++) &#123;            char c &#x3D; s[j];            if(isNum(c)) &#123;                tempNums.add(c - &#39;0&#39;);            &#125; else &#123;                break;            &#125;        &#125;        return j;    &#125;&#125;</code></pre><h1 id="7-实现-strstr-28"><a class="markdownIt-Anchor" href="#7-实现-strstr-28"></a> 7. 实现 strStr() 28</h1><ul><li><a href="https://leetcode-cn.com/problems/implement-strstr/">题目</a></li></ul><hr /><p>实现 strStr() 函数。<br />给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。<br />说明：<br />当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。<br />对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。</p><pre class="line-numbers language-none"><code class="language-none">示例 1：输入：haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;输出：2示例 2：输入：haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;输出：-1示例 3：输入：haystack &#x3D; &quot;&quot;, needle &#x3D; &quot;&quot;输出：0提示：0 &lt;&#x3D; haystack.length, needle.length &lt;&#x3D; 5 * 104haystack 和 needle 仅由小写英文字符组成</code></pre><h2 id="java解法-7"><a class="markdownIt-Anchor" href="#java解法-7"></a> Java解法</h2><ul><li>法一：双指针遍历两个字符串，直到找到匹配的子串或者余下的长度比子串长度还小时停止。<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210911131211.png" alt="" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ImplementStrStr28 &#123;    public int strStr(String haystack, String needle) &#123;        &#x2F;&#x2F;将字符串转化为字符数组，方便遍历        char[] s1 &#x3D; haystack.toCharArray();        char[] s2 &#x3D; needle.toCharArray();        int l1 &#x3D; s1.length;        int l2 &#x3D; s2.length;        &#x2F;&#x2F;如果子串为空字符串，返回0        if(s2.length &#x3D;&#x3D; 0) &#123;            return 0;        &#125;        &#x2F;&#x2F;结果默认为-1        int res &#x3D; -1;        &#x2F;&#x2F;遍历字符串，直到所剩长度比子串长度小        for(int i &#x3D; 0; i + l2 &lt;&#x3D; l1; i++) &#123;            &#x2F;&#x2F;如果当前字符与子串第一个字符相同，则继续比较之后的字符            if(s1[i] &#x3D;&#x3D; s2[0]) &#123;                int j &#x3D; i + 1;                int t &#x3D; 1;                &#x2F;&#x2F;当子串只有一位字符时，可以直接返回                if(t &#x3D;&#x3D; l2) &#123;                    return res &#x3D; i;                &#125;                &#x2F;&#x2F;双指针，遍历两个字符串，逐个比较字符是否相同，直到子串遍历完                while (t &lt; l2) &#123;                    if(s1[j] !&#x3D; s2[t]) &#123;                        break;                    &#125;                    t++;                    j++;                &#125;                &#x2F;&#x2F;如果子串被遍历完了，说明完全匹配，返回开始下标即可                if(t &#x3D;&#x3D; l2) &#123;                    return res &#x3D; i;                &#125;            &#125;        &#125;        &#x2F;&#x2F;到达这里，说明前面没有找到匹配子串，直接返回默认值-1        return res;    &#125;&#125;</code></pre><ul><li>法二：KMP(字符串模式匹配算法)<a href="https://www.zestaken.top/post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%B2">KMP解析</a>:其中心思想是利用子串的对称性来在比较的时候跳过一些对称的部分，以起到加速匹配的效果。<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20211114114926.png" alt="" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int strStr(String haystack, String needle) &#123;    char[] s1 &#x3D; haystack.toCharArray();    char[] s2 &#x3D; needle.toCharArray();    int l1 &#x3D; s1.length;    int l2 &#x3D; s2.length;    int result &#x3D; -1; &#x2F;&#x2F;结果默认为-1    &#x2F;&#x2F;子串为空串直接返回0    if(l2 &#x3D;&#x3D; 0) &#123;        result &#x3D; 0;        return  result;    &#125;    &#x2F;&#x2F;求子串每一个元素的next数组（即当前元素之前对称的元素对数）    int i &#x3D; 0, k &#x3D; -1;    int[] next &#x3D; new int[l2];    next[0] &#x3D; -1; &#x2F;&#x2F;第一个元素设为-1，因为它之前没有元素    while(i &lt; l2 - 1) &#123; &#x2F;&#x2F;最后一个元素在倒数第二个元素遍历时已经记录        if(k &#x3D;&#x3D; -1 || s2[i] &#x3D;&#x3D; s2[k]) &#123;            i++; &#x2F;&#x2F;若之前有元素相等，则记在下一个元素的next值上            k++; &#x2F;&#x2F;k值从-1开始，与i对应元素依此比过来，如果相等则k与i同时移位，如果不等k回溯到它的next值处再比较，i不变            &#x2F;&#x2F;next值的求取实质是子串前半部分与后半部分比较，得元素对应相等个数；可以看成是两个串的匹配，又可以用next回溯的思想，有点递归的感觉            next[i] &#x3D; k; &#x2F;&#x2F;k的值代表着对称相等的元素对数        &#125; else &#123;            k &#x3D; next[k];        &#125;    &#125;    int j &#x3D; 0, m &#x3D; 0;    while(j + l2 - m &lt;&#x3D; l1 &amp;&amp; m &lt; l2) &#123;        if(m &#x3D;&#x3D; -1 || s2[m] &#x3D;&#x3D; s1[j]) &#123; &#x2F;&#x2F;m等于负一说明子串从头开始寻找，主串后移一位            j++;            m++;        &#125; else &#123;            m &#x3D; next[m];        &#125;        if(m  &#x3D;&#x3D; l2) &#123;            result &#x3D; j - m; &#x2F;&#x2F;当前位置是子串最后一个元素对应的位置，减去子串长度即为开始匹配的位置        &#125;    &#125;    return result;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中man命令的使用</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Linux/Linux%E4%B8%ADman%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Linux/Linux%E4%B8%ADman%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="man命令介绍"><a class="markdownIt-Anchor" href="#man命令介绍"></a> man命令介绍</h1><ul><li>Linux提供了丰富的帮助手册，当你需要查看某个命令的参数时不必到处上网查找，只要<code>man</code>一下即可。</li><li>可以使用<code>man man</code>查看man的使用方法。</li><li>man命令分为以下几个章节（按真实顺序排列）：<ol><li>标准用户命令（Executable programs or shell commands）</li><li>系统调用（System calls）functions provided by the kernel</li><li>库调用（Library call）functions within program libraries</li><li>特殊文件（设备文件）的访问入口（/dev）Special files (usually found in /dev)</li><li>文件格式（配置文件的语法），指定程序的运行特性 File formats and conventions</li><li>游戏（Games）</li><li>杂项（Miscellaneous）including macro packages and conventions</li><li>管理命令 System administration commands</li><li>跟kernel有关的文件 Kernel routines</li></ol></li></ul><h1 id="man命令的常用参数"><a class="markdownIt-Anchor" href="#man命令的常用参数"></a> man命令的常用参数</h1><ul><li><code>man -f</code>:与<code>whatis</code>命令功能相同，可以简洁地显示命令的功能，以及它所属的章节。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210606220020.jpg" alt="" /></li><li><code>man -k</code>:与<code>apropos</code>命令功能相同，可以在所有命令的manual页面中的Description部分中查找命令后接的关键词，然后对查找到关键词的页面简洁地返回一行描述，以及有该命令完整的名字和所在的页面。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210606220638.png" alt="" /></li><li>可以在查命令时，指定对应的章节，如：<code>man 3 sleep</code>只查第三节的sleep：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/20210606220936.png" alt="" /><ul><li>如果不指定对应的章节如：<code>man sleep</code>，则默认查最小的章节，对sleep来说，就是Sleep（1）</li></ul></li></ul><h1 id="man的基本使用方法"><a class="markdownIt-Anchor" href="#man的基本使用方法"></a> man的基本使用方法</h1><ul><li>翻页：<ul><li>向后翻一屏：space(空格键)</li><li>向前翻一屏：b</li><li>向后翻一行：Enter(回车键) 或者j</li><li>向前翻一行：k</li></ul></li><li>查找：<ul><li><code>/KEYWORD</code>: 向后查找</li><li><code>?KEYWORD</code>:  向前查找</li><li>在进入查找模式之后：<ul><li>N：前一个</li><li>n：下一个</li></ul></li></ul></li><li>退出：q</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言-从字符串结束标志到Linux进程的内存分配</title>
      <link href="//post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%93%E6%9D%9F%E6%A0%87%E5%BF%97%E5%88%B0Linux%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/index.html"/>
      <url>//post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%93%E6%9D%9F%E6%A0%87%E5%BF%97%E5%88%B0Linux%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="c语言-从字符串结束标志到linux进程的内存分配"><a class="markdownIt-Anchor" href="#c语言-从字符串结束标志到linux进程的内存分配"></a> C语言-从字符串结束标志到Linux进程的内存分配</h1><h2 id="字符串结束标志"><a class="markdownIt-Anchor" href="#字符串结束标志"></a> 字符串结束标志</h2><ul><li>众所周知（除了本人）C语言中字符串的实质就是一个字符数组，但是字符串这个字符数组有点特殊，它的最后一位一定是<code>'\0'</code>（即空字符）用来标识字符串的结束。</li><li>C语言最令人头痛事情之一访问越界，特别是数组访问越界，如果发生了是什么样子？答案马上揭晓。。。</li></ul><h2 id="错误示范"><a class="markdownIt-Anchor" href="#错误示范"></a> 错误示范</h2><ul><li>尘封已久的C语言现在被我拿来干了啥可悲的事情呢？</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;&#x2F;&#x2F;整个程序的目的是依次读入16位的数（4个16进制数），然后累加，中途结果超出16位则去掉最高位再在末尾加一，如果读取的数不够4位16进制数，则在末尾补零到4位int main(int argc, char *argv[]) &#123;    u_int32_t sum &#x3D; 0;    char *data &#x3D; argv[1];    char temp[4];    int i &#x3D; 0;    int flag &#x3D; 0;    while(data[i] !&#x3D; &#39;\0&#39; &amp;&amp; flag &#x3D;&#x3D; 0) &#123;        for(int j &#x3D; 0; j &lt; 4; j++) &#123;            if(data[i + j] !&#x3D; &#39;\0&#39;) &#123;                temp[j] &#x3D; data[i + j];            &#125; else &#123;                &#x2F;&#x2F;错误点：如果还差2位才到4位，那么第一次读到&#39;\0&#39;之后的一次循环在干什么呢？那岂不是直接超出数组边界，在访问一个未定义的空间                    temp[j] &#x3D; &#39;0&#39;;                         flag &#x3D; 1;            &#125;        &#125;        if(flag &#x3D;&#x3D; 0) &#123;            i &#x3D; i  + 4;        &#125;        sum +&#x3D; strtol(temp, NULL, 16);        if(sum &gt; 0xFFFF) &#123;            sum &#x3D; sum - 0x10000 + 0x0001;        &#125;    &#125;     &#x2F;&#x2F;测试越界后得到的最后四位字符是什么     printf(&quot;最后四位字符：&quot;);     for(i &#x3D; 0; i &lt; 4; i++) &#123;             printf(&quot;%c&quot;,temp[i]);     &#125;      printf(&quot;\n&quot;);    u_int16_t checksum &#x3D; ~sum;    printf(&quot;%04x\n&quot;, checksum);&#125;</code></pre><ul><li>我这个铁憨憨不仅忘了字符串只有最后一位是<code>'\0'</code>，而且还很自然地实现了越界访问（菜，是一种怎样的忧伤）。</li><li>看一看越界后会有什么效果：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/J5zLVA.png" alt="J5zLVA" /><ul><li>所以T和E是两个什么玩意儿？虽然它们很不正常，但是为什么每次越界后得到的都是T和E？越界之后的结果不应该是随机的？</li><li>本次测试使用的是MacOS操作系统，clang 11.0.0编译器</li></ul></li></ul><h2 id="探索越界之谜"><a class="markdownIt-Anchor" href="#探索越界之谜"></a> 探索越界之谜</h2><h3 id="编译器"><a class="markdownIt-Anchor" href="#编译器"></a> 编译器</h3><ul><li>首先怀疑的是越界之后的结果和不同的编译器有关，因为每次越界的结果都一样。</li><li>MacOS虽然明面上使用的是gcc命令编译，但是实质上用的是clang（LLVM clang）。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/jbwrRj.png" alt="jbwrRj" /></li><li>对于当前主流桌面操作系统而言，可使用 Visual C++、GCC 以及 LLVM Clang 这三大编译器。<ul><li>Visual C++（简称 MSVC）是由微软开发的，只能用于 Windows 操作系统；</li><li>GCC 和 LLVM Clang 除了可用于 Windows 操作系统之外，主要用于 Unix/Linux 操作系统。</li></ul></li><li>给Mac电脑装一个真正的gcc试试：(<code>brew install gcc</code>)<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/Bh7lSd.png" alt="Bh7lSd" /><ul><li>用gcc编译之后再运行：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/h0YSc8.png" alt="h0YSc8" /></li><li>结果竟然一模一样！难道不是编译器不同导致的!</li></ul></li></ul><h3 id="越界之后的结果查看"><a class="markdownIt-Anchor" href="#越界之后的结果查看"></a> 越界之后的结果查看</h3><ul><li>之所以怀疑是编译器的问题主要是之前认为编译器会自动识别程序的越界访问，然后用一些固定的字符来提示用户，现在恍然大悟，我怕是想多了。（我的专业课可能上了个寂寞）</li><li>打印越界之后的更多信息试一试：</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;&#x2F;&#x2F;整个程序的目的是依次读入16位的数（4个16进制数），然后累加，中途结果超出16位则去掉最高位再在末尾加一，如果读取的数不够4位16进制数，则在末尾补零到4位int main(int argc, char *argv[]) &#123;    u_int32_t sum &#x3D; 0;    char *data &#x3D; argv[1];    char temp[4];    int i &#x3D; 0;    int flag &#x3D; 0;    while(data[i] !&#x3D; &#39;\0&#39; &amp;&amp; flag &#x3D;&#x3D; 0) &#123;        for(int j &#x3D; 0; j &lt; 4; j++) &#123;            if(data[i + j] !&#x3D; &#39;\0&#39;) &#123;                temp[j] &#x3D; data[i + j];            &#125; else &#123;                &#x2F;&#x2F;错误点：如果还差2位才到4位，那么第一次读到&#39;\0&#39;之后的一次循环在干什么呢？那岂不是直接超出数组边界，在访问一个未定义的空间                &#x2F;**打印越界之后的信息**&#x2F;    printf(&quot;%dover%d:%s\n&quot;,i, j,&amp;data[i+j]);    printf(&quot;%dvaluei%d:%c\n&quot;,i, j,data[i+j]);                    temp[j] &#x3D; &#39;0&#39;;                         flag &#x3D; 1;            &#125;        &#125;            &#x2F;**打印越界之后的信息**&#x2F;    printf(&quot;%dover4:%s\n&quot;, i ,&amp;data[i+4]);    printf(&quot;%dvalue4:%c\n&quot;,i, data[i+4]);    printf(&quot;%dover5:%s\n&quot;, i, &amp;data[i+5]);    printf(&quot;%dvalue5:%c\n&quot;,i, data[i+5]);    printf(&quot;%dover6:%s\n&quot;,i,  &amp;data[i+6]);    printf(&quot;%dvalue6:%c\n&quot;,i, data[i+6]);    printf(&quot;%dover7:%s\n&quot;,i, &amp;data[i+7]);    printf(&quot;%dvalue7:%c\n&quot;,i,data[i+7]);        if(flag &#x3D;&#x3D; 0) &#123;            i &#x3D; i  + 4;        &#125;        sum +&#x3D; strtol(temp, NULL, 16);        if(sum &gt; 0xFFFF) &#123;            sum &#x3D; sum - 0x10000 + 0x0001;        &#125;    &#125;     &#x2F;&#x2F;测试越界后得到的最后四位字符是什么     printf(&quot;最后四位字符：&quot;);     for(i &#x3D; 0; i &lt; 4; i++) &#123;             printf(&quot;%c&quot;,temp[i]);     &#125;      printf(&quot;\n&quot;);    u_int16_t checksum &#x3D; ~sum;    printf(&quot;%04x\n&quot;, checksum);&#125;</code></pre><ul><li>运行结果如图：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/rnHYOO.png" alt="rnHYOO" /></li><li>真是拨云见日，在data数组之后存放的是一个字符串<code>TERM_SESSION_ID=w0t0p0:6389D1E3-6A5A-4F0C-9AAB-7BBF04CC0875</code>,每次越界之后读取的就是这个字符串中的内容了，T和E这两个奇怪的东西就是这样来的。</li><li>但是还有一个问题，为什么每次运行程序的结果都一样，我的data数组紧邻的为什么就一定是这个奇怪的字符串。</li></ul><h3 id="linux的全局环境变量"><a class="markdownIt-Anchor" href="#linux的全局环境变量"></a> Linux的全局环境变量</h3><ul><li>使用<code>printenv</code>或<code>env</code>命令可以查看linux的全局环境变量（mac也适用),部分全局环境变量截图如下：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/BSX2O1.png" alt="BSX2O1" /></li><li>全局变量的第一条便是<code>TERM_SESSION_ID=w0t0p0:6389D1E3-6A5A-4F0C-9AAB-7BBF04CC0875</code>，看来我们越界之后极有可能访问到来存储全局环境变量字符串的空间。</li><li>感觉有点不放心，在网上看了一种能直接在程序内查看当前进程环境变量的方法：</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;&#x2F;&#x2F;整个程序的目的是依次读入16位的数（4个16进制数），然后累加，中途结果超出16位则去掉最高位再在末尾加一，如果读取的数不够4位16进制数，则在末尾补零到4位int main(int argc, char *argv[]) &#123;    &#x2F;&#x2F;。。。    &#x2F;&#x2F;省略原来的代码    &#x2F;&#x2F; ...    &#x2F;&#x2F;查看当前进程的环境变量    printf(&quot;-------------------------\n&quot;);    extern char **environ;    for(int i &#x3D; 0; environ[i]!&#x3D; NULL; i++)&#123;   printf(&quot;%s\n&quot;,environ[i]);   &#125;   return 0;&#125;</code></pre><ul><li>结果：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/ZNXP0L.png" alt="ZNXP0L" /><ul><li>也出现了<code>TERM_SESSION_ID=w0t0p0:6389D1E3-6A5A-4F0C-9AAB-7BBF04CC0875</code>而且也在第一个。</li><li>当前进程的环境变量应该是继承而来的。</li></ul></li></ul><h3 id="linux的内存分配"><a class="markdownIt-Anchor" href="#linux的内存分配"></a> Linux的内存分配</h3><ul><li>通过前面的尝试发现，在我定义的数组之后应该存储的是进程的环境变量。所以，linux中，一个进程的内存究竟是如何组织的？</li><li>进程的内存组织：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/h0oHPe.png" alt="h0oHPe" /></li><li>如果是按照这种组织，那么我在进程运行时创建的数组应该在堆中，那么才有可能访问到紧邻的静态数据。堆的数据一般是通过malloc分配的。</li><li>不太确定这种方式定义的数组是在堆中分配的，将我们的数组用malloc分配试一试。<ul><li>原来：</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">char *data &#x3D; argv[1]</code></pre><ul><li>使用malloc动态分配：</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">char *data &#x3D; (char *)malloc(sizeof(argv[1]));data &#x3D; argv[1];</code></pre></li></ul><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/ZH5ILP.png" alt="ZH5ILP" /></p><ul><li>结果和原来一模一样，越界之后依然是<code>TERM_SESSION_ID=w0t0p0:6389D1E3-6A5A-4F0C-9AAB-7BBF04CC0875</code>。那么证明了，我创建的字符数组，是存放在堆中的。</li><li>哪些数据存放在哪些位置：<ul><li><code>.text</code>（代码)段：程序源代码编译后得到的机器指令放在这个地方。也就是说是它是可执行程序在内存中的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，而不允许写入（修改）操作——它是不可写的。</li><li><code>.data</code>:数据段用来存放可执行文件中已初始化全局变量，换句话说就是存放程序已初始化的局部静态分配的变量和全局变量。</li><li><code>.bss</code>: 为未初始化的全局变量和局部静态变量预留位置。在内存中的bss段全部置零。</li><li><strong>堆（heap）</strong>：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。</li><li><strong>栈（stack）</strong>：栈是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</li><li><strong>共享库的内存映射区域</strong>：存放一些共享的对象，如动态链接库。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/r2gQFe.png" alt="r2gQFe" /></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 专业基础 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索引擎命令</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%91%BD%E4%BB%A4/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%91%BD%E4%BB%A4/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="搜索引擎命令"><a class="markdownIt-Anchor" href="#搜索引擎命令"></a> 搜索引擎命令</h1><h2 id="双引号"><a class="markdownIt-Anchor" href="#双引号"></a> 双引号</h2><ul><li>把搜索词放在双引号中，代表完全匹配搜索，也就是说搜索结果返回的页面包含双引号中出现的所有的词，连顺序也必须完全匹配。</li><li>bd和Google 都支持这个指令。</li><li>例如搜索： “seo方法图片”</li></ul><h2 id="减号"><a class="markdownIt-Anchor" href="#减号"></a> 减号</h2><ul><li>减号代表搜索不包含减号后面的词的页面。</li><li>使用这个指令时减号前面必须是空格，减号后面没有空格，紧跟着需要排除的词。</li><li>Google 和bd都支持这个指令。</li><li>例如：搜索 -引擎</li><li>返回的则是包含“搜索”这个词，却不包含“引擎”这个词的结果</li></ul><h2 id="星号"><a class="markdownIt-Anchor" href="#星号"></a> 星号</h2><ul><li>星号*是常用的通配符，也可以用在搜索中。</li><li>百度不支持<code>*</code>号搜索指令。</li><li>比如在Google 中搜索：搜索*擎</li><li>其中的<code>*</code>号代表任何文字。返回的结果就不仅包含“搜索引擎”，还包含了“搜索收擎”，“搜索巨擎”等内容。</li></ul><h2 id="inurl"><a class="markdownIt-Anchor" href="#inurl"></a> inurl</h2><ul><li>指令用于搜索查询词出现在url 中的页面。</li><li>bd和Google 都支持inurl 指令。</li><li>inurl 指令支持中文和英文。</li><li>比如搜索：inurl:搜索引擎优化</li><li>返回的结果都是网址url 中包含“搜索引擎优化”的页面。由于关键词出现在url 中对排名有一定影响，使用inurl:搜索可以更准确地找到竞争对手。</li></ul><h2 id="inanchor"><a class="markdownIt-Anchor" href="#inanchor"></a> inanchor</h2><ul><li>指令返回的结果是导入链接锚文字中包含搜索词的页面。</li><li>百度不支持inanchor。</li><li>比如在Google 搜索 ：inanchor:点击这里返回的结果页面本身并不一定包含“点击这里”这四个字，而是指向这些页面的链接锚文字中出现了“点击这里”这四个字。</li><li>可以用来找到某个关键词的竞争对手，而且这些竞争对手往往是做过SEO 的。</li><li>研究竞争对手页面有哪些外部链接，就可以找到很多链接资源。</li></ul><h2 id="intitle"><a class="markdownIt-Anchor" href="#intitle"></a> intitle</h2><ul><li>指令返回的是页面title 中包含关键词的页面。</li><li>Google 和bd都支持intitle 指令。</li><li>使用intitle 指令找到的文件是更准确的竞争页面。</li><li>如果关键词只出现在页面可见文字中，而没有出现在title 中，大部分情况是并没有针对关键词进行优化，所以也不是有力的竞争对手。</li></ul><h2 id="allintitle"><a class="markdownIt-Anchor" href="#allintitle"></a> allintitle</h2><ul><li>搜索返回的是页面标题中包含多组关键词的文件。</li><li>例如 ：allintitle:SEO 搜索引擎优化</li><li>就相当于：intitle:SEO intitle:搜索引擎优化</li><li>返回的是标题中中既包含“SEO”，也包含“搜索引擎优化”的页面</li></ul><h2 id="allinurl"><a class="markdownIt-Anchor" href="#allinurl"></a> allinurl</h2><ul><li>与allintitle: 类似。</li><li>allinurl:SEO 搜索引擎优化</li><li>就相当于 ：inurl:SEO inurl:搜索引擎优化</li></ul><h2 id="filetype"><a class="markdownIt-Anchor" href="#filetype"></a> filetype</h2><ul><li>用于搜索特定文件格式。</li><li>Google 和bd都支持filetype 指令。</li><li>比如搜索filetype:pdf SEO</li><li>返回的就是包含SEO 这个关键词的所有pdf 文件。</li></ul><h2 id="site"><a class="markdownIt-Anchor" href="#site"></a> site</h2><ul><li>是SEO 最熟悉的高级搜索指令，用来搜索某个域名下的所有文件。</li><li>注意事项：<ul><li>site:后边跟的冒号必须是英文的“:”，中文的全角冒号“：”无用</li><li>网址前不能带“http://”</li><li>网址后边不能带斜杠“/”，其实是哪里都不能带“/”</li><li>网址中不要用“www”，除非你有特别目的，用“www”会导致错过网站内的内容，因为很多网站的频道是没有“www”的</li></ul></li></ul><h2 id="linkdomain"><a class="markdownIt-Anchor" href="#linkdomain"></a> linkdomain</h2><ul><li>指令只适用于雅虎，返回的是某个域名的反向链接。雅虎的反向链接数据还比较准确，是SEO 人员研究竞争对手外部链接情况的重要工具之一。</li><li>比如搜索linkdomain:<a href="http://cnseotool.com">http://cnseotool.com</a> -site:<a href="http://cnseotool.xn--com-bk2ek92ajye73gm3id1f4u4a9doda488b2umj0qvm0ecso">http://cnseotool.com得到的就是点石网站的外部链接</a>，因为-site:<a href="http://cnseotool.com">http://cnseotool.com</a> 已经排除了点石本身的页面，也就是内部链接，剩下的就都是外部链接了。</li></ul><h2 id="related"><a class="markdownIt-Anchor" href="#related"></a> related</h2><ul><li>指令只适用于Google，返回的结果是与某个网站有关联的页面。比如搜索related:<a href="http://cnseotool.com">http://cnseotool.com</a>,我们就可以得到Google 所认为的与点石网站有关联的其他页面。</li><li>这种关联到底指的是什么，Google 并没有明确说明，一般认为指的是有共同外部链接的网站。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 杂技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arch</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Linux/Arch/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Linux/Arch/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="arch虚拟机安装"><a class="markdownIt-Anchor" href="#arch虚拟机安装"></a> Arch虚拟机安装</h1><p><a href="https://wiki.archlinux.org/index.php/Installation_guide">参考Archwiki</a></p><ol><li>在<a href="https://archlinux.org/download/">官网</a>选择一个镜像源下载iso文件。</li><li>在VMware安装iso镜像；</li><li>启动虚拟机后，经过一会儿的等待，会自动进入命令行界面；</li><li>arch安装需要连接网络，检查网络是否畅通，可使用<code>ping</code>命令：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210307094657.png" alt="" /></li><li>更新系统时间：<code>timedatectl set-ntp true</code></li><li>检查引导模式：<code> ls /sys/firmware/efi/efivars</code><ol><li>如果显示目录，则是EFI模式；</li><li>如果有错，不显示，则是BIOS模式<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210307101020.png" alt="" /></li></ol></li><li>分区：<ol><li>查看目前分区情况:<code>fdisk -l</code><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210307101409.png" alt="" /></li><li>创建分区：`fdisk /dev/sda<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210307102000.png" alt="" /></li><li>格式化分区：<ol><li>格式化swap分区，并启动：<code>mkswap /dev/sda1</code>,<code>swapon /dev/sda1</code><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210307102440.png" alt="" /></li><li>将另外一个大容量的分区，格式化为ETX4格式,并挂载到<code>/mnt</code>目录：<code>mkfs.ext4 /dev/sda2</code>,<code>mount /dev/sda2 /mnt</code></li></ol></li></ol></li><li>安装软件包：<ol><li>配置镜像源：暂时省略,因为现在在live环境中使用reflector进行镜像的管理，貌似你一连接网络，live系统会自动执行reflector命令来帮你选择镜像源，默认的是根据下载速率进行排序，</li><li>安装基本包：<code>pacstrap /mnt base linux linux-firmware</code>，<ol><li>这里要注意的是，上面的命令并不包括所有的基本程序，如网络管理程序、文本编辑器等，如果你想安装这些程序，可以将名字添加到pacstrap后，并用空格隔开。你也可以在Chroot进新系统后使用<code>pacman</code>手动安装软件包或组。</li></ol></li></ol></li><li>配置系统:<ol><li>生成自动挂载分区的fstab文件:<code>genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</code><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210307105154.png" alt="" /></li><li>切换到新系统,Chroot意为Change root，相当于把操纵权交给我们新安装（或已经存在）的Linux系统，执行了这步以后，我们的操作都相当于在磁盘上新装的系统中进行。<code>arch-chroot /mnt</code><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210307105356.png" alt="" /></li><li>更改时区，依次执行如下命令设置我们的时区为上海并生成相关文件：<code>ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code>,<code>hwclock --systohc</code></li><li>安装一个vim，便于之后的操作：<code>pacman -S vim</code></li><li>设置Locale，即语言选项,执行如下命令来编辑/etc/locale.gen文件：<code>vim /etc/locale.gen</code><ol><li>在文件中找到<code>en_US.UTF-8 UTF-8</code>,<code>zh_CN.UTF-8 UTF-8</code>,<code>zh_HK.UTF-8 UTF-8</code>,<code>zh_TW.UTF-8 UTF-8</code> 这四行，去掉行首的#号，保存并退出。</li><li>然后执行：<code>locale-gen</code></li><li>打开（不存在时会创建）<code>/etc/locale.conf</code>文件,在文件的第一行加入以下内容：<code>LANG=en_US.UTF-8</code></li></ol></li><li>网络配置：<ol><li>设置主机名：打开/etc/hostname文件,在文件的第一行输入你自己设定的一个myhostname(我的是zestaken)</li><li>编辑<code>etc/hosts</code>文件，在文件末添加如下内容：</li></ol> <pre class="line-numbers language-none"><code class="language-none">127.0.0.1localhost::1    localhost127.0.1.1myhostname.localdomainmyhostname</code></pre><ol start="3"><li>安装dhcpcd,dhcpd 是 Internet Systems Consortium DHCP 的服务，它被用作局域网环境中的路由管理。<code>pacman -S dhcpcd</code></li><li>启动dhcpcd服务：<code>systemctl enable dhcpcd.service</code></li></ol></li><li>设置ROOT用户密码：<ol><li><code>#</code>代表以Root用户执行命令，``$代表以普通用户执行命令</li><li>通过<code>passwd</code>设置ROOT密码，我设置的是<code>1</code>.</li></ol></li><li>安装引导工具Grub2:<ol><li>首先安装os-prober和ntfs-3g这两个包，它可以配合Grub检测已经存在的系统，自动设置启动选项:<code>pacman -S os-prober ntfs-3g</code></li><li>如果为BIOS/MBR引导方式:<ol><li>安装grub包：<code>pacman -S grub</code></li><li>部署grub：<code>grub-install --target=i386-pc /dev/sdx</code> （将sdx换成你安装的硬盘）注意这里的sdx应该为硬盘（例如/dev/sda），而不是形如/dev/sda1这样的分区。</li><li>生成配置文件：<code>grub-mkconfig -o /boot/grub/grub.cfg</code></li></ol></li></ol></li><li>退出新安装好的系统：<code>exit</code></li><li>写在已经挂载好的分区：<code>umount -R /mnt</code></li><li>重启:<code>reboot</code></li><li>再次打开会有如下页面,输入root，再输入之前设置的密码，显示出命令提示符，恭喜你，你已经成功安装ArchLinux！<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210307113916.png" alt="" /></li></ol></li></ol><h1 id="美化arch"><a class="markdownIt-Anchor" href="#美化arch"></a> 美化Arch</h1><ul><li>安装xorg服务，xorg服务是linux桌面的硬件接口，所有的窗管都是x窗口的实现：<code>pacman -S xorg xterm xorg-xinit</code></li><li>安装显示管理器：显示管理器也就是Linux启动之后的启动界面。世界上有很多个显示管理器，这里使用sddm，一个不错的显示管理器。<ul><li>安装：<code>pacman -S sddm</code></li><li>设置开机自启动：<code>systemctl enable sddm.service</code></li></ul></li><li>安装KDE（Plasma）桌面：<ul><li><code>pacman -S plasma kde-applications</code></li></ul></li><li>重启之前先创建用户(使用默认设置）：<code>useradd -m username</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Arch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/SpringMVC/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/SpringMVC/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="springmvc简介"><a class="markdownIt-Anchor" href="#springmvc简介"></a> SpringMVC简介</h1><p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#spring-web">官方文档</a></p><ul><li>SpringMVC是一个web框架，围绕<code>DispatcherServlet</code>设计；</li><li>DispacherServelt的作用是将请求分发到不同的处理器。<ul><li>DispatcherServlet是一个实际的Servlet，它继承自HttpServlet类。</li></ul></li><li>SpringMVC和许多其他的MVC框架一样，以请求为驱动，围绕一个中心servlet分派请求及提供其他功能。</li><li>传统MVC架构：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210307210022.png" alt="" /></li></ul><h1 id="springmvc执行原理"><a class="markdownIt-Anchor" href="#springmvc执行原理"></a> SpringMVC执行原理</h1><ul><li>SpringMVC核心架构：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210307210107.png" alt="" /></li></ul><h1 id="快速入门"><a class="markdownIt-Anchor" href="#快速入门"></a> 快速入门</h1><ol><li>建立一个web支持的项目；</li><li>配置maven的资源过滤问题：</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;build&gt;    &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;            &lt;includes&gt;                &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;            &lt;&#x2F;includes&gt;            &lt;filtering&gt;false&lt;&#x2F;filtering&gt;        &lt;&#x2F;resource&gt;        &lt;resource&gt;            &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;            &lt;includes&gt;                &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;            &lt;&#x2F;includes&gt;            &lt;filtering&gt;false&lt;&#x2F;filtering&gt;        &lt;&#x2F;resource&gt;    &lt;&#x2F;resources&gt;&lt;&#x2F;build&gt;</code></pre><ol start="3"><li>导入相关依赖，主要是<code>spring-webmvc</code></li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;    &lt;version&gt;5.3.3&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><ol start="4"><li>配置web.xml<ul><li>web.xml的版本要4.0及以上；</li><li>在项目结构中，将maven导入的依赖，全部导入到artifacts的依赖中去。</li><li>注册DispatchServlet,管理SpringMVC配置文件，设置启动级别为1，映射路径为<code>/</code></li></ul></li></ol>  <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;  &lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;          xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;          xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;          version&#x3D;&quot;4.0&quot;&gt;      &lt;!-- 注册servlet --&gt;      &lt;servlet&gt;          &lt;servlet-name&gt;SpringMVC&lt;&#x2F;servlet-name&gt;          &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;、          &lt;!-- 通过初始化参数指定SpringMVC配置文件的位置，进行关联 --&gt;          &lt;init-param&gt;              &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;              &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;&#x2F;param-value&gt;          &lt;&#x2F;init-param&gt;          &lt;!-- 启动顺序，数字越小，启动越早 --&gt;          &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;      &lt;&#x2F;servlet&gt;      &lt;!-- 所有请求都会被springmvc拦截 --&gt;      &lt;servlet-mapping&gt;          &lt;servlet-name&gt;SpringMVC&lt;&#x2F;servlet-name&gt;          &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;      &lt;&#x2F;servlet-mapping&gt;  &lt;&#x2F;web-app&gt;</code></pre><ol start="5"><li>配置Springmvc-servlet.xml(web.xml关联的springmvc配置文件，放在resouce目录下)</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;       xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans            https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context            https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd&quot;&gt;    &lt;context:annotation-config&#x2F;&gt;    &lt;!--    自动扫描包，让指定包下的注解生效，由IOC容器统一管理--&gt;    &lt;context:component-scan base-package&#x3D;&quot;com.zestaken.controller&quot;&#x2F;&gt;    &lt;!--    让springmvc不处理静态资源，如.css .js .html .mp3 .mp4--&gt;        &lt;mvc:default-servlet-handler&#x2F;&gt;    &lt;!--    支持mvc注解驱动--&gt;        &lt;mvc:annotation-driven&#x2F;&gt;    &lt;!--    配置视图解析器--&gt;        &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;            id&#x3D;&quot;internalResourceViewResolver&quot;&gt;    &lt;!--        前缀--&gt;            &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot;&#x2F;&gt;    &lt;!--        后缀--&gt;            &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt;        &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;</code></pre><ul><li>在视图解析器中，将所有的视图都放在**/WEB-INF/**目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。</li></ul><ol start="6"><li>创建controller：</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(&quot;&#x2F;HelloController&quot;)public class HelloController &#123;        &#x2F;&#x2F;真实访问地址就是：项目名&#x2F;HelloController&#x2F;hello1    @RequestMapping(&quot;&#x2F;hello1&quot;)    public String sayHello(Model model) &#123;        &#x2F;&#x2F;向模型中添加属性msg与值，可以在jsp页面中取出并渲染        model.addAttribute(&quot;msg&quot;, &quot;hello, springmvc&quot;);        &#x2F;&#x2F;返回值代表视图：WEB-INF&#x2F;jsp&#x2F;hello.jsp        return &quot;hello&quot;;    &#125;&#125;</code></pre><ul><li><code>@Controller</code>是为了让Spring IOC容器自动扫描到；被这个注解的类中的所有方法，如果返回值是String，并且有具体的页面可以操作，那么就会被视图解析器解析。#</li><li><code>@ResquestMapping</code>是为了映射请求路径，这里因为类与方法上都有映射，所以访问时应该是<code>HelloController/hello</code>(类上的映射可以不写)</li><li>方法中声明的Model类型的参数是为了把Action中的数据带到视图层中；</li><li>方法返回的结果是视图的名称hello，加上==配置文件中的前后缀==变成WEB-INF/jsp/hello.jsp</li></ul><ol start="7"><li>创建视图层：<pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt;     &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;h1&gt;$&#123;msg&#125;&lt;&#x2F;h1&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt;</code></pre></li><li>启动tomcat，访问/HelloController/hello1。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210307221352.png" alt="" /></li></ol><h1 id="restful风格"><a class="markdownIt-Anchor" href="#restful风格"></a> Restful风格</h1><ul><li>Restful风格：一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</li><li>REST即Representational State Transfer的缩写，可译为&quot;表现层状态转化”。REST最大的几个特点为：资源、统一接口、URI和无状态。</li><li>资源：互联网所有的事物都可以被抽象为资源 。</li><li>资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。 <br />分别对应 添加、 删除、修改、查询。</li><li>传统方式操作资源：通过不同的参数来实现不同的效果，方法单一，都是GET或者POST。</li></ul><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;127.0.0.1&#x2F;item&#x2F;queryUser.action?id&#x3D;1   查询,GET http:&#x2F;&#x2F;127.0.0.1&#x2F;item&#x2F;saveUser.action             新增,POST http:&#x2F;&#x2F;127.0.0.1&#x2F;item&#x2F;updateUser.action          更新,POST http:&#x2F;&#x2F;127.0.0.1&#x2F;item&#x2F;deleteUser.action?id&#x3D;1  删除,GET或POST</code></pre><ul><li>使用RESTful操作资源 :<ul><li>通过不同的请求方法来实现不同的效果。请求的地址一样，但是因为请求的方式不同，实现的功能不同。<ul><li>可以通过 GET、 POST、 PUT、 PATCH、 DELETE 等方式对服务端的资源进行操作。其中，GET 用于查询资源，POST 用于创建资源，PUT 用于更新服务端的资源的全部信息，PATCH 用于更新服务端的资源的部分信息，DELETE 用于删除服务端的资源。</li></ul></li><li>同时隐藏了参数的传递，直接将参数写入到地址中，隐藏了参数名。</li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">【GET】 &#x2F;users # 查询用户信息列表【GET】 &#x2F;users&#x2F;1001 # 查看某个用户信息（其中1001就是要用到方法中的参数）【POST】 &#x2F;users # 新建用户信息【PUT】 &#x2F;users&#x2F;1001 # 更新用户信息(全部字段)【PATCH】 &#x2F;users&#x2F;1001 # 更新用户信息(部分字段)【DELETE】 &#x2F;users&#x2F;1001 # 删除用户信息</code></pre><ul><li>传统方法实现示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class HelloController &#123;    @RequestMapping(&quot;&#x2F;hello1&quot;)    public String sayHello(int a, int b,Model model) &#123;        int res &#x3D; a + b;        model.addAttribute(&quot;msg&quot;, &quot;输出结果为：&quot;+res);        return &quot;hello&quot;;    &#125;&#125;</code></pre><ul><li>请求这个方法的路径：<code>http://localhost:8080/SpringMVC_war_exploded/hello1?a=1&amp;b=2</code></li><li>Restful风格实现示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.*;@Controllerpublic class HelloController &#123;&#x2F;&#x2F;    @RequestMapping(value &#x3D; &quot;&#x2F;hello1&#x2F;&#123;a&#125;&#x2F;&#123;b&#125;&quot;,method &#x3D; RequestMethod.GET)    @GetMapping(&quot;&#x2F;hello&#x2F;&#123;a&#125;&#x2F;&#123;b&#125;&quot;)    public String GETHello(@PathVariable int a, @PathVariable int b, Model model) &#123;        int res &#x3D; a - b;        model.addAttribute(&quot;msg&quot;, &quot;GET输出结果为：&quot;+res);        return &quot;hello&quot;;    &#125;    @PostMapping(&quot;&#x2F;hello&#x2F;&#123;b&#125;&#x2F;&#123;a&#125;&quot;)    public String POSTHello(@PathVariable int a, @PathVariable int b, Model model) &#123;        int res &#x3D; a - b;        model.addAttribute(&quot;msg&quot;, &quot;POST输出结果为：&quot;+res);        return &quot;hello&quot;;    &#125;&#125;&#125;</code></pre><ul><li>将参数的传递放到路径中去：<ul><li>方法的参数必须加上<code>@PathVariable</code>注解</li><li>方法的路径中，必须对应方法的参数(名称相同，<code>&#123;a&#125;</code>对应参数<code>int a</code>)，并且用花括号括起来。</li></ul></li><li>限制不同的请求方法，只能使用不同的方法<ul><li>一种方法是给<code>@RequestMapping</code>注解加上method参数</li><li>一种方法是使用对应请求方法特有的map注解,如，GEI方法对应的<code>@GETMapping</code>注解。</li></ul></li><li>请求GETHello的请求路径：<code>http://localhost:8080/SpringMVC_war_exploded/hello/1/2</code><ul><li>路径中的参数必须与参数的类型对应。</li><li>请求生效必须采用GET方法。</li></ul></li></ul><h1 id="重定向和转发"><a class="markdownIt-Anchor" href="#重定向和转发"></a> 重定向和转发</h1><ul><li>法一： ModelAndView对象：设置该对象，根据view的名称，和视图解析器跳转到指定的页面。<ul><li>视图解析器配置示例：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--    配置视图解析器--&gt;     &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;         id&#x3D;&quot;internalResourceViewResolver&quot;&gt; &lt;!--        前缀--&gt;         &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot;&#x2F;&gt; &lt;!--        后缀--&gt;         &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt;     &lt;&#x2F;bean&gt; &lt;&#x2F;beans&gt;</code></pre><ul><li>页面位置：视图解析器的前缀 + viewName + 视图解析器后缀。</li><li>高级写法中，ModelAndView对象简化为了Model对象：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">  @RequestMapping(&quot;&#x2F;hello1&quot;)public String sayHello(int a, int b,Model model) &#123;    int res &#x3D; a + b;    model.addAttribute(&quot;msg&quot;, &quot;输出结果为：&quot;+res);    return &quot;hello&quot;;&#125;</code></pre><ul><li>在路径前面加上转发或者重定向的前缀，可以实现转发或者重定向（如果不加，==默认是转发==）：</li></ul>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">      @RequestMapping(&quot;&#x2F;hello1&quot;)public String sayHello(int a, int b,Model model) &#123;    int res &#x3D; a + b;    model.addAttribute(&quot;msg&quot;, &quot;输出结果为：&quot;+res);    &#x2F;&#x2F;重定向    return &quot;redirect:hello&quot;;&#125;</code></pre></li><li>法二：==不使用视图解析器==，直接使用SpringMvc实现<ul><li>这种情况下，需要将页面的位置具体出来。</li></ul>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">      @RequestMapping(&quot;&#x2F;hello1&quot;)public String sayHello(int a, int b,Model model) &#123;    int res &#x3D; a + b;    model.addAttribute(&quot;msg&quot;, &quot;输出结果为：&quot;+res);    return &quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;hello.jsp&quot;;&#125;</code></pre><pre><code>  * 默认是转发；  * 可以在路径前面加前缀，来分别实现转发和重定向。  * 如：</code></pre>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">      @RequestMapping(&quot;&#x2F;hello1&quot;)public String sayHello(int a, int b,Model model) &#123;    int res &#x3D; a + b;    model.addAttribute(&quot;msg&quot;, &quot;输出结果为：&quot;+res);    &#x2F;&#x2F;转发     return &quot;forward:&#x2F;WEB-INF&#x2F;jsp&#x2F;hello.jsp&quot;;&#125;      @RequestMapping(&quot;&#x2F;hello1&quot;)public String sayHello(int a, int b,Model model) &#123;    int res &#x3D; a + b;    model.addAttribute(&quot;msg&quot;, &quot;输出结果为：&quot;+res);    &#x2F;&#x2F;重定向(重定向好像不能访问WEB-INF文件夹下的内容)     return &quot;redirect:&#x2F;index.jsp&quot;;&#125;</code></pre></li></ul><h1 id="接收请求参数和数据回显"><a class="markdownIt-Anchor" href="#接收请求参数和数据回显"></a> 接收请求参数和数据回显</h1><ul><li>基本接收参数方式：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(&quot;&#x2F;user&quot;)public class UserController &#123;    &#x2F;&#x2F;请求示例：localhost:8080&#x2F;user&#x2F;t1 ? name &#x3D; zhangjie    @GetMapping(&quot;&#x2F;t1&quot;)    public String test1(String name, Model model) &#123;        &#x2F;&#x2F;name接收到前端传进来的参数name        System.out.println(name);        &#x2F;&#x2F;将要传给前端的结果封装到Model对象中，返回给前端        model.addAttribute(name);        &#x2F;&#x2F;视图跳转        return &quot;test&quot;;    &#125;&#125;</code></pre><ul><li>前端请求的参数必须与函数的形参名相同才行。</li><li>可以在需要从前端接收的参数名前加上<code>@RequestParam(&quot;前端传递的参数名&quot;)</code>来限定参数的性质。示例：</li></ul>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">public String test1(@RequestParam(&quot;username&quot;) String name, Model model) &#x2F;&#x2F;请求示例：localhost:8080&#x2F;user&#x2F;t1 ? username &#x3D; zhangjie</code></pre><ul><li>接收前端的参数：前端传递的参数可以==封装为一个对象==：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;实体类package com.zestaken.pojo;public class User &#123;    public void setId(int id) &#123;        this.id &#x3D; id;    &#125;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;    public int getId() &#123;        return id;    &#125;    public String getName() &#123;        return name;    &#125;    private int id;    private String name;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id&#x3D;&quot; + id +                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;&#x2F;&#x2F;controller类@Controller@RequestMapping(&quot;&#x2F;user&quot;)public class UserController &#123;    &#x2F;&#x2F;请求示例：localhost:8080&#x2F;user&#x2F;t1 ? id &#x3D; 1 &amp;&amp; name &#x3D; zhangjie     @GetMapping(&quot;&#x2F;t1&quot;)    public String test1(User user, Model model) &#123;        &#x2F;&#x2F;name接收到前端传进来的参数user        System.out.println(user.toString());        &#x2F;&#x2F;将要传给前端的结果封装到Model对象中，返回给前端        model.addAttribute(user.toString());        &#x2F;&#x2F;视图跳转        return &quot;test&quot;;    &#125;&#125;</code></pre><ul><li>接收前端用户传递的参数，判断参数的名字，==假设参数名字直接在方法的形参中定义了，可以直接使用==</li><li>假设方法中定义的形参是一个对象，则将前端传递的参数与对象中的属性名进行匹配，如果名字一致则将参数写到对象的属性中去，如果不一致匹配不到则该对象的该属性值为空。</li><li>回显结果到前端：通过ModelAndView对象实现</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.controller;import org.springframework.stereotype.Controller;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.lang.annotation.Annotation;public class Controller2 implements Controller &#123;    public ModelAndView test1(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) &#123;        ModelAndView modelAndView &#x3D; new ModelAndView();        &#x2F;&#x2F;设置返回给前端的内容        modelAndView.addObject(&quot;msg&quot;, &quot;controllertest&quot;);        &#x2F;&#x2F;设置要响应的前端页面        modelAndView.setViewName(&quot;test&quot;);        return modelAndView;    &#125;    @Override    public String value() &#123;        return null;    &#125;    @Override    public Class&lt;? extends Annotation&gt; annotationType() &#123;        return null;    &#125;&#125;</code></pre><ul><li>需要实现Controller接口；</li><li>可以获取请求和响应的参数；</li><li>通过ModelAndView对象来设置响应给前端的结果，和具体的的前端页面。</li><li>回显结果到前端：通过Model对象来实现。</li><li>回显结果到前端：通过ModelMap来实现。</li><li>三种回显数据的方法的对比：<ul><li>Model：只有几种方法，只适用于储存数据，是ModelMap的精简版；</li><li>ModelMap:继承了LinkedMap,除了实现了自身的一些方法，同样的继承LinkedMap方法和特性。功能更齐全。</li><li>ModelAndView:可以在储存数据的同时，进行设置返回的逻辑视图，进行控制展示层的跳转。</li></ul></li></ul><h1 id="后台乱码问题"><a class="markdownIt-Anchor" href="#后台乱码问题"></a> 后台乱码问题</h1><ul><li>在前端编码方式为utf-8的情况下，因为服务端的编码问题导致经由后台代码的中文输出为乱码。</li><li>解决方案：使用SpringMVC的乱码过滤器过滤器。</li><li>在<code>web.xml</code>中配置SpringMVC的乱码过滤器：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;filter&gt;    &lt;filter-name&gt;encoding&lt;&#x2F;filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;        &lt;param-name&gt;utf-8&gt;&lt;&#x2F;param-name&gt;    &lt;&#x2F;init-param&gt;&lt;&#x2F;filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;encoding&lt;&#x2F;filter-name&gt;    &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;&lt;&#x2F;filter-mapping&gt;</code></pre><h1 id="ssm整合"><a class="markdownIt-Anchor" href="#ssm整合"></a> SSM整合</h1><ol><li>maven的pom.xml配置，导入相关依赖包</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;    &lt;groupId&gt;com.example&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;ssm&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;    &lt;name&gt;ssm&lt;&#x2F;name&gt;    &lt;packaging&gt;war&lt;&#x2F;packaging&gt;    &lt;properties&gt;        &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;        &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt;        &lt;junit.version&gt;5.6.2&lt;&#x2F;junit.version&gt;    &lt;&#x2F;properties&gt;&lt;!--    依赖：junit，数据库驱动，连接池，servlet，jsp，mybatis，mybatis-spring，spring servlet jsp jstl--&gt;    &lt;dependencies&gt;&lt;!--        web包--&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;javaee-web-api&lt;&#x2F;artifactId&gt;            &lt;version&gt;8.0.1&lt;&#x2F;version&gt;            &lt;scope&gt;provided&lt;&#x2F;scope&gt;        &lt;&#x2F;dependency&gt;&lt;!--        junit--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.junit.jupiter&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;junit-jupiter-api&lt;&#x2F;artifactId&gt;            &lt;version&gt;$&#123;junit.version&#125;&lt;&#x2F;version&gt;            &lt;scope&gt;test&lt;&#x2F;scope&gt;        &lt;&#x2F;dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.junit.jupiter&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;junit-jupiter-engine&lt;&#x2F;artifactId&gt;            &lt;version&gt;$&#123;junit.version&#125;&lt;&#x2F;version&gt;            &lt;scope&gt;test&lt;&#x2F;scope&gt;        &lt;&#x2F;dependency&gt;&lt;!--        mysql数据库驱动包， 数据库连接池c3p0--&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;            &lt;version&gt;8.0.23&lt;&#x2F;version&gt;        &lt;&#x2F;dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.mchange&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;c3p0&lt;&#x2F;artifactId&gt;            &lt;version&gt;0.9.5.2&lt;&#x2F;version&gt;        &lt;&#x2F;dependency&gt;&lt;!--        servlet jsp--&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt;            &lt;version&gt;2.5&lt;&#x2F;version&gt;        &lt;&#x2F;dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt;            &lt;version&gt;2.2&lt;&#x2F;version&gt;        &lt;&#x2F;dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;jstl&lt;&#x2F;artifactId&gt;            &lt;version&gt;1.2&lt;&#x2F;version&gt;        &lt;&#x2F;dependency&gt;&lt;!--        mybatis mybatis-spring--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;            &lt;version&gt;3.5.6&lt;&#x2F;version&gt;        &lt;&#x2F;dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt;            &lt;version&gt;2.0.6&lt;&#x2F;version&gt;        &lt;&#x2F;dependency&gt;&lt;!--        spring依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;            &lt;version&gt;5.3.3&lt;&#x2F;version&gt;        &lt;&#x2F;dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;            &lt;version&gt;5.3.4&lt;&#x2F;version&gt;        &lt;&#x2F;dependency&gt;    &lt;&#x2F;dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;                &lt;artifactId&gt;maven-war-plugin&lt;&#x2F;artifactId&gt;                &lt;version&gt;3.3.0&lt;&#x2F;version&gt;            &lt;&#x2F;plugin&gt;        &lt;&#x2F;plugins&gt;&lt;!--        配置静态资源导出问题--&gt;            &lt;resources&gt;                &lt;resource&gt;                    &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;                    &lt;includes&gt;                        &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;                        &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;                    &lt;&#x2F;includes&gt;                    &lt;filtering&gt;false&lt;&#x2F;filtering&gt;                &lt;&#x2F;resource&gt;                &lt;resource&gt;                    &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;                    &lt;includes&gt;                        &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;                        &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;                    &lt;&#x2F;includes&gt;                    &lt;filtering&gt;false&lt;&#x2F;filtering&gt;                &lt;&#x2F;resource&gt;            &lt;&#x2F;resources&gt;    &lt;&#x2F;build&gt;&lt;&#x2F;project&gt;</code></pre><ol start="2"><li>编写基本目录结构：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210312104652.png" alt="" /></li></ol><h2 id="一mybaits层编写"><a class="markdownIt-Anchor" href="#一mybaits层编写"></a> 一：mybaits层编写</h2><ol><li><p>连接数据库<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210311225308.png" alt="" /></p></li><li><p>编写mybatis层配置：</p><ol><li>mybatis-config.xml，并管理</li></ol></li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;&lt;!-- 核心配置文件 --&gt;&lt;configuration&gt;&lt;!--    配置数据源的工作交给spring去做--&gt;&lt;!--    &lt;properties resource&#x3D;&quot;db.properties&quot;&gt;--&gt;&lt;!--        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;--&gt;&lt;!--    &lt;&#x2F;properties&gt;--&gt;&lt;!--    &lt;environments default&#x3D;&quot;development&quot;&gt;--&gt;&lt;!--        &lt;environment id&#x3D;&quot;development&quot;&gt;--&gt;&lt;!--            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;--&gt;&lt;!--            &lt;!&amp;ndash;配置数据源&amp;ndash;&gt;--&gt;&lt;!--            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;--&gt;&lt;!--                &lt;!&amp;ndash;注册驱动，同jdbc&amp;ndash;&gt;--&gt;&lt;!--                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt;--&gt;&lt;!--                &lt;!&amp;ndash;数据库连接路径&amp;ndash;&gt;--&gt;&lt;!--                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;--&gt;&lt;!--                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;--&gt;&lt;!--                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt;--&gt;&lt;!--            &lt;&#x2F;dataSource&gt;--&gt;&lt;!--        &lt;&#x2F;environment&gt;--&gt;&lt;!--    &lt;&#x2F;environments&gt;--&gt;&lt;!--    mybatis的配置文件中可以做配置别名等工作--&gt;&lt;typeAliases&gt;    &lt;package name&#x3D;&quot;com.zestaken.pojo&quot;&#x2F;&gt;&lt;&#x2F;typeAliases&gt;&lt;!--每一个Mapper.xml文件都需要在这个mybatis核心配置文件中注册--&gt;&lt;mappers&gt;    &lt;mapper resource&#x3D;&quot;com&#x2F;zestaken&#x2F;dao&#x2F;T_collegeMapper.xml&quot;&#x2F;&gt;&lt;&#x2F;mappers&gt;&lt;&#x2F;configuration&gt;</code></pre><ol start="3"><li>编写数据库配置文件：database.properties</li></ol><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">jdbc.driver &#x3D; com.mysql.cj.Driver# 如果使用的是MySQL8.0以上版本，需要加上一个时区配置:serverTimezone&#x3D;Asia&#x2F;Shanghaijdbc.url &#x3D; jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;youth_study?serverTimezone&#x3D;Asia&#x2F;Shanghaijdbc.usrname &#x3D; rootjdbc.password &#x3D; root</code></pre><ol start="4"><li>编写实体类pojo：</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.pojo;import java.sql.Date;public class T_college &#123;    private int id;    private String name;    private Date gmt_create;    private Date gmt_modified;    public int getId() &#123;        return id;    &#125;    public String getName() &#123;        return name;    &#125;    public Date getGmt_create() &#123;        return gmt_create;    &#125;    public Date getGmt_modified() &#123;        return gmt_modified;    &#125;    public void setId(int id) &#123;        this.id &#x3D; id;    &#125;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;    public void setGmt_create(Date gmt_create) &#123;        this.gmt_create &#x3D; gmt_create;    &#125;    public void setGmt_modified(Date gmt_modified) &#123;        this.gmt_modified &#x3D; gmt_modified;    &#125;    @Override    public String toString() &#123;        return &quot;T_college&#123;&quot; +                &quot;id&#x3D;&quot; + id +                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, gmt_create&#x3D;&quot; + gmt_create +                &quot;, gmt_modified&#x3D;&quot; + gmt_modified +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><ul><li>属性名与数据库字段名相同；</li><li>并编写每个属性的getter和setter方法</li><li>编写toString方法</li><li><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210312110729.png" alt="" /></li><li>类名就是表名配合首字母大写</li></ul><ol start="5"><li>编写操作数据库的方法（dao层）接口，命名为pojo实体类加Mapper，如：T_collegeMapper</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.dao;import com.zestaken.pojo.T_college;import org.apache.ibatis.annotations.Param;import java.util.List;public interface T_collegeMapper &#123;    &#x2F;&#x2F;    增加一个学院    int addCollege(T_college college);    &#x2F;&#x2F;删除一个指定的学院    int deleteCollege(@Param(&quot;collegeID&quot;) int id);    &#x2F;&#x2F;更新一个学院的信息    int updateCollege(T_college college);    &#x2F;&#x2F;查询一个学院    T_college queryCollege(@Param(&quot;collegeID&quot;) int id);    &#x2F;&#x2F;查询全部的学院    List&lt;T_college&gt; queryAllCollege();&#125;</code></pre><p>6.编写对应dao层接口的mapper配置文件：T_collegeMapper.xml</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace&#x3D;&quot;com.zestaken.dao.T_collegeMapper&quot;&gt;    &lt;insert id&#x3D;&quot;addCollege&quot; parameterType&#x3D;&quot;T_college&quot;&gt;    insert into youth_study.t_college(id,name)    value (#&#123;id&#125;,#&#123;name&#125;);    &lt;&#x2F;insert&gt;    &lt;delete id&#x3D;&quot;deleteCollege&quot; parameterType&#x3D;&quot;int&quot;&gt;    delete from youth_study.t_college    where id &#x3D; #&#123;collegeID&#125;;    &lt;&#x2F;delete&gt;        &lt;update id&#x3D;&quot;updateCollege&quot; parameterType&#x3D;&quot;T_college&quot;&gt;    update youth_study.t_college    set name&#x3D;#&#123;name&#125;    where id &#x3D; #&#123;id&#125;;    &lt;&#x2F;update&gt;    &lt;select id&#x3D;&quot;queryCollege&quot; resultType&#x3D;&quot;T_college&quot;&gt;    select * form youth_study.t_college    where id &#x3D; #&#123;collegeID&#125;;    &lt;&#x2F;select&gt;    &lt;select id&#x3D;&quot;queryAllCollege&quot; resultType&#x3D;&quot;T_college&quot;&gt;    select * from youth_study.t_college;    &lt;&#x2F;select&gt;&lt;&#x2F;mapper&gt;</code></pre><ol start="7"><li>绑定mapper，在mybatis-config.xml中配置：</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;mappers&gt;    &lt;mapper resource&#x3D;&quot;com&#x2F;zestaken&#x2F;dao&#x2F;T_collegeMapper.xml&quot;&#x2F;&gt;&lt;&#x2F;mappers&gt;</code></pre><p>8.编写业务层的接口：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.service;import com.zestaken.pojo.T_college;import java.util.List;public interface T_collegeService &#123;    &#x2F;&#x2F;    增加一个学院    int addCollege(T_college college);    &#x2F;&#x2F;删除一个指定的学院    int deleteCollege(int id);    &#x2F;&#x2F;更新一个学院的信息    int updateCollege(T_college college);    &#x2F;&#x2F;查询一个学院    T_college queryCollege(int id);    &#x2F;&#x2F;查询全部的学院    List&lt;T_college&gt; queryAllCollege();&#125;</code></pre><p>9.实现业务层的接口:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.service;import com.zestaken.dao.T_collegeMapper;import com.zestaken.pojo.T_college;import java.util.List;public class T_collegeServiceImpl implements T_collegeService&#123;    &#x2F;&#x2F;service层调dao层实现功能    private T_collegeMapper t_collegeMapper;    &#x2F;&#x2F;方便之后用Spring托管这个对象    public void setT_collegeMapper(T_collegeMapper t_collegeMapper) &#123;        this.t_collegeMapper &#x3D; t_collegeMapper;    &#125;    @Override    public int addCollege(T_college college) &#123;        return t_collegeMapper.addCollege(college);    &#125;    @Override    public int deleteCollege(int id) &#123;        return t_collegeMapper.deleteCollege(id);    &#125;    @Override    public int updateCollege(T_college college) &#123;        return t_collegeMapper.updateCollege(college);    &#125;    @Override    public T_college queryCollege(int id) &#123;        return t_collegeMapper.queryCollege(id);    &#125;    @Override    public List&lt;T_college&gt; queryAllCollege() &#123;        return t_collegeMapper.queryAllCollege();    &#125;&#125;</code></pre><h2 id="spring层"><a class="markdownIt-Anchor" href="#spring层"></a> Spring层</h2><ul><li>要将Spring相关的所有配置文件整合在到一起（本质上写一个spring的配置文件就足够了，分开写只是为了思路更清晰）<ul><li>可以通过用import配置文件的方法实现:<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210313164643.png" alt="" /></li><li>也可以利用idea配置实现：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210313164431.png" alt="" /></li></ul></li></ul><h3 id="spring整合dao层"><a class="markdownIt-Anchor" href="#spring整合dao层"></a> Spring整合dao层</h3><ul><li>编写spring-dao.xml配置文件：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans            https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context            https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;&lt;!--    关联数据库配置文件--&gt;    &lt;context:property-placeholder location&#x3D;&quot;classpath:database.properties&quot;&#x2F;&gt;&lt;!--    配置连接池，此处使用c3p0--&gt;    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;property name&#x3D;&quot;driverClass&quot; value&#x3D;&quot;$&#123;jdbc.driver&#125;&quot;&#x2F;&gt;        &lt;property name&#x3D;&quot;jdbcUrl&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;        &lt;property name&#x3D;&quot;user&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&quot;&#x2F;&gt;    &lt;!--        c3p0配置--&gt;        &lt;property name&#x3D;&quot;maxPoolSize&quot; value&#x3D;&quot;30&quot;&#x2F;&gt;        &lt;property name&#x3D;&quot;minPoolSize&quot; value&#x3D;&quot;10&quot;&#x2F;&gt;        &lt;property name&#x3D;&quot;autoCommitOnClose&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;        &lt;property name&#x3D;&quot;checkoutTimeout&quot; value&#x3D;&quot;10000&quot;&#x2F;&gt;        &lt;property name&#x3D;&quot;acquireRetryAttempts&quot; value&#x3D;&quot;2&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;&lt;!--    sqlSessionFactory配置--&gt;    &lt;bean id&#x3D;&quot;sqlSessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;    &lt;!--        绑定数据源--&gt;        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;    &lt;!--        绑定mybatis的配置文件--&gt;        &lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;classpath:mybatis-config.xml&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;&lt;!--    配置dao接口的扫描包 动态实现Dao接口注入到Spring容器中（不用写接口实现类了）--&gt;    &lt;bean class&#x3D;&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;        &lt;property name&#x3D;&quot;sqlSessionFactoryBeanName&quot; value&#x3D;&quot;sqlSessionFactory&quot;&#x2F;&gt;        &lt;property name&#x3D;&quot;basePackage&quot; value&#x3D;&quot;com.zestaken.dao&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;</code></pre><h3 id="spring整合service层"><a class="markdownIt-Anchor" href="#spring整合service层"></a> Spring整合service层</h3><ul><li>写一个spring-sevice.xml配置文件：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans            https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context            https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;&lt;!--    扫描service层下的包, 要被扫描的类上面要加上@Compoent（或者更详细的@Service注解）--&gt;    &lt;context:component-scan base-package&#x3D;&quot;com.zestaken.service&quot;&#x2F;&gt;&lt;!--    将service层的业务类注入到Spring，可以通过配置，或者注解实现--&gt;    &lt;bean id&#x3D;&quot;T_collegeServiceImpl&quot; class&#x3D;&quot;com.zestaken.service.T_collegeServiceImpl&quot;&gt;        &lt;property name&#x3D;&quot;t_collegeMapper&quot; ref&#x3D;&quot;t_collegeMapper&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;&lt;!--声明式事务配置--&gt;    &lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;&lt;!--        注入数据源--&gt;        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;</code></pre><ul><li>如果需要aop的配置，也写在这里。</li></ul><h2 id="springmvc层"><a class="markdownIt-Anchor" href="#springmvc层"></a> SpringMVC层</h2><ul><li>编写WEB-INF目录下的web.xml配置文件：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;         version&#x3D;&quot;4.0&quot;&gt;&lt;!--    DispatchServlet配置--&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;&lt;!--            &lt;param-value&gt;classpath:spring-mvc.xml&lt;&#x2F;param-value&gt;--&gt;&lt;!--            不能只导入Springmvc的配置文件，需要导入所有spring的配置文件，不然有一些bean会找不到--&gt;            &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt;        &lt;&#x2F;init-param&gt;        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;    &lt;&#x2F;servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;        &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;    &lt;&#x2F;servlet-mapping&gt;    &lt;!--    乱码过滤配置--&gt;    &lt;filter&gt;        &lt;filter-name&gt;encodingFilter&lt;&#x2F;filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;            &lt;param-value&gt;utf-8&lt;&#x2F;param-value&gt;        &lt;&#x2F;init-param&gt;    &lt;&#x2F;filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;encodingFilter&lt;&#x2F;filter-name&gt;        &lt;url-pattern&gt;*&lt;&#x2F;url-pattern&gt;    &lt;&#x2F;filter-mapping&gt;&lt;!--    配置session--&gt;    &lt;session-config&gt;        &lt;session-timeout&gt;15&lt;&#x2F;session-timeout&gt;    &lt;&#x2F;session-config&gt;&lt;&#x2F;web-app&gt;&gt;</code></pre><ul><li>编写spring-mvc.xml配置文件：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans            https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context            https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;comtext&#x2F;spring-context.xsd            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd&quot;&gt;&lt;!--    注解驱动--&gt;    &lt;mvc:annotation-driven&#x2F;&gt;&lt;!--    静态资源过滤--&gt;    &lt;mvc:default-servlet-handler&#x2F;&gt;&lt;!--    扫描包：controller--&gt;    &lt;context:component-scan base-package&#x3D;&quot;com.zestaken.controller&quot;&#x2F;&gt;&lt;!--    视图解析器--&gt;    &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot;&#x2F;&gt;        &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;</code></pre><h2 id="编写实际项目"><a class="markdownIt-Anchor" href="#编写实际项目"></a> 编写实际项目</h2><ul><li>编写web.xml(WEB-INF)目录下的：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;         version&#x3D;&quot;4.0&quot;&gt;&lt;!--    DispatchServlet配置--&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;&lt;!--            &lt;param-value&gt;classpath:spring-mvc.xml&lt;&#x2F;param-value&gt;--&gt;&lt;!--            不能只导入Springmvc的配置文件，需要导入所有spring的配置文件，不然有一些bean会找不到--&gt;            &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt;        &lt;&#x2F;init-param&gt;        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;    &lt;&#x2F;servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;        &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;    &lt;&#x2F;servlet-mapping&gt;&lt;!--    &lt;context-param&gt;--&gt;&lt;!--        &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;--&gt;&lt;!--        &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt;--&gt;&lt;!--    &lt;&#x2F;context-param&gt;--&gt;    &lt;!--    乱码过滤配置--&gt;    &lt;filter&gt;        &lt;filter-name&gt;encodingFilter&lt;&#x2F;filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;            &lt;param-value&gt;utf-8&lt;&#x2F;param-value&gt;        &lt;&#x2F;init-param&gt;    &lt;&#x2F;filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;encodingFilter&lt;&#x2F;filter-name&gt;        &lt;url-pattern&gt;*&lt;&#x2F;url-pattern&gt;    &lt;&#x2F;filter-mapping&gt;&lt;!--    配置session--&gt;    &lt;session-config&gt;        &lt;session-timeout&gt;15&lt;&#x2F;session-timeout&gt;    &lt;&#x2F;session-config&gt;&lt;&#x2F;web-app&gt;</code></pre><ul><li>编写controller：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.controller;import com.zestaken.pojo.T_college;import com.zestaken.service.T_collegeService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import java.util.List;@Controller@RequestMapping(&quot;&#x2F;college&quot;)public class T_collegeController &#123;    &#x2F;&#x2F;controller调service层    @Autowired    @Qualifier(&quot;T_collegeServiceImpl&quot;)    private T_collegeService t_collegeService;    public void setT_collegeService(T_collegeService t_collegeService) &#123;        this.t_collegeService &#x3D; t_collegeService;    &#125;    @RequestMapping(&quot;&#x2F;allCollege&quot;)    public  String queryAllCollege(Model model) &#123;        List&lt;T_college&gt; t_colleges &#x3D; t_collegeService.queryAllCollege();        model.addAttribute(&quot;msg&quot;, t_colleges);        return &quot;allCollege&quot;;    &#125;&#125;</code></pre><ul><li>编写页面：<ul><li><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210313220441.png" alt="" /></li></ul></li></ul><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%--  Created by IntelliJ IDEA.  User: 12246  Date: 2021&#x2F;3&#x2F;13  Time: 19:15  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;首页&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h1&gt;    &lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;college&#x2F;allCollege&quot;&gt;进入学院展示页面&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%--  Created by IntelliJ IDEA.  User: 12246  Date: 2021&#x2F;3&#x2F;13  Time: 19:14  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;allCollege&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h1&gt;$&#123;msg&#125;&lt;&#x2F;h1&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><ul><li>配置Tomcat，启动项目。</li><li>最后总架构：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210313220644.png" alt="" /></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 后端 </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言-错误处理与信号处理</title>
      <link href="//post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/index.html"/>
      <url>//post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="errnoh错误"><a class="markdownIt-Anchor" href="#errnoh错误"></a> <code>&lt;errno.h&gt;</code>:错误</h1><ul><li>标准库中的一些函数通过向<code>&lt;erron.h&gt;</code>中声明的<strong>int型errno变量</strong>存储一个错误码（正整数）来表示有错误发生。</li><li>如果使用的一个库函数，通过给errno赋值来产生程序运行出错的信号，我们可以在调用这个函数之后，==检查erron的值是否为0==，来判断函数调用过程中是否有错误发生。</li><li>使用errno来检测函数调用的错误，需要==在函数调用前将errno置零==。</li><li>errno中存储的错误值经常是以下两个宏：<ul><li><strong>EDOM(定义域错误)</strong>：传递给函数的一个参数==超出了定义域==，使用这个宏。</li><li><strong>ERANGE(取值范围错误)</strong>：函数的==返回值太大,无法用返回类型==。</li></ul></li><li>与变量errno有关的两个函数（都不属于<code>&lt;errno.h&gt;</code>）:<ul><li><strong>perror</strong>函数：<ul><li>在<code>&lt;stdio.h&gt;</code>中声明，用于显示描述错误的信息；perror函数会==输出到stderr流==。</li><li>原型：<code>void perror(const char *s)</code></li><li>参数：<ul><li>一个作为部分错误消息的字符串。</li></ul></li><li>返回值：<ul><li>依次显示下列内容：<ol><li>调用perror的参数；</li><li>一个分号；</li><li>一个空格；</li><li>一条出错消息：消息的内容根据errno的值决定；</li><li>一个换行符。</li></ol></li><li>示例：<code>perror(&quot;sqrt error&quot;); sqrt error: Numercial argument out of domain</code></li></ul></li></ul></li><li><strong>strerror</strong>函数：<ul><li>在<code>&lt;string.h&gt;</code>声明，当以错误码为参数调用strerror时，函数会==返回一个指针,它指向一个描述这个错误的字符串==；</li><li>原型：<code>char *strerror(int errnum)</code></li><li>参数：<ul><li>strerror函数的参数==通常是errno的值==，但以任意整数为参数都能返回一个字符串。</li></ul></li><li>示例：<code>puts(strerror(EDOM))</code></li></ul></li><li>对于同一个错误，perror函数和strerror函数返回的消息的值是相同的。</li></ul></li><li>示例：</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">errno &#x3D; 0;y &#x3D; sqrt(x);if(errno !&#x3D; 0) &#123;    perror(&quot;sqrt error&quot;);    puts(strerror(erron));&#125;</code></pre><h1 id="signalh信号处理"><a class="markdownIt-Anchor" href="#signalh信号处理"></a> <code>&lt;signal.h&gt;</code>：信号处理</h1><ul><li><code>&lt;signal.h&gt;</code>提供了==处理异常情况（异常情况又称为信号）的工具==。</li><li><strong>信号</strong>：当有错误或者外部事件发生时，称为产生了一个信号。很多信号可以在程序执行过程中的任意时刻发生。</li><li><strong>信号类型</strong>：<ul><li>==运行时错误==，如（除以0）；</li><li>==发生在程序以外的事件==，如：操作系统对正在运行的程序的中断信号。</li></ul></li><li><strong>信号宏</strong>：<ul><li>信号宏：<code>&lt;signal.h&gt;</code>中定义了一系列的宏,==用于表示不同的信号==；</li><li>6种信号宏：<ol><li><code>SIGABRT</code>:异常终止；</li><li><code>SIGFPE</code>:在算术运算中发生错误；</li><li><code>SIGILL</code>:无效指令；</li><li><code>SIGINT</code>:中断；</li><li><code>SIGSEGV</code>:无效存储访问；</li><li><code>SIGTERM</code>:终止请求。</li></ol></li></ul></li><li><strong>signal</strong>函数：<ul><li>signal是<code>&lt;signal.h&gt;</code>提供的，用来==安装信号处理函数，以便将来给定的信号发生时使用==。</li><li>原型：<code>void (*signal(int sig, void (*func)(int)))(int)</code></li><li>参数：<ul><li>第一个参数是==特定信号的编码（表示不同信号的宏）==；</li><li>第二个参数是==一个指向会在信号发生时处理这一信号的函数的指针==；</li></ul></li><li>返回值：<ul><li>一旦调用信号处理函数返回,==程序会从信号发生点恢复并继续执行==，除了SIGABRT和SIGFPE两种信号。</li><li>signal的返回值是一个==指向指定信号的前一个处理函数的指针==。可以用于恢复原来的处理函数。</li><li>如果一个signal函数调用失败，==会返回SIG_ERR（一个在<code>&lt;signal.h&gt;</code>中定义的宏）并在errno中存入一个正值。==</li></ul></li></ul></li><li><strong>信号处理函数</strong>:<ul><li>自定义信号处理函数：<ul><li>每个信号处理函数都必须有一个==int类型的参数==，且返回类型为void。</li><li>当一个特定的信号产生并调用相应的信号处理函数时，==信号的编码会作为参数传递给处理函数==。</li></ul></li><li>预定义的信号处理函数：<code>&lt;signal.h&gt;</code>提供了一些预定义的信号处理函数,这些函数==都是用宏表示的==。<ul><li><strong>SIG_DFL</strong>:<ul><li>按==默认==方式处理信号。</li><li>调用该函数的结果是由实现定义的，但大多数情况下会导致程序终止。</li></ul></li><li><strong>SIG_IGN</strong>:<ul><li>当指定的信号产生时，==忽略该信号==；</li></ul></li></ul></li></ul></li><li><strong>raise</strong>函数：<ul><li><code>&lt;signal.h&gt;</code>中声明，用来==使程序主动触发信号==。</li><li>原型：<code>int raise(int sig)</code></li><li>参数：<ul><li>sig参数用于==指定所需信号的编码==；</li></ul></li><li>返回值：<ul><li>raise函数的返回值，代表产生信号是否成功：==成功为0，失败为非0==。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 专业基础 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言-输入输出</title>
      <link href="//post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/index.html"/>
      <url>//post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="流"><a class="markdownIt-Anchor" href="#流"></a> 流</h1><ul><li><strong>流(Stream)</strong>: C语言中，流表示==任意输入的源或任意输出的目的地==。</li><li>流经常表示存储在不同介质的==文件==，也经常和==不存储文件的设备(如网络端口，打印机)==关联。</li><li><code>&lt;stido.h&gt;</code>中的函数可以处理各种形式的流。</li></ul><h2 id="文件指针"><a class="markdownIt-Anchor" href="#文件指针"></a> 文件指针</h2><ul><li><strong>文件指针(file pointer)</strong>：C程序中==对流的访问是通过文件指针来实现的==。</li><li><strong>文件指针的类型</strong>：<code>FILE *</code><ul><li>FILE类型是在<code>&lt;stdio.h&gt;</code>中声明的。</li><li>示例:<code>FILE *fp1;</code></li></ul></li></ul><h2 id="标准流和重定向"><a class="markdownIt-Anchor" href="#标准流和重定向"></a> 标准流和重定向</h2><ul><li><code>&lt;stdio.h&gt;</code>提供了3个标准流：<ol><li><code>stdin</code>:标准输入流，默认是键盘。</li><li><code>stdout</code>:标准输出流，默认是屏幕。</li><li><code>stderr</code>:标准错误，默认是屏幕。</li></ol></li><li><strong>标准流的特性</strong>：<ul><li>这三个标准流==可以直接使用，不需要对其进行声明，也不用打开或者关闭==。</li><li>stdin,stdout,stderr是三个==文件指针==。</li></ul></li><li><strong>重定向</strong>：<ul><li>操作系统通过==重定向的操作改变标准流的默认含义==。</li><li><strong>输出重定向</strong>：使stdin流表示文件，而不是键盘,通过在命令行中使用<code>&lt;</code>实现，如：<code>demo &lt;in.dat</code>,运行demo程序时从in.dat文件中获取数据。</li><li><strong>输出重定向</strong>：使stdout流表示文件，而不是屏幕，通过在命令行中使用<code>&gt;</code>实现，如：<code>demo &gt;out.dat</code>，运行demo程序时输出到out.dat文件中。</li></ul></li></ul><h2 id="文本文件和二进制文件"><a class="markdownIt-Anchor" href="#文本文件和二进制文件"></a> 文本文件和二进制文件</h2><ul><li><code>&lt;stdio.h&gt;</code>支持<strong>文本文件</strong>和<strong>二进制文件</strong>。</li><li><strong>文本文件(text file)</strong>：<ul><li>在文本文件中，==字节表示字符==；</li><li><strong>文本文件分为若干行</strong>：<ul><li>文本文件的每一行通常==以一两个特殊字符结尾==；</li><li>windows系统是以==回车符<code>\x0d</code>和回行符<code>\x0a</code>==结尾；</li><li>unix操作系统是以==一个单独的回行符<code>\x0a</code>==结尾。</li></ul></li><li><strong>文本文件末尾可以包含一个特殊的文件末尾标识符</strong>：<ul><li>文件末尾标识==不是必须的，但一旦存在，就标志着文件的结束==。</li></ul></li></ul></li><li><strong>二进制文件</strong>：<ul><li>在二进制文件中，==字节可以表示很多类型的数据==。</li><li>二进制文件==不分行，没有行末标记和文件末尾标记==。</li></ul></li></ul><h1 id="文件操作"><a class="markdownIt-Anchor" href="#文件操作"></a> 文件操作</h1><ul><li><code>&lt;stdio.h&gt;</code>提供了一系列的文件操作，包括打开文件，关闭文件，改变文件的缓冲方式，删除文件以及重命名文件等。</li></ul><h2 id="打开文件"><a class="markdownIt-Anchor" href="#打开文件"></a> 打开文件</h2><ul><li><strong><code>fopen()</code>函数</strong>：<ul><li>将文件打开并用作==流==；</li><li>原型：<code>FILE *fopen(const char *filename, const char *mode)</code></li><li><strong>filename</strong>：要打开文件的文件名（可能包含文件的==路径信息==。）<ul><li>路径：在windows系统中的路径中含有<code>\</code>,会被C语言识别为转移字符，而导致错误。常用<code>\\</code>或者<code>/</code>来替换路径中的<code>\</code>。</li></ul></li><li><strong>mode</strong>:==模式字符串==，用来指定打算对文件执行的操作。对==文本文件和对二进制文件的模式字符串是不一样的==。<ul><li>对<strong>文本文件</strong>的六种模式字符串：<ol><li><code>&quot;r&quot;</code>:打开文件用于读；</li><li><code>&quot;w&quot;</code>:打开文件用于写(文件不需要存在)</li><li><code>&quot;a&quot;</code>:打开文件用于追加（文件不需要存在）</li><li><code>&quot;r+&quot;</code>&quot;:打开文件用于==读和写，从文件头开始==；</li><li><code>&quot;w+&quot;</code>:打开文件用于==读和写（如果文件存在就清空）==；</li><li><code>&quot;a+&quot;</code>:打开文件用于==读和写（如果文件存在就追加）==。</li></ol></li><li>对<strong>二进制文件</strong>也有六种模式字符串，只需要在文件文件的基础上==加上b==即可。</li></ul></li><li><strong>返回值</strong>：<ul><li>fopen函数的返回值是一个==文件指针==；</li><li>当无法代开文件时，会==返回一个空指针==。</li></ul></li></ul></li></ul><h2 id="关闭文件"><a class="markdownIt-Anchor" href="#关闭文件"></a> 关闭文件</h2><ul><li><strong><code>flclose()</code>函数</strong>:<ul><li>关闭不再使用的文件。</li><li>原型：<code>int fclose(FILE *stream)</code></li><li><strong>参数</strong>：<ul><li>==必须是来自fopen函数或者freopen函数的文件指针==；</li></ul></li><li><strong>返回值</strong>：<ul><li>如果成功关闭的文件，返回==0==；</li><li>如果失败，返回==EOF==(EOP是<code>&lt;stdio.h&gt;</code>中定义的宏)</li></ul></li></ul></li></ul><h2 id="为打开的流附加文件"><a class="markdownIt-Anchor" href="#为打开的流附加文件"></a> 为打开的流附加文件</h2><ul><li><strong><code>freopen()</code>函数</strong>：<ul><li>该函数为已经打开的流附加上一个不同的文件。</li><li>原型:<code>FILE *freopen(const char *filename, const char *mode, FILE *stream)</code></li><li><strong>参数</strong>:<ul><li>前两个参数同fopen一样；</li><li>第三个参数是一个文件指针，指向一个已经打开了的流。</li></ul></li><li><strong>返回值</strong>：<ul><li>正常的返回值是它的第三个参数，一个文件指针；</li><li>如果无法打开新文件，返回==空指针==。</li></ul></li></ul></li></ul><h2 id="从命令行获取文件名"><a class="markdownIt-Anchor" href="#从命令行获取文件名"></a> 从命令行获取文件名</h2><ul><li>执行程序时，可以通过将==文件名放入命令行的方式为程序提供文件名==。</li><li>示例：命令<code>demo demo1.txt demo2.txt</code>，其中demo是程序名，剩下的是文件名。在C语言中<code>argv[1]</code>指向字符串<code>demo1.txt</code>,<code>argv[2]</code>指向字符串<code>demo2.txt</code></li></ul><h2 id="临时文件"><a class="markdownIt-Anchor" href="#临时文件"></a> 临时文件</h2><ul><li><strong>临时文件</strong>：==只在程序运行时==存在的文件。</li><li><code>&lt;stdio.h&gt;</code>提供了两个函数来处理临时文件。</li><li><code>tmpfile()</code>:<ul><li>tmpfile函数用于==创建临时文件==（用wb+模式打开），这个临时文件在==关闭它或者程序终止==时消失。</li><li>原型：<code>FILE *tmpfile(void)</code></li><li>返回值：<ul><li>如果创建文件成功，会返回==文件指针==；</li><li>如果创建失败，返回==空指针==。</li></ul></li><li>特点：<ul><li>无法知道tmpfile创建的临时文件的==文件名==；</li><li>无法使用tmpfile创建的文件成为==永久性的==。</li></ul></li></ul></li><li><code>tmpnam()</code>:<ul><li>tmpname函数为临时文件==产生名字==。</li><li>原型：<code>char *tmpnam(char *s);</code></li><li>参数：<ul><li>如果参数是一个空指针，tmpnam会==将生成的文件名存储到一个静态字符数组变量中去，并且返回指向这个变量的指针==；</li><li>传递给tmpnam的参数应该是一个==字符数组==，tmpnam会将文件名存储到这个字符数组中去，并==返回指向这个数组第一个元素的指针==。</li></ul></li><li>tmpnam函数常与fopen函数配合生成具有名字的临时文件。</li></ul></li></ul><h2 id="文件缓冲"><a class="markdownIt-Anchor" href="#文件缓冲"></a> 文件缓冲</h2><ul><li>使用文件缓冲的原因：向外存写入或者读出数据都是==相对较慢==的操作。</li><li><strong>缓冲(buffering)</strong>：将写入流或者输入流中的数据，先写入==缓冲区==，最后再将缓冲区的内容写入实际的设备。</li><li><code>&lt;stdio.h&gt;</code>中的缓冲函数，会在缓冲有用时==自动进行缓冲操作==，缓冲是在后台发生的。</li><li><strong><code>fflush</code>函数</strong>：<ul><li>调用fflush函数，可以按照我们希望的频率==将缓冲区的内容写到相应设备上去==。</li><li>原型：<code>int fflush(FILE *stream)</code></li><li>参数：<ul><li>如果传递的是一个==文件指针==，则将与该文件指针相关联的文件的缓冲区内容写到实际设备。</li><li>如果传递的是一个==空指针==，则将所有缓冲区内容写到实际设备上去。</li></ul></li><li>返回值；<ul><li>调用成功，==返回0==;</li><li>调用失败，==返回EOF==。</li></ul></li></ul></li><li><strong><code>setvbuf</code>函数</strong>:<ul><li>改变缓冲流的方法，并且允许控制缓冲区的大小和位置。</li><li>原型：<code>int setvbuf(FILE *stream, char *buf, int mode, size_t size);</code></li><li>参数：<ul><li><code>stream</code>:需要改变缓冲方式的流；</li><li><code>buf</code>:期望的==缓冲区的地址==；<ul><li>如果实参为空指针，则会==创建一个指定大小的缓冲区==。</li></ul></li><li><code>mode</code>:期望的缓冲类型，只能为==下列三个宏==：<ol><li><code>_IOFBF</code>:==满缓冲==，当缓冲区为空时，从流读入数据；当缓冲区满时，向流写入数据；</li><li><code>_IOLBF</code>:==行缓冲==，每次从流读入一行数据或者向流写入一行数据；</li><li><code>_IONBF</code>:==无缓冲==，直接从流读入数据或者直接向流写入数据，而没有缓冲区。</li></ol></li><li><code>size</code>:缓冲区内==字节的数量==。</li></ul></li><li>返回值：<ul><li>调用成功，==返回0==；</li><li>调用失败，==返回非零值==。</li></ul></li></ul></li><li><code>setbuf</code>函数：<ul><li>setvbuf的早期版。</li></ul></li></ul><h2 id="文件删除与重命名"><a class="markdownIt-Anchor" href="#文件删除与重命名"></a> 文件删除与重命名</h2><ul><li><strong><code>remove</code>函数</strong>：<ul><li>用于删除文件；</li><li>原型：<code>int remove(const char *filename)</code></li><li>参数：<ul><li><strong>文件名</strong>；</li></ul></li><li>返回值：<ul><li>成功，0；</li><li>失败，非零值。</li></ul></li><li>要删除的文件需要<strong>关闭</strong>。</li></ul></li><li><strong><code>rename</code>函数</strong>：<ul><li>改变文件的名字；</li><li>原型：<code>int rename(const char *old, const char *new)</code></li><li>参数：<ul><li>old：原来的文件名；</li><li>new：新的文件名。</li></ul></li><li>返回值：<ul><li>成功，0；</li><li>失败，非零值。</li></ul></li><li>注意：<ul><li>要改名的文件需要<strong>关闭</strong>。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 专业基础 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言-指针</title>
      <link href="//post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80-%E6%8C%87%E9%92%88/index.html"/>
      <url>//post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80-%E6%8C%87%E9%92%88/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="指针的基本概念"><a class="markdownIt-Anchor" href="#指针的基本概念"></a> 指针的基本概念</h1><ul><li>==指针就是地址，而指针变量就是存储地址的变量==。</li><li>指针变量的声明：在普通变量声明的基础上加上<code>*</code>:<ul><li>如指向int类型对象的指针变量：<code>int *p;</code></li></ul></li><li><strong>取地址运算符</strong>：用于获取变量的地址，来给指针变量赋值。<ul><li>示例：</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">int i, *p;p &#x3D; &amp;i;</code></pre></li><li><strong>间接寻址运算符</strong>：用于访问指针变量指向的对象的内容。<ul><li>示例：</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">int i, *p;p &#x3D; &amp;i;i &#x3D; *p;</code></pre><ul><li>不要混淆间接寻址运算符和指针变量的声明时的<code>*</code>的功能。</li><li><code>*p</code>相当于<code>i</code>的==别名==，对<code>*p</code>执行的任何操作，与直接对<code>i</code>做操作的效果一样。</li></ul></li></ul><h1 id="指针与数组"><a class="markdownIt-Anchor" href="#指针与数组"></a> 指针与数组</h1><ul><li>指针可以指向数组元素:<ul><li>示例：</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">int a[10],*p;p &#x3D; &amp;a[0];*p &#x3D; 5;</code></pre><ul><li>如果==指针指向数组元素，那么对该指针进行算运算==就是有意义的：<ol><li><strong>指针加上整数</strong>：指针加上整数，代表该指针指向更右边数组的元素，如<code> int *p = &amp;a[0]</code>，给p加上2之后，p指向<code>a[2]</code></li><li><strong>指针减去整数</strong>：指针减去整数，代表该指针指向更左边数组的元素，如<code>int *p = a[2]</code>，给p减去2之后，p指向<code>a[0]</code></li><li><strong>两个指针相减</strong>：两个指针相减，结果为这两个指针指向的数组元素之间间隔的数组元素个数，如<code>int *p = &amp;a[5]; int *q = &amp;a[1]</code>，那么p和q相减的结果就是4。</li></ol></li></ul></li><li>可以直接<strong>将数组名赋值给指针变量</strong>：<ul><li>如：<code>int a[2] = &#123;0, 1, 2&#125;; int *p = a;</code></li><li>实质是p指向该数组的第一个元素<code>a[0]</code></li><li>==数组的名字实质上是指向数组第一个元素的指针==</li><li>不能给数组名赋值。</li></ul></li><li><strong>数组型形式参数</strong>：<ul><li>在将数组作为形式参数传递给函数的时候，实际传递的是==指向该数组的第一个元素的指针（或者说是数组名）==。</li><li>==声明形式参数为指针就相当于声明变量为数组==(但是普通变量不可以这样理解），可以==将数组型形式参数声明为指针==，如：<code>int function(int a[], int n)</code>与<code>int function(int *a, int n)</code>等价。</li><li>可以给函数传递==数组的片段==，如：<code>function(&amp;a[6], 10)</code></li></ul></li><li><strong>用指针作为数组名</strong>：<ul><li>可以将指针看做数组名进行==取下标操作==。</li><li>编译器将<code>p[i]</code>看做`*(p+i)。</li><li>对指针进行取下标操作的前提是:==该指针是指向了一个数组的首元素==。</li><li>示例：</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">int a[10], *p;p &#x3D; a;int num &#x3D; p[1];</code></pre></li><li><strong>指针数组</strong>：<ul><li>元素是指针的数组，如：<code>int *p[10]</code>，声明了一个数组，这个数组存储10个int型指针变量。</li></ul></li><li><strong>指向指针的指针</strong>：<ul><li>示例：</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">char *p1;char **p2 &#x3D; &amp;p1;</code></pre></li></ul><h2 id="指针和多维数组"><a class="markdownIt-Anchor" href="#指针和多维数组"></a> 指针和多维数组</h2><ul><li>C语言中的多维数组，可以理解为将每一行的元素依次排列；</li><li><strong>将二维数组看做是一维数组</strong>来处理：<ul><li>指针指向二维数组的第一个元素，指针每次加一，都会指向数组的下一个元素，如果到达本行末尾，就指向下一行的第一个元素。</li></ul></li><li><strong>将指针指向某一行的第一个元素</strong>：<ul><li>一般方法：</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">int a[10][10], *p;&#x2F;&#x2F;指向第二行的第一个元素p &#x3D; &amp;a[1][0]; </code></pre><ul><li>简写：根据可以对指针进行去下标操作，利用<code>&amp;a[i][0] = &amp;(*(a[i] + 0))</code></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">int a[10][10], *p;&#x2F;&#x2F;指向第三行的第一个元素p &#x3D; a[2];</code></pre></li><li><strong>指向一维数组的指针</strong>：<ul><li>对一维数组，我们常用的指针是指向==数组的第一个元素的==；</li><li>可以定义==指向一个一维数组的指针==：<code>int (*p)[10]</code>,这是声明了一个指向长度为10的整型数组的指针p；</li><li>对于二维数组，可以看做是==一个每个元素都是一维数组的一维数组==；</li><li>使用指向数组的指针来==按行遍历二维数组==：</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">int a[10][11], (*p)[10];&#x2F;&#x2F;省去数组赋值等&#x2F;&#x2F;按列遍历数组，并将数组第五列的值赋为0for(p &#x3D; &amp;a[0]; p &lt; &amp;a[10]; p++) &#123;  (*p)[4];&#125;</code></pre><ul><li>在二维数组中，<code>a[i]</code>取的是第i-1行第一个元素的地址，<code>&amp;a[i]</code>取的是第i-1行的地址（第i-1个一维数组的地址）</li><li>对于指向数组的指针来说：<code>*p</code>是取出指向的数组，<code>(*p)[i]</code>是取出指向的数组中的第i-1个元素。</li></ul></li><li><strong>用多维数组名作为指针</strong>：<ul><li>二维数组的==数组名是一个指向一维数组的指针==，例如<code>int a[10][10]</code>的数组名<code>a</code>代表的意思是<code>&amp;a[0]</code>。</li></ul></li><li><strong>多维数组的长度</strong>：<ul><li>对于==一维数组在声明时就赋值的情况下，可以省略数组的长度==，如：<code>int a[] = &#123;1, 2&#125;</code></li><li>==二维数组在声明时就赋值可以省略第一维的长度==,最后的二维数组的每一维的长度都是每一行的数组的长度是==根据最长的数组的长度来确定==的。如果有一些行的数据不够填满整行，那么C语言==会用空字符<code>\0</code>来填补==。</li></ul></li></ul><h1 id="字符串数组"><a class="markdownIt-Anchor" href="#字符串数组"></a> 字符串数组</h1><h2 id="二维数组实现字符串数组"><a class="markdownIt-Anchor" href="#二维数组实现字符串数组"></a> 二维数组实现字符串数组</h2><ul><li><strong>字符串字面量</strong>：<ul><li>字符串是一个==字符数组==；</li><li>字符串字面量就是这个数组的数组名，==是一个<code>char *</code>类型的指针==。</li><li>字符串字面量是==不能被修改的==</li></ul></li><li>创建一个二维数组，按照每行一个字符串(==一维字符数组==)的方式，将一系列字符串存入一个数组中。</li><li>示例：</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">char planets[][8] &#x3D; &#123; &quot;Mercury&quot;, &quot;Venus&quot;, &quot;Earth&quot;,  &quot;Mars&quot;, &quot;Jupiter&quot;, &quot;Saturn&quot;,  &quot;Urans&quot;, &quot;Neptune&quot;, &quot;Pluto&quot; &#125;;</code></pre><ul><li>因为每一行字符串的长度是省略的，所以每一行的长度是系统自动确定的。在二维数组中，每一行的数组的长度是根据最长的数组的长度来确定的。如果有一些行的数据不够填满整行，那么C语言<strong>会用空字符<code>\0</code>来填补，造成了空间浪费</strong>。</li><li>可以理解为用这种方式创建的<strong>二维数组都是矩形的</strong>。</li></ul><h2 id="指针数组实现字符串数组"><a class="markdownIt-Anchor" href="#指针数组实现字符串数组"></a> 指针数组实现字符串数组</h2><ul><li>要想实现<strong>参差不齐的二维数组</strong>，需要使用<strong>元素为指针的数组</strong>。</li><li>建立一个<strong>元素都是指向字符串的指针</strong>的数组，来实现字符串数组。</li><li>示例：</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">char *planets[] &#x3D; &#123; &quot;Mercury&quot;, &quot;Venus&quot;, &quot;Earth&quot;,&quot;Mars&quot;, &quot;Jupiter&quot;, &quot;Saturn&quot;,&quot;Urans&quot;, &quot;Neptune&quot;, &quot;Pluto&quot;&#125;;</code></pre><h2 id="字符串数组的应用命令行参数"><a class="markdownIt-Anchor" href="#字符串数组的应用命令行参数"></a> 字符串数组的应用：命令行参数</h2><ul><li>运行程序是需要提供一些信息，这些信息从命令行中提供，称为<strong>命令行参数</strong>（C语言中也叫程序参数）。</li><li>为了访问命令行参数必须将<strong>main函数定义为含有两个特殊参数的的函数</strong>：<ul><li><code>argc</code>参数：argc是参数计数的参数，为int型，用于记录<strong>命令行参数的数量</strong>。</li><li><code>argv</code>参数：argv是<strong>指向命令行参数的指针数组</strong>，这些命令行参数以<strong>字符串</strong>的形式存储。<ul><li>argv是<code>char *argv[]</code>型的，实质就是一个字符串数组。</li><li><code>argv[0]</code>指向<strong>程序名</strong>；</li><li><code>argv[1]</code>到<code>argv[argc - 1]</code>指向余下的命令行参数。</li><li><code>argv[argc]</code>是一个附加元素，这个元素始终是一个<strong>空指针</strong>。</li></ul></li></ul></li><li>示例：</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define NUM_PLANETS 9int main(int argc, char* argv[]) &#123;char *planets[] &#x3D; &#123; &quot;Mercury&quot;, &quot;Venus&quot;, &quot;Earth&quot;,&quot;Mars&quot;, &quot;Jupiter&quot;, &quot;Saturn&quot;,&quot;Urans&quot;, &quot;Neptune&quot;, &quot;Pluto&quot; &#125;;int i, j;for (i &#x3D; 1; i &lt; argc; i++) &#123;for (j &#x3D; 0; j &lt; NUM_PLANETS; j++) &#123;if (strcmp(argv[i], planets[j]) &#x3D;&#x3D; 0) &#123;printf_s(&quot;%s is planet %d\n&quot;, argv[i], j + 1);break;&#125;if (j &#x3D;&#x3D; NUM_PLANETS) &#123;printf_s(&quot;%s is not a planet\n&quot;, argv[i]);&#125;&#125;&#125;return 0;&#125;</code></pre><h1 id="动态存储分配"><a class="markdownIt-Anchor" href="#动态存储分配"></a> 动态存储分配</h1><ul><li><strong>动态存储分配</strong>：在程序==运行期间==分配内存单元的能力</li><li>内存分配函数所获得的内存块都来自一个称为**堆（heap）**的存储池。</li><li><strong>内存分配函数</strong>有三种，都是声明在<code>&lt;stdlib.h&gt;</code>头中的：<ol><li><strong><code>malloc</code>函数</strong>：分配内存块，但是不对内存块进行初始化。（最常用，最高效）<ul><li>原型：<code>void *malloc(size_t size)</code>,malloc函数分配size个字节的内存块，并且返回指向该内存块的指针。</li><li>示例：<code>int *a = (n * sizeof(int));</code>,为长度为n的int型数组分配空间。</li></ul></li><li><strong><code>calloc</code>函数</strong>：分配内存块，并且对内存块进行清零。<ul><li>原型：<code>void *calloc(size_t nmemb, size_t size);</code>,calloc函数为nmemb个元素的数组分配内存空间，其中每个元素的长度都是size个字节。</li><li>在分配了内存之后，calloc函数会==通过把所有位设置为0的方式进行初始化==。</li><li>将nemeb设为1，可以为==任何类型的数据项分配内存==。</li><li>示例：<code>int *a = calloc(n, sizeof(int))</code>，为长度为n的int型数组分配空间。</li></ul></li><li><strong><code>realloc</code>函数</strong>：调整先前分配的内存块大小。<ul><li>原型：<code>void *realloc(void *ptr, size_t size);</code>,调用realloc函数时，==ptr必须指向先前通过malloc，calloc或realloc的调用获得的内存块==。size表示内存块的新尺寸。</li><li>如果realloc==以空指针作为第一个实际参数，那么它的行为就行malloc函数一样==。</li><li>如果realloc==以0作为第二个实际参数，那么它会释放掉内存块==。</li></ul></li></ol></li><li><strong>内存分配函数的返回值</strong>：<ul><li><strong><code>void *</code></strong>:内存分配函数会返回<code>void *</code>类型的值，该类型的指针是==通用指针==，指向分配的内存。<ul><li>可以将==<code>void *</code>类型的变量赋给任意类型的指针变量。</li></ul></li></ul></li><li><strong>空指针</strong>：<ul><li>当找不到需要的足够大的内存块时，内存分配函数会返回==空指针==；</li><li>空指针是==不指向任何地方的指针==，这是一个用于区别于所有有效指针的特殊值。</li><li>测试内存分配函数的返回值是否是空指针，用来==判断内存分配是否成功==。</li><li><strong>NULL</strong>宏：空指针用NULL宏来表示。NULL宏在多个头（包括<code>&lt;stido.h&gt;</code>和<code>&lt;stdlib.h&gt;</code>）中都有定义。</li></ul></li><li><strong>释放存储空间</strong>：<ul><li><strong><code>free()</code>函数</strong>：<ul><li>原型：<code>void free(void *ptr)</code></li><li>==调用free函数会释放掉ptr指针指向的内存块==</li><li>free函数的实际参数必须是==先前由内存分配函数返回的指针==。</li></ul></li></ul></li></ul><h1 id="指向函数的指针"><a class="markdownIt-Anchor" href="#指向函数的指针"></a> 指向函数的指针</h1><ul><li>如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段==存储空间的首地址==称为这个函数的地址,而且==函数名表示的就是这个地址==。</li><li><strong>函数指针</strong>；用一个指针变量来存储函数的地址。</li><li><strong>函数指针的声明</strong>：<ul><li>声明模板：<code>函数返回值类型 (*函数指针变量名)(函数参数类型列表);</code></li><li>示例：<code>int (*p)(int,int);</code></li></ul></li><li><strong>函数指针调用函数</strong>：<ul><li>通过<code>*</code>运算符来取出实际的函数。也可以直接通过函数指针变量名调用；</li><li>示例：</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">int fun(int x);&#x2F;&#x2F;声明函数int (*p)(int);&#x2F;&#x2F;声明函数指针p &#x3D; fun; &#x2F;&#x2F;函数指针指向fun函数int result &#x3D; (*p)(5);&#x2F;&#x2F;调用函数&#x2F;&#x2F;或者int result &#x3D; p(5);</code></pre></li><li><strong>存储函数指针的指针数组</strong>：<ul><li>可以声明元素为函数指针的数组：<code>void (*funs[10])(int);</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 专业基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Spring/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Spring/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="spring简介"><a class="markdownIt-Anchor" href="#spring简介"></a> Spring简介</h1><ul><li>历史：<ol><li>2002年，首次推出Spring框架的雏形：interface21框架</li><li>2004年3月24日，基于interface21框架，发布了Spring框架的1.0版本（本次学习使用的是Spring5）</li><li>Spring Framework的创始人：Rod Johnson</li></ol></li><li>Spring理念：使现有技术更加容易使用，本身整合了现有的很多技术框架。</li><li>SSH:struct2+Spring+Hibernate</li><li>SSM:SpringMVC+Spring+Mybatis</li><li><a href="https://spring.io/projects/spring-framework">官方文档</a></li><li><a href="https://repo.spring.io/realse/org/springframework/spring">官网下载地址</a></li><li><a href="https://github.com/spring-projects/spring-framework">github地址</a></li><li>maven坐标：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- 安装这个包，会自动添加其它依赖的包--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;    &lt;version&gt;5.3.3&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;!-- 和mybatis整合需要的包 --&gt;&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework&#x2F;spring-webmvc --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;    &lt;version&gt;5.3.3&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><ul><li><p>Spring优点：</p><ol><li>是一个开源的免费的框架；</li><li>轻量级，非入侵式框架；</li><li><strong>控制反转（IOC）</strong></li><li><strong>面向切面编程（AOP）</strong></li><li>支持事务的处理</li><li>支持框架整合</li></ol></li><li><p>缺点：配置繁琐</p></li><li><p>Spring的组成：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210210093918.jpg" alt="" /></p></li><li><p>Spring的拓展：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210210094952.jpg" alt="" /></p><ul><li>SpringBoot：<ul><li>一个快速开发的脚手架；</li><li>基于SpringBoot可以快速开发单个的微服务；</li><li>约定大于配置</li></ul></li><li>SpringCloud:<ul><li>SpringCloud是基于SpringBoot实现的。</li></ul></li><li>学习SpringBoot的前提是Spring及SpringMVC</li></ul></li></ul><h1 id="ioc"><a class="markdownIt-Anchor" href="#ioc"></a> IOC</h1><h2 id="ioc原型"><a class="markdownIt-Anchor" href="#ioc原型"></a> IOC原型</h2><ul><li>普通接口实现：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.service;import com.zestaken.dao.UserDao;import com.zestaken.dao.UserDaoImpl;&#x2F;&#x2F;在service层调用Dao层的方法进行业务操作public class UserServiceImpl implements UserService&#123;    &#x2F;&#x2F;直接在编写程序时写好UserDao属性    private UserDao userDao &#x3D; new UserDaoImpl();    @Override    public void getUsers() &#123;        userDao.getUsers();    &#125;&#125;</code></pre><ul><li>IOC注入思想实现：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.service;import com.zestaken.dao.UserDao;public class UserServiceImpl implements UserService&#123;    &#x2F;&#x2F;编写程序将UserDao对象设置为从外界获取注入的值，而不是直接由程序员设置    private UserDao userDao;    &#x2F;&#x2F;注入UserDao的值    public void setUserDao(UserDao userDao) &#123;        this.userDao &#x3D; userDao;    &#125;    @Override    public void getUsers() &#123;        userDao.getUsers();    &#125;&#125;</code></pre><ul><li>用普通的方法实现，每一次新增UserDao接口的实现类，都需要修改UserService实现类的代码。</li><li>普通实现方法:程序是<strong>主动创建对象</strong>，控制权在程序员的手上。</li><li>IOC思想实现：使用set注入后，程序<strong>不再具有主动性</strong>，而是被动接受传递的对象。</li><li>优点：程序员不用再去管理对象的创建了，系统的耦合性大大降低。</li></ul><h2 id="ioc本质"><a class="markdownIt-Anchor" href="#ioc本质"></a> IOC本质</h2><ul><li>控制反转（Inversion Of Control），是一种设计思想，DI（Dependency Injection，依赖注入）是实现IOC的一种方式。</li><li>未使用IOC思想的面向对象编程中，对象的创建和对象间的依赖关系，完全硬编码在程序中，<strong>对象的创建由程序自己控制</strong>，使用IOC思想后，<strong>对象的创建转移给第三方</strong>，控制反转即<strong>获得依赖对象的方式反转了</strong>。</li><li>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式；</li><li>在Spring中实现IOC的是<strong>IOC容器</strong>，其<strong>实现方法是DI（依赖注入）</strong>。</li></ul><h2 id="spring的ioc实现"><a class="markdownIt-Anchor" href="#spring的ioc实现"></a> Spring的IOC实现</h2><ol><li>书写接口实现类：</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;Dao层实现package com.zestaken.dao;public class UserDaoImpl implements UserDao&#123;    @Override    public void getUsers() &#123;        System.out.println(&quot;sql查询&quot;);    &#125;&#125;&#x2F;&#x2F;Service层实现package com.zestaken.service;import com.zestaken.dao.UserDao;public class UserServiceImpl implements UserService&#123;    private UserDao userDao ;    &#x2F;&#x2F;注入UserDao的值    &#x2F;&#x2F;使用Spring管理的类的属性，必须由set方法设定    public void setUserDao(UserDao userDao) &#123;        this.userDao &#x3D; userDao;    &#125;    @Override    public void getUsers() &#123;        userDao.getUsers();    &#125;&#125;</code></pre><ol start="2"><li>将实现类用xml的方式交给Spring管理</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;&lt;!--    在Spring中使用bean来创建对象，--&gt;&lt;!--    id是该类生成的对象名，class是完全限定类名--&gt;    &lt;bean id&#x3D;&quot;userDaoImpl&quot; class&#x3D;&quot;com.zestaken.dao.UserDaoImpl&quot;&#x2F;&gt;    &lt;bean id&#x3D;&quot;userServiceImpl&quot; class&#x3D;&quot;com.zestaken.service.UserServiceImpl&quot;&gt;&lt;!--        name指定需要赋值的属性 ref指定传递的对象--&gt;        &lt;property name&#x3D;&quot;userDao&quot; ref&#x3D;&quot;userDaoImpl&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;</code></pre><ol start="3"><li>测试：</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.service;import org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class ServiceTest &#123;    @Test    public void userServiceImplTest()&#123;        &#x2F;&#x2F;获取Spring的上下文对象,参数是配置文件名        ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        &#x2F;&#x2F;现在所有的对象都交由Spring管理了，要想使用对象，只需要从Spring中取出即可（Spring中这些对象叫做bean）        UserServiceImpl userServiceImpl &#x3D; (UserServiceImpl) context.getBean(&quot;userServiceImpl&quot;);        &#x2F;&#x2F;获取出对象之后，即可正常使用        userServiceImpl.getUsers();    &#125;&#125;</code></pre><ul><li>控制：传统的程序的对象是由程序本身控制创建的，使用Spring的对象是由Spring来创建的；</li><li>反转：程序本身不创建对象，而变成<strong>被动的接收对象</strong>。</li><li>IOC即对象由Spring来创建，管理和装配。我们只需要修改相应的配置文件，例如此处由xml文件配置，则修改xml文件即可修改程序实现。</li></ul><h2 id="spring中ioc创建对象的方式"><a class="markdownIt-Anchor" href="#spring中ioc创建对象的方式"></a> Spring中IOC创建对象的方式</h2><ol><li>通过类的无参构造方法类构造对象，默认使用这种。</li><li>使用有参的构造方法构造：<ol><li>下标赋值：</li></ol> <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id&#x3D;&quot;exampleBean&quot; class&#x3D;&quot;examples.ExampleBean&quot;&gt;&lt;constructor-arg index&#x3D;&quot;0&quot; value&#x3D;&quot;7500000&quot;&#x2F;&gt;&lt;constructor-arg index&#x3D;&quot;1&quot; value&#x3D;&quot;42&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;</code></pre><ol start="2"><li>类型赋值：</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id&#x3D;&quot;exampleBean&quot; class&#x3D;&quot;examples.ExampleBean&quot;&gt; &lt;constructor-arg type&#x3D;&quot;int&quot; value&#x3D;&quot;7500000&quot;&#x2F;&gt; &lt;constructor-arg type&#x3D;&quot;java.lang.String&quot; value&#x3D;&quot;42&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;</code></pre><ol start="3"><li>参数名赋值(常用)：</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id&#x3D;&quot;exampleBean&quot; class&#x3D;&quot;examples.ExampleBean&quot;&gt; &lt;constructor-arg name&#x3D;&quot;years&quot; value&#x3D;&quot;7500000&quot;&#x2F;&gt; &lt;constructor-arg name&#x3D;&quot;ultimateAnswer&quot; value&#x3D;&quot;42&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;</code></pre></li></ol><h1 id="spring配置"><a class="markdownIt-Anchor" href="#spring配置"></a> Spring配置</h1><h2 id="alias别名"><a class="markdownIt-Anchor" href="#alias别名"></a> alias(别名)</h2><ul><li>如果配置了别名，我们也可以使用别名来获取到这个对象：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;alias name&#x3D;&quot;userDaoImpl&quot; alias&#x3D;&quot;userDaoImpl2&quot;&#x2F;&gt;</code></pre><h2 id="bean配置"><a class="markdownIt-Anchor" href="#bean配置"></a> Bean配置</h2><ul><li>id:bean的唯一标识符，相当于对象名；</li><li>class：bean对象所对应的类的完全限定类名</li><li>name：也是别名，而且那么可以同时取多个别名，并且别名之间可以用空格，<code>,</code>,<code>;</code>等来分隔</li><li>示例：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id&#x3D;&quot;userDaoImpl&quot; class&#x3D;&quot;com.zestaken.dao.UserDaoImpl&quot; name&#x3D;&quot;zhangjie lisi,zestaken;zhangsan&quot;&#x2F;&gt;</code></pre><h2 id="import配置"><a class="markdownIt-Anchor" href="#import配置"></a> import配置</h2><ul><li>一般用于团队开发使用，可以将多个配置文件导入到一个配置文件从而合并为一个配置文件:</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;import resource&#x3D;&quot;bean1.xml&quot;&#x2F;&gt;&lt;import resource&#x3D;&quot;bean2.xml&quot;&#x2F;&gt;&lt;import resource&#x3D;&quot;bean3.xml&quot;&#x2F;&gt;</code></pre><h1 id="依赖注入di"><a class="markdownIt-Anchor" href="#依赖注入di"></a> 依赖注入(DI)</h1><h2 id="一构造器注入"><a class="markdownIt-Anchor" href="#一构造器注入"></a> 一：构造器注入</h2><ul><li>构造器注入即有参数的构造方法来构造对象，在构造时将对象属性初始化。</li><li>三种方式：<ol><li>下标赋值：</li></ol>  <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id&#x3D;&quot;exampleBean&quot; class&#x3D;&quot;examples.ExampleBean&quot;&gt;&lt;constructor-arg index&#x3D;&quot;0&quot; value&#x3D;&quot;7500000&quot;&#x2F;&gt;&lt;constructor-arg index&#x3D;&quot;1&quot; value&#x3D;&quot;42&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;</code></pre><ol start="2"><li>类型赋值：</li></ol> <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id&#x3D;&quot;exampleBean&quot; class&#x3D;&quot;examples.ExampleBean&quot;&gt; &lt;constructor-arg type&#x3D;&quot;int&quot; value&#x3D;&quot;7500000&quot;&#x2F;&gt; &lt;constructor-arg type&#x3D;&quot;java.lang.String&quot; value&#x3D;&quot;42&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;</code></pre><ol start="3"><li>参数名赋值(常用)：</li></ol> <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id&#x3D;&quot;exampleBean&quot; class&#x3D;&quot;examples.ExampleBean&quot;&gt; &lt;constructor-arg name&#x3D;&quot;years&quot; value&#x3D;&quot;7500000&quot;&#x2F;&gt; &lt;constructor-arg name&#x3D;&quot;ultimateAnswer&quot; value&#x3D;&quot;42&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;</code></pre></li></ul><h2 id="二setter方法注入"><a class="markdownIt-Anchor" href="#二setter方法注入"></a> 二:setter方法注入</h2><ul><li>依赖：bean对象的创建依赖于容器；</li><li>注入:bean对象中的所有属性由容器来注入。</li><li>使用这种方式注入的属性，必须全部使用setter方法来设置属性。</li><li>不同类型的属性的注入方式不同：<ol><li>基本类型以及String类型的注入：通过<code>value</code>来实现</li></ol>  <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;zhangjie&quot;&#x2F;&gt;</code></pre><ol start="2"><li>bean类型注入（即属性类型是类类型，且这个类的实现对象必须在Spring中注册）：使用<code>ref</code>:</li></ol> <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id&#x3D;&quot;address&quot; class&#x3D;&quot;com.zestaken.pojo.Address&quot;&#x2F;&gt;&lt;bean id&#x3D;&quot;person&quot; class&#x3D;&quot;com.zestaken.pojo.Person&quot;&gt;     &lt;property name&#x3D;&quot;address&quot; ref&#x3D;&quot;address&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;</code></pre><ol start="3"><li>数组，list集合 map集合,set集合类型的注入，需要使用专门的标签：</li></ol> <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">   &lt;!-- 数组 --&gt;       &lt;property name&#x3D;&quot;books&quot;&gt;        &lt;array&gt;            &lt;value&gt;红楼梦&lt;&#x2F;value&gt;            &lt;value&gt;西游记&lt;&#x2F;value&gt;        &lt;&#x2F;array&gt;    &lt;&#x2F;property&gt;    &lt;!--list集合  --&gt;    &lt;property name&#x3D;&quot;hobbys&quot;&gt;        &lt;list&gt;            &lt;value&gt;写代码&lt;&#x2F;value&gt;            &lt;value&gt;看书&lt;&#x2F;value&gt;        &lt;&#x2F;list&gt;    &lt;&#x2F;property&gt;    &lt;!--map集合  --&gt;    &lt;property name&#x3D;&quot;card&quot;&gt;        &lt;map&gt;            &lt;entry key&#x3D;&quot;身份证&quot; value&#x3D;&quot;123435&quot;&#x2F;&gt;            &lt;entry key&#x3D;&quot;银行卡&quot; value&#x3D;&quot;2340273&quot;&#x2F;&gt;        &lt;&#x2F;map&gt;    &lt;&#x2F;property&gt;&lt;!--set集合  --&gt;    &lt;property name&#x3D;&quot;games&quot;&gt;        &lt;set&gt;            &lt;value&gt;lol&lt;&#x2F;value&gt;            &lt;value&gt;csgo&lt;&#x2F;value&gt;            &lt;value&gt;overwatch&lt;&#x2F;value&gt;        &lt;&#x2F;set&gt;    &lt;&#x2F;property&gt;</code></pre><ol start="4"><li>Properties类型的注入：</li></ol>  <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;property name&#x3D;&quot;properties&quot;&gt;    &lt;props&gt;        &lt;prop key&#x3D;&quot;username&quot;&gt;zhangjie&lt;&#x2F;prop&gt;        &lt;prop key&#x3D;&quot;password&quot;&gt;12435325&lt;&#x2F;prop&gt;    &lt;&#x2F;props&gt;&lt;&#x2F;property&gt;</code></pre><ol start="5"><li>赋值为null的注入：</li></ol>  <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;property name&#x3D;&quot;girlfriend&quot;&gt;    &lt;null&#x2F;&gt;&lt;&#x2F;property&gt;</code></pre></li></ul><h2 id="三c命名空间注入"><a class="markdownIt-Anchor" href="#三c命名空间注入"></a> 三：c命名空间注入</h2><ul><li>对应构造器注入的方式，c命名空间相当于constructor-arg标签，所以必须有有参数的构造方法才能使用这种方式。</li><li>使用c命名空间，必须先导入对应的xml约束：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">xmlns:c&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;c&quot;</code></pre><ul><li>示例；</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- c-namespace declaration with argument names --&gt;   &lt;bean id&#x3D;&quot;beanOne&quot; class&#x3D;&quot;x.y.ThingOne&quot; c:thingTwo-ref&#x3D;&quot;beanTwo&quot;       c:thingThree-ref&#x3D;&quot;beanThree&quot; c:email&#x3D;&quot;something@somewhere.com&quot;&#x2F;&gt;</code></pre><h2 id="四p命名空间注入"><a class="markdownIt-Anchor" href="#四p命名空间注入"></a> 四：p命名空间注入</h2><ul><li>对应setter的注入方式，p命名空间相当于property标签，所以必须有setter方法才能使用这种方法。</li><li>使用p命名空间，也必须先导入相应的xml约束：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;</code></pre><ul><li>示例：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean name&#x3D;&quot;p-namespace&quot; class&#x3D;&quot;com.example.ExampleBean&quot;    p:email&#x3D;&quot;someone@somewhere.com&quot;&#x2F;&gt;</code></pre><h1 id="bean的作用域"><a class="markdownIt-Anchor" href="#bean的作用域"></a> Bean的作用域</h1><ol><li>单例模式:从一个bean中无论获取多少次获取的都是同一个对象。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210220100546.jpg" alt="" /><ul><li>单例模式是bean的默认作用域，也可以显式设置：</li></ul> <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.something.DefaultAccountService&quot;&#x2F;&gt;&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.something.DefaultAccountService&quot; scope&#x3D;&quot;singleton&quot;&#x2F;&gt;</code></pre></li><li>原型模式：每次从bean中获取的对象都是新的对象。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210220100858.jpg" alt="" /><ul><li>设置原型模式：</li></ul> <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.something.DefaultAccountService&quot; scope&#x3D;&quot;prototype&quot;&#x2F;&gt;</code></pre></li><li>Request</li><li>Session</li><li>Application</li><li>WebSocket （后面的四个都是在web开发中使用的）</li></ol><h1 id="bean的自动装配"><a class="markdownIt-Anchor" href="#bean的自动装配"></a> Bean的自动装配</h1><ul><li>装配：有些对象的属性是另一个由Spring管理的对象，给这个属性赋值就是装配。所以不是所有由Spring管理的对象都需要装配。</li><li>自动装配：Spring会在上下文中自动寻找，并<strong>自动给bean装配属性</strong>。</li><li>Spring中的三种装配方式：<ol><li>在xml中显式的配置</li><li>在java中显式的配置</li><li>隐式的自动装配bean</li></ol></li><li>自动装配的两种方式：<ol><li>byName：会自动在容器上下文中寻找id属性值和自己对象的set方法后面的名称相同的bean。<ol><li>使用byName需要保证所有bean的id唯一，并且这个bean的id值需要和自动注入的属性的对应的set方法值一致。</li><li>示例：</li></ol></li></ol> <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id&#x3D;&quot;userServiceImpl&quot; class&#x3D;&quot;com.zestaken.service.UserServiceImpl&quot; autowire&#x3D;&quot;byName&quot;&gt; &lt;!--        name指定需要赋值的属性 ref指定传递的对象--&gt; &lt;!--        &lt;property name&#x3D;&quot;userDao&quot; ref&#x3D;&quot;userDaoImpl&quot;&#x2F;&gt; --&gt;&lt;&#x2F;bean&gt;</code></pre><ol start="2"><li>byType:会自动在容器上下文中寻找和自己对象的类型相同的bean。</li><li>使用byType需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致。</li><li>示例：</li></ol>  <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;bean id&#x3D;&quot;userServiceImpl&quot; class&#x3D;&quot;com.zestaken.service.UserServiceImpl&quot; autowire&#x3D;&quot;byType&quot;&gt;&lt;!--        name指定需要赋值的属性 ref指定传递的对象--&gt;&lt;!--        &lt;property name&#x3D;&quot;userDao&quot; ref&#x3D;&quot;userDaoImpl&quot;&#x2F;&gt; --&gt;&lt;&#x2F;bean&gt;</code></pre></li></ul><h1 id="spring注解开发"><a class="markdownIt-Anchor" href="#spring注解开发"></a> Spring注解开发</h1><ul><li><strong>开启注解</strong>：<ul><li>扫描包中的注解：如扫描<code>@Component</code>注解<code>&lt;context:component-scan base-package=&quot;com.zestaken&quot;/&gt;</code></li><li>配置注解的支持：<code>&lt;context:annotation-config/&gt;</code></li></ul></li><li>xml与注解优缺点：<ul><li>xml更加万能，维护更加方便；</li><li>注解需要能够修改类中的代码，维护相对困难；</li></ul></li><li>xml与注解配合使用：<ul><li>xml用来管理bean；</li><li>注解只负责属性注入，即<code>@Value</code>。</li></ul></li></ul><h2 id="注解注册bean"><a class="markdownIt-Anchor" href="#注解注册bean"></a> 注解注册bean</h2><ul><li><code>@Component</code>注解：<ul><li>组件注解，==放在类上==,说明这个类被Spring管理了，即==注册lbean==；</li><li>自动注入的bean对象名是==类名的首字母小写==形成的。</li><li>等价于<code>&lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.zestaken.dao.UserDaoImpl&quot; /&gt;</code></li></ul></li><li><code>@Component</code>为mvc模式形成的衍生注解,这些==注解功能完全相同==，只是为了更好的区分架构层而使用：<ul><li>dao层:<code>@Repository</code></li><li>service层：<code>@Service</code></li><li>controller层：<code>@Controller</code></li></ul></li></ul><h2 id="注解注入属性"><a class="markdownIt-Anchor" href="#注解注入属性"></a> 注解注入属性</h2><ul><li><code>@Value(&quot;属性值&quot;)</code>注解：<ul><li>在基本类型以及字符串类型对象上使用，为创建的对象的的对应属性赋值。</li><li>等价于<code>&lt;property name=&quot;name&quot; value=&quot;zestaken&quot;/&gt;</code></li></ul></li></ul><h2 id="注解配置作用域"><a class="markdownIt-Anchor" href="#注解配置作用域"></a> 注解配置作用域</h2><ul><li><code>@Scope(&quot;作用域&quot;)</code>注解：<ul><li>用于配置bean对象的作用域，如：<code>@Scope(&quot;prototype&quot;)</code></li></ul></li></ul><h2 id="注解实现自动装配"><a class="markdownIt-Anchor" href="#注解实现自动装配"></a> 注解实现自动装配</h2><ul><li>注解使用配置：<ol><li>导入约束：<ul><li><code>xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</code></li><li><code> http://www.springframework.org/schema/context</code></li><li><code>https://www.springframework.org/schema/context/spring-context.xsd&quot;</code><br />2.配置注解的支持：<code>&lt;context:annotation-config/&gt;</code></li></ul></li><li>示例：</li></ol>  <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;    xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;    &lt;context:annotation-config&#x2F;&gt;&lt;&#x2F;beans&gt;</code></pre></li><li><code>@Autowired</code>注解：<ul><li>使用该注解在类中需要导入包:<code>import org.springframework.beans.factory.annotation.Autowired;</code><ul><li>这个包需要在maven中配置导入。</li></ul></li><li>直接在==属性==上使用即可，也可以在set方法上使用。</li><li>使用这个注解，可以==不用编写属性对应的set方法==。前提是要被装配的属性在Spring容器中存在。</li><li>配置注解<code>@Autowired(required = false)</code>可以使属性可以为空，默认不能。与注解<code>@Nullable</code>作用相同。</li><li><code>@Autowird</code>注解：会自动根据该属性的==类型或者名字==来自动装配;<ul><li>可以配合使用<code>@Qualifier(value = &quot;属性名&quot;)</code>来限定根据bean id的名字来装配。</li></ul></li><li>示例：</li></ul>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.service;import com.zestaken.dao.UserDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;public class UserServiceImpl implements UserService&#123;    @Autowired    @Qualifier(value &#x3D; &quot;userDaoImpl&quot;)    private UserDao userDao ;    &#x2F;&#x2F;注入UserDao的值    &#x2F;&#x2F;使用Spring管理的类的属性，必须由set方法设定    public void setUserDao(UserDao userDao) &#123;        this.userDao &#x3D; userDao;    &#125;    @Override    public void getUsers() &#123;        userDao.getUsers();    &#125;&#125;</code></pre></li><li><code>@Resource</code>注解：<ul><li><code>@Resource</code>注解是java==原生==的，无需导入包；</li><li><code>@Resource</code>相当于拥有<code>@Autowired</code>和<code>@Qualifier</code>两个注解的功能。</li><li>直接使用该注解，和<code>@Autowired</code>一样；</li><li>该注解可以设置参数，限定查找的bean id属性名，如：<code>@Resource(name = &quot;userDaoImpl&quot;)</code>.</li></ul></li></ul><h1 id="使用java来配置spring"><a class="markdownIt-Anchor" href="#使用java来配置spring"></a> 使用Java来配置Spring</h1><ul><li>本质：使用一个java配置类通过注解的方式来完全取代xml配置文件。</li></ul><ol><li>配置类：</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.config;import com.zestaken.dao.UserDao;import com.zestaken.dao.UserDaoImpl;import com.zestaken.service.UserService;import com.zestaken.service.UserServiceImpl;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class AppConfig &#123;    @Bean    public UserDao userDao() &#123;        return new UserDaoImpl();    &#125;    @Bean    public UserService userService() &#123;        return new UserServiceImpl();    &#125;&#125;</code></pre><ul><li><code>@Configuration</code>注解：在配置类上面使用，代表这是一个配置类。（这个配置类的底层实质也是一个被Spring容器管理的类）</li><li><code>@Bean</code>注解：类似xml文件中的bean标签的作用，用于设置bean对象的方法之上：<ul><li>这个==方法的名字，相当于bean对象中的id属性==；</li><li>这个==方法的返回值，相当于bean对象中的class属性==。</li></ul></li><li>还有一些诸如扫描包，导入其它配置类的注解等。</li></ul><ol start="2"><li>被注册到Spring容器的类</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;UserDaopackage com.zestaken.dao;import org.springframework.stereotype.Component;@Componentpublic class UserDaoImpl implements UserDao&#123;    @Override    public void getUsers() &#123;        System.out.println(&quot;sql查询&quot;);    &#125;&#125;&#x2F;&#x2F;UserServicepackage com.zestaken.service;import com.zestaken.dao.UserDao;import org.springframework.stereotype.Component;import javax.annotation.Resource;@Componentpublic class UserServiceImpl implements UserService&#123;    @Resource    private UserDao userDao ;    &#x2F;&#x2F;注入UserDao的值    &#x2F;&#x2F;使用Spring管理的类的属性，必须由set方法设定    public void setUserDao(UserDao userDao) &#123;        this.userDao &#x3D; userDao;    &#125;    @Override    public void getUsers() &#123;        userDao.getUsers();    &#125;&#125;</code></pre><ul><li>和普通注解开发一样。</li><li>测试：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.service;import com.zestaken.config.AppConfig;import org.junit.jupiter.api.Test;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class ServiceTest &#123;    @Test    public void  userServiceImplTest()&#123;        &#x2F;&#x2F;获取Spring的上下文对象,此处使用AnnotationConfig        AnnotationConfigApplicationContext annotationConfigApplicationContext &#x3D; new AnnotationConfigApplicationContext(AppConfig.class);        &#x2F;&#x2F;现在所有的对象都交由Spring管理了，要想使用对象，只需要从Spring中取出即可（Spring中这些对象叫做bean）        UserService userServiceImpl &#x3D; (UserService)annotationConfigApplicationContext.getBean(&quot;userService&quot;);        &#x2F;&#x2F;获取出对象之后，即可正常使用        userServiceImpl.getUsers();    &#125;&#125;</code></pre><ul><li><strong>获取上下文的方式</strong>：<code>AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(AppConfig.class);</code><ul><li><strong>参数</strong>:参数是要使用的配置类的class属性值。</li></ul></li></ul><h1 id="aop"><a class="markdownIt-Anchor" href="#aop"></a> AOP</h1><ul><li><strong>AOP(Aspect Oriented Programming)</strong>:面向切面编程，通过==预编译技术和运行期间动态代理==实现程序功能的统一维护的一种技术。</li><li>Spring中AOP：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210228205043.jpg" alt="" /></li><li>AOP在Spring中的作用：<ul><li>提供声明式事务：允许用户自定义切面。</li></ul></li></ul><h2 id="spring中aop概念"><a class="markdownIt-Anchor" href="#spring中aop概念"></a> Spring中AOP概念</h2><ul><li><strong>横切关注点</strong>：<ul><li>跨越应用程序多个模块的方法或功能。</li><li>与我们业务逻辑无关的，但是需要我们关注的的部分，就是横切关注点，如日志，安全，缓存和事务等。</li></ul></li><li><strong>切面（Aspect）</strong>:<ul><li>横切关注点被模块化的特殊对象；</li><li>切面==是一个类==。</li></ul></li><li><strong>通知（Advice）</strong>:<ul><li>切面必须要完成的工作；</li><li>==通知是切面类中的一个方法==。</li><li>Spring中支持五种类型的Advice:<ol><li><strong>前置通知</strong>:<ol><li>连接点：方法前；</li><li>实现接口：<code>org.springframework.aop.MethodBeforeAdvice</code></li></ol></li><li><strong>后置通知</strong>：<ol><li>连接点：方法后；</li><li>实现接口：<code>org.springframework.aop.AfterReturningAdvice</code></li></ol></li><li><strong>环绕通知</strong>：<ol><li>连接点：方法前后；</li><li>实现接口：<code>org.aopalliance.intercept.MethodInterceptor</code></li></ol></li><li><strong>异常抛出通知</strong>：<ol><li>连接点：方法抛出异常；</li><li>实现接口：<code> org.springframework.aop.ThrowsAdvice</code></li></ol></li><li><strong>引介通知</strong>：<ol><li>连接点：类中增加新的方法属性。</li><li>实现接口：<code>org.springframework.aop.IntroductionInterceptor</code></li></ol></li></ol></li></ul></li><li><strong>目标（Target）</strong>：<ul><li>被通知的对象</li></ul></li><li><strong>代理(Proxy)</strong>:<ul><li>向目标对象应用通知之后创建的==对象==；</li></ul></li><li><strong>切入点（PointCut）</strong>：<ul><li>切面通知执行“地点”的定义；</li></ul></li><li><strong>连接点（JointPoint）</strong>：<ul><li>与切入点匹配的执行点。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210228211039.jpg" alt="" /></li></ul></li></ul><h2 id="spring实现aop"><a class="markdownIt-Anchor" href="#spring实现aop"></a> Spring实现AOP</h2><ul><li>不论采用何种方法，首先都需要先导入一个织入包：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.aspectj&#x2F;aspectjweaver --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.9.6&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><h3 id="方式一使用spring的api接口实现aop"><a class="markdownIt-Anchor" href="#方式一使用spring的api接口实现aop"></a> 方式一：使用Spring的API接口实现AOP</h3><ul><li>主功能的接口：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.service;public interface UserService &#123;    void add();    void delete();&#125;</code></pre><ul><li>实现主功能的类：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.service;public class UserServiceImpl implements UserService &#123;    @Override    public void add() &#123;        System.out.println(&quot;add...&quot;);    &#125;    @Override    public void delete() &#123;        System.out.println(&quot;delete...&quot;);    &#125;&#125;</code></pre><ul><li>在主功能的方法前加上日志的类：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.log;import org.springframework.aop.MethodBeforeAdvice;import java.lang.reflect.Method;public class Log implements MethodBeforeAdvice &#123;    @Override    public void before(Method method, Object[] args, Object target) throws Throwable &#123;        System.out.println(target.getClass().getName()+&quot;的&quot;+method.getName()+&quot;方法被执行了&quot;);    &#125;&#125;</code></pre><ul><li>before方法的参数：<ul><li>method:要执行的目标对象的方法</li><li>args：要执行的目标方法的参数</li><li>target：目标对象</li></ul></li><li>要增加到切点的的类，应该==根据这个类中方法插入的位置，来实现不用的Spring的aop的API接口==.</li><li>在applicationContext.xml文件中==注册主功能类和增加日志方法的类,并配置aop==：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt;&lt;!--    注册主功能类和增加日志功能的类--&gt;    &lt;bean id&#x3D;&quot;userServiceImpl&quot; class&#x3D;&quot;com.zestaken.service.UserServiceImpl&quot;&#x2F;&gt;    &lt;bean id&#x3D;&quot;log&quot; class&#x3D;&quot;com.zestaken.log.Log&quot;&#x2F;&gt;&lt;!--    配置aop，需要导入约束--&gt;    &lt;aop:config&gt;&lt;!--        配置切入点--&gt;&lt;!--        id是切入点的名字--&gt;&lt;!--        expression描述切入点的位置,使用execution表达式,execution表达式的格式为（修饰词，返回值，类名，方法名，参数）--&gt;        &lt;aop:pointcut id&#x3D;&quot;pointcut1&quot; expression&#x3D;&quot;execution(* com.zestaken.service.UserService.*(..))&quot;&#x2F;&gt;&lt;!--        配置增加到切入点的方法--&gt;        &lt;aop:advisor advice-ref&#x3D;&quot;log&quot; pointcut-ref&#x3D;&quot;pointcut1&quot;&#x2F;&gt;    &lt;&#x2F;aop:config&gt;&lt;&#x2F;beans&gt;</code></pre><ul><li>导入的约束：<ul><li><code>xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</code></li><li><code>http://www.springframework.org/schema/aop</code></li><li><code>https://www.springframework.org/schema/aop/spring-aop.xsd</code></li></ul></li><li>excution表达式描述切入点的位置，==其中可以用<code>*</code>通配符来表示适用于各种修饰词，返回值，方法名，用<code>(..)</code>表示方法的任何参数==。</li><li>测试aop：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">import com.zestaken.service.UserService;import org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest &#123;    @Test    public void aopTest() &#123;        &#x2F;&#x2F;获取配置文件生成上下文对象        ApplicationContext classPathXmlApplicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        &#x2F;&#x2F;获取接口        UserService userService &#x3D; (UserService)classPathXmlApplicationContext.getBean(&quot;userServiceImpl&quot;);        &#x2F;&#x2F;测试方法        userService.add();        userService.delete();    &#125;&#125;</code></pre><ul><li><strong>==注意：aop的本质是动态代理，动态代理的是接口，所以从容器中获取出来的应该是接口类型的对象==</strong>。</li></ul><h3 id="方法二自定义方法实现aop"><a class="markdownIt-Anchor" href="#方法二自定义方法实现aop"></a> 方法二：自定义方法实现AOP</h3><ul><li>主功能类与接口不变。</li><li>在主功能类前增加日志功能的类：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Log &#123;    void before()&#123;        System.out.println(&quot;before....&quot;);    &#125;&#125;</code></pre><ul><li>==无需实现接口==，只是一个普通的类。</li><li>配置文件：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;aop:config&gt;    &lt;aop:aspect ref&#x3D;&quot;log&quot;&gt;        &lt;aop:pointcut id&#x3D;&quot;pointcut2&quot; expression&#x3D;&quot;execution(* com.zestaken.service.UserServiceImpl.*(..))&quot;&#x2F;&gt;        &lt;aop:before method&#x3D;&quot;before&quot; pointcut-ref&#x3D;&quot;pointcut2&quot;&#x2F;&gt;    &lt;&#x2F;aop:aspect&gt;&lt;&#x2F;aop:config&gt;</code></pre><ul><li>在类注册好，以及导入必须的约束的情况下，修改aop的配置。</li><li><code>&lt;aop:aspect&gt;</code>标签中，用==属性ref设置需要放入切面的方法==</li><li><code>&lt;aop:pointcut&gt;</code>标签中，正常设置切入点。</li><li><code>&lt;aop:before&gt;</code>以及<code>&lt;aop:after&gt;</code>等标签设置将绑定的方法==放入哪个位置，以及放入的方式==。</li></ul><h3 id="方法三使用注解实现aop"><a class="markdownIt-Anchor" href="#方法三使用注解实现aop"></a> 方法三：使用注解实现AOP</h3><ul><li><strong>只修改实现增强功能的类以及xml文件</strong>。</li><li>实现增强功能的类:</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class Log &#123;    @Before(&quot;execution(* com.zestaken.service.UserServiceImpl.*(..))&quot;)    void before()&#123;        System.out.println(&quot;before....&quot;);    &#125;&#125;</code></pre><ul><li><code>@Aspect</code>注解：表示该类是用于切面的增强功能的类。</li><li><code>@Before</code>注解：表示切入的方式，参数是切入点的位置。<ul><li>可以有多种切入方式。如<code>@After</code>，<code>@Around</code>等。</li></ul></li><li>可以给通知方法传递参数**<code>ProceedingJoinPoint joinPoint</code>连接点对象**，作用是获取切入点的信息。如方法名之类的。</li><li>xml配置文件：==省去aop配置，开启aop的注解功能==。但是aop的相关约束还是要有。</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;aop:aspectj-autoproxy proxy-target-class&#x3D;&quot;false&quot;&#x2F;&gt;</code></pre><ul><li>在注册了相关的bean之后，再开启aop的注解。</li><li>aop的动态代理默认是用jdk方式实现的 ，将proxy-target-class属性设为true会改为使用cglib实现。</li><li>proxy-target-class属性可以省略，这样默认使用jdk方式。</li></ul><h1 id="spring整合mybatis"><a class="markdownIt-Anchor" href="#spring整合mybatis"></a> Spring整合Mybatis</h1><h2 id="导入相关jar包"><a class="markdownIt-Anchor" href="#导入相关jar包"></a> 导入相关jar包</h2><ol><li>junit</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;    &lt;version&gt;4.13&lt;&#x2F;version&gt;    &lt;scope&gt;test&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt;</code></pre><ol start="2"><li>mybatis</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;    &lt;version&gt;3.5.6&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><ol start="3"><li>mysql数据库</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;    &lt;version&gt;8.0.23&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><ol start="4"><li>Spring基本包</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;    &lt;version&gt;5.3.3&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><ol start="5"><li>Spring的AOP织入包</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.9.6&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><ol start="6"><li>Spring操作数据库必须的包</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;    &lt;version&gt;5.3.4&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><ol start="7"><li>整合Mybatis和Spring的包：mybatis-spring</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt;    &lt;version&gt;2.0.6&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><h2 id="spring整合mybatis方式一"><a class="markdownIt-Anchor" href="#spring整合mybatis方式一"></a> Spring整合Mybatis方式一</h2><p><a href="http://mybatis.org/spring/zh/index.html">Mybatis-spring文档</a></p><ol><li>编写Spring对Mybatis的配置文件：</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!--suppress ALL --&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;&lt;!--    注册DataSource 使用Spring的提供的JDBC来替换Mybatis的数据源配置--&gt;    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.cj.jdbc.Driver&quot;&#x2F;&gt;        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;youth_study&quot;&#x2F;&gt;        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;&lt;!--    sqlSessionFactory--&gt;    &lt;bean id&#x3D;&quot;sqlSessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;&lt;!--        绑定Mybatis的配置文件，使这两个配置文件同时作用，各自负责一部分配置--&gt;        &lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;classpath:mybatis-config.xml&quot;&#x2F;&gt;        &lt;!-- 绑定mapper.xml文件，起到注册mapper的作用 --&gt;        &lt;property name&#x3D;&quot;mapperLocations&quot; value&#x3D;&quot;classpath:com&#x2F;zestaken&#x2F;dao&#x2F;T_collegeMapper.xml&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;&lt;!--    sqlSessionTemplate：就是实际使用的sqlSession--&gt;    &lt;bean id&#x3D;&quot;sqlSessionTemplate&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;&lt;!--        只能使用构造器注入sqlSessionFactory，因为没有set方法--&gt;        &lt;constructor-arg index&#x3D;&quot;0&quot; ref&#x3D;&quot;sqlSessionFactory&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;</code></pre><ul><li>这是一个Spring配置文件，==Spring配置文件的约束要有==。</li><li><strong>配置数据源（datasource）</strong>：使用<code>org.springframework.jdbc.datasource.DriverManagerDataSource</code>类。具体配置与mybatis一样。</li><li><strong>配置sqlSessionFactory</strong>：<ul><li>使用<code>org.mybatis.spring.SqlSessionFactoryBean</code>类；</li><li>配置使用的数据源；</li><li>导入mybatis本来的配置；</li><li>导入mapper的配置。</li></ul></li><li><strong>配置sqlSessionTemplate</strong>:<ul><li>使用<code>org.mybatis.spring.SqlSessionTemplate</code>类；</li><li>用以==取代原来的sqlSession对象。</li><li>向sqlSessionTemplate==注入sqlSessionFactory==，并且只能使用构造器注入，因为没有set方法。</li></ul></li><li><strong>将mapper实现类注册为bean</strong>：<ul><li>==将sqlSessionTemplate==注入到mapper实现类中去。</li></ul></li></ul><ol start="3"><li>编写mapper实现类</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.dao;import com.zestaken.pojo.T_college;import org.mybatis.spring.SqlSessionTemplate;import java.util.List;public class T_collegeMapperImpl implements T_collegeMapper &#123;&#x2F;&#x2F;    需要导入包，SqlSessionTemplate模板或得sqlSession来执行操作    private SqlSessionTemplate sqlSession;&#x2F;&#x2F;设置sqlSession的set方法，方便Spring的注入    public void setSqlSession(SqlSessionTemplate sqlSession) &#123;        this.sqlSession &#x3D; sqlSession;    &#125;    public List&lt;T_college&gt; getT_collegeList() &#123;        T_collegeMapper t_collegeMapper &#x3D; sqlSession.getMapper(T_collegeMapper.class);        List&lt;T_college&gt; t_collegeList &#x3D; t_collegeMapper.getT_collegeList();        return t_collegeList;    &#125;&#125;</code></pre><ul><li>这个实现类需要实现mapper接口中的方法；</li><li>同时==还需创建SqlSessionTemplate属性，并设置它对应的set方法==。<ul><li><code>SqlSessionTemplate属性</code>需要导入包：<code>org.mybatis.spring.SqlSessionTemplate</code></li></ul></li><li>相当于将==实际使用时获取mapper，执行对应sql语句的步骤直接放到这个实现类中去完成==，实际使用的时候，只需==获取该实现类的bean，调用相应的方法即可==。<br />4.Spring配置文件：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!--suppress ALL --&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;&lt;!--将数据库操作实现类注册到Spring--&gt;    &lt;bean id&#x3D;&quot;t_collegeMapperImpl&quot; class&#x3D;&quot;com.zestaken.dao.T_collegeMapperImpl&quot;&gt;        &lt;property name&#x3D;&quot;sqlSession&quot; ref&#x3D;&quot;sqlSessionTemplate&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;</code></pre><ol start="5"><li>mybatis-config.xml配置文件：</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;&lt;!-- 核心配置文件 --&gt;&lt;configuration&gt;&lt;&#x2F;configuration&gt;</code></pre><ol start="6"><li>测试：</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void getT_collegeListTest()&#123;    ClassPathXmlApplicationContext classPathXmlApplicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;spring-dao.xml&quot;);    T_collegeMapper t_collegeMapperImpl &#x3D; classPathXmlApplicationContext.getBean(&quot;t_collegeMapperImpl&quot;, T_collegeMapper.class);    List&lt;T_college&gt; t_collegeList &#x3D; t_collegeMapperImpl.getT_collegeList();    for(T_college college : t_collegeList)&#123;        System.out.println(college);    &#125;&#125;</code></pre><ul><li>Spring整合Mybatis的常用配置方法：<ul><li>mybatis自己的配置文件(一般是mybatis-config.xml)中只放别名和设置的配置；(==将与Spring对Mybaits的配置相同的配置全部移除，如数据源配置，mapper注册等==)</li><li>关于Spring的Mybatis配置单独创建一个Spring配置文件来管理；</li><li>Spring自己的配置（如注册bean等）用一个单独的Spring配置文件来管理。</li></ul></li></ul><h2 id="spring整合mybatis方式二"><a class="markdownIt-Anchor" href="#spring整合mybatis方式二"></a> Spring整合Mybatis方式二</h2><ul><li>在方式一的基础上==只对mapper实现类获取SqlSessionTemplate的方式作了简化==；</li><li>mapper实现类：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.dao;import com.zestaken.pojo.T_college;import org.apache.ibatis.session.SqlSession;import org.mybatis.spring.support.SqlSessionDaoSupport;import java.util.List;public class T_collegeMapperImpl extends SqlSessionDaoSupport implements T_collegeMapper &#123;    public List&lt;T_college&gt; getT_collegeList() &#123;        SqlSession sqlSession &#x3D; getSqlSession();        T_collegeMapper t_collegeMapper &#x3D; sqlSession.getMapper(T_collegeMapper.class);        List&lt;T_college&gt; t_collegeList &#x3D; t_collegeMapper.getT_collegeList();        return t_collegeList;    &#125;&#125;</code></pre><ul><li>mapper实现类需要==继承SqlSessionDaoSupport类==，使用这个类需要导入包：<code>org.mybatis.spring.support.SqlSessionDaoSupport</code></li><li>实现类==无需再设置SqlSessionTemplate属性==，可以直接通过==getSqlSession方法获取SqlSessionTemplate对象==。</li><li>mapper实现类注册bean</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--将数据库操作实现类注册到Spring--&gt;    &lt;bean id&#x3D;&quot;t_collegeMapperImpl&quot; class&#x3D;&quot;com.zestaken.dao.T_collegeMapperImpl&quot;&gt;        &lt;property name&#x3D;&quot;sqlSessionFactory&quot; ref&#x3D;&quot;sqlSessionFactory&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;</code></pre><ul><li>虽然无需再向mapper实现类中注入sqlSessionTemplate，但是需要==注入sqlSessionFactory==,用来产生SqlSessionTemplate对象。</li></ul><h2 id="spring中事务管理"><a class="markdownIt-Anchor" href="#spring中事务管理"></a> Spring中事务管理</h2><ul><li><strong>事务(Transaction)</strong>：把一组业务绑在一起，看成一个业务，这些业务当且仅当所有业务都执行成功时，每一个业务才能成功执行，只要有一个业务没有成功，那么最后，所有业务都是失败的结果。</li><li><strong>事务作用</strong>：确保数据的完整性与一致性。</li><li><strong>事务的ACID属性</strong>：<ol><li><strong>原子性（atomicity）</strong>。一个事务是一个不可分割的工作单位，事务中包括的操作==要么都做，要么都不做==。</li><li><strong>一致性（consistency）</strong>。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。</li><li><strong>隔离性（isolation）</strong>。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，==并发执行的各个事务之间不能互相干扰==。</li><li><strong>持久性（durability）</strong>。持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</li></ol></li><li>Spring支持两种事务：<ul><li>声明式事务（又称交由容器管理事务）；</li><li>编程式事务：在程序中通过try/catch实现事务。</li></ul></li></ul><h3 id="声明式事务配置"><a class="markdownIt-Anchor" href="#声明式事务配置"></a> 声明式事务配置</h3><ol><li>在Spring对Mybatis的配置文件中==开启声明式事务==：</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--    配置声明式事务--&gt;    &lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;</code></pre><ul><li>需要给transactionManger==注入datasource数据源==。</li></ul><ol start="2"><li>结合AOP实现事务的织入：</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--    结合aop实现事务的织入--&gt;&lt;!--    配置事务通知--&gt;    &lt;tx:advice id&#x3D;&quot;txAdvice&quot; transaction-manager&#x3D;&quot;transactionManager&quot;&gt;&lt;!--        给具体的方法配置事务--&gt;&lt;!--配置每个方法事务的特性,如传播性propagation--&gt;        &lt;tx:attributes&gt;            &lt;tx:method name&#x3D;&quot;getT_collegeList&quot; propagation&#x3D;&quot;REQUIRED&quot;&#x2F;&gt;        &lt;&#x2F;tx:attributes&gt;    &lt;&#x2F;tx:advice&gt;&lt;!--    配置事务切入--&gt;    &lt;aop:config&gt;        &lt;aop:pointcut id&#x3D;&quot;txPointCut&quot;  expression&#x3D;&quot;execution(* com.zestaken.dao.*.*(..))&quot;&#x2F;&gt;        &lt;aop:advisor advice-ref&#x3D;&quot;txAdvice&quot; pointcut-ref&#x3D;&quot;txPointCut&quot;&#x2F;&gt;    &lt;&#x2F;aop:config&gt;</code></pre><ul><li>配置事务通知（即使用tx标签）需要导入tx的约束：<ul><li><code>xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</code></li><li><code> http://www.springframework.org/schema/tx</code></li><li><code>http://www.springframework.org/schema/tx/spring-tx.xsd</code></li></ul></li><li>给具体的方法配置事务：<ul><li>以后在切入点，只要==方法名和配置相同的方法，就会被配置上事务==。</li></ul></li><li>配置事务的切入：<ul><li>通过切入的方式，使事务在具体的位置生效。</li></ul></li><li>最终效果：<ul><li>一个配置了事务的方法中，对数据库的操作中，只要有一个失败了，其余的所有操作都不会生效。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 后端 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Mybatis/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Mybatis/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="mybatis简介"><a class="markdownIt-Anchor" href="#mybatis简介"></a> Mybatis简介</h1><ul><li>MyBatis 是一款优秀的<strong>持久层框架</strong>。<ul><li>持久化：将程序的数据永久存储到硬盘上；</li><li>持久层：完成持久化工作的代码块，即三层架构中的<strong>DAO层</strong>。</li></ul></li><li>MyBatis 避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。</li><li>MyBatis 可以使用简单的 <strong>XML 或注解来配置和映射原生信息</strong>，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。</li><li>Mybatis资料：<ul><li><a href="https://mybatis.org/mybatis-3/zh/index.html">官方文档</a></li><li><a href="https://github.com/mybatis/mybatis-3/releases">下载地址</a></li><li>maven坐标：</li></ul></li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.mybatis&#x2F;mybatis --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;    &lt;version&gt;3.5.6&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><ul><li>优点：<ul><li>简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件。</li><li>灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 <strong>sql写在xml里</strong>，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。</li><li>解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离。</li><li>提供xml标签，支持编写动态sql。</li></ul></li></ul><h1 id="快速入门"><a class="markdownIt-Anchor" href="#快速入门"></a> 快速入门</h1><h2 id="一环境搭建"><a class="markdownIt-Anchor" href="#一环境搭建"></a> 一：环境搭建</h2><ol><li>通过maven导入三个jar包：<ol><li>mysql驱动包：</li><li>junit包；</li><li>mybatisjar包</li></ol></li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependencies&gt;    &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;mysql&#x2F;mysql-connector-java --&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;        &lt;version&gt;8.0.23&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;        &lt;version&gt;4.13&lt;&#x2F;version&gt;        &lt;scope&gt;test&lt;&#x2F;scope&gt;    &lt;&#x2F;dependency&gt;&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;        &lt;version&gt;3.5.6&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</code></pre><h2 id="二编写核心配置文件"><a class="markdownIt-Anchor" href="#二编写核心配置文件"></a> 二：编写核心配置文件</h2><ul><li><code>mybatis-config.xml</code>,maven项目放在resources目录下：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;configuration&gt;    &lt;environments default&#x3D;&quot;development&quot;&gt;        &lt;environment id&#x3D;&quot;development&quot;&gt;            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;            &lt;!--配置数据源--&gt;            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;                &lt;!--注册驱动，同jdbc--&gt;                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;                &lt;!--数据库连接路径--&gt;                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;youth_study&quot;&#x2F;&gt;                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;            &lt;&#x2F;dataSource&gt;        &lt;&#x2F;environment&gt;    &lt;&#x2F;environments&gt;    &lt;!--每一个Mapper.xml文件都需要在这个mybatis核心配置文件中注册--&gt;    &lt;mappers&gt;        &lt;mapper resource&#x3D;&quot;org&#x2F;mybatis&#x2F;example&#x2F;BlogMapper.xml&quot;&#x2F;&gt;    &lt;&#x2F;mappers&gt;&lt;&#x2F;configuration&gt;</code></pre><h2 id="三编写mybatis工具类"><a class="markdownIt-Anchor" href="#三编写mybatis工具类"></a> 三：编写Mybatis工具类</h2><ul><li>编写一个用来获取SQLSession实例的工具类：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.utils;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class MybatisUtils &#123;    private static SqlSessionFactory sqlSessionFactory;    static &#123;        try &#123;            &#x2F;&#x2F;1.加载核心配置文件            String resource &#x3D; &quot;mybatis-config.xml&quot;;            InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);            &#x2F;&#x2F;2.根据xml核心配置文件获取对应的SqlSessionFactory对象            sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    &#x2F;&#x2F;2.从SqlSessionFactory实例中获得 SqlSession 的实例。    &#x2F;&#x2F; SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。    &#x2F;&#x2F; 你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。    public static SqlSession getSqlSession()&#123;        return sqlSessionFactory.openSession();    &#125;&#125;</code></pre><h2 id="四编写操作表的接口并实现"><a class="markdownIt-Anchor" href="#四编写操作表的接口并实现"></a> 四：编写操作表的接口并实现</h2><ul><li>接口：T_collegeMapper</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.dao;import com.zestaken.Pojo.T_college;import java.util.List;public interface T_collegeMapper &#123;    List&lt;T_college&gt; getT_collegeList();&#125;</code></pre><ul><li>实现：Mapper.xml实现了接口实现类的功能</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace绑定一个Mapper接口--&gt;&lt;mapper namespace&#x3D;&quot;com.zestaken.dao.T_collegeMapper&quot;&gt;    &lt;!--id是需要实现的接口中的方法名--&gt;    &lt;!--resultType是返回结果的类型，如果返回的是结果集，则用resultMap--&gt;    &lt;!--select是要执行sql查询语句--&gt;    &lt;select id&#x3D;&quot;getUserList&quot; resultType&#x3D;&quot;com.zestaken.Pojo.T_college&quot; &gt;    select * from youth_study.t_college;  &lt;&#x2F;select&gt;&lt;&#x2F;mapper&gt;</code></pre><ul><li>注：Mapper.xml文件需要在mybatis-config.xml文件中注册：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--每一个Mapper.xml文件都需要在这个mybatis核心配置文件中注册--&gt;&lt;mappers&gt;    &lt;mapper resource&#x3D;&quot;org&#x2F;mybatis&#x2F;example&#x2F;BlogMapper.xml&quot;&#x2F;&gt;&lt;&#x2F;mappers&gt;</code></pre><h2 id="五编写junit测试类"><a class="markdownIt-Anchor" href="#五编写junit测试类"></a> 五：编写junit测试类</h2><ul><li>编写一个可以查询表的测试类：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.junit.Test;import java.util.List;public class T_collegeMapperTest &#123;    @Test    public void test()&#123;        &#x2F;&#x2F;1.获取SqlSession实例        SqlSession sqlSession &#x3D; MybatisUtils.getSqlSession();        &#x2F;&#x2F;2.获取Mapper接口的实现类        T_collegeMapper t_collegeMapper &#x3D; sqlSession.getMapper(T_collegeMapper.class);        &#x2F;&#x2F;3.执行sql        List&lt;T_college&gt; t_collegeList &#x3D; t_collegeMapper.getT_collegeList();        for(T_college college : t_collegeList)&#123;            System.out.println(college);        &#125;        &#x2F;&#x2F;4.释放sqlSession        sqlSession.close();    &#125;&#125;</code></pre><h2 id="六常见错误"><a class="markdownIt-Anchor" href="#六常见错误"></a> 六：常见错误</h2><ol><li>Mapper.xml文件没有在mybatis-config.xml文件中注册；</li><li>没有配置maven，使maven可以导入java包下的配置文件。（因为maven默认所有配置文件都是放在resources目录下的）<ul><li>在pom.xml中配置，使maven可以导入java包下的配置文件：</li></ul></li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;build&gt;    &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;            &lt;includes&gt;                &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;            &lt;&#x2F;includes&gt;            &lt;filtering&gt;false&lt;&#x2F;filtering&gt;        &lt;&#x2F;resource&gt;        &lt;resource&gt;            &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;            &lt;includes&gt;                &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;            &lt;&#x2F;includes&gt;            &lt;filtering&gt;false&lt;&#x2F;filtering&gt;        &lt;&#x2F;resource&gt;    &lt;&#x2F;resources&gt;&lt;&#x2F;build&gt;</code></pre><h1 id="mybatis的crud操作"><a class="markdownIt-Anchor" href="#mybatis的crud操作"></a> Mybatis的CRUD操作</h1><ul><li>在mapper接口中增加对应操作的方法，在mapper.xml中增加对应的sql语句。</li><li>取参数：<ul><li><strong>表对象传递的属性可以通过<code>#&#123;&#125;</code>取出使用，但是属性名，数据项的名字，以及sql中参数的名字需要一致</strong></li><li><strong>Map对象传递的参数也可以通过<code>#&#123;&#125;</code>取出使用，只需要参数名和map中的key名相同即可</strong>。</li></ul></li><li><strong>增删改操作必须提交事务才能生效</strong>。</li><li>增删改操作的返回值默认为int，这个类型不需要在<code>resultType</code>中设置，如果操作成功则返回1，操作失败返回0；</li><li>参数可以用<code>#&#123;参数名&#125;</code>取出来</li><li>parameterType：参数类型</li><li>resultType:返回值类型</li><li>id：namespace中接口中的方法名</li><li>查询操作用<code>&lt;select&gt;&lt;/select&gt;</code></li><li>添加操作用<code>&lt;insert&gt;&lt;/insert&gt;</code></li><li>修改操作用<code>&lt;update&gt;&lt;/update&gt;</code></li><li>删除操作用<code>&lt;delete&gt;&lt;/delete&gt;</code></li><li>示例：<ol><li>mapper接口</li></ol></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">import com.zestaken.pojo.T_college;import java.util.List;public interface T_collegeMapper &#123;    &#x2F;&#x2F;查询表中的所有值    List&lt;T_college&gt; getT_collegeList();    &#x2F;&#x2F;根据id查询表中的值    T_college getT_collegeByID(int id);    &#x2F;&#x2F;向表中插入新的数据    int insertT_collegeList(T_college t_college);    &#x2F;&#x2F;修改表中某项的数据    int updateT_collegeList(T_college t_college);    &#x2F;&#x2F;删除表中指定id的项    int deleteT_collegeList(int id);&#125;</code></pre><ol start="2"><li>mapper.xml</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace绑定一个Mapper接口--&gt;&lt;mapper namespace&#x3D;&quot;com.zestaken.dao.T_collegeMapper&quot;&gt;    &lt;!--id是需要实现的接口中的方法名--&gt;    &lt;!--resultType是返回结果的类型，如果返回的是结果集，则用resultMap--&gt;    &lt;!--select是要执行sql查询语句--&gt;    &lt;select id&#x3D;&quot;getT_collegeList&quot; resultType&#x3D;&quot;com.zestaken.pojo.T_college&quot; &gt;    select * from youth_study.t_college;  &lt;&#x2F;select&gt;&lt;!--    参数用#&#123;&#125;取出来--&gt;    &lt;select id&#x3D;&quot;getT_collegeByID&quot; parameterType&#x3D;&quot;int&quot; resultType&#x3D;&quot;com.zestaken.pojo.T_college&quot;&gt;        select * from youth_study.t_college where id &#x3D; #&#123;id&#125;;    &lt;&#x2F;select&gt;    &lt;!--表对象中的属性可以直接取出来   --&gt;    &lt;insert id&#x3D;&quot;insertT_collegeList&quot; parameterType&#x3D;&quot;com.zestaken.pojo.T_college&quot; &gt;-- 虽然参数是表对象，但是表对象中的属性可以直接取出来，就相当于传递的参数是一系列的属性值        insert into youth_study.t_college(id,name) values(#&#123;id&#125;,#&#123;name&#125;);    &lt;&#x2F;insert&gt;    &lt;update id&#x3D;&quot;updateT_collegeList&quot; parameterType&#x3D;&quot;com.zestaken.pojo.T_college&quot;&gt;        update youth_study.t_college set name&#x3D;#&#123;name&#125; where id &#x3D; #&#123;id&#125;;    &lt;&#x2F;update&gt;    &lt;delete id&#x3D;&quot;deleteT_collegeList&quot; parameterType&#x3D;&quot;int&quot;&gt;        delete from youth_study.t_college where id &#x3D; #&#123;id&#125;;    &lt;&#x2F;delete&gt;&lt;&#x2F;mapper&gt;</code></pre><ol start="3"><li>测试类</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.zestaken.dao;import com.zestaken.pojo.T_college;import com.zestaken.utils.MybatisUtils;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import java.util.List;public class T_collegeMapperTest &#123;    @Test    public void get()&#123;        &#x2F;&#x2F;1.获取SqlSession实例        SqlSession sqlSession &#x3D; MybatisUtils.getSqlSession();        &#x2F;&#x2F;2.获取Mapper接口的实现类        T_collegeMapper t_collegeMapper &#x3D; sqlSession.getMapper(T_collegeMapper.class);        &#x2F;&#x2F;3.执行sql        List&lt;T_college&gt; t_collegeList &#x3D; t_collegeMapper.getT_collegeList();        for(T_college college : t_collegeList)&#123;            System.out.println(college);        &#125;        &#x2F;&#x2F;4.释放sqlSession        sqlSession.close();    &#125;    @Test    public void getByID()&#123;        SqlSession sqlSession &#x3D; MybatisUtils.getSqlSession();        T_collegeMapper mapper &#x3D; sqlSession.getMapper(T_collegeMapper.class);        T_college college &#x3D; mapper.getT_collegeByID(100);        System.out.println(college);        sqlSession.close();    &#125;    @Test    public void insert()&#123;        SqlSession sqlSession &#x3D; MybatisUtils.getSqlSession();        T_collegeMapper mapper &#x3D; sqlSession.getMapper(T_collegeMapper.class);        T_college t_college &#x3D; new T_college();        t_college.setId(100);        t_college.setName(&quot;zhangjie&quot;);        mapper.insertT_collegeList(t_college);        &#x2F;&#x2F;增删改操作必须提交事务才能生效        sqlSession.commit();        sqlSession.close();    &#125;    @Test    public void updateT_collegeList()&#123;        SqlSession sqlSession &#x3D; MybatisUtils.getSqlSession();        T_collegeMapper mapper &#x3D; sqlSession.getMapper(T_collegeMapper.class);        T_college t_college &#x3D; new T_college();        t_college.setId(100);        t_college.setName(&quot;zhangsi&quot;);        mapper.updateT_collegeList(t_college);        sqlSession.commit();        sqlSession.close();    &#125;    @Test    public void deleteT_collegeList()&#123;        SqlSession sqlSession &#x3D; MybatisUtils.getSqlSession();        T_collegeMapper mapper &#x3D; sqlSession.getMapper(T_collegeMapper.class);        mapper.deleteT_collegeList(100);        sqlSession.commit();        sqlSession.close();    &#125;&#125;</code></pre><h1 id="配置解析"><a class="markdownIt-Anchor" href="#配置解析"></a> 配置解析</h1><h2 id="核心配置文件"><a class="markdownIt-Anchor" href="#核心配置文件"></a> 核心配置文件</h2><ul><li>核心配置文件（即mybatis-config.xml）.</li><li>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 配置文档的顶层结构如下：</li><li>configuration（配置）<ol><li>properties（属性）</li><li>settings（设置）</li><li>typeAliases（类型别名）</li><li>typeHandlers（类型处理器）</li><li>objectFactory（对象工厂）</li><li>plugins（插件）</li><li>environments（环境配置）</li><li>environment（环境变量）</li><li>transactionManager（事务管理器）</li><li>dataSource（数据源）</li><li>databaseIdProvider（数据库厂商标识）</li><li>mappers（映射器）</li></ol></li></ul><h2 id="环境配置environments"><a class="markdownIt-Anchor" href="#环境配置environments"></a> 环境配置（environments）</h2><ul><li>MyBatis 可以配置成<strong>适应多种环境</strong>，这种机制有助于将 SQL 映射应用于多种数据库之中,现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置。</li><li>尽管可以配置多个环境，但<strong>每个 SqlSessionFactory 实例只能选择一种环境</strong></li><li>配置详情：<ul><li>默认使用的环境默认ID（比如：default=“development”）。<ul><li>默认环境和环境ID顾名思义。 环境可以随意命名，但务必保证默认的环境ID要匹配其中一个环境ID。。</li></ul></li><li>每个environment元素定义的环境ID（比如：id=“development”）。</li><li>事务管理器的配置（比如：type=“JDBC”）。<ul><li>Mybatis有两种事务管理器：JDBC、MANGED；</li><li>Spring+Mybatis的搭配没有必要设置事务管理器，因为会被Spring的配置覆盖。</li></ul></li><li>数据源的配置（比如：type=“POOLED”）。<ul><li>Mybatis有三种内建的数据源类型：<ul><li>POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来（主要使用POOLED）</li><li>UNPOOLED：这个数据源的实现会每次请求时打开和关闭连接。</li><li>JNDI：这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用。</li></ul></li></ul></li></ul></li><li>示例：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;environments default&#x3D;&quot;development&quot;&gt;  &lt;environment id&#x3D;&quot;development&quot;&gt;    &lt;transactionManager type&#x3D;&quot;JDBC&quot;&gt;      &lt;property name&#x3D;&quot;...&quot; value&#x3D;&quot;...&quot;&#x2F;&gt;    &lt;&#x2F;transactionManager&gt;    &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;      &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt;      &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;      &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;      &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt;    &lt;&#x2F;dataSource&gt;  &lt;&#x2F;environment&gt;&lt;&#x2F;environments&gt;</code></pre><h2 id="属性properties"><a class="markdownIt-Anchor" href="#属性properties"></a> 属性（properties）</h2><ul><li>通过properties<strong>实现引用配置文件</strong>；</li><li>示例：<ol><li>创建db.properties文件</li></ol></li></ul><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">driver&#x3D;com.mysql.jdbc.Driverurl&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;youth_studyusername&#x3D;root</code></pre><ol start="2"><li>在mybatis-config.xml文件中导入配置文件</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;&lt;!-- 核心配置文件 --&gt;&lt;configuration&gt;    &lt;properties resource&#x3D;&quot;db.properties&quot;&gt;        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;    &lt;&#x2F;properties&gt;    &lt;environments default&#x3D;&quot;development&quot;&gt;        &lt;environment id&#x3D;&quot;development&quot;&gt;            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;            &lt;!--配置数据源--&gt;            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;                &lt;!--注册驱动，同jdbc--&gt;                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt;                &lt;!--数据库连接路径--&gt;                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt;            &lt;&#x2F;dataSource&gt;        &lt;&#x2F;environment&gt;    &lt;&#x2F;environments&gt;    &lt;!--每一个Mapper.xml文件都需要在这个mybatis核心配置文件中注册--&gt;    &lt;mappers&gt;        &lt;mapper resource&#x3D;&quot;com&#x2F;zestaken&#x2F;dao&#x2F;T_collegeMapper.xml&quot;&#x2F;&gt;    &lt;&#x2F;mappers&gt;&lt;&#x2F;configuration&gt;</code></pre><ul><li>properties配置**必须放在<code>&lt;configuration&gt;&lt;/configuration&gt;</code>标签内的最开始位置。</li><li>properties属性可以直接引入外部的配置文件；</li><li>可以在properties标签中通过property标签动态设置属性</li><li>如果在property标签中动态配置的属性与外部配置文件有冲突，则<strong>优先使用外部配置文件的配置</strong>。</li></ul><h2 id="类型别名typealiases"><a class="markdownIt-Anchor" href="#类型别名typealiases"></a> 类型别名（typeAliases）</h2><ul><li>类型别名可为 Java 类型设置一个缩写名字。</li><li>它仅用于 XML 配置，意在降低冗余的全限定类名书写。</li><li>typeAliases配置需要写在配置的第三位，即properties之后。</li><li>三种配置别名的方法：<ol><li>完全限定名配置：</li></ol></li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;typeAliases&gt;  &lt;typeAlias alias&#x3D;&quot;Author&quot; type&#x3D;&quot;domain.blog.Author&quot;&#x2F;&gt;&lt;&#x2F;typeAliases&gt;</code></pre><ol start="2"><li>包名配置：<ol><li>Mybaits会在指定的包名下搜索需要的javabean</li><li>扫描实体类的包，它的默认名就为<strong>这个类的类名，并且首字母小写</strong>。</li></ol></li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;typeAliases&gt;  &lt;package name&#x3D;&quot;domain.blog&quot;&#x2F;&gt;&lt;&#x2F;typeAliases&gt;</code></pre><ol start="3"><li>注解配置，需要结合包名配置：<ol><li>每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。</li><li>若有注解，则别名为其注解值。</li></ol></li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">@Alias(&quot;author&quot;)public class Author &#123;    ...&#125;</code></pre><h2 id="设置settings"><a class="markdownIt-Anchor" href="#设置settings"></a> 设置（settings）</h2><ul><li>常用设置：<ul><li>cacheEnabled：全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。</li><li>lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。</li><li>logImpl：指定 MyBatis 所用日志的具体实现，未指定时将自动查找。</li></ul></li><li>示例：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;settings&gt;  &lt;setting name&#x3D;&quot;cacheEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;  &lt;setting name&#x3D;&quot;lazyLoadingEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;  &lt;setting name&#x3D;&quot;multipleResultSetsEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;  &lt;setting name&#x3D;&quot;useColumnLabel&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;  &lt;setting name&#x3D;&quot;useGeneratedKeys&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;  &lt;setting name&#x3D;&quot;autoMappingBehavior&quot; value&#x3D;&quot;PARTIAL&quot;&#x2F;&gt;  &lt;setting name&#x3D;&quot;autoMappingUnknownColumnBehavior&quot; value&#x3D;&quot;WARNING&quot;&#x2F;&gt;  &lt;setting name&#x3D;&quot;defaultExecutorType&quot; value&#x3D;&quot;SIMPLE&quot;&#x2F;&gt;  &lt;setting name&#x3D;&quot;defaultStatementTimeout&quot; value&#x3D;&quot;25&quot;&#x2F;&gt;  &lt;setting name&#x3D;&quot;defaultFetchSize&quot; value&#x3D;&quot;100&quot;&#x2F;&gt;  &lt;setting name&#x3D;&quot;safeRowBoundsEnabled&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;  &lt;setting name&#x3D;&quot;mapUnderscoreToCamelCase&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;  &lt;setting name&#x3D;&quot;localCacheScope&quot; value&#x3D;&quot;SESSION&quot;&#x2F;&gt;  &lt;setting name&#x3D;&quot;jdbcTypeForNull&quot; value&#x3D;&quot;OTHER&quot;&#x2F;&gt;  &lt;setting name&#x3D;&quot;lazyLoadTriggerMethods&quot; value&#x3D;&quot;equals,clone,hashCode,toString&quot;&#x2F;&gt;&lt;&#x2F;settings&gt;</code></pre><h2 id="插件plugins"><a class="markdownIt-Anchor" href="#插件plugins"></a> 插件（plugins）</h2><ul><li>可以使用一些mybaits插件来简化代码的书写。</li><li>mybatis常用插件：<ol><li>mybatis-generator-core</li><li>mybatis-plus</li><li>通用mapper</li></ol></li></ul><h2 id="映射器mappers"><a class="markdownIt-Anchor" href="#映射器mappers"></a> 映射器（mappers）</h2><ul><li>mapper.xml文件在使用之前必须注册，注册有三种方式。</li></ul><ol><li>方式一：通过xml文件的完全限定名来注册（推荐使用）</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt;  &lt;mapper resource&#x3D;&quot;org&#x2F;mybatis&#x2F;builder&#x2F;AuthorMapper.xml&quot;&#x2F;&gt;  &lt;mapper resource&#x3D;&quot;org&#x2F;mybatis&#x2F;builder&#x2F;BlogMapper.xml&quot;&#x2F;&gt;  &lt;mapper resource&#x3D;&quot;org&#x2F;mybatis&#x2F;builder&#x2F;PostMapper.xml&quot;&#x2F;&gt;&lt;&#x2F;mappers&gt;</code></pre><ol start="2"><li>方式二：使用接口名来注册</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;mappers&gt;  &lt;mapper class&#x3D;&quot;org.mybatis.builder.AuthorMapper&quot;&#x2F;&gt;  &lt;mapper class&#x3D;&quot;org.mybatis.builder.BlogMapper&quot;&#x2F;&gt;  &lt;mapper class&#x3D;&quot;org.mybatis.builder.PostMapper&quot;&#x2F;&gt;&lt;&#x2F;mappers&gt;</code></pre><ul><li><strong>接口和mapper.xml文件必须同名</strong></li><li><strong>接口和mapper配置文件必须再同一个包下</strong>。</li></ul><ol start="3"><li>方式三:使用包名来注册</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;mappers&gt;  &lt;package name&#x3D;&quot;org.mybatis.builder&quot;&#x2F;&gt;&lt;&#x2F;mappers&gt;</code></pre><ul><li><strong>接口和mapper.xml文件必须同名</strong></li><li><strong>接口和mapper配置文件必须再同一个包下</strong>。</li></ul><h1 id="mybatis注解开发"><a class="markdownIt-Anchor" href="#mybatis注解开发"></a> Mybatis注解开发</h1><ul><li>不使用mapper.xml文件来实现Mapper接口，而使用注解的方式来实现接口。</li><li>示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package org.mybatis.example;public interface BlogMapper &#123;  @Select(&quot;SELECT * FROM blog WHERE id &#x3D; #&#123;id&#125;&quot;)  Blog selectBlog(int id);&#125;</code></pre><ul><li>同时还需要在mybatis-config.xml文件中绑定接口：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;mappers&gt;  &lt;mapper class&#x3D;&quot;org.mybatis.example.BlogMapper&quot;&#x2F;&gt;&lt;&#x2F;mappers&gt;</code></pre><h2 id="注解实现crud"><a class="markdownIt-Anchor" href="#注解实现crud"></a> 注解实现CRUD</h2><ol><li>在编写工具类的时候实现自动提交事务：</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static SqlSession getSqlSession()&#123;  &#x2F;&#x2F;只需要传递一个boolean参数即可    return sqlSessionFactory.openSession(true);&#125;</code></pre><ol start="2"><li>编写接口增加注解：<ol><li>增：<code>@insert()</code></li><li>删：<code>@delete()</code></li><li>改：<code>@update()</code></li><li>查：<code>@select()</code></li></ol></li><li><code>@param()</code>参数设置：<ol><li>基本类型的参数或者String类型的参数，需要加上；</li><li>引用类型的参数不用加；</li><li>如果只有一个基本类型的话，可以忽略，但是建议加上；</li><li>在sql中引用<code>@param()</code>设置的属性名</li><li>如果<code>@param()</code>括号中没有内容，则属性名和参数名默认相同。</li><li>示例：</li></ol></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@delete(delete from youth_study.t_college where id &#x3D; #&#123;id&#125; and name &#x3D; #&#123;name&#125;)int delete(@param(&quot;id&quot;) int id, @param(&quot;name&quot;) String name);</code></pre><h1 id="mybatis日志"><a class="markdownIt-Anchor" href="#mybatis日志"></a> Mybatis日志</h1><ul><li>操作出现了异常的时候，日志是很好的排错工具；</li><li>settings中的logImpl可以设置日志的实现方式，共有以下几种：<ol><li>SLF4J</li><li>LOG4J</li><li>LOG4J2</li><li>JDK_LOGGING</li><li>COMMONS_LOGGING</li><li>STDOUT_LOGGING：标准日志输出，一旦在settins中启用，便无需其他的配置</li><li>NO_LOGGING</li></ol></li><li>配置STDOUT_LOGGING:</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;settings&gt;  &lt;setting name &#x3D; &quot;logImpl&quot; value &#x3D; &quot;STDOUT_LOGGING&quot;&#x2F;&gt;&lt;&#x2F;settings&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-栈</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/Leetcode-%E6%A0%88/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/Leetcode-%E6%A0%88/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码地址"><a class="markdownIt-Anchor" href="#代码地址"></a> 代码地址</h1><p><a href="https://github.com/zestaken/newblog/tree/master/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/Code/src/main/java/stack">github</a></p><h1 id="1-删除最外层的括号-1021"><a class="markdownIt-Anchor" href="#1-删除最外层的括号-1021"></a> 1. 删除最外层的括号 1021</h1><ul><li>题目：</li></ul><hr /><p>有效括号字符串为空 (“”)、“(” + A + “)” 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，“”，“()”，“(())()” 和 “(()(()))” 都是有效的括号字符串。</p><p>如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。</p><p>给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。</p><p>对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。</p><p></p><p>示例 1：</p><p>输入：“(()())(())”<br />输出：“()()()”<br />解释：<br />输入字符串为 “(()())(())”，原语化分解得到 “(()())” + “(())”，<br />删除每个部分中的最外层括号后得到 “()()” + “()” = “()()()”。<br />示例 2：</p><p>输入：“(()())(())(()(()))”<br />输出：“()()()()(())”<br />解释：<br />输入字符串为 “(()())(())(()(()))”，原语化分解得到 “(()())” + “(())” + “(()(()))”，<br />删除每个部分中的最外层括号后得到 “()()” + “()” + “()(())” = “()()()()(())”。<br />示例 3：</p><p>输入：“()()”<br />输出：“”<br />解释：<br />输入字符串为 “()()”，原语化分解得到 “()” + “()”，<br />删除每个部分中的最外层括号后得到 “” + “” = “”。</p><h2 id="java解法"><a class="markdownIt-Anchor" href="#java解法"></a> java解法</h2><ul><li>法一：<ul><li>使用一个栈来压入左括号，并将最外层括号设置为<code>*</code>来表示，再设置一个StringBuilder来录入除最外层括号的括号。</li><li>每一次栈遇到右括号就弹出，以此来逐个匹配括号，从而判断谁为最外层的括号。</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Stack;public class Solution &#123;    public String removeOuterParentheses(String S) &#123;        Stack&lt;Character&gt; stack &#x3D; new Stack&lt;&gt;();        StringBuilder stringBuilder &#x3D; new StringBuilder();        &#x2F;&#x2F;遍历字符串        for(char i : S.toCharArray()) &#123;            &#x2F;&#x2F;如果栈不为空，则证明不是最外层的左括号，存入stringBulider            if(i &#x3D;&#x3D; &#39;(&#39; &amp;&amp; !stack.isEmpty()) &#123;                   stringBuilder.append(i);                    stack.push(i);            &#125;else if(i &#x3D;&#x3D; &#39;(&#39; &amp;&amp; stack.isEmpty()) &#123;                stack.push(&#39;*&#39;);            &#125; else &#123; &#x2F;&#x2F;如果为右括号，则栈中内容弹出，并根据边界记号来判断是否到边界，如果不是，则将右括号也存入stringBuilder                char temp1 &#x3D; stack.pop();                if(temp1 !&#x3D; &#39;*&#39;) &#123;                    stringBuilder.append(i);                &#125;            &#125;        &#125;        return String.valueOf(stringBuilder);    &#125;    public static void main(String[] args) &#123;        String s &#x3D; &quot;(()())(()(()))&quot;;        Solution solution &#x3D; new Solution();        System.out.println(solution.removeOuterParentheses(s));    &#125;&#125;</code></pre><ul><li>法二：<ul><li>设置一个数字来记录括号的层数，最外层的括号的层数为1，当层数不为1时将括号存入stringBuilder对象中。</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public String removeOuterParentheses(String S) &#123;    StringBuilder stringBuilder &#x3D; new StringBuilder();    int level &#x3D; 0;    for(char i : S.toCharArray()) &#123;        &#x2F;&#x2F;层数按照左括号来记录        if(i &#x3D;&#x3D; &#39;(&#39;) &#123;            level++;        &#125;        &#x2F;&#x2F;层数大于1时存入，需要放在level减1之前，否则右括号存不进去        if(level &gt; 1) &#123;            stringBuilder.append(i);        &#125;        &#x2F;&#x2F;当出现右括号时，将当前的层数减一，类似于用栈记录的出栈效果        if(i &#x3D;&#x3D; &#39;)&#39;)&#123;            level--;        &#125;    &#125;    return String.valueOf(stringBuilder);&#125;</code></pre><h1 id="2-剑指-offer-09-用两个栈实现队列"><a class="markdownIt-Anchor" href="#2-剑指-offer-09-用两个栈实现队列"></a> 2. 剑指 Offer 09. 用两个栈实现队列</h1><ul><li>题目：</li></ul><hr /><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><p></p><p>示例 1：</p><p>输入：<br />[“CQueue”,“appendTail”,“deleteHead”,“deleteHead”]<br />[[],[3],[],[]]<br />输出：[null,null,3,-1]<br />示例 2：</p><p>输入：<br />[“CQueue”,“deleteHead”,“appendTail”,“appendTail”,“deleteHead”,“deleteHead”]<br />[[],[],[5],[2],[],[]]<br />输出：[null,-1,null,null,5,2]<br />提示：</p><p>1 &lt;= values &lt;= 10000<br />最多会对 appendTail、deleteHead 进行 10000 次调用</p><ul><li>题目解释：</li></ul><hr /><p>输入：</p><p><code>[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;] </code><br />这一行表示每一行代码的操作,其CQueue方法是构造器方法，即是创建队列的操作。</p><p><code>[[],[3],[],[]]</code><br />这个表示每一行代码操作所需要的参数</p><h2 id="java解法-2"><a class="markdownIt-Anchor" href="#java解法-2"></a> java解法</h2><ol><li>法一：<ol><li>设置两个栈，每次添加数据时就向第一个栈中添加数据，每次输出数据时就先将第一个栈中的数据弹出并压入第二个栈中，再依次弹出第二个栈中的数据。</li></ol></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">package stack;import java.util.Stack;public class CQueue &#123;    Stack&lt;Integer&gt; stack1;    Stack&lt;Integer&gt; stack2;    public CQueue()&#123;        stack1 &#x3D; new Stack&lt;&gt;();        stack2 &#x3D; new Stack&lt;&gt;();    &#125;    public void appendTail(int value) &#123;        stack1.push(value);    &#125;    public int deleteHead()&#123;        int temp;        while(!stack1.isEmpty()) &#123;            temp &#x3D; stack1.pop();            stack2.push(temp);        &#125;        if(stack2.isEmpty()) &#123;            return -1;        &#125;        int value &#x3D; stack2.pop();        while(!stack2.isEmpty()) &#123;            temp &#x3D; stack2.pop();            stack1.push(temp);        &#125;        return value;    &#125;    public static void main(String[] args) &#123;        CQueue cQueue &#x3D; new CQueue();        cQueue.appendTail(1);        cQueue.appendTail(2);        cQueue.appendTail(3);        cQueue.deleteHead();        Stack&lt;Integer&gt; stack &#x3D; cQueue.stack1;        while(!stack.isEmpty()) &#123;            System.out.println(stack.pop());        &#125;    &#125;&#125;</code></pre><h1 id="3-1047-删除字符串中的所有相邻重复项"><a class="markdownIt-Anchor" href="#3-1047-删除字符串中的所有相邻重复项"></a> 3. 1047. 删除字符串中的所有相邻重复项</h1><ul><li>题目：</li></ul><hr /><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p>示例：</p><pre class="line-numbers language-none"><code class="language-none">输入：&quot;abbaca&quot;输出：&quot;ca&quot;解释：例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。</code></pre><p>提示：<br />1 &lt;= S.length &lt;= 20000<br />S 仅由小写英文字母组成。</p><h2 id="java解法-3"><a class="markdownIt-Anchor" href="#java解法-3"></a> java解法</h2><ul><li>法一：<ul><li>设置一个栈，依次将字符串中字符压栈，栈顶内容始终是当前字符的相邻的前一个字符。</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public String removeDuplicates(String S) &#123;        Stack&lt;Character&gt; stack &#x3D; new Stack&lt;&gt;();        &#x2F;&#x2F;遍历字符串，将字符串删除重复后存入栈中        for(char i : S.toCharArray()) &#123;            if(stack.isEmpty()) &#123;                stack.push(i);                continue;            &#125;            char temp &#x3D; stack.pop();            &#x2F;&#x2F;如果栈顶的内容与刚读取的字符相同，则弹出栈顶内容，并进行下一次循环；如果相同，则将新字符压入栈            if(temp &#x3D;&#x3D; i) &#123;                continue;            &#125; else &#123;                stack.push(temp);                stack.push(i);            &#125;        &#125;        StringBuilder s1 &#x3D; new StringBuilder();        &#x2F;&#x2F;将栈中内容从头插入新字符串        while(!stack.isEmpty()) &#123;            char temp  &#x3D; stack.pop();            s1.insert(0,temp);        &#125;        return s1.toString();    &#125;    public static void main(String[] args) &#123;        String s &#x3D; &quot;abbaca&quot;;        Solution solution &#x3D; new Solution();        String s1 &#x3D; solution.removeDuplicates(s);        System.out.println(s1);    &#125;&#125;</code></pre><ul><li>法二：<ul><li>设置一个存储所有可能的重复情况的集合，然后将字符串与集合中所有内容比较，如果有相同的则替换为空字符串。</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public String removeDuplicates(String S) &#123;    HashSet&lt;String&gt; duplicates &#x3D; new HashSet&lt;&gt;();    StringBuilder sb &#x3D; new StringBuilder();    &#x2F;&#x2F;将重复字符串&quot;aa&quot;到&quot;zz&quot;存入集合中，使用哈希集合的原因是这种集合内部不允许内容重复    for(char i &#x3D; &#39;a&#39;; i &lt;&#x3D; &#39;z&#39;; i++) &#123;        sb.setLength(0);        sb.append(i);        sb.append(i);        duplicates.add(sb.toString());    &#125;    &#x2F;&#x2F;遍历集合，与字符串内容比较，如果字符串中有相同内容则替换为空字符串    &#x2F;&#x2F;设置一个记录字符串长度的变量，如果两次while循环之后的长度没变，说明字符串中的重复字符串已经被替换完了    int preLength &#x3D; -1;    while(preLength !&#x3D; S.length()) &#123;        preLength &#x3D; S.length();        for(String d : duplicates) &#123;            S &#x3D; S.replace(d,&quot;&quot;);        &#125;    &#125;    return S;&#125;</code></pre><h1 id="4-682-棒球比赛"><a class="markdownIt-Anchor" href="#4-682-棒球比赛"></a> 4. 682. 棒球比赛</h1><ul><li>题目：</li></ul><hr /><p>你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。</p><p>比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则：</p><p>整数 x - 表示本回合新获得分数 x<br />“+” - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。<br />“D” - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。<br />“C” - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。<br />请你返回记录中所有得分的总和。</p><p></p><p>示例 1：</p><p>输入：ops = [“5”,“2”,“C”,“D”,“+”]<br />输出：30<br />解释：<br />“5” - 记录加 5 ，记录现在是 [5]<br />“2” - 记录加 2 ，记录现在是 [5, 2]<br />“C” - 使前一次得分的记录无效并将其移除，记录现在是 [5].<br />“D” - 记录加 2 * 5 = 10 ，记录现在是 [5, 10].<br />“+” - 记录加 5 + 10 = 15 ，记录现在是 [5, 10, 15].<br />所有得分的总和 5 + 10 + 15 = 30<br />示例 2：</p><p>输入：ops = [“5”,“-2”,“4”,“C”,“D”,“9”,“+”,“+”]<br />输出：27<br />解释：<br />“5” - 记录加 5 ，记录现在是 [5]<br />“-2” - 记录加 -2 ，记录现在是 [5, -2]<br />“4” - 记录加 4 ，记录现在是 [5, -2, 4]<br />“C” - 使前一次得分的记录无效并将其移除，记录现在是 [5, -2]<br />“D” - 记录加 2 * -2 = -4 ，记录现在是 [5, -2, -4]<br />“9” - 记录加 9 ，记录现在是 [5, -2, -4, 9]<br />“+” - 记录加 -4 + 9 = 5 ，记录现在是 [5, -2, -4, 9, 5]<br />“+” - 记录加 9 + 5 = 14 ，记录现在是 [5, -2, -4, 9, 5, 14]<br />所有得分的总和 5 + -2 + -4 + 9 + 5 + 14 = 27<br />示例 3：</p><p>输入：ops = [“1”]<br />输出：1</p><p>提示：</p><p>1 &lt;= ops.length &lt;= 1000<br />ops[i] 为 “C”、“D”、“+”，或者一个表示整数的字符串。整数范围是 [-3 * 104, 3 * 104]<br />对于 “+” 操作，题目数据保证记录此操作时前面总是存在两个有效的分数<br />对于 “C” 和 “D” 操作，题目数据保证记录此操作时前面总是存在一个有效的分数</p><h2 id="java解法-4"><a class="markdownIt-Anchor" href="#java解法-4"></a> java解法</h2><ul><li>法一：<ul><li>依次读出字符串数组中的字符串，如果是特殊字符，则执行该字符对应的操作，如果是数字则转换为整型压入栈中,最后遍历栈计算和。</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public int calPoints(String[] ops) &#123;        Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;();        for(String op : ops) &#123;            if(op.equals(&quot;C&quot;)) &#123;                stack.pop();            &#125;else if(op.equals(&quot;D&quot;)) &#123;                stack.push(stack.peek() * 2);            &#125;else if(op.equals(&quot;+&quot;)) &#123;                int top &#x3D; stack.pop();                int newTop &#x3D; top + stack.peek();                stack.push(top);                stack.push(newTop);            &#125;else &#123;                stack.push(Integer.parseInt(op));            &#125;        &#125;        int sum &#x3D; 0;        for(int point : stack) &#123;            sum +&#x3D; point;        &#125;        return sum;    &#125;    public static void main(String[] args) &#123;        String[] ops &#x3D; &#123;&quot;5&quot;,&quot;-2&quot;,&quot;4&quot;,&quot;C&quot;,&quot;D&quot;,&quot;9&quot;,&quot;+&quot;,&quot;+&quot;&#125;;        Solution solution &#x3D; new Solution();        int points &#x3D; solution.calPoints(ops);        System.out.println(points);    &#125;&#125;</code></pre><h1 id="5-用栈实现队列-232"><a class="markdownIt-Anchor" href="#5-用栈实现队列-232"></a> 5. 用栈实现队列 232</h1><ul><li><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">题目</a></li></ul><hr /><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p><p>实现 MyQueue 类：</p><p>void push(int x) 将元素 x 推到队列的末尾<br />int pop() 从队列的开头移除并返回元素<br />int peek() 返回队列开头的元素<br />boolean empty() 如果队列为空，返回 true ；否则，返回 false</p><p>说明：</p><p>你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。<br />你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</p><p>进阶：</p><p>你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。</p><pre class="line-numbers language-none"><code class="language-none">示例：输入：[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;][[], [1], [2], [], [], []]输出：[null, null, null, 1, 1, false]解释：MyQueue myQueue &#x3D; new MyQueue();myQueue.push(1); &#x2F;&#x2F; queue is: [1]myQueue.push(2); &#x2F;&#x2F; queue is: [1, 2] (leftmost is front of the queue)myQueue.peek(); &#x2F;&#x2F; return 1myQueue.pop(); &#x2F;&#x2F; return 1, queue is [2]myQueue.empty(); &#x2F;&#x2F; return false</code></pre><p>提示：</p><p>1 &lt;= x &lt;= 9<br />最多调用 100 次 push、pop、peek 和 empty<br />假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）</p><h2 id="java解法-5"><a class="markdownIt-Anchor" href="#java解法-5"></a> Java解法</h2><ul><li>法一：用两个栈来实现队列，一个栈负责接收输入，一个栈负责pop和peek。通过在两个栈之间的倒腾，来颠倒元素的顺序，负负得正，变为先入先出<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210720215034.png" alt="" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MyQueue &#123;    Stack&lt;Integer&gt; in;    Stack&lt;Integer&gt; out;    public MyQueue()&#123;        in &#x3D; new Stack&lt;&gt;();        out &#x3D; new Stack&lt;&gt;();    &#125;    public void push(int x) &#123;        in.push(x);    &#125;    public int pop() &#123;        while(!in.isEmpty()) &#123;            int temp &#x3D; in.pop();            out.push(temp);        &#125;        int res &#x3D;  out.pop();        while(!out.isEmpty()) &#123;            int temp &#x3D; out.pop();            in.push(temp);        &#125;        return res;    &#125;    public int peek() &#123;        while(!in.isEmpty()) &#123;            int temp &#x3D; in.pop();            out.push(temp);        &#125;        int res &#x3D; out.peek();        while(!out.isEmpty()) &#123;            int temp &#x3D; out.pop();            in.push(temp);        &#125;        return res;    &#125;    public boolean empty() &#123;        return in.isEmpty();    &#125;&#125;</code></pre><h1 id="6-最小栈-155"><a class="markdownIt-Anchor" href="#6-最小栈-155"></a> 6. 最小栈 155</h1><ul><li><a href="https://leetcode-cn.com/problems/min-stack/">题目</a></li></ul><hr /><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><p>push(x) —— 将元素 x 推入栈中。<br />pop() —— 删除栈顶的元素。<br />top() —— 获取栈顶元素。<br />getMin() —— 检索栈中的最小元素。</p><pre class="line-numbers language-none"><code class="language-none">示例:输入：[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;][[],[-2],[0],[-3],[],[],[],[]]输出：[null,null,null,null,-3,null,0,-2]解释：MinStack minStack &#x3D; new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   --&gt; 返回 -3.minStack.pop();minStack.top();      --&gt; 返回 0.minStack.getMin();   --&gt; 返回 -2.</code></pre><p>提示：</p><p>pop、top 和 getMin 操作总是在 非空栈 上调用。</p><h2 id="java解法-6"><a class="markdownIt-Anchor" href="#java解法-6"></a> Java解法</h2><ul><li>法一：使用一个辅助栈，将当前最小的元素压入栈顶，每次pop的时候检查元素是否与辅助栈的栈顶元素相同，如果相同则将辅助栈栈顶元素也弹出。因为栈先进后出的特性，所以当当前最小元素弹出后顶替上来的元素值在栈中一定还存在。<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/d58FXH.png" alt="d58FXH" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MinStack155 &#123;    Stack&lt;Integer&gt; value;    Stack&lt;Integer&gt; min;    public MinStack155() &#123;        value &#x3D; new Stack&lt;&gt;();        min &#x3D; new Stack&lt;&gt;();    &#125;    public void push(int val) &#123;        &#x2F;&#x2F;若当前值比栈中存的最小值小，则存入最小值栈中        if(min.isEmpty()) &#123;            min.push(val);        &#125;else if(val &lt;&#x3D; min.peek()) &#123; &#x2F;&#x2F;注意与最小值相等也要再压一次，弹出的时候才能持平            min.push(val);        &#125;        value.push(val);    &#125;    public int pop() &#123;        if(value.peek().equals(min.peek())) &#123;            min.pop();        &#125;        return value.pop();    &#125;    public int top() &#123;        return value.peek();    &#125;    public int getMin() &#123;        return min.peek();    &#125;&#125;</code></pre><h1 id="7-有效的括号-20"><a class="markdownIt-Anchor" href="#7-有效的括号-20"></a> 7. 有效的括号 20</h1><ul><li><a href="https://leetcode-cn.com/problems/valid-parentheses/">题目</a></li></ul><hr /><p>给定一个只包括 ‘(’，‘)’，‘{’，‘}’，‘[’，‘]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br />左括号必须以正确的顺序闭合。</p><pre class="line-numbers language-none"><code class="language-none">示例 1：输入：s &#x3D; &quot;()&quot;输出：true示例 2：输入：s &#x3D; &quot;()[]&#123;&#125;&quot;输出：true示例 3：输入：s &#x3D; &quot;(]&quot;输出：false示例 4：输入：s &#x3D; &quot;([)]&quot;输出：false示例 5：输入：s &#x3D; &quot;&#123;[]&#125;&quot;输出：true</code></pre><p>提示：</p><p>1 &lt;= s.length &lt;= 104<br />s 仅由括号 ‘()[]{}’ 组成</p><h2 id="java解法-7"><a class="markdownIt-Anchor" href="#java解法-7"></a> Java解法</h2><ul><li>法一：利用栈的先进先出特性，左括号进栈，遇右括号则出栈匹配<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/XBDlRE.png" alt="XBDlRE" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ValidParentheses20 &#123;    public boolean isValid(String s) &#123;        Stack&lt;Character&gt; stack &#x3D; new Stack&lt;&gt;();        int len &#x3D; s.length();        if(len % 2 !&#x3D; 0) &#123; &#x2F;&#x2F;括号数为奇数肯定不对            return false;        &#125;        &#x2F;&#x2F;遍历括号，左括号进栈，右括号出栈比对        int i;        for(i &#x3D; 0; i &lt; len; i++) &#123;            char temp &#x3D; s.charAt(i);            if(temp &#x3D;&#x3D; &#39;(&#39; || temp &#x3D;&#x3D; &#39;[&#39; || temp &#x3D;&#x3D; &#39;&#123;&#39;) &#123;                stack.push(temp);            &#125; else &#123;                char temp2;                if(!stack.isEmpty()) &#123;                    temp2 &#x3D; stack.pop();                &#125; else &#123;                    return false;                &#125;                if(temp2 &#x3D;&#x3D; &#39;(&#39; &amp;&amp; temp &#x3D;&#x3D; &#39;)&#39;) &#123;                    continue;                &#125; else if(temp2 &#x3D;&#x3D; &#39;[&#39; &amp;&amp; temp &#x3D;&#x3D; &#39;]&#39;) &#123;                    continue;                &#125; else if(temp2 &#x3D;&#x3D; &#39;&#123;&#39; &amp;&amp; temp &#x3D;&#x3D; &#39;&#125;&#39;) &#123;                    continue;                &#125; else &#123;                    return false;                &#125;            &#125;        &#125;        &#x2F;&#x2F;最终字符串遍历完并且栈空则说明配对成功        if(stack.isEmpty() || i &#x3D;&#x3D; len - 1) &#123;            return true;        &#125; else &#123;            return false;        &#125;    &#125;&#125;</code></pre><h1 id="8-每日温度-739"><a class="markdownIt-Anchor" href="#8-每日温度-739"></a> 8. 每日温度 739</h1><ul><li><a href="https://leetcode-cn.com/problems/daily-temperatures/">题目</a></li></ul><hr /><p>请根据每日 气温 列表 temperatures ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><pre class="line-numbers language-none"><code class="language-none">示例 1:输入: temperatures &#x3D; [73,74,75,71,69,72,76,73]输出: [1,1,4,2,1,1,0,0]示例 2:输入: temperatures &#x3D; [30,40,50,60   ]输出: [1,1,1,0]示例 3:输入: temperatures &#x3D; [30,60,90]输出: [1,1,0] 提示：1 &lt;&#x3D; temperatures.length &lt;&#x3D; 10530 &lt;&#x3D; temperatures[i] &lt;&#x3D; 100</code></pre><h2 id="java解法-8"><a class="markdownIt-Anchor" href="#java解法-8"></a> Java解法</h2><ul><li>法一：单调栈的思路：用栈存储温度对应的下标，每遇到温度较高的则出栈存储，温度小的则入栈，保证栈中对应温度呈递减排列<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/l6kYqI.png" alt="l6kYqI" /></li><li>与<a href="https://leetcode-cn.com/problems/max-chunks-to-make-sorted/">最多能完成排序的块</a>类似，因为都是根据值的大小来划分位置，所以存值不重要，存位置下标才重要。此外，都利用了在关键结果出现前左右两边的值都是单纯的比关键结果小或者大的单调性。</li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DailyTemperatures739 &#123;    public int[] dailyTemperatures(int[] temperatures) &#123;        int len &#x3D; temperatures.length;        &#x2F;&#x2F;存储下标的栈        Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;();        &#x2F;&#x2F;用来存储结果的数组        int[] days &#x3D; new int[len];        &#x2F;&#x2F;遍历整个温度数组        for(int i &#x3D; 0; i &lt; len; i++) &#123;            &#x2F;&#x2F;当栈为空，或者当前遍历到的温度不大于栈中下标对应的温度，则将对应下标压入栈中            if(stack.isEmpty() || temperatures[i] &lt;&#x3D; temperatures[stack.peek()]) &#123;                stack.push(i);                continue;            &#125;                        &#x2F;&#x2F;当栈不为空，或者当前温度高于栈顶下标对应的温度            while(!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;                &#x2F;&#x2F;当遇到比自己温度高的，出栈，将下标相减就是间隔天数                int index &#x3D; stack.pop();                days[index] &#x3D; i - index;            &#125;            stack.push(i);        &#125;                &#x2F;&#x2F;最后还留在栈中的就是没有找到之后比自己温度高的，直接赋为0        while(!stack.isEmpty()) &#123;            int index &#x3D; stack.pop();            days[index] &#x3D; 0;        &#125;        return days;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Redis/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Redis/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="redis概念"><a class="markdownIt-Anchor" href="#redis概念"></a> Redis概念</h1><ul><li>redis是一款高性能的NOSQL系列的非关系型数据库。<ul><li>Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</li><li>Redis支持的键值数据类型：<ol><li>String:字符串类型;</li><li>hash:哈希类型;</li><li>list：列表类型;</li><li>set：集合类型;</li><li>sortedset:有序集合类型。</li></ol></li><li>Redis的应用场景：<ol><li>数据缓存（数据查询，短链接，新闻内容，商品内容等）</li><li>聊天室的在线好友列表;</li><li>任务队列（秒杀，抢购，12306的高并发等）</li><li>应用排行榜;</li><li>数据过期处理;</li><li>分布式集群架构中的session分离</li></ol></li></ul></li><li>NOSQL:Not Only SQL ,泛指非关系型数据库。<ul><li>为了应对大规模数据的挑战。</li></ul></li><li>关系型数据库：<ul><li>数据之间有关联关系。</li><li>数据存储在硬盘的文件中。</li><li>数据以表的形式存储。</li></ul></li><li>非关系型数据库，<ul><li>数据之间没有关系;</li><li>数据存储在内存中;</li><li>存储格式有key:value形式，文档形式，图片形式等。</li></ul></li><li>主流NOSQL产品：<ul><li>键值（key:value)数据库：<ul><li>Tokyo Cabinet/Tyrant， Redis， Voldemort， Oracle BDB</li><li>应用场景：内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。</li><li>数据模型：Key 指向 Value 的键值对，通常用hashtable来实现</li></ul></li><li>列存储数据库：<ul><li>Cassandra， HBase， Riak</li><li>应用场景：分布式的文件系统</li><li>数据模型：以列簇式存储，将同一列数据存在一起</li></ul></li><li>文档型数据库：<ul><li>CouchDB， MongoDb</li><li>应用场景：Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容）</li><li>数据模型：Key-Value对应的键值对，Value为结构化数据</li></ul></li><li>图形(Graph)数据库：<ul><li>Neo4J， InfoGrid， Infinite Graph</li><li>应用场景：社交网络，推荐系统等。专注于构建关系图谱</li><li>数据模型：图结构。</li></ul></li></ul></li></ul><h1 id="redis的安装"><a class="markdownIt-Anchor" href="#redis的安装"></a> Redis的安装</h1><ul><li>下载：<a href="https://redis.io">官网</a>,<a href="https://www.redis.net.cn">中文网</a></li><li>为linux系统下载的<code>.tar.gz</code>文件，通过<code>tar -xzf</code>命令解压缩;</li><li>进入解压缩文件目录下，执行<code>make</code>编译该文件</li><li>二进制文件保存在src目录下：<ul><li><code>src/redis-cli</code>是客户端的启动文件;</li><li><code>src/redis-serve</code>是服务端的启动文件。</li></ul></li><li><code>redis.conf</code>是redis的配置文件。</li></ul><h1 id="redis的数据结构"><a class="markdownIt-Anchor" href="#redis的数据结构"></a> Redis的数据结构</h1><ul><li>redis存储的都是key:value格式的数据，其中<strong>key都是字符串类型</strong>,而value有五种数据结构。</li><li>value的五种数据结构：<ol><li>String:字符串类型, 如：zhangjie</li><li>hash:哈希类型,还是键值对，理解为套娃。如：name zhangjie</li><li>list：列表类型,理解为双向队列，如：zhangsan lisi wangwu zhangsan</li><li>set：集合类型,与list类似，只是<strong>不允许重复元素</strong></li><li>sortedset:有序集合类型,在set的基础上，对集合中的元素进行排序。</li></ol></li></ul><h1 id="redis的命令操作"><a class="markdownIt-Anchor" href="#redis的命令操作"></a> Redis的命令操作</h1><p><a href="https://www.redis.net.cn/tutorial/3501.html">官方文档</a></p><ul><li>字符串类型：<ul><li>存储：<code>set key value</code>,如：<code>set username zhangjie</code></li><li>获取：<code>get key</code>,如：<code>get username</code></li><li>删除：<code>del key</code>,如: <code>del username</code></li></ul></li><li>哈希类型：<ul><li>存储:<code>hset key field value</code>,如：<code>hset usernames username1 zhangjie</code></li><li>获取:<code>hget key field</code>,如：<code>hget usernames username1</code></li><li>获取所有的field和value：<code>hgetall key</code>,如：<code>hgetall usernames</code></li><li>删除：<code>hdel key field</code>,如：<code>hdel usernames username1</code></li></ul></li><li>列表类型：<ul><li>可以添加一个元素到列表的头部或者尾部</li><li>存储：<ul><li><code>lpush key value</code>:将元素加入列表左边,如：<code>lpush usernames zhangjie</code></li><li><code>rpush key value</code>:将元素加入列表右边</li></ul></li><li>获取：<ul><li><code>lrange key start end</code>:获取指定范围内的元素，如：<code>lrange usernames 0 -1</code>，代表获取列表中的所有元素。</li></ul></li><li>删除：<ul><li><code>lpop key</code>:代表删除列表最左边的元素，并将该元素返回，如:<code>lpop usernames</code></li><li><code>rpop key</code>:代表删除列表最右边的元素，并将该元素返回。</li></ul></li></ul></li><li>集合类型：不允许重复元素<ul><li>存储：<code>sadd key value</code>,如：<code>sadd key a</code>,还可以一次存入多个元素，如：<code>sadd key b c</code></li><li>获取：<code>smembers key</code>，获取set集合中的所有元素，但是<strong>不保证和存入的顺序一样</strong>。如：<code>smembers key</code></li><li>删除：<code>srem key value</code>,删除集合中的某个元素，如：<code>srem key a</code></li></ul></li><li>有序集合类型：不允许重复元素，且元素有顺序<ul><li>存储：<code>zadd key score value</code>,其中score是value对应的分数，用来作为排序的依据（score小的元素在前），如：<code>zadd key 80 zhangjie</code></li><li>获取：<ul><li><code>zrange key start end</code>,获取指定范围内的元素，如：<code>zrange key 0 -1</code>,获取集合中所有的元素。</li><li><code>zrange key start end withscores</code>，或获取指定范围内的元素以及对应的socre。</li></ul></li><li>删除：<code>zrem key value</code></li></ul></li><li>通用的命令：<ul><li><code>keys *</code>:获取所有的键（<code>*</code>的位置可以换为正则表达式，获取符合指定规则的键）</li><li><code>type key</code>:获取指定键对应的value的类型;</li><li><code>del key</code>:删除指定的key value（不止适用于String类型，也适用于所有类型，直接删除指定键）</li></ul></li></ul><h1 id="持久化"><a class="markdownIt-Anchor" href="#持久化"></a> 持久化</h1><ul><li>Redis的持久化：将Redis内存中的文件存储到硬盘文件中去。</li><li>Redis持久化的两种机制：<ul><li>RDB：默认方式，不需要配置，默认使用这种方式。<ul><li>在一定的间隔时间中，检测key的变化情况，然后持久化数据。</li><li>linux操作系统的关于RDB的配置在<code>redis.conf</code>文件中。</li></ul></li></ul></li></ul><pre class="line-numbers language-conf" data-language="conf"><code class="language-conf"># after 900 sec(15 min) if at least 1 key changedsave 900 1# after 300 sec(5 min) if at least 10 key changedsave 300 10# after 60 sec(1 min) if at least 10000 key changedsave 60 10000</code></pre><ul><li>AOF：日志记录的方式，可以记录每一条命令的操作。可以在每一条命令操作后，持久化数据<ul><li>编辑<code>redis.conf</code>文件</li></ul></li></ul><pre class="line-numbers language-conf" data-language="conf"><code class="language-conf"># no是指AOF方式关闭，yes是打开appendonly no# appendfsync always：每一次操作都进行持久化，如果需要启动则取消注释appendfsync everysec #每隔一秒进行一次持久化操作# appendfsync no：不进行持久化操作</code></pre><h1 id="java客户端-jedis"><a class="markdownIt-Anchor" href="#java客户端-jedis"></a> Java客户端-Jedis</h1><ul><li>Jedis:一款Java操作Redis数据库的工具</li><li>使用步骤：<ol><li>下载并导入相关jar包到工程中：<ol><li><a href="https://commons.apache.org/proper/commons-pool/download_pool.cgi">common-pool2</a></li><li><a href="https://mvnrepository.com/artifact/redis.clients/jedis?__cf_chl_captcha_tk__=d41db408314d60fb331623deabd9a15fe36abc20-1612082289-0-AVlmsRyd0pFMVLysGHAjfOhsUPRBHl6zROFnuHmysV6K7TigdSA1uvSeNmDDWTGalFggBbwRBai91Temzk2O6Jrst1jxpXIFZQib8pQTTtT6QmgsW0hE7HLfbz22RleXBOGwJrTEIHP5OipDQnpaYmvWNWosSJ8HkrWh5MPyB8ypP3Kp9zRONNgpzqY2jeTrRSixucDR7JbxJsCYeu7iRe0z2aC2TCcDS8nYy3XWJbjwVbAu8CedWeWxBWjra0azGe-L1K8uLq7W9SeT-pZbA6d8pbTcj4qsm7WKSZH94RvWgh_UfDzCD9RPOKGrq7taDoO9hM2jk12X7v1jqTkPoTCd8x0Me0tdHsGCSOGtKe_6Fub13BJBQS1xWXIeQT95yjdgRs_eXdUom5d7MIrErcKAuGTJkdGnzJG--LIjrhdKrlvioSKGg4UvToUYkV1Oc1SmjoicGh1vitlE8OT6p5m_Jbu2Bc9zybE7IfgRoBGuPZeZWS3oqJlEKJeM6D6TMWOM09WLhdgZkurzOzKDnwUN1CYnciZFlyoDrvzkHfkVdZl-Z0vhWM42cOWIANBLtpPKOnMFoWfH56jIJGGjrUF7VOee4isrl3_fFwg7zPsDcggPgIlwGrxV-VKXy_6oCQ">Jedis</a></li></ol></li><li>获取数据库连接：</li></ol></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">Jedis jedis &#x3D; new Jedis(&quot;localhost&quot;,6379);&#x2F;&#x2F;localhost是主机ip地址，因为是本机，所以直接用localhost&#x2F;&#x2F;6379是Redis的端口号，Redis服务器启动时会显示端口号，默认是6379&#x2F;&#x2F;如果空参则默认是localhost和6379参数</code></pre><ol start="3"><li>操作数据库,如：<code>jedis.set(&quot;username&quot;,&quot;zhanjie&quot;);</code>,与命令行操作基本类似</li><li>关闭连接：<code>jedis.close();</code></li></ol><h1 id="jedis连接池"><a class="markdownIt-Anchor" href="#jedis连接池"></a> Jedis连接池</h1><ol><li>创建Jedis连接池对象：<code>JedisPool jedisPool = new JedisPool();</code></li><li>获取Jedis对象：<code>Jedis jedis = jedisPool.getResource();</code></li><li>使用Jedis对象：，如：<code>jedis.set(&quot;username&quot;,&quot;zhangjie&quot;);</code></li><li>关闭对象，归还到连接池中：<code>jedis.close();</code></li></ol><ul><li>JedisPoolConfig对象，可以作为参数传给JedisPool构造器，配置连接池。如：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">JedisPoolConfig config &#x3D; new JedisPoolConfig();config.setMaxTotal(50);config.setMaxIdel(10);JedisPool jedisPool &#x3D; new JedisPool(config,&quot;localhost&quot;,6379);</code></pre><ul><li>可以类似JDBC写Jedis连接池的工具类，来简化代码的书写。</li><li>注：使用Jedis的连接池还需要额外导入两个包：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;slf4j-log4j12&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.7.9&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;slf4j-api&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.7.22&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/JSON/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/JSON/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="json概述"><a class="markdownIt-Anchor" href="#json概述"></a> JSON概述</h1><ul><li>JSON：JavaScript 对象表示法（JavaScript Object Notation）。</li><li>采用完全独立于编程语言的文本格式来存储和表示数据。</li><li>JSON是存储和交换文本信息的语法。类似XML。用于数据的传输。</li><li>JSON比XML更小、更快，更易解析。</li></ul><h1 id="json基本规则"><a class="markdownIt-Anchor" href="#json基本规则"></a> JSON基本规则</h1><ul><li>数据在（名称:值）对中：json数据是由==键值对==构成的。<ul><li><strong>键</strong>：用==引号（单双都行）引起来，也可以不使用引号==；</li><li>值的取值类型：<ol><li>数字（整数或者浮点数）,不用加引号</li><li>字符串（在双引号中）</li><li>逻辑值（true或者false）</li><li>数组（在方括号中），如：<code>&#123;&quot;person&quot;:[&#123;name : &quot;zhangsan&quot;&#125;,&#123;name:&quot;lisi&quot;&#125;]&#125;</code></li><li>对象（在花括号中），如：<code>&#123;&quot;address&quot;:&#123;&quot;province&quot;:&quot;陕西&quot;,&quot;四川&quot;&#125;&#125;</code></li><li>null</li></ol></li><li>数据由逗号分隔：多个键值对<strong>由逗号</strong>分隔；</li><li>花括号保存对象：使用{}定义json格式；</li><li>方括号保存数组:<code>[]</code></li><li>示例：</li></ul></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F;基本定义格式var person &#x3D; &#123;&quot;name&quot;:&quot;zhangjie&quot;,&quot;age&quot;:19, &quot;gender&quot; : true&#125;;&#x2F;&#x2F;对象中嵌套数组var persons &#x3D; &#123;    &quot;person&quot;:[        &#123;&quot;name&quot;:&quot;zhangjie&quot;,&quot;age&quot;:23,&quot;gender&quot;:true&#125;,        &#123;&quot;name&quot;:&quot;lisi&quot;, &quot;age&quot;:24,&quot;gender&quot;:true&#125;,        &#123;&quot;name&quot;:&quot;wangwu&quot;,&quot;age&quot;:25,&quot;gender&quot;:false&#125;    ]&#125;;&#x2F;&#x2F;数组中嵌套对象var ps &#x3D; [        &#123;&quot;name&quot;:&quot;zhangjie&quot;,&quot;age&quot;:23,&quot;gender&quot;:true&#125;,        &#123;&quot;name&quot;:&quot;lisi&quot;, &quot;age&quot;:24,&quot;gender&quot;:true&#125;,        &#123;&quot;name&quot;:&quot;wangwu&quot;,&quot;age&quot;:25,&quot;gender&quot;:false&#125;    ];</code></pre><h1 id="获取数据"><a class="markdownIt-Anchor" href="#获取数据"></a> 获取数据</h1><ol><li><code>json对象.键名；</code></li><li><code>json对象[&quot;键名&quot;]</code></li><li>遍历json对象：使用for…in循环</li></ol><ul><li>示例：</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">person.name ;person[&quot;name&quot;];for(var key in person) &#123;    &#x2F;&#x2F;获取到的key是一个字符串    alert(person[key]);&#x2F;&#x2F;key原本就是字符串，不用引号包裹&#125;</code></pre><h1 id="json数据与javascript对象的相互转化"><a class="markdownIt-Anchor" href="#json数据与javascript对象的相互转化"></a> JSON数据与JavaScript对象的相互转化</h1><ul><li>JavaScript转换为JSON数据（就是有特殊格式的字符串）：</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var user &#x3D; &#123;  name : &quot;zhangjie&quot;,  age: 20,  sex: &quot;男&quot;&#125;;var json &#x3D; JSON.stringify(user);</code></pre><ul><li>将JSON数据转换为JavaScript对象：</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var jsObj &#x3D; JSON.parse(json);</code></pre><h1 id="json数据与java对象的相互转换"><a class="markdownIt-Anchor" href="#json数据与java对象的相互转换"></a> JSON数据与java对象的相互转换</h1><ul><li>JSON的解析器：用于转换json的工具类<ul><li>常见解析器：Jsonlib,Gson,fastJson,jackson</li></ul></li></ul><h2 id="java对象转换json"><a class="markdownIt-Anchor" href="#java对象转换json"></a> Java对象转换JSON</h2><ul><li>此处使用Jackson</li><li>使用步骤：<ol><li>导入jackson的相关jar包；</li><li>创建jackson的核心类对象：ObjectMapper;</li><li>调用ObjectMapper的相关方法进行转换<ol><li><code>writeValue(参数1，obj)</code>:<ol><li>参数1:<ol><li><code>File</code>：将obj对象转换为<strong>JSON字符串</strong>,并保存到指定的<strong>文件</strong>中；</li><li><code>Writer</code>:将obj对象转换为JSON字符串，并将json数据填充到<strong>字符输出流</strong>中；</li><li><code>OutputStream</code>:将obj对象转换为JSON字符串，并将json数据填充到<strong>字节输出流</strong>中。</li></ol></li><li>writeValueAsString(obj):将对象转为JSON字符串</li></ol></li><li>示例：</li></ol></li></ol></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">ObjectMapper mapper &#x3D; new ObjectMapper();String json &#x3D; mapper.writeValueAsString(person);mapper.writeValue(new File(&quot;c:&#x2F;person.txt&quot;));</code></pre><ul><li>注解：<ul><li><code>@JsonIgnore</code>:排除指定属性，不参与转换。将注解放在对应属性定义位置即可。</li><li><code>@JsonFormat</code>:将属性值转换为格式化字符串。<ul><li>如；<code>@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)</code></li></ul></li></ul></li><li>List集合转换为JSON是数组格式的，在这个数组中存放JSON对象;</li><li>Map集合转换为JSON，是一个集合对应一个JSON对象，中间的内容是键值对。</li></ul><h2 id="json对象转为java对象"><a class="markdownIt-Anchor" href="#json对象转为java对象"></a> JSON对象转为Java对象</h2><ul><li>此处使用Jackson</li><li>使用步骤：<ol><li>导入jackson的相关jar包；</li><li>创建jackson的核心类对象：ObjectMapper;</li><li>调用ObjectMapper的相关方法进行转换<ol><li><code>readValue(json字符串对象,Class)</code>，如：<code>Person person = mapper.readValue(jsonString,Person.class)</code>.</li></ol></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AJAX</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%89%8D%E7%AB%AF/AJAX/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%89%8D%E7%AB%AF/AJAX/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="ajax概述"><a class="markdownIt-Anchor" href="#ajax概述"></a> AJAX概述</h1><ul><li>概念：ASynchronous JavaScript And XML,异步的JavaScript和XML</li><li>异步和同步：<ul><li>异步：客户端向服务器端发送请求后，<strong>无需等待服务器端的响应</strong>。在服务器处理请求的过程中，客户端可以进行其他操作。</li><li>同步：客户端向服务器端发送请求后，<strong>必须等待服务器端的响应</strong>。在等待的期间，客户端不能做其他操作。</li></ul></li><li>作用：<ul><li>Ajax是一种在无需加载整个网页的情况下，能够<strong>更新部分网页</strong>的技术。</li><li>通过在后台与服务器进行的少量数据交换，Ajax可以使网页实现异步更新，即可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用Ajax)如果需要更新内容，必须重载整个页面。</li></ul></li></ul><h1 id="ajax的实现方式"><a class="markdownIt-Anchor" href="#ajax的实现方式"></a> AJAX的实现方式</h1><ol><li>原生的JS实现方式</li><li>JQuery实现方式</li></ol><h2 id="原生的js实现方式"><a class="markdownIt-Anchor" href="#原生的js实现方式"></a> 原生的JS实现方式</h2><ol><li>定义一个用于异步请求的方法：<ol><li><code>&lt;input type=&quot;button&quot; value=&quot;发送异步请求&quot; onclick=&quot;fun();&quot;&gt;</code></li></ol></li><li>创建发送异步请求的对象：</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var xmlhttp;if (window.XMLHttpRequest)  &#123;&#x2F;&#x2F; code for IE7+, Firefox, Chrome, Opera, Safari  xmlhttp&#x3D;new XMLHttpRequest();  &#125;else  &#123;&#x2F;&#x2F; code for IE6, IE5  xmlhttp&#x3D;new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</code></pre><ol start="3"><li>建立连接：<ol><li><code>xmlhttp.open(&quot;GET&quot;,&quot;test1.txt&quot;,true)</code>，参数：<ol><li>请求方式：GET，POST<ol><li>GET方式：请求参数在URL后面拼接，send方法为空参,如：<code>xmlhttp.open(&quot;GET&quot;,&quot;ajaxServlet?username=zhangjie&quot;,true)</code></li><li>POST方式：请求参数在send方法中定义，如：<code>xmlhttp.send(&quot;username=zhangjie&quot;)</code></li></ol></li><li>请求的URL:文件在服务器上的位置</li><li>同步或者异步请求：true（异步）或者false（同步）</li></ol></li></ol></li><li>发送请求：<ol><li><code>xmlhttp.send(string)</code>:string参数仅用于POST请求。</li></ol></li><li>接受并处理来在服务器的响应结果：<ol><li>获取方式：<code>xmlhttp.responseText</code>或者<code>xmlhttp.responseXML</code><ol><li>responseText属性：获得字符串形式的响应数据。</li><li>responseXML属性：获得XML形式的响应数据。</li></ol></li><li>获取时间：当XMLHttpTRequest对象的就绪状态(readyState属性)改变时，触发事件onreadystatechange</li></ol><ul><li>onreadystatechange存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。</li><li>readyState:存有XMLHttpRequest 的状态。从 0 到 4 发生变化。<ul><li>0: 请求未初始化</li><li>1: 服务器连接已建立</li><li>2: 请求已接收</li><li>3: 请求处理中</li><li>4: 请求已完成，且响应已就绪</li></ul></li></ul><pre><code>* status:XMLHttpState对象的状态 * 200: &quot;OK&quot; * 404: 未找到页面</code></pre><ol start="3"><li>获取实现：</li></ol></li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">xmlhttp.onreadystatechange&#x3D;function()  &#123;      &#x2F;&#x2F;判断readyState的状态是否为4,判断status响应状态码是否为200  if (xmlhttp.readyState&#x3D;&#x3D;4 &amp;&amp; xmlhttp.status&#x3D;&#x3D;200)    &#123;        &#x2F;&#x2F;获取服务器的响应结果    document.getElementById(&quot;myDiv&quot;).innerHTML&#x3D;xmlhttp.responseText;    &#125;  &#125;</code></pre><h2 id="jquery实现方式"><a class="markdownIt-Anchor" href="#jquery实现方式"></a> JQuery实现方式</h2><ol><li><code>$.ajax()</code>:<ol><li>语法：<code>$.ajax(&#123;键值对&#125;);</code></li><li>示例：</li></ol></li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$.ajax(&#123;    url:&quot;ajaxServlet&quot;, &#x2F;&#x2F;请求路径    type:&quot;POST&quot;, &#x2F;&#x2F;请求方式    data:(&quot;username&quot;:&quot;jack&quot;,&quot;age&quot;:23),    success:function(data)&#123;        alert(data+&quot;成功啦&quot;);    &#125;, &#x2F;&#x2F;响应成功后的回调函数    error:function() &#123;        alert(&quot;出错啦&quot;);    &#125;, &#x2F;&#x2F;表示如果请求响应如果出现错误，会执行的回调函数    dataType:&quot;text&quot; &#x2F;&#x2F;设置接受到的响应数据格式&#125;)</code></pre><ol start="2"><li><code>$.get()</code>:发送get请求<ol><li>语法：<code>$.get(url,[data], [callbacke],[type])</code><ol><li>url:请求路径，必须有;</li><li>data:请求参数;</li><li>callback:回调函数;</li><li>type:响应结果类型。</li></ol></li></ol></li><li><code>$.post()</code>:发送post请求<ol><li>语法：同get类似。</li><li>示例：</li></ol></li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$.post(&quot;ajaxServlet&quot;,(username:&quot;zhangjie&quot;), function(data)&#123;    alert(data);&#125;,&quot;text&quot;);</code></pre><ul><li><code>serialize()</code>:通过序列化<strong>表单</strong>值，创建URL编码文本字符串。您可以选择一个或多个表单元素（比如input及/或文本框），或者 form 元素本身。序列化的值可在生成 AJAX 请求时用于 URL 查询字符串中(即作为data参数）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> AJAX </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JQuery</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%89%8D%E7%AB%AF/JQuery/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%89%8D%E7%AB%AF/JQuery/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="jquery概念"><a class="markdownIt-Anchor" href="#jquery概念"></a> JQuery概念</h1><p><a href="https://www.w3school.com.cn/jquery/index.asp">参考文档</a></p><ul><li>jQuery是一个快速、简洁的<strong>JavaScript框架</strong>，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化<strong>HTML文档操作、事件处理、动画设计和Ajax交互</strong>。</li><li>JavaScript框架：本质上就是一些<strong>js文件</strong>，这些文件中封装了js的原生代码。</li></ul><h1 id="快速入门"><a class="markdownIt-Anchor" href="#快速入门"></a> 快速入门</h1><ol><li>下载JQuery<ol><li>版本说明：<ol><li>1.x：兼容ie678,使用最为广泛的，官方只做BUG维护，功能不再新增。因此一般项目来说，使用1.x版本就可以了，最终版本：1.12.4 (2016年5月20日)</li><li>2.x：不兼容ie678，很少有人使用，官方只做BUG维护，功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，最终版本：2.2.4 (2016年5月20日)</li><li>3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求，一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。目前该版本是官方主要更新维护的版本。最新版本：3.3.1（2018年1月20日）</li></ol></li></ol></li><li>导入JQuery的js文件：导入.min.js文件。</li><li>使用</li></ol><h1 id="jquery对象和js对象的区别与转换"><a class="markdownIt-Anchor" href="#jquery对象和js对象的区别与转换"></a> JQuery对象和JS对象的区别与转换</h1><ul><li>JQuery获取元素对象：<code>var $divs = $(&quot;div&quot;);</code>;</li><li>JS获取元素对象：<code>var div2 = document.getElementsByTagName(&quot;div&quot;);</code></li><li>JQuery对象在操作时更加方便，但是<strong>JQuery对象和JS对象的方法是不通用的</strong>。</li><li>JQuery对象和JS对象的互相转换：<ul><li>JS–&gt;JQ：<code>$(JS对象)</code>,如：<code>$(divs).html(&quot;修改html内容&quot;)</code></li><li>JQ–&gt;JS：<code>jq对象[索引]</code>或者<code>jq对象.get(索引)</code>,如：<code>$divs[1].innerHTML(&quot;修改HTML内容&quot;)</code>或者<code>$divs.get(0).innerHTML(&quot;修改HTML内容&quot;)</code></li></ul></li></ul><h1 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h1><ul><li>事件绑定：<ul><li>示例：获取b1按钮,绑定单击事件。</li></ul></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(&quot;#b1&quot;).click(function()&#123;   alert(&quot;click&quot;);&#125;)</code></pre><ul><li>入口函数：dom文档加载完成后执行该函数中的代码<ul><li>js写法：</li></ul></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">windows.onload &#x3D; function()&#123;   alert(&quot;js&quot;);&#125;</code></pre><ul><li>jq写法：</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(function()&#123;   alert(&quot;jq&quot;);&#125;)</code></pre><ul><li>windows.onload与$(function(){})的区别：<ul><li>windows.onload <strong>只能定义一次</strong>,如果定义多次，后边的会将前面的覆盖掉。</li><li>$(function(){})<strong>可以定义多次</strong>。</li></ul></li><li>样式控制：css方法<ul><li>用css原本的样式名称：<code>$(&quot;#div1&quot;).css(&quot;background-color&quot;,&quot;red&quot;);</code></li><li>用dom的对象名称：<code>$(&quot;#div1&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);</code></li></ul></li></ul><h1 id="选择器"><a class="markdownIt-Anchor" href="#选择器"></a> 选择器</h1><h2 id="基本选择器"><a class="markdownIt-Anchor" href="#基本选择器"></a> 基本选择器</h2><ol><li>标签选择器：（元素选择器）<ol><li>语法：<code>$(&quot;html标签名&quot;)</code>,获得所有匹配标签名的元素;</li></ol></li><li>id选择器：<ol><li>语法：<code>$(&quot;#id的属性值&quot;)</code>,获得与指定id属性值匹配的元素;</li></ol></li><li>类选择器：<ol><li>语法：<code>$(&quot;.class的属性值&quot;)</code>,获得与指定的class属性值匹配的元素;</li></ol></li></ol><ul><li>并集选择器：<ul><li>语法：<code>$(&quot;选择器1,选择器2&quot;)</code>,获取多个选择器选中的所有元素。</li></ul></li></ul><h2 id="层级选择器"><a class="markdownIt-Anchor" href="#层级选择器"></a> 层级选择器</h2><ol><li>后代选择器：<ol><li>语法：<code>$(&quot;选择器1 选择器2)</code>,选择选择器1选择的元素中满足选择器2的所有元素。（多层嵌套的也选择）</li></ol></li><li>子选择器：<ol><li>语法：<code>$(&quot;选择器1 &gt; 选择器2)</code>,选择选择器1选择的元素中满足选择器2的所有子元素。（多层嵌套的不选择)</li></ol></li></ol><h2 id="属性选择器"><a class="markdownIt-Anchor" href="#属性选择器"></a> 属性选择器</h2><ol><li>属性名称选择器：<ol><li>语法：<code>$(&quot;标签名[属性名]&quot;)</code>,该标签下包含指定的属性的元素;</li></ol></li><li>属性选择器：<ol><li>语法:<code>$(&quot;标签名[属性名 = '值']&quot;)</code>,该标签下<strong>包含指定属性且该属性等于指定值</strong>的元素。</li><li>语法:<code>$(&quot;标签名[属性名 != '值']&quot;)</code>,该标签下<strong>不包含指定属性获知该属性不等于指定值</strong>的元素。</li><li>语法:<code>$(&quot;标签名[属性名 ^= '值']&quot;)</code>,该标签下<strong>包含指定属性且该属性值以指定值开始</strong>的元素。</li><li>语法:<code>$(&quot;标签名[属性名 $= '值']&quot;)</code>,该标签下<strong>包含指定属性且该属性值以指定值结尾</strong>的元素。</li><li>语法:<code>$(&quot;标签名[属性名 *= '值']&quot;)</code>,该标签下<strong>包含指定属性且该属性值中包含指定的值</strong>的元素。</li></ol></li><li>复合属性选择器：<ol><li>语法：<code>$(&quot;标签名[属性名 = '值'][][]...&quot;)</code>,该标签下，同时满足多个属性限定条件的元素。</li></ol></li></ol><h2 id="过滤选择器"><a class="markdownIt-Anchor" href="#过滤选择器"></a> 过滤选择器</h2><ol><li>首元素选择器：<ol><li>语法：<code>:first</code>,获得选择的元素中的第一个元素，如<code>$(div:first)</code>。</li></ol></li><li>尾元素选择器;<ol><li>语法：<code>:last</code>,获得选择的元素中的最后一个元素。</li></ol></li><li>非元素选择器：<ol><li>语法：<code>：not(selector)</code>,获得选择的与元素中，不包括指定内容的元素。如：<code>$(div:not(.one))</code>，选择div中class不为one的元素。</li></ol></li><li>偶数选择器：<ol><li>语法：<code>：even</code>,获得选择的元素中第偶数个的元素，从0开始计数。如;<code>$(div:even)</code>。</li></ol></li><li>奇数选择器：<ol><li>语法：<code>：odd</code>,获得选择的元素中第奇数个的元素，从0开始计数。</li></ol></li><li>等于索引选择器：<ol><li>语法：<code>:eq(index)</code>,获得选择的元素中第某位的元素。</li></ol></li><li>大于索引选择器：<ol><li>语法：<code>:gt(index)</code>,获得选择的元素中索引大于指定索引的元素。</li></ol></li><li>小于索引选择器：<ol><li>语法：<code>：lt(index)</code>,获得选择的元素中索引小于指定索引的元素。</li></ol></li><li>标题选择器：<ol><li>语法：<code>:header</code>,获得标题元素，没有参数，固定的写法。</li></ol></li></ol><h2 id="表单过滤选择器"><a class="markdownIt-Anchor" href="#表单过滤选择器"></a> 表单过滤选择器</h2><ol><li>可用元素选择器：<ol><li>语法：<code>：enabled</code>,获得可用元素;</li></ol></li><li>不可用元素选择器：<ol><li>语法：<code>：disabled</code>,获得不可用元素;如：<code>$(&quot;input[type = 'text']:disabled&quot;).val(&quot;diabled&quot;)</code>，获取改变表单中不可用<code>&lt;input&gt;</code>元素的值。</li></ol></li><li>选中选择器1：<ol><li>语法：<code>:checked</code>,获得单选/复选框中选中的元素。</li></ol></li><li>选中选择器2:<ol><li>语法：<code>:selected</code>，获得下拉框中选中的元素。如:<code>$(&quot;#job &gt; option :selected&quot;)</code>，获取下拉框选中的元素，若为多个，则相当于存在一个数组中。</li></ol></li></ol><h1 id="dom操作"><a class="markdownIt-Anchor" href="#dom操作"></a> DOM操作</h1><h2 id="内容操作"><a class="markdownIt-Anchor" href="#内容操作"></a> 内容操作</h2><ol><li><code>html()</code>:<strong>获取/设置元素的标签体内容</strong>,标签体内容包括该标签中嵌套的标签。</li><li><code>text()</code>:获取/设置元素的标签体的<strong>纯文本</strong>内容。</li><li><code>val()</code>:获取/设置元素的value属性值。</li></ol><ul><li>注：方法中不传参数，就是获取元素对应内容，方法中传递参数就是修改元素对应的内容。</li></ul><h2 id="属性操作"><a class="markdownIt-Anchor" href="#属性操作"></a> 属性操作</h2><ol><li>通用属性操作：<ol><li><code>attr()</code>:获取设置元素的属性,参数只有属性名则获取属性值，如果参数还有属性值则设置属性值。如：<code>$(&quot;#bj&quot;).attr(&quot;name&quot;)</code>和<code>$(&quot;#bj&quot;).attr(&quot;name&quot;,&quot;beijing&quot;)</code></li><li>removeAttr()`：删除属性。</li><li><code>prop()</code>:获取设置元素的属性;</li><li>removeProp()`：删除属性。</li></ol><ul><li>attr和prop的区别：<ul><li>如果操作的是元素的<strong>固有属性</strong>,则建议使用prop;</li><li>如果操作的是元素的<strong>自定义属性</strong>,则建议使用attr。</li></ul></li></ul></li><li>对class属性的操作：<ol><li><code>addClass()</code>:添加class属性值;</li><li><code>removeClass()</code>:删除class属性值，如：<code>removeClass(&quot;one&quot;)</code>,删除class=&quot;one&quot;的属性。</li><li><code>toggleClass()</code>:切换class属性值;<ol><li>如：<code>toggleClass(&quot;one&quot;)</code>:判断元素对象上存在class=“one”，则将属性值one删除掉;如果元素对象上不存在class=“one”,则添加。</li></ol></li></ol></li><li>CRUD操作：<ol><li><code>append()</code>:父元素将子元素追加到末尾。<ol><li>对象1.append(对象2):将对象2<strong>添加到对象1元素内部</strong>,并且在末尾。（对象2会移动）</li></ol></li><li><code>prepend()</code>:父元素将子元素追加到开头。<ol><li>对象1.perpend(对象2）：将对象2<strong>添加到对象1元素内部</strong>,并且在开头。</li></ol></li><li><code>appendTo()</code>:<ol><li>对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾。</li></ol></li><li><code>prependTo()</code>:<ol><li>对象1.prepend(对象2):将对象1添加到对象2内部，并且在开头。</li></ol></li><li><code>after()</code>:添加元素到元素后边<ol><li>对象1.after(对象2):将对象2添加到对象1后边，<strong>对象1和对象2是兄弟关系</strong>。</li></ol></li><li><code>before()</code>:添加元素到元素前边<ol><li>对象1.before(对象2):将对象2添加对象1前边，<strong>对象1和对象2是兄弟关系</strong>。</li></ol></li><li><code>insertAfter()</code>:<ol><li>对象1.insertAfter(对象2):将对象1添加到对象2后边，<strong>对象1和对象2是兄弟关系</strong>。</li></ol></li><li><code>insertBefore()</code>:<ol><li>对象1.insertBefore(对象2):将对象1添加到对象2前边，<strong>对象1和对象2是兄弟关系</strong>。</li></ol></li><li><code>remove()</code>：移除元素<ol><li>对象.remove():将对象删除掉;</li></ol></li><li><code>empty()</code>:清空元素的所有后代元素。<ol><li>对象.empty():将对象的后代元素全部清空，但是<strong>保留当前对象以及其属性节点</strong>。</li></ol></li><li><code>clone()</code>:克隆元素并且选中这些克隆。</li></ol></li></ol><h1 id="jquery动画"><a class="markdownIt-Anchor" href="#jquery动画"></a> JQuery动画</h1><ul><li><p>默认显示和隐藏方式：</p><ol><li><code>show([speed], [easing],[fn])</code>:<ol><li>speed:动画的速度。三个预定义的值(slow,normal,fast)或表示动画时长的毫秒数值(如：1000);</li><li>easing:用来指定切换效果。默认是swing,可用参数是linear;<ol><li>swing:动画执行时效果是，先慢，中间快，最后又慢。</li><li>linear：动画执行是匀速的。</li></ol></li><li>fn:在动画执行结束时执行的函数，每个元素执行一次。</li></ol></li><li><code>hide([speed], [easing],[fn])</code>;</li><li><code>toggle([speed], [easing],[fn])</code>:在show和hide之间切换。</li></ol></li><li><p>JQuery动画效果是同通过修改元素属性来实现的，如hide()就会设置的其中一个属性就是：<code>style=&quot;display:none&quot;</code></p></li><li><p>滑动显示和隐藏方式：</p><ol><li><code>slideDown([speed], [easing],[fn])</code></li><li><code>slideUp([speed], [easing],[fn])</code></li><li><code>slideToggle([speed], [easing],[fn])</code></li></ol></li><li><p>淡入淡出显示和隐藏方式：</p><ul><li><code>fadeIn([speed],[easing],[fn])</code></li><li><code>fadeOut([speed],[easing],[fn])</code></li><li><code>fadeToggle([speed],[easing],[fn])</code></li></ul></li></ul><h1 id="jquery遍历"><a class="markdownIt-Anchor" href="#jquery遍历"></a> JQuery遍历</h1><ul><li>JS的遍历方式：<code>for(初始化值;循环结束条件;步长)</code>，也适用于JQ</li><li>JQ的遍历方式：<ol><li><code>jq对象.each(callback)</code>:callback是一个函数。<ol><li>语法：<code>jq对象.each(function(index,element)[]&#123;&#125;)</code><ol><li><code>index</code>:就是元素在集合中的索引</li><li><code>element</code>：就是集合中每一个元素对象。</li><li><code>this</code>:集合中的当前元素对象。</li></ol></li><li>回调函数的返回值：<ol><li><code>false</code>:如果当前的function返回为false，则结束循环。(break)</li><li><code>true</code>:如果当前的function返回为true,则结束本次循环，继续下次循环。（continue)</li></ol></li></ol></li><li><code>$.each(object, callback)</code>,其中callback是回调函数。</li><li><code>for...of:jq对象</code>:3.0版本后提供的方式<ol><li>语法：<code>for（元素对象 of 容器对象)</code>.</li></ol></li></ol></li></ul><h1 id="jquery事件绑定"><a class="markdownIt-Anchor" href="#jquery事件绑定"></a> JQuery事件绑定</h1><ol><li>jquery标准事件绑定方式：<code>jq对象.事件方法（回调函数)</code><ol><li>如果调用事件方法，不传递回调函数，则会触发浏览器的默认行为。如：<ol><li><code>jq对象.focus()</code>，使对象获得焦点;</li><li><code>表单对象.submit()</code>,使表单提交。</li></ol></li></ol></li><li>on绑定事件/off解除绑定：<ol><li><code>jq对象.on(&quot;事件名称&quot;,回调函数)</code>;</li><li><code>jq对象.off(&quot;事件名称&quot;)</code>:<ol><li>如果off方法不传递任何参数，则将组件上的所有事件全部解除。</li></ol></li></ol></li><li>事件切换：toggle<ol><li><code>jq对象.toggle(fn1,fn2,...)</code>:当单击jq对象对应的组件后，会执行fn1,第二次点击会执行fn2,依次循环往复。</li><li>注意：1.9版本后，toggle方法的事件切换功能被删除，jquery Migrate插件（js代码）可以恢复此功能。此js文件需要自行下载。<ol><li><code>&lt;script src=&quot;../js/jquery-migrate-1.0.0.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</code></li></ol></li></ol></li></ol><h1 id="jquery插件"><a class="markdownIt-Anchor" href="#jquery插件"></a> JQuery插件</h1><ol><li><code>$.fn.extend(object)</code>:<ol><li>增强通过jquery获取的对象的功能。（即<code>$(&quot;选择器&quot;)</code>的功能)</li></ol></li><li><code>$.extend(object)</code>:<ol><li>增强JQuery对象自身的功能。(即<code>$</code>自身的功能)</li></ol></li></ol><ul><li>示例：</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$.extend(&#123;   max:function(a,b) &#123;      return a &gt;&#x3D; b ? a : b;   &#125;,   min:function(a,b) &#123;      return a &lt;&#x3D; b ? a : b;   &#125;&#125;)$.max(2,3);$.fn.extend(&#123;   check:function(a,b) &#123;      alert(&quot;check&quot;);   &#125;&#125;)$(&quot;btn-check&quot;).check();</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 前端 </tag>
            
            <tag> JQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="java设计模式简介"><a class="markdownIt-Anchor" href="#java设计模式简介"></a> Java设计模式简介</h1><ul><li>设计模式（Design pattern）:是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。（23中设计模式别称：GOF23）<ul><li>模式：在某些场景下，针对某类问题的某种通用的解决方案。</li><li>场景：项目所在的环境</li><li>问题：约束条件，项目目标等</li><li>解决方案：通用、可复用的设计，解决约束达到目标。</li></ul></li><li>设计模式的三个分类：<ul><li>创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。<ul><li>五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li></ul></li><li>结构型模式：把类或对象结合在一起形成一个更大的结构。<ul><li>适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li></ul></li><li>行为型模式：类和对象如何交互，及划分责任和算法。<ul><li>策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210121160034.png" alt="" /></li></ul></li></ul></li><li>7大设计模式原则：</li></ul><table><thead><tr><th>设计原则</th><th>设计原则定义</th><th>设计原则详解</th></tr></thead><tbody><tr><td>开闭原则</td><td>开闭原则是指一个软件实体，如类、模块和函数应该对扩展开放,对修改关闭，也就是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。</td><td><a href="https://geek-docs.com/design-pattern/design-principle/open-close-principle.html">开闭原则详解</a></td></tr><tr><td>里氏替换原则</td><td>里氏替换原则是关于继承的一个原则，遵循里氏替换原则能够更好地发挥继承的作用，里氏替换原则最早是在1988年，由麻省理工学院的一位姓里的女士（Barbara Liskov）提出来的。子类可以扩展父类的功能，但不能改变父类的功能</td><td><a href="https://geek-docs.com/design-pattern/design-principle/liskov-substitution-principle.html">里氏替换原则详解</a></td></tr><tr><td>迪米特原则</td><td>迪米特原则它要求一个对象应该对其他对象有最少的了解，所以迪米特法则又叫做最少知识原则。</td><td><a href="https://geek-docs.com/design-pattern/design-principle/law-of-demeter.html">迪米特原则详解</a></td></tr><tr><td>单一职责原则</td><td>单一职责原则(Single Responsibility Principle)是面向对象设计原则的一种。单一职责原则是指不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。</td><td><a href="https://geek-docs.com/design-pattern/design-principle/single-responsibility-principle.html">单一职责原则详解</a></td></tr><tr><td>接口分离原则</td><td>接口分离原则指在设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。</td><td><a href="https://geek-docs.com/design-pattern/design-principle/interface-segregation-principle.html">接口分离原则详解</a></td></tr><tr><td>依赖倒置原则</td><td>依赖倒置原则指的是高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定)。抽象(稳定)不应该依赖于实现细节(变化)，实现细节应该依赖于抽象(稳定)。即面向接口编程</td><td><a href="https://geek-docs.com/design-pattern/design-principle/dependence-inversion-principle.html">依赖倒置原则</a></td></tr><tr><td>组合/聚合复用原则</td><td>组合/聚合复用原则是指尽量使用组合/聚合，不要使用类继承。</td><td><a href="https://geek-docs.com/design-pattern/design-principle/composite-aggregate-reuse-principle.html">组合/聚合复用原则详解</a></td></tr></tbody></table><ul><li>23种设计模式简述：<ol><li>单例模式：某个类只能有一个实例，提供一个全局的访问点。</li><li>工厂方法模式：工厂方法模式是简单工厂模式的进一步抽象和推广，是GoF设计模式的一种。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。</li><li>抽象工厂模式：创建相关或依赖对象的家族，而无需明确指定具体类。</li><li>建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造。</li><li>原型模式：通过复制现有的实例来创建新的实例。</li><li>适配器模式：将一个类的方法接口转换成客户希望的另外一个接口。</li><li>组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构。</li><li>装饰模式：动态的给对象添加新的功能。</li><li>代理模式：为其他对象提供一个代理以便控制这个对象的访问。</li><li>享元（蝇量）模式：通过共享技术来有效的支持大量细粒度的对象。</li><li>外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。</li><li>桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化。</li><li>模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。</li><li>解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。</li><li>策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。</li><li>状态模式：允许一个对象在其对象内部状态改变时改变它的行为。</li><li>观察者模式：对象间的一对多的依赖关系。</li><li>备忘录模式：在不破坏封装的前提下，保持对象的内部状态。</li><li>中介者模式：用一个中介对象来封装一系列的对象交互。</li><li>命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。</li><li>访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。</li><li>责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。</li><li>迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。</li></ol></li></ul><h1 id="代理模式"><a class="markdownIt-Anchor" href="#代理模式"></a> 代理模式</h1><ul><li>代理模式(Proxy Pattern) 是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理。代理模式给某一个对象提供一个代理，并<strong>由代理对象控制对原对象的引用</strong>。代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210121162916.png" alt="" /></li><li>三种代理模式：<ol><li>静态代理；</li><li>JDK动态代理；</li><li>Cglib动态代理。</li></ol></li></ul><h2 id="静态代理"><a class="markdownIt-Anchor" href="#静态代理"></a> 静态代理</h2><h1 id="工厂设计模式"><a class="markdownIt-Anchor" href="#工厂设计模式"></a> 工厂设计模式</h1><ul><li>属于创建者模式；</li><li>实现了创建者和调用者的分离；</li><li>分类：<ol><li>简单工厂模式；</li><li>工厂方法模式；</li><li>抽象工厂模式；</li></ol></li><li>主要遵循原则：<ol><li>开闭原则；</li><li>依赖倒置原则；</li><li>迪米特原则；</li></ol></li><li>核心本质：<ol><li>实例化对象不使用new，用工厂方法替代；</li><li>将选择实现类，创建对象统一管理和控制，从而将调用者和我们的实现类解耦。</li></ol></li></ul><h2 id="简单工厂模式"><a class="markdownIt-Anchor" href="#简单工厂模式"></a> 简单工厂模式</h2><ul><li>用来生产同一等级结构中的任意产品（对于增加新的产品，需要扩展已有的代码）</li><li>虽然不符合开闭原则，但是因为其简单，所以实际中使用得最多。</li><li>示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;车接口package simpliFactory;public interface Car &#123;    void name();&#125;&#x2F;&#x2F;benci车实体类package simpliFactory;public class BenciCar implements Car &#123;    @Override    public void name() &#123;        System.out.println(&quot;benci&quot;);    &#125;&#125;&#x2F;&#x2F;bmw车实体类package simpliFactory;public class BMWCar implements Car &#123;    @Override    public void name() &#123;        System.out.println(&quot;BMW&quot;);    &#125;&#125;&#x2F;&#x2F;车工厂package simpliFactory;public class CarFactory &#123;    public static Car getCar(String name) &#123;      &#x2F;&#x2F;想要增加新的车型，必须修改这里面的代码        if(name.equals(&quot;bmw&quot;)) &#123;            return new BMWCar();        &#125;else if(name.equals(&quot;benci&quot;)) &#123;            return new BenciCar();        &#125;else &#123;            return null;        &#125;    &#125;&#125;&#x2F;&#x2F;消费者从车工厂购买车package simpliFactory;public class Consumer &#123;    public static void main(String[] args) &#123;        Car car1 &#x3D; CarFactory.getCar(&quot;bmw&quot;);        Car car2 &#x3D; CarFactory.getCar(&quot;benci&quot;);        car1.name();        car2.name();    &#125;&#125;</code></pre><h2 id="工厂方法模式"><a class="markdownIt-Anchor" href="#工厂方法模式"></a> 工厂方法模式</h2><ul><li>用来生产同一等级结构中的固定产品（支持增加任意产品）</li><li>不修改已有类的前提下，通过增加<strong>新的工厂类</strong>来实现扩展。</li><li>示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;车接口package methodFactory;public interface Car &#123;    void name();&#125;&#x2F;&#x2F;车工厂接口package methodFactory;public interface CarFactory &#123;     Car getCar();&#125;&#x2F;&#x2F;BMW车实体类package methodFactory;public class BMWCar implements Car &#123;    @Override    public void name() &#123;        System.out.println(&quot;BMW&quot;);    &#125;&#125;&#x2F;&#x2F;Benci车实体类package methodFactory;public class BenciCar implements Car &#123;    @Override    public void name() &#123;        System.out.println(&quot;benci&quot;);    &#125;&#125;&#x2F;&#x2F;BMW车工厂类package methodFactory;public class BMWFactory implements CarFactory &#123;    @Override    public  Car getCar() &#123;        return new BMWCar();    &#125;&#125;&#x2F;&#x2F;Benci车工厂类package methodFactory;public class BenciFactory implements CarFactory&#123;    @Override    public Car getCar() &#123;        return new BenciCar();    &#125;&#125;&#x2F;&#x2F;消费者从对应的工厂获取对应的车package methodFactory;public class Consumer &#123;    public static void main(String[] args) &#123;        Car car1 &#x3D; new BMWFactory().getCar();        Car car2 &#x3D; new BenciFactory().getCar();        car1.name();        car2.name();    &#125;&#125;</code></pre><h2 id="抽象工厂模式"><a class="markdownIt-Anchor" href="#抽象工厂模式"></a> 抽象工厂模式</h2><ul><li>抽象工厂提供了一个创建一系列相关或相互依赖产品（即一个产品簇）的接口，无需指定它们具体的类。</li><li>核心：将一个系列的产品统一到一起创建。增加新系列的产品容易，但是修改产品簇中的产品困难。</li><li>示例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210207173309.jpg" alt="" /></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;产品簇中产品之一-手机接口package abstractFactory;public interface IphoneProduct &#123;    void call();&#125;&#x2F;&#x2F;产品簇中产品之一-路由器接口package abstractFactory;public interface IRouterProduct &#123;    void openWifi();&#125;&#x2F;&#x2F;小米系列产品之手机实体类package abstractFactory;public class XIaomiPhone  implements IphoneProduct&#123;    @Override    public void call() &#123;        System.out.println(&quot;小米打电话&quot;);    &#125;&#125;&#x2F;&#x2F;小米系列产品之路由器实体类package abstractFactory;public class XIaomiRouter implements IRouterProduct &#123;    @Override    public void openWifi() &#123;        System.out.println(&quot;小米路由器连wifi&quot;);    &#125;&#125;&#x2F;&#x2F;华为系列产品之手机实体类package abstractFactory;public class HuaweiPhone  implements IphoneProduct&#123;    @Override    public void call() &#123;        System.out.println(&quot;华为打电话&quot;);    &#125;&#125;&#x2F;&#x2F;华为系列产品之路由器实体类package abstractFactory;public class HuaweiRouter implements IRouterProduct&#123;    @Override    public void openWifi() &#123;        System.out.println(&quot;华为路由器连wifi&quot;);    &#125;&#125;&#x2F;&#x2F;抽象工厂-用于生产生产不同系列产品的工厂package abstractFactory;public interface IProductFactory &#123;    IphoneProduct producePhone();    IRouterProduct produceRouter();&#125;&#x2F;&#x2F;小米系列产品的生产工厂package abstractFactory;public class XiaomiProductFactory implements IProductFactory &#123;    @Override    public IphoneProduct producePhone() &#123;        return new XIaomiPhone();    &#125;    @Override    public IRouterProduct produceRouter() &#123;        return new XIaomiRouter();    &#125;&#125;&#x2F;&#x2F;华为系列产品的生产工厂package abstractFactory;public class HuaweiProductFactory implements IProductFactory &#123;    @Override    public IphoneProduct producePhone() &#123;        return new HuaweiPhone();    &#125;    @Override    public IRouterProduct produceRouter() &#123;        return new HuaweiRouter();    &#125;&#125;&#x2F;&#x2F;从不同工厂取出不同系列产品package abstractFactory;public class Client &#123;    public static void main(String[] args) &#123;        IProductFactory xiaomi &#x3D; new XiaomiProductFactory();        IphoneProduct phone1 &#x3D; xiaomi.producePhone();        IRouterProduct router1 &#x3D; xiaomi.produceRouter();        IProductFactory huawei &#x3D; new HuaweiProductFactory();        IphoneProduct phone2 &#x3D; huawei.producePhone();        IRouterProduct router2 &#x3D; huawei.produceRouter();        phone1.call();        router1.openWifi();        phone2.call();        router2.openWifi();    &#125;&#125;</code></pre><h1 id="代理模式-2"><a class="markdownIt-Anchor" href="#代理模式-2"></a> 代理模式</h1><h2 id="静态代理-2"><a class="markdownIt-Anchor" href="#静态代理-2"></a> 静态代理</h2><ul><li>抽象角色：一般用接口或抽象类来解决，用来统一真实角色和代理角色的核心功能。</li><li>真实角色：被代理的角色；</li><li>代理角色：代理真实角色，代理真实角色后，一般会增加一些附属功能。</li><li>客户：访问代理对象的人。</li></ul><hr /><ul><li>优点：<ul><li>可以使真实角色的业务简化，不用去关注一些公共的业务；</li><li>公共业务交给代理角色，实现了业务的分工；</li><li>公共业务发生扩展的时候，方便集中管理，不用去直接修改原有代码，只用增强代理角色的功能。</li></ul></li><li>缺点：<ul><li>一个真实角色就会产生一个代理角色，代码量会翻倍。</li></ul></li><li>代码实现步骤：<ol><li>接口：</li></ol></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package staticProxy;&#x2F;&#x2F;真实角色和代理角色都要实现相同的接口，以确保代理和真实角色的核心功能统一，例如，房东不需要婚介所public interface Rent &#123;    void rent();&#125;</code></pre><ol start="2"><li>真实角色：</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">package staticProxy;&#x2F;&#x2F;房东-真实角色public class Host implements Rent&#123;    @Override    public void rent() &#123;        System.out.println(&quot;房东出租房屋&quot;);    &#125;&#125;</code></pre><pre><code>3. 代理角色：</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">package staticProxy;&#x2F;&#x2F;中介-代理角色public class Proxy implements Rent &#123;    private Host host;    public Proxy(Host host)&#123;        this.host &#x3D; host;    &#125;    &#x2F;&#x2F;代理角色除了实现真实角色的功能外，往往还需实现一些附属功能，这正是代理的作用所在。    @Override    public void rent() &#123; &#x2F;&#x2F;核心功能rent中添加一些附属功能        seeHouse();        host.rent();        fare();    &#125;    public void seeHouse() &#123;        System.out.println(&quot;中介带客户看房子&quot;);    &#125;    public void fare() &#123;        System.out.println(&quot;中介收取费用&quot;);    &#125;&#125;</code></pre><pre><code>4. 客户：</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">package staticProxy;public class Client &#123;    public static void main(String[] args) &#123;        Host host &#x3D; new Host();        Proxy proxy &#x3D; new Proxy(host);        proxy.rent();    &#125;&#125;</code></pre><h2 id="动态代理"><a class="markdownIt-Anchor" href="#动态代理"></a> 动态代理</h2><ul><li>动态代理和静态代理发挥的作用相同，只是代理角色生成的方式不同；</li><li>动态代理的代理类是动态生成的，不是像静态代理类一样是我们事先写好的；</li><li>动态代理的分类：<ol><li>基于接口的动态代理；</li><li>基于类的动态代理；</li></ol></li><li>动态代理的实现方式：<ol><li>jdk动态代理–基于接口；</li><li>cglib–基于类；</li><li>javasist–java字节码实现；</li></ol></li></ul><h3 id="jdk动态代理"><a class="markdownIt-Anchor" href="#jdk动态代理"></a> jdk动态代理</h3><ul><li>jdk的动态代理是通过Proxy类和 InvocationHandler接口实现的；</li><li>Proxy类提供生成满足对应接口的代理实例的静态方法；</li><li>InvocationHandler是一个接口，每一个动态生成的代理实例都有一个对应的实现了InvocationHandler接口的类。</li><li>示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;统一真实角色和代理角色的接口public interface Rent &#123;    void rent();&#125;&#x2F;&#x2F;真实角色1public class Host implements Rent &#123;    @Override    public void rent() &#123;        System.out.println(&quot;房东1出租房子&quot;);    &#125;&#125;&#x2F;&#x2F;真实角色2public class Host2 implements Rent &#123;    @Override    public void rent() &#123;        System.out.println(&quot;房东2出租房屋&quot;);    &#125;&#125;&#x2F;&#x2F;代理处理类，用于生成实现和真实角色一样接口的代理实例public class ProxyInvocationHandler implements InvocationHandler &#123;    &#x2F;&#x2F;需要实现的接口    private Object target;    &#x2F;&#x2F;设置对应的接口    public void setTarget(Object target)&#123;        this.target &#x3D; target;    &#125;    &#x2F;&#x2F;获取代理实例    public Object getProxy()&#123;        return Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces(),this);    &#125;    &#x2F;&#x2F;实现代理实例的方法    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        Object result &#x3D; method.invoke(target,args);        log(method.getName());        return result;    &#125;    &#x2F;&#x2F;添加代理实例的附属方法    public void log(String methodName) &#123;        System.out.println(&quot;执行了&quot;+methodName+&quot;方法&quot;);    &#125;&#125;&#x2F;&#x2F;通过代理实现租房public class Client &#123;    public static void main(String[] args) &#123;        Host host1 &#x3D; new Host();        Host2 host2 &#x3D; new Host2();        ProxyInvocationHandler pih &#x3D; new ProxyInvocationHandler();&#x2F;&#x2F;生成代理处理对象        pih.setTarget(host1);&#x2F;&#x2F;设置需要被代理的真实对象        Rent proxy &#x3D; (Rent)pih.getProxy();&#x2F;&#x2F;生成对应的代理对象        proxy.rent();        pih.setTarget(host2);        Rent proxy2 &#x3D; (Rent) pih.getProxy();        proxy2.rent();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Listener</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Listener/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Listener/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="listener概述"><a class="markdownIt-Anchor" href="#listener概述"></a> Listener概述</h1><ul><li>JavaWeb三大组件之一（Servlet,Filter,Listener)</li><li>事件监听机制：<ul><li>事件：一件事情，如：点击。</li><li>事件源：事件发生的地方。</li><li>监听器：一个对象;</li><li>注册监听：将事件，事件源，监听器绑定在一起。当事件源上发生某个事件后，执行监听器的代码。</li></ul></li></ul><h1 id="servletcontextlistener"><a class="markdownIt-Anchor" href="#servletcontextlistener"></a> ServletContextListener</h1><ul><li>ServletContextListener:一个接口，用来监听ServletContext对象的创建和销毁。</li><li>接口方法：<ul><li><code>void contextInitalized(ServletContextEvent sce)</code>:ServletContext对象创建后会调用该方法。</li><li><code>void contextDestroyed(ServletContextEvent sce)</code>:ServletContext对象被销毁之前会调用该方法。</li></ul></li><li>使用步骤：<ol><li>定义一个类，<strong>实现ServletContextListener接口</strong>;</li><li>复习方法;</li><li>配置：<ul><li>web.xml:<ol><li>只用配置监听器的类名。<br />2.可以指定初始化参数<code>&lt;context-param&gt;</code></li></ol></li></ul></li></ol></li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;listener&gt;    &lt;listener-class&gt;监听器类的完全限定名&lt;&#x2F;listener-class&gt;&lt;&#x2F;listener&gt;&lt;context-param&gt;    &lt;param-name&gt;参数名&lt;&#x2F;param-name&gt;    &lt;param-value&gt;参数内容&lt;&#x2F;param-value&gt;&lt;&#x2F;context-param&gt;</code></pre><ul><li>注解配置：无需写参数。<ul><li><code>@WebListener</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 后端 </tag>
            
            <tag> Listener </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Filter</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Filter/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Filter/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="filter概述"><a class="markdownIt-Anchor" href="#filter概述"></a> Filter概述</h1><ul><li>JavaWeb的三大组件（servlet，Filter，Listener)之一。</li><li>web中的过滤器：当访问服务器的资源时，过滤器可以将每次请求拦截下来，完成一些特殊的功能;</li><li>作用：<ul><li>一般用于完成<strong>通用的操作</strong>,如：登录验证，统一编码处理，敏感字符过滤。</li></ul></li></ul><h1 id="filter快速入门"><a class="markdownIt-Anchor" href="#filter快速入门"></a> Filter快速入门</h1><ul><li>步骤：<ol><li>定义一个类，实现<strong>接口Filter</strong>,注意这个Filter接口是java.servlet包下的（因为java.util包下也有Filter接口）;</li><li>复写方法，（主要起作用的方法是doFilter)</li><li>配置拦截路径：<ol><li>在web.xml文件中去配置;</li><li>用注解<code>@WebFilter</code>注解，如：<code>@WebFilter(&quot;/demo1&quot;)</code>代表访问/demo1目录下的资源的时候执行拦截。</li></ol></li></ol></li><li>示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">import javax.servlet.*;import javax.servlet.annotation.WebFilter;import java.io.IOException;@WebFilter(&quot;&#x2F;*&quot;)public class FilterDemo1 implements Filter &#123;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;    &#125;    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;        System.out.println(&quot;I&#39;m Filter!&quot;);        chain.doFilter(request, response);    &#125;    @Override    public void destroy() &#123;            &#125;&#125;</code></pre><h1 id="webxml配置方式"><a class="markdownIt-Anchor" href="#webxml配置方式"></a> web.xml配置方式</h1><ul><li>配置filter;</li><li>配置filter的拦截路径。</li><li>示例：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;filter&gt;    &lt;filter-name&gt;过滤器的名字&lt;&#x2F;filter-name&gt;    &lt;filter-class&gt;过滤器的完全限定类名&lt;&#x2F;filter-class&gt;&lt;&#x2F;filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;过滤器的名字&lt;&#x2F;filter-name&gt;    &lt;url-pattern&gt;拦截的路径&lt;&#x2F;url-pattern&gt;&lt;&#x2F;filter-mapping&gt;</code></pre><h1 id="过滤器的执行流程和生命周期方法"><a class="markdownIt-Anchor" href="#过滤器的执行流程和生命周期方法"></a> 过滤器的执行流程和生命周期方法</h1><ul><li>执行流程：<ol><li>执行过滤器，拦截请求，对request对象请求执行增强操作;</li><li>放行请求,执行放行后对应的资源;</li><li>执行放行后的语句，对response对象响应执行增强操作。</li></ol></li><li>生命周期方法：<ol><li><code>init()</code>:</li></ol><ul><li>在<strong>服务器启动</strong>后，会创建Filter对象，然后调用init方法。</li><li>只执行一次，用于<strong>加载资源</strong>。</li></ul><ol start="2"><li><code>doFilter()</code>:<ul><li>每一次请求被拦截的资源时，会执行。</li><li>会执行多次。</li></ul></li><li><code>destroy()</code>:在<strong>服务器关闭后</strong>,Filter被销毁。<ol><li>如果服务器是正常关闭，则会执行destroy方法;</li><li>只执行一次，用于<strong>释放资源</strong>。</li></ol></li></ol></li></ul><h1 id="过滤器配置"><a class="markdownIt-Anchor" href="#过滤器配置"></a> 过滤器配置</h1><ul><li>过滤器拦截路径配置：<ol><li>具体资源路径：<code>/index.jsp</code>,只有访问index.jsp资源时，过滤器才会被执行;</li><li>拦截目录：<code>/user/*</code>,访问/user下的所有资源时，过滤器都会被执行;</li><li>后缀名拦截：<code>*.jsp</code>，访问所有后缀名为jsp的资源时，过滤器都会被执行。</li><li>拦截所有资源：<code>/*</code>，访问所有资源时，过滤器都会被执行。</li></ol></li><li>拦截方式配置：<ul><li>注解配置：设置dispatcherTypes属性：<ol><li>REQUEST:默认值，浏览器直接请求资源时拦截;</li><li>FORWARD：转发访问资源时拦截;</li><li>INCLUDE：包含访问资源时拦截;</li><li>ERROR：错误跳转资源时拦截;</li><li>ASYNC:异步访问资源时拦截。</li></ol></li><li>web.xml配置：设置<code>&lt;dispathcer&gt;&lt;/dispathcer&gt;</code>标签。</li><li>示例：<ul><li><code>@WebFilter(value = &quot;/index.jsp&quot;,dispatcherTypes = DispatcherType.REQUEST)</code>：拦截直接访问index.jsp资源的请求;</li><li><code>@WebFilter(value = &quot;/index.jsp&quot;,dispatcherTypes = &#123;DispatcherType.REQUEST,DispatcherType.FORWARD&#125;)</code>:拦截直接请求index.jsp或者转发访问index.jsp资源。</li><li>web.xml配置：拦截直接请求。</li></ul></li></ul></li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;filter&gt;    &lt;filter-name&gt;过滤器的名字&lt;&#x2F;filter-name&gt;    &lt;filter-class&gt;过滤器的完全限定类名&lt;&#x2F;filter-class&gt;&lt;&#x2F;filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;过滤器的名字&lt;&#x2F;filter-name&gt;    &lt;url-pattern&gt;拦截的路径&lt;&#x2F;url-pattern&gt;    &lt;dispatcher&gt;REQUEST&lt;&#x2F;dispatcher&gt;&lt;&#x2F;filter-mapping&gt;</code></pre><h1 id="过滤器链"><a class="markdownIt-Anchor" href="#过滤器链"></a> 过滤器链</h1><ul><li>过滤器的先后顺序：<ul><li>注解配置：按照**类名的字符串比较规则比较，值小的先执行<ul><li>如： AFilter和BFilter，AFilter先执行;</li><li>如：FilterDemo6和FilterDemo17,FilterDemo17先执行。</li></ul></li><li>web.xml配置：<code>&lt;filter-mapping&gt;</code>标签谁定义在上面，谁先执行。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 后端 </tag>
            
            <tag> Filter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSTL</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/JSTL/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/JSTL/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="jstl概述"><a class="markdownIt-Anchor" href="#jstl概述"></a> JSTL概述</h1><ul><li>JSTL:JavaServer Pages Tag Library,JSP标准标签库。</li><li>JSTL是由Apache组织提供的开源的免费的JSP标签;</li><li>作用：用于简化和替换JSP页面上的<strong>java代码</strong>;</li><li>使用步骤：<ol><li>导入JSTL相关的jar包;</li><li>引入标签库：taglib指令：<code>&lt;%@ taglib %&gt;</code><ul><li>一般将JSTL标签库，将前缀设为<code>c</code>。</li></ul></li><li>使用标签。</li></ol></li><li>示例：</li></ul><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt;</code></pre><h1 id="常用的jstl标签"><a class="markdownIt-Anchor" href="#常用的jstl标签"></a> 常用的JSTL标签</h1><h2 id="if标签"><a class="markdownIt-Anchor" href="#if标签"></a> if标签</h2><ul><li>if：相当于java代码的if语句</li><li>属性：<ul><li>test:必须的属性，接受boolean表达式，相当于原来if语句的条件;<ul><li>如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容;</li><li>一般情况下，test属性值会结合EL表达式一起使用,如：</li></ul></li></ul></li></ul><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;c:if test&#x3D;&quot;$&#123;not empty list&#125;&quot;&gt;    遍历集合;&lt;&#x2F;c:if&gt;</code></pre><ul><li>if标签没有else情况，要想实现else情况，则可以再定义一个if标签。</li></ul><h2 id="choose"><a class="markdownIt-Anchor" href="#choose"></a> choose</h2><ul><li>choose:相当于java代码的switch语句</li><li>使用choose标签声明：相当于switch声明;</li><li>使用when标签判断：相当于case;</li><li>使用otherwise标签做其他情况的声明：相当于default</li><li>示例：</li></ul><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;c:choose&gt;    &lt;c:when test&#x3D;&quot;$&#123;number &#x3D;&#x3D; 1&#125;&quot;&gt; 1&lt;&#x2F;c:when&gt;    &lt;c:when test&#x3D;&quot;$&#123;number &#x3D;&#x3D; 2&#125;&quot;&gt; 2&lt;&#x2F;c:when&gt;    &lt;c:otherwise&gt;默认数字&lt;&#x2F;c:otherwise&gt;&lt;&#x2F;c:choose&gt;</code></pre><h2 id="foreach"><a class="markdownIt-Anchor" href="#foreach"></a> forEach</h2><ul><li>forEach:相当于java的for语句</li><li>作用：<ol><li>完成重复的操作;</li><li>遍历容器。</li></ol></li><li>完成重复的操作：相当于<code>for(int i = 0; i &lt; 10; i++)</code><ul><li>属性：<ul><li>begin:开始值，相当于i = 0;</li><li>end:结束值;</li><li>var：临时变量，相当于i;</li><li>step:步长，为1时相当于++;</li><li>varStatus:循环状态对象<ul><li>index属性：容器中的元素的索引，从0开始;</li><li>count属性：循环次数，从1开始。</li></ul></li></ul></li></ul></li><li>遍历容器：相当于<code>for(int i ： numbers)</code><ul><li>属性：<ul><li>items:容器对象;</li><li>var:容器中元素的临时变量;</li><li>varStatus:循环状态对象<ul><li>index属性：容器中的元素的索引，从0开始;</li><li>count属性：循环次数，从1开始。</li></ul></li></ul></li></ul></li><li>示例：</li></ul><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;c:forEach items&#x3D;“$&#123;list&#125;&quot; var&#x3D;&quot;str&quot; varStatus&#x3D;&quot;s&quot;&gt;    $&#123;s.index&#125; $&#123;s.count&#125; $&#123;str&#125;&lt;br&gt;&lt;&#x2F;c:forEach&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> JSP </tag>
            
            <tag> JSTL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EL表达式</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="el表达式概述"><a class="markdownIt-Anchor" href="#el表达式概述"></a> EL表达式概述</h1><ul><li>概念：Expression Language ,表达式语言</li><li>作用：替换和简化jsp页面中的代码的编写;</li><li>语法：<code>$&#123;表达式&#125;</code>;</li><li>jsp默认支持EL表达式：<ul><li>如果要忽略EL表达式：<ol><li>设置jsp中的page指令：<code>isELIgnored = &quot;true&quot;</code>,忽略当前jsp页面中的所有EL表达式;</li><li><code>\$&#123;表达式&#125;</code>:忽略当前这个EL表达式。</li></ol></li></ul></li><li>用法：<ul><li>运算，并在页面上显示运算结果;</li><li>获取值。</li></ul></li></ul><h1 id="el的运算"><a class="markdownIt-Anchor" href="#el的运算"></a> EL的运算</h1><ul><li>算术运算符：<code>+ ,-, *, / ,%</code>,其中<code>/</code>可以用<code>div</code>代替，<code>%</code>可以用<code>mod</code>代替。</li><li>比较运算符：<code>&gt; &lt; &gt;= == !=</code></li><li>逻辑运算符：<code>&amp;&amp;(and), ||(or), !(not)</code></li><li>空运算符：<code>empty</code>:<ul><li>功能：用于判断字符串，集合，数组对象是否为null并且长度是否为0;</li><li>示例：<code>$&#123;empty list&#125;</code>,返回结果为boolean型。 一般常用<code>$&#123;not empty list&#125;</code>:判断不为null或者长度不为0;</li></ul></li></ul><h1 id="el获取值"><a class="markdownIt-Anchor" href="#el获取值"></a> EL获取值</h1><ul><li>EL表达式只能从<strong>域对象</strong>中获取值;</li><li>语法：<ul><li><code>$&#123;域名称.键名&#125;</code>:从指定域中获取指定键的值;</li><li><code>$&#123;键名&#125;</code>：表示依次从最小的域中查找是否有该键对应的值，知道找到为止，若没有找到，则返回空字符串。</li></ul></li><li>域名称与域对象的对应关系：<ol><li>pageScope --&gt; pageContext;</li><li>requestScopt --&gt; request;</li><li>sessionScope --&gt; session;</li><li>applicationScope --&gt; application(ServletContext);</li></ol></li><li>示例：<ul><li>在域对象中存储了<code>name 张三</code></li><li>获取：<code>$&#123;requestScope.name&#125;</code>将在页面上打印张三。</li></ul></li><li>EL获取对象值：<ul><li><code>$&#123;域名称.键名.属性名&#125;</code>:本质上回去调用对象的getter方法，所以必须有对应的getXxx方法的属性才能调用（甚至只有getXxx的方法，没有实际对应的属性也可以）</li><li>对应的对象必须首先以键值对的形式存入对应的域对象中，如:<code>request.setAttribute(&quot;user&quot;,user)</code>,将user对象存入request域中去。</li></ul></li><li>EL获取List集合：<ul><li><code>$&#123;域名称.键名[索引]&#125;</code></li></ul></li><li>EL获取Map集合的值<ul><li><code>$&#123;域名称.键名.key名称&#125;</code></li><li><code>$&#123;域名称.键名[&quot;key名称&quot;]&#125;</code></li></ul></li></ul><h1 id="el的隐式对象"><a class="markdownIt-Anchor" href="#el的隐式对象"></a> EL的隐式对象</h1><ul><li>EL中不用创建可以直接使用的对象（类似jsp中的内置对象）。</li><li>EL表达式中有11个隐式对象：</li><li>pageContext对象：<ul><li>获取其他八个内置对象。</li><li>示例：动态获取虚拟目录：<code>$&#123;pageContext.request.contextPath&#125;</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> EL表达式 </tag>
            
            <tag> JSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVC开发模式与三层架构</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/MVC%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/MVC%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="演变历史"><a class="markdownIt-Anchor" href="#演变历史"></a> 演变历史</h1><ol><li>早期只有servlet，只能使用response输出标签数据，很麻烦。</li><li>后来又有jsp，简化了servlet的开发;</li><li>如果过度使用jsp，在jsp中既有大量的java代码，又写html,造成难以维护，难以分工协作。</li><li>再后来，java的web开发，借鉴MVC开发模式，使得程序的设计更加的合理性。</li></ol><h1 id="mvc开发模式"><a class="markdownIt-Anchor" href="#mvc开发模式"></a> MVC开发模式</h1><ul><li>M:Model,模型。<ul><li>完成具体的业务操作，如：查询数据库，封装对象。</li><li>一般使用JavaBean完成。</li></ul></li><li>V:view,视图。<ul><li>展示数据;</li><li>使用JSP来完成。</li></ul></li><li>C：Controller,控制器。<ul><li>获取用户的输入;</li><li>调用模型;</li><li>将数据交给视图进行展示。</li><li>使用Servlet来完成。</li></ul></li><li>优点：<ul><li>耦合性低，方便维护，可以利于分工协作；</li><li>重用性高（主要指控制器和模型）</li></ul></li><li>缺点：<ul><li>使得项目的架构便复杂，对开发人员的要求高。</li></ul></li></ul><h1 id="三层架构"><a class="markdownIt-Anchor" href="#三层架构"></a> 三层架构</h1><ul><li>界面层（表示层/web层）<ul><li>用户看得到的界面。用户可以通过界面上的组件和服务器进行交互。</li><li>接收用户参数，封装数据，调用业务逻辑层完成处理，转发jsp页面完成显示。</li><li>用SpringMVC框架实现。</li></ul></li><li>业务逻辑层(service层)：<ul><li>处理业务逻辑的代码;</li><li>组合DAO层中的简单方法，形成复杂的功能（业务逻辑操作）。</li><li>用Spring框架实现。</li></ul></li><li>数据访问层(DAO层：Data Access Object)：<ul><li>操作数据库存储文件。</li><li>定义了对于数据库最基本的CRUD操作;、</li><li>用MyBatis框架实现。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210119193423.PNG" alt="" /></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> MVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>会话技术-session</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF-session/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF-session/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="session概述"><a class="markdownIt-Anchor" href="#session概述"></a> session概述</h1><ul><li>概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象（HTTPSession)中。</li><li>session的特点：<ul><li>session用于存储一次会话的多次请求数据，存在<strong>服务器端</strong>;</li><li>session可以存储<strong>任意类型，任意大小</strong>的数据。</li></ul></li><li>session与cookie的区别：<ul><li>session存储在服务器端，cookie存储在客户端;</li><li>session没有数据大小限制，而cookie有;</li><li>session数据存储在服务器端相对安全。</li></ul></li></ul><h1 id="session快速入门"><a class="markdownIt-Anchor" href="#session快速入门"></a> session快速入门</h1><ol><li>获取HttpSession对象：<code>HttpSession session = request.getSession();</code></li><li>使用HttpSession对象：<ol><li>获取属性：<code>Object getAttribute(String name)</code></li><li>设置属性：<code>void setAttribute(String name, String value);</code></li><li>删除属性：<code>void removeAttribute(Strin name)</code></li></ol></li></ol><h1 id="session的基本原理"><a class="markdownIt-Anchor" href="#session的基本原理"></a> session的基本原理</h1><ul><li>在一次会话范围内多次获取的Session对象是同一个Session对象。</li><li>Session的实现是依赖于Cookie的：<ol><li>在第一次请求创建了Session对象之后，服务器的<code>set-cookie</code>响应头之中会携带Session的id信息;</li><li>在客户端进行第二次请求时，会自动发送一个cookie头，在这个头中包含有<code>set-cookie</code>中携带回来的Session对象的Id信息;</li><li>服务器接受到Session的id信息后，或检查服务器中有无该session对象，如果有，则继续使用。</li></ol></li><li>当客户端关闭后，服务器不关闭，两次获取的session：<ul><li>默认情况下，不相同;</li><li>客户端关闭后，session也能相同方法：<ul><li>将携带JSESSIONID信息的cookie持久化存储到本地：<ol><li>创建cookie;</li><li>键设置为JESSIONID;</li><li>设置最大存活时间;</li><li>将cookie在响应消息中发回客户端。</li></ol></li></ul></li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">Cookie c &#x3D; new Cookie(&quot;JESSIONID&quot;, session.getId());c.setMaxAge(60*60);&#x2F;&#x2F;持久化到磁盘1个小时response.addCookie(c);</code></pre><ul><li>客户端不关闭，服务器关闭后，两次读取的session：<ul><li>两次获取的session不是同一个，但是要确保数据不丢失。</li><li>seession的钝化：在服务器正常关闭之前，将session对象序列化到硬盘上;</li><li>session的活化：在服务器启动之后，将session文件转化为内存中的session对象，实现数据的继续使用。</li><li>tomcat服务器会自动完成session的钝化和活化，但是IDEA不会。</li></ul></li><li>session的失效时间：<ol><li>服务器关闭时自动销session对象;</li><li>session对象调用invalidate()方法进行自毁;</li><li>session的默认失效时间（在这段时间内，session没有任何操作或这变化，则被销毁）：<ol><li>修改默认失效时间：在服务器的<code>web.xml</code>配置文件中找到：</li></ol></li></ol></li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;session-config&gt;    &lt;session-timeout&gt;30&lt;&#x2F;session-timeout&gt;&lt;&#x2F;session-config&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 后端 </tag>
            
            <tag> 会话技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/JSP/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/JSP/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="jsp概念"><a class="markdownIt-Anchor" href="#jsp概念"></a> JSP概念</h1><ul><li>JSP:Java Server Pages:java服务器端页面</li><li>一个特殊的页面，其中既<strong>可以指定定义html标签，又可以定义java代码</strong>，用于简化书写。</li><li>JSP的注释：<ul><li>html注释： <code>&lt;!-- --&gt;</code>，只能用来注释html代码片段;</li><li>JSP注释：<code>&lt;%-- --%&gt;</code>,可以注释所有，推荐使用。</li></ul></li></ul><h1 id="jsp原理"><a class="markdownIt-Anchor" href="#jsp原理"></a> JSP原理</h1><ul><li>JSP文件本质上是一个Servlet类。</li><li>服务器请求JSP资源之后，服务器会先将JSP文件转换为一个java文件，然后再编译成.class文件，由.class文件提供服务。</li></ul><h1 id="jsp脚本"><a class="markdownIt-Anchor" href="#jsp脚本"></a> JSP脚本</h1><ul><li>JSP脚本：JSP定义java代码的方式。</li><li><code>&lt;% code %&gt;</code>:定义的java代码，在servlce方法中。service方法中可以定义什么，该脚本中就可以定义什么。</li><li><code>&lt;%! code %&gt;</code>:定义的java代码,在JSP转换后的java类的成员位置。（定义该类的全局变量）</li><li><code>&lt;%= code %&gt;</code>:定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。</li></ul><h1 id="jsp的内置对象"><a class="markdownIt-Anchor" href="#jsp的内置对象"></a> JSP的内置对象</h1><ul><li>在JSP页面中<strong>不需要获取和创建</strong>，可以直接使用的对象（其本质是JSP内部已经提前创建好了）</li><li>JSP一共有9个内置对象：<ul><li>pageContext:<ul><li>对应java真实类型：PageContext</li><li>作用：域对象，当前页面共享数据，还可以获取其他八个内置对象;</li></ul></li><li>request:<ul><li>对应java真实类型：HttpServletRequest</li><li>作用：域对象，一次请求的多个资源（转发）</li></ul></li><li>session:<ul><li>真实类型：HttpSession</li><li>作用：域对象，一次会话间的多个请求间。</li></ul></li><li>application:<ul><li>真实类型：ServletContext</li><li>作用：域对象，所有用户间共享数据。</li></ul></li><li>response:<ul><li>真实类型：HttpServletResponse</li><li>作用：响应对象</li></ul></li><li>page:<ul><li>真实类型：Object</li><li>作用：当前页面（Servlet)的对象，即<code>this</code>。</li></ul></li><li>out:字符输出流对象。可以将数据输出到页面上，和<code>response.getWriter()</code>类似。<ul><li>真实类型：JspWriter</li><li>作用：输出流对象，将数据输出到页面上。</li><li><code>response.getWriter()</code>和<code>out.write()</code>的区别：<ul><li>在他tomcat服务器真正给客户端做出响应之前，会先找response的缓冲区数据，再找out缓冲区数据。</li><li><code>response.getWriter()</code>数据输出永远在<code>out.write()</code>之前。</li></ul></li></ul></li><li>config:<ul><li>真实类型：ServletConfig</li><li>作用：Servlet的配置对象</li></ul></li><li>exception:<ul><li>真实类型：Throwable</li><li>作用：异常对象，只有指令<code>isErrorPage</code>标识为true的jsp页面才可以用。</li></ul></li></ul></li></ul><h1 id="jsp的指令"><a class="markdownIt-Anchor" href="#jsp的指令"></a> JSP的指令</h1><ul><li>作用：用于配置JSP页面，导入资源文件;</li><li>格式：<code>&lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 %&gt;</code></li><li>分类：<ul><li>page：配置jsp页面的指令;<ul><li><code>content-type</code>:等同于<code>response.setContentType()</code>;<ul><li>设置响应体的MIME类型以及字符集;</li><li>设置当前页面的编码（只能是高级的IDE），如果是低级工具，需要设置<code>pageEncoding</code>属性设置当前页面的字符集。</li></ul></li><li><code>language</code>:设置jsp页面中使用的代码，如java;</li><li><code>buffer</code>:设置缓冲区的大小;</li><li><code>import</code>:倒入java代码中需要使用的包;</li><li><code>errorPage</code>:当前页面发生异常后，会自动跳转到指定的错误页面，如：<code>errorPage = &quot;500.jsp&quot;</code>;</li><li><code>isErrorPage</code>:标识当前页面是否是错误页面：<ul><li>true:是，可以使用<strong>内置对象exception</strong>;</li><li>false:否，默认值，不可以使用内置对象exception。</li></ul></li></ul></li><li>include：描述页面直接包含关系的指令，倒入页面的资源文件。<ul><li>如：<code>&lt;%@ include file = &quot;top.jsp&quot;&gt;</code></li></ul></li><li>taglib:用于导入资源，一般是标签库;<ul><li>如：<code>&lt;%@ taglib prefix=&quot;c&quot; uri = &quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;</code></li><li>prefix:自定义的前缀，使用标签库中的标签，前面必须带上的标识。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> JSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>会话技术-cookie</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF-cookie/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF-cookie/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="会话技术"><a class="markdownIt-Anchor" href="#会话技术"></a> 会话技术</h1><ul><li>会话：一次会话中包含多次请求和响应。<ul><li>一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止;</li></ul></li><li>功能：在一次会话的多次请求间，<strong>共享数据</strong>。</li><li>方式：<ol><li>客户端会话技术：Cookie</li><li>服务器端会话技术：Session</li></ol></li></ul><h1 id="cookie概念"><a class="markdownIt-Anchor" href="#cookie概念"></a> Cookie概念</h1><ul><li>客户端会话技术，将数据保存到客户端，来实现多次请求数据共享。</li><li>Cookie实现原理:基于响应头<code>set-cookie</code>和请求头<code>cookie</code>实现。</li><li>一次发送<strong>多个Cookie</strong>:<ul><li>可以同时创建多个Cookie对象，使用reponse调用多次addCookie方法发送cookie即可。</li></ul></li><li>cookie的特点：<ol><li>cookie存储数据在客户端浏览器（不安全）</li><li>浏览器对于单个<strong>cookie的大小</strong>有限制（一般为4kb);</li><li>浏览器对同一个域名下的<strong>总cookie数量</strong>也有限制(一般为20个)。</li></ol></li><li>cookie的作用：<ol><li>cookie一般用于存储少量不太敏感的数据;</li><li>在<strong>不登录</strong>的情况下，完成服务器对客户端的身份识别。</li></ol></li></ul><h1 id="快速入门"><a class="markdownIt-Anchor" href="#快速入门"></a> 快速入门</h1><ol><li>创建cookie对象，绑定数据:<code>new Cookie(String name, String value);</code><ol><li>同名的cookie的对象的数据会被覆盖掉。</li></ol></li><li>让response对象发送Cookie对象：<code>response.addCookie(Cookie cookie);</code></li><li>request对象会自动从客户端携带Cookie对象,我们从request对象获取Cookie:<code>Cookie[] request.getCookies()</code></li></ol><h1 id="cookie在浏览器中保存的时间"><a class="markdownIt-Anchor" href="#cookie在浏览器中保存的时间"></a> cookie在浏览器中保存的时间</h1><ul><li>默认情况下，<strong>当浏览器关闭后</strong>，Cookie数据被销毁。</li><li>持久化存储：<ul><li>使用Cookie对象中的setMaxAge对象。</li><li><code>setMaxAge(int seconds)</code><ul><li>正数：将Cookie数据写到<strong>硬盘</strong>中，来持久化存储。参数值指定cookie在磁盘中的存活时间，到时间删除硬盘中的cookie文件。</li><li>负数:默认值，当浏览器被关闭后删除cookie。</li><li>零：删除当前的cookie信息。</li></ul></li></ul></li></ul><h1 id="cookie的共享范围"><a class="markdownIt-Anchor" href="#cookie的共享范围"></a> Cookie的共享范围</h1><ul><li>在一个服务器的不同web项目间：<ul><li>默认情况下cookie不能在他们之间共享;</li><li>cookie对象的<code>setPath(String path)</code>方法：设置cookie的获取范围，默认情况下，设置的是当前项目的虚拟路径;</li><li>如果需要<strong>在一个服务器的多个项目间共享cookie</strong>，可以将path设置为<code>/</code>,代表当前服务器的根目录。</li></ul></li><li>在不同的tomcat服务器间共享cookie：<ul><li>通过cookie对象的<code>setDomain(String path)</code>方法。</li><li>如果设置的一级域名相同，那么多个服务器之间cookie也可以共享，如：<ul><li><code>setDomain(&quot;.baidu.com&quot;)</code>，则<code>tieba.baidu.com</code>和<code>news.baidu.com</code>中的cookie可以共享。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 后端 </tag>
            
            <tag> 会话技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BeanUtils</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/BeanUtils/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/BeanUtils/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="beanutils介绍"><a class="markdownIt-Anchor" href="#beanutils介绍"></a> BeanUtils介绍</h1><ul><li>BeanUtils是<strong>Apache commens</strong>组件里面的成员，由Apache提供的一套开源api，用于简化对<strong>javaBean</strong>的操作，能够对基本类型自动转换。</li><li>功能：封装数据;<ul><li>我们知道一个JavaBean通常包含了<strong>大量的属性</strong>，很多情况下，对JavaBean的处理导致了大量的get/set代码堆积，增加了代码长度和阅读代码的难度，而BeanUtils可以对Bean中的属性进行封装。</li></ul></li></ul><h2 id="javabean"><a class="markdownIt-Anchor" href="#javabean"></a> JavaBean</h2><ul><li>javaBean实质就是<strong>java类</strong>，只不过是遵循了某种规范的java类。</li><li>遵循的规范：<ol><li>类必须用public来修饰;</li><li>必须具有一个无参的构造方法</li><li>属性必须私有化</li><li>私有化的属性必须通过public类型的方法来暴露，也就是说要出现setXXX()、getXXX()或者isXXX()的方法;</li></ol></li><li>JavaBean示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Student &#123;private String name;private String id;private int age;private String sex;private Date d;public Student() &#123;super();&#125;public Date getD() &#123;return d;&#125;public void setD(Date d) &#123;this.d &#x3D; d;&#125;public String getName() &#123;return name;&#125;public void setName(String name) &#123;this.name &#x3D; name;&#125;public String getId() &#123;return id;&#125;public void setId(String id) &#123;this.id &#x3D; id;&#125;public int getAge() &#123;return age;&#125;public void setAge(int age) &#123;this.age &#x3D; age;&#125;public String getSex() &#123;return sex;&#125;public void setSex(String sex) &#123;this.sex &#x3D; sex;&#125;@Overridepublic String toString() &#123;return &quot;Student [name&#x3D;&quot; + name + &quot;, id&#x3D;&quot; + id + &quot;, age&#x3D;&quot; + age+ &quot;, sex&#x3D;&quot; + sex + &quot;, d&#x3D;&quot; + d + &quot;]&quot;;&#125;&#125;</code></pre><h2 id="配置beanutils"><a class="markdownIt-Anchor" href="#配置beanutils"></a> 配置BeanUtils</h2><ol><li>下载BeanUtils:<a href="http://commons.apache.org/proper/commons-beanutils/download_beanutils.cgi">官网</a>，下载好组件，再到项目里面引入jar文件。</li><li>导入核心包<ul><li>commons-beanutils-1.9.3.jar</li><li>commons-logging-1.2.jar</li><li>注意：当缺少日志jar包，会出现如下的报错情况。java.lang.NoClassDefFoundError: org/apache/commons/logging/LogFactory</li><li>logging组件的<a href="http://commons.apache.org/proper/commons-logging/download_logging.cgi">下载地址</a></li></ul></li></ol><h1 id="beanutils方法"><a class="markdownIt-Anchor" href="#beanutils方法"></a> BeanUtils方法</h1><ul><li>把orig中的值copy到dest中:<code>public void copyProperties(java.lang.Object dest, java.lang.Object orig)</code></li><li>把Bean的属性值放入到一个Map里面:<code>public java.util.Map describe(java.lang.Objectbean)</code></li><li>把properties里面的值放入bean中:<code> public void populate(java.lang.Object bean, java.util.Mapproperties)</code>;</li><li>设置Bean对象的名称为name的property的值为value:public void setProperty(java.lang.Object bean, java.lang.Stringname,java.lang.Object value);</li><li>取得bean对象中名为name的属性的值:<code>public String getProperty(java.lang.Object bean, java.lang.Stringname)</code>;</li><li>map数据封装到javaBean示例：<ul><li>注意：要map中的数据封装到JavaBean中去，需要map中的key与JavaBean里面的私有化的属性要相匹配</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void test() throws Exception &#123;&#x2F;&#x2F;创建对象Student s2&#x3D;new Student();&#x2F;&#x2F;1.map的数据拷贝到对象中去Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;String,Object&gt;();map.put(&quot;id&quot;,&quot;12233&quot;);map.put(&quot;name&quot;,&quot;老王&quot;);map.put(&quot;sex&quot;,&quot;男&quot;);BeanUtils.populate(s2, map);System.out.println(s2);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> BeanUtils </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/HTTP%E5%8D%8F%E8%AE%AE/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/HTTP%E5%8D%8F%E8%AE%AE/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="http协议的概念"><a class="markdownIt-Anchor" href="#http协议的概念"></a> HTTP协议的概念</h1><ul><li><strong>超文本传输协议（HTTP，HyperText Transfer Protocol)<strong>是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。它是TCP/IP协议的一个应用层协议简单来说，HTTP协议就是</strong>客户端和服务器交互</strong>的一种通迅的格式。</li><li>特点：<ul><li>基于TCP/IP的高级协议;</li><li>默认端口号：80;</li><li>基于请求响应模型：<strong>一次请求对应一次响应</strong></li><li>无状态：每次<strong>请求之间相互独立</strong>，不能交互数据.</li></ul></li></ul><h2 id="http10和http11"><a class="markdownIt-Anchor" href="#http10和http11"></a> HTTP1.0和HTTP1.1</h2><ul><li>HTTP1.0协议中，客户端与web服务器建立连接后，只能获得<strong>一个web资源</strong>【短连接，获取资源后就断开连接】</li><li>HTTP1.1协议，允许客户端与web服务器建立连接后，在一个连接上获取<strong>多个web资源</strong>【保持连接】</li></ul><h1 id="http请求"><a class="markdownIt-Anchor" href="#http请求"></a> HTTP请求</h1><ul><li>浏览器向服务器请求某个web资源时，称之为浏览器向服务器发送了一个http请求。一个完整http请求应该包含三个部分：<ol><li>请求行【描述客户端的请求方式、请求的资源名称，以及使用的HTTP协议版本号】</li><li>多个消息头【描述客户端请求哪台主机，以及客户端的一些环境信息等】</li><li>一个空行：分割POST请求的请求头和请求体；</li><li>请求体（正文：post方式才有）：封装POST请求消息的请求参数。</li></ol></li></ul><h2 id="请求行"><a class="markdownIt-Anchor" href="#请求行"></a> 请求行</h2><ul><li>请求行：<code>GET /java.html HTTP/1.1</code>。请求行中的<strong>GET称之为请求方式，之后跟请求的路径，最后是请求协议版本</strong>。请求方式有：POST,GET,HEAD,OPTIONS,DELETE,TRACE,PUT。</li><li>常用的请求方式有：<strong>POST,GET</strong><ul><li>一般来说，当我们点击超链接，通过地址栏访问都是get请求方式。通过表单提交的数据一般是post方式。</li><li>可以简单理解GET方式用来<strong>查询数据</strong>,POST方式用来<strong>提交数据</strong>，get的提交速度比post<strong>快</strong>。</li><li>GET方式：<ul><li>请求参数在请求行中（即url后）</li><li>请求的url是有限制的。</li></ul></li><li>POST方式：<ul><li>请求的参数在请求体中;</li><li>请求的url长度没有限制。</li></ul></li></ul></li></ul><h3 id="请求头"><a class="markdownIt-Anchor" href="#请求头"></a> 请求头</h3><ul><li>格式：<code>请求头名称：请求头值</code></li><li><strong>User-Agent</strong>: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)【浏览器告诉服务器，我访问你使用的浏览器的版本信息】<ul><li>可以在服务器端捕获该头的信息，解决浏览器的兼容问题。</li></ul></li><li><strong>Referer</strong>: <a href="http://www.it315.org/index.jsp%E3%80%90%E6%B5%8F%E8%A7%88%E5%99%A8%E5%91%8A%E8%AF%89%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E5%BD%93%E5%89%8D%E8%AF%B7%E6%B1%82%E6%98%AF%E4%BB%8E%E9%82%A3%E4%B8%AA%E9%A1%B5%E9%9D%A2%E6%9D%A5%E7%9A%84---%E5%8F%8D%E7%9B%97%E9%93%BE%E3%80%91">http://www.it315.org/index.jsp【浏览器告诉服务器，当前请求是从那个页面来的---反盗链】</a><ul><li>可以用作<strong>反盗链</strong>和<strong>统计流量来源信息</strong>。</li></ul></li><li>Accept: text/html,image/* 【浏览器告诉服务器，它支持的数据类型】</li><li>Accept-Charset: ISO-8859-1 【浏览器告诉服务器，它支持哪种字符集】</li><li>Accept-Encoding: gzip,compress 【浏览器告诉服务器，它支持的压缩格式】</li><li>Accept-Language: en-us,zh-cn 【浏览器告诉服务器，它的语言环境】</li><li>Host: <a href="http://www.it315.org:80">www.it315.org:80</a>【浏览器告诉服务器，它想访问哪台主机】</li><li>If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，缓存数据的时间】</li><li>Cookie【浏览器告诉服务器，带来的Cookie是什么】</li><li>Connection: close/Keep-Alive 【浏览器告诉服务器，请求完后是断开链接还是保持链接】</li><li>Date: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，请求的时间】</li></ul><h2 id="http响应"><a class="markdownIt-Anchor" href="#http响应"></a> HTTP响应</h2><ul><li>一个HTTP响应代表着服务器向浏览器回送数据。一个完整的HTTP响应应该包含四个部分:<ol><li>一个响应行【用于描述服务器对请求的处理结果。】</li><li>多个响应头【用于描述服务器的基本信息，以及数据的描述，服务器通过这些数据的描述信息，可以通知客户端如何处理等一会儿它回送的数据】</li><li>一个响应空行</li><li>响应体：服务器向客户端回送的数据</li></ol></li></ul><h3 id="响应行"><a class="markdownIt-Anchor" href="#响应行"></a> 响应行</h3><ul><li>格式： HTTP版本号　状态码　原因叙述</li><li>响应行：HTTP/1.1 200 OK</li><li>状态码用于表示服务器对请求的处理结果和响应的状态，它是一个三位的十进制数。响应状态码分为5类:<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201010121055.png" alt="" /><ol><li>1xx:服务器接收客户端消息，但没有接收完成，等待一段时间后，发送1xx代码;</li><li>2xx：成功。代表：200</li><li>3xx:重定向。代表：302（重定向），304（访问缓存）。</li><li>4xx：客户端错误<ol><li>404：请求路径没有对应资源;</li><li>405：请求方式没有对应的doXxx方法;</li></ol></li><li>5xx:服务器端错误。代表：500（服务器内部出现异常）。</li></ol></li></ul><h3 id="响应头"><a class="markdownIt-Anchor" href="#响应头"></a> 响应头</h3><ul><li>格式：头名称：值</li><li><strong>Content-Type</strong>: text/html; charset=UTF8 【服务器告诉浏览器本次响应体数据的格式（html）以及编码格式（UTF-8）】</li><li><strong>Content-Disposition</strong>:<ul><li>attachment; filename=aaa.zip【服务器告诉浏览器以下载方式打开数据】</li><li>in-line:默认值，在当前页面打开数据</li></ul></li><li>Location: <a href="http://www.it315.org/index.jsp">http://www.it315.org/index.jsp</a> 【服务器告诉浏览器要跳转到哪个页面】</li><li>Server:apache tomcat【服务器告诉浏览器，服务器的型号是什么】</li><li>Content-Encoding: gzip 【服务器告诉浏览器数据压缩的格式】</li><li>Content-Length: 80 【服务器告诉浏览器回送数据的长度】</li><li>Content-Language: zh-cn 【服务器告诉浏览器，服务器的语言环境】</li><li>Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT【服务器告诉浏览器该资源上次更新时间】</li><li>Refresh: 1;url=<a href="http://www.it315.org">http://www.it315.org</a>【服务器告诉浏览器要定时刷新】</li><li>Transfer-Encoding: chunked 【服务器告诉浏览器数据以分块方式回送】</li><li>Set-Cookie:SS=Q0=5Lb_nQ; path=/search【服务器告诉浏览器要保存Cookie】</li><li>Expires: -1【服务器告诉浏览器不要设置缓存】</li><li>Cache-Control: no-cache 【服务器告诉浏览器不要设置缓存】</li><li>Pragma: no-cache 【服务器告诉浏览器不要设置缓存】</li><li>Connection: close/Keep-Alive 【服务器告诉浏览器连接方式】</li><li>Date: Tue, 11 Jul 2000 18:23:51 GMT【服务器告诉浏览器回送数据的时间】</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XML</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/XML/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/XML/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="xml概述"><a class="markdownIt-Anchor" href="#xml概述"></a> XML概述</h1><p><a href="https://www.w3school.com.cn/xml/index.asp">参考手册</a></p><ul><li>概念：Extensible Markup Language 可扩展标记语言<ul><li>可扩展：标签都是自定义的。</li></ul></li><li>功能：<ul><li>存储数据<ul><li>作为配置文件</li><li>在网络中传输</li></ul></li></ul></li><li>XML与HTML：<ul><li>都是w3c（万维网联盟）的产物</li><li>xml的标签都是自定义的，html的标签是预定义的；</li><li>xml的语法严格，html的语法松散；</li><li>xml是存储数据的，html是展示数据的。</li></ul></li></ul><h1 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h1><ul><li>xml文档的后缀名为<code>xml</code>;</li><li>xml文档的<strong>第一行</strong>定义为<strong>文档声明</strong>。</li><li>xml中<strong>有且仅有一个根标签</strong>。</li><li>属性值必须用引号（单双均可）引起来。</li><li>标签必须正确关闭（要么是围堵标签，要么是自闭和标签）;</li><li>xml标签名称<strong>区分大小写</strong>。</li></ul><h1 id="组成部分"><a class="markdownIt-Anchor" href="#组成部分"></a> 组成部分</h1><ol><li>文档声明<ol><li>格式：<code>&lt;?xml 属性列表 ?&gt;</code></li><li>属性列表：<ol><li>version:版本号，<strong>必须的属性</strong>;</li><li>encoding:编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1</li><li>standalone:是否独立，一般不会用</li></ol><ul><li>yes：不依赖于其他文件</li><li>no：依赖其他文件</li></ul></li></ol></li><li>指令<ol><li>示例：<code>&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot;&gt;</code></li></ol></li><li>标签<ul><li>名称可以含字母、数字以及其他的字符</li><li>名称不能以数字或者标点符号开始</li><li>名称不能以字符 “xml”（或者 XML、Xml）开始</li><li>名称不能包含空格</li></ul></li><li>属性<ul><li>id属性值唯一</li></ul></li><li>文本<ul><li><strong>CDATA</strong>区：在该区域中的数据会被原样展示<ul><li>格式：<code>&lt;![CDATA[需要展示的数据]]&gt;</code></li></ul></li></ul></li></ol><h1 id="约束"><a class="markdownIt-Anchor" href="#约束"></a> 约束</h1><ul><li>约束：规定XML文档的书写规则</li><li>XML与约束之间的关系图：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201225180146.png" alt="" /></li><li>分类：<ul><li>DTD:简单的约束技术</li><li>Schema:复杂的约束技术</li></ul></li><li>DTD：<ul><li><a href="https://www.w3school.com.cn/dtd/dtd_intro.asp">参考资料</a></li><li>约束文件名的后缀为<code>.dtd</code></li><li>引入dtd文档到xml文档中，之后如果xml的书写不满足dtd文档的规范，则会报错。<ul><li>内部dtd：将约束规则定义在xml文档中<ul><li>样式；<code>&lt;!DOCTYPE 根标签名 [dtd约束规则内容]&gt;</code></li></ul></li><li>外部dtd：将约束的规则定义在外部的dtd文件中<ul><li>本地：<code>&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件在本机的位置（相对路径）&quot;&gt;</code></li><li>网络:<code>&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd在本地的文件名&quot;&quot;dtd文件在网络的位置（URL）&quot;&gt;</code></li></ul></li></ul></li><li>无法规定标签内的内容</li></ul></li><li>Schema:<ul><li><a href="https://www.w3school.com.cn/schema/index.asp">参考资料</a></li><li>是DTD的替代者，可以规定标签体内的内容格式。</li><li>Schema文档的后缀名为<code>.xsd</code></li><li>在xml文档中引入Schema文档：<ol><li>填写xml文档的的<strong>根元素</strong></li><li>引入xsi前缀：<code>xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</code>,后面的内容又很多种选择，可以根据ide的提示内容来选择。</li><li>引入xsd文件的命名空间：<code>xsi:schemaLocation=&quot;http://www.w3school.com.cn note.xsd&quot;</code>前面的内容可以自定义，后面的内容是xsd文件名</li><li>为每一个xsd约束声明一个前缀，作为标识：<code>xmlns=&quot;http://www.w3school.com.cn</code>或者<code>xmlns:a=&quot;http://www.w3school2.com.cn</code>,如果没有指定前缀的话则默认为空前缀。</li><li>引入的每个xsd文件对应一个前缀，该xsd文件内的标签在使用时必须带上该xsd文件的前缀，（空前缀除外）。如：<code>&lt;students&gt;&lt;/students&gt;</code>和<code>&lt;a:students&gt;&lt;/a:students&gt;</code></li></ol></li></ul></li></ul><h1 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h1><ul><li>对xml文档的操作：<ol><li>解析（读取）：将文档中的数据<strong>读取到内存中</strong>。</li><li>写入：将内存中的数据保存到xml文档中，持久化的存储。</li></ol></li><li>解析xml的方式：<ol><li>DOM：将标记语言文档<strong>一次性</strong>加载进内存，在内存中形成一颗DOM树。<ol><li>优点：操作方便，可以对文档进行<strong>CRUD</strong>的所有操作。</li><li>缺点:因为一次性读取，且DOM树占内存，所以十分消耗内存。</li></ol></li><li>SAX：<strong>逐行</strong>读取，基于事件驱动的。<ol><li>优点：不占内存</li><li>缺点：<strong>只能读取</strong>，不能CRUD。</li></ol></li></ol></li><li>XML常见的解析器：基于不同的解析的方式写出来的<strong>工具包</strong>。<ul><li>JAXP：sun公司提供的解析器，支持DOM和SAX思想，不常用。</li><li>DOM4J:非常优秀的基于DOM思想的解析器。</li><li>Jsoup:jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。也可以用来解析XML。</li><li>PULL：Android操作系统内置的解析器，基于SAX思想。</li></ul></li></ul><h1 id="jsoup"><a class="markdownIt-Anchor" href="#jsoup"></a> Jsoup</h1><h2 id="快速入门"><a class="markdownIt-Anchor" href="#快速入门"></a> 快速入门</h2><ul><li>步骤：<ol><li>导入jar包<ol><li>在<a href="https://jsoup.org/download">官网</a>下载jar包</li></ol></li><li>获取Document对象<ol><li>获取对应xml的路径：<code>String path = JsoupDemo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();</code>即：<code>String path = 类名.class.getClassLoader().getResource(&quot;xml文档名&quot;).getPath();</code></li><li>解析xml文档，加载文档进内存，获取DOM树（对应Document对象）：<code>Document document = Jsoup.parse(new File(path),&quot;utf-8&quot;);</code> 即：<code>Document document = Jsoup.parse(new File(path),&quot;和xml文档一致的字符集&quot;);</code></li></ol></li><li>获取对应的标签（Element对象）<ol><li><code>Elements elements = document.getElementsByTagName(&quot;student&quot;);</code></li></ol></li><li>获取数据<ol><li>获取元素对象：<code>Elements elements = document.getElementsByTag(&quot;name&quot;);</code>即：<code>Elements elements = Document对象名.getElementsByTag(&quot;标签名&quot;);</code></li><li>Elements是一个类似集合的对象，它里面会依次存好符合条件的所有元素对象。<ol><li>获取指定对象:<code>elements.get(0);</code></li><li>获取指定对象，如：<code>elemets.get(0).text();</code></li></ol></li></ol></li></ol></li><li>示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package xml.jsoup;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.select.Elements;import java.io.File;import java.io.IOException;public class JsoupDemo1 &#123;    public static void main(String[] args) throws IOException &#123;        &#x2F;&#x2F;1.获取Document对象        &#x2F;&#x2F;1.1获取xml文件的路径        String path &#x3D; JsoupDemo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();        &#x2F;&#x2F;1.2获取Document对象        Document document &#x3D; Jsoup.parse(new File(path), &quot;UTF-8&quot;);        &#x2F;&#x2F;2.获取对应的xml标签        Elements e &#x3D;  document.getElementsByTag(&quot;student&quot;);        System.out.println(e.text());    &#125;&#125;</code></pre><h2 id="对象的使用"><a class="markdownIt-Anchor" href="#对象的使用"></a> 对象的使用</h2><ul><li>Jsoup:工具类，可以解析html或xml文档，返回Document对象<ul><li>parse方法：解析html或者xml文档，返回Document对象<ul><li><code>parse(File in ,String charseName)</code>:解析本地的xml或html文件</li><li><code>parse(String html)</code>:解析xml或者html字符串；</li><li><code>parse(URL url, int timeoutMills);</code>:通过网络路径获取指定的html或xml的文档对象。（可以用来爬虫）<ul><li>timeoutMills：指的是<strong>超时时间</strong>，如果超过这个时间还没有响应的话则认为获取失败。</li></ul></li></ul></li></ul></li><li>Document:文档对象，代表内存中的DOM树<ul><li>用于获取任意Element对象：<ul><li><code>getElementById(String id)</code>:根据id属性值获取唯一的element对象；</li><li><code>getElemnetsByTag(String tagName)</code>:根据标签名称获取元素对象<strong>集合</strong>；</li><li><code>getElementsByAttribute(String key)</code>:根据属性名称获取元素对象的<strong>集合</strong></li><li><code>getElementsByAttributeValue(String key, String value)</code>:根据对应的<strong>属性名和属性值</strong>获取元素的集合。</li></ul></li></ul></li><li>Elements：元素ELement对象的集合，可以当作<code>ArrayList&lt;Element&gt;</code>来使用</li><li>Element：元素对象<ul><li>同样的方法但是只能获取当前元素的子元素对象：<ul><li><code>getElementById(String id)</code>:根据id属性值获取唯一的element对象；</li><li><code>getElemnetsByTag(String tagName)</code>:根据标签名称获取元素对象<strong>集合</strong>；</li><li><code>getElementsByAttribute(String key)</code>:根据属性名称获取元素对象的<strong>集合</strong></li><li><code>getElementsByAttributeValue(String key, String value)</code>:根据对应的<strong>属性名和属性值</strong>获取元素的集合。</li></ul></li><li>获取属性：<ul><li><code>String attr(String key)</code>:根据属性名称获取属性值</li></ul></li><li>获取文本内容：<ul><li><code>String text()</code>:获取文本内容；</li><li><code>String html()</code>:获取标签体的所有内容（包括子标签的字符串内容）</li></ul></li></ul></li><li>Node：节点对象。<ul><li>是Document和Element的父类。</li></ul></li></ul><h2 id="快速查询"><a class="markdownIt-Anchor" href="#快速查询"></a> 快速查询</h2><h3 id="selector选择器"><a class="markdownIt-Anchor" href="#selector选择器"></a> selector:选择器</h3><ul><li>使用的方法：<code>Elements select(String cssQuery)</code>;</li><li>语法：<ul><li>cssQuery是将css选择器的写法，写到一个字符串中，可以类比css选择器理解</li><li>参照jsoup-javadoc中的网页文档查找selector理解。</li></ul></li><li>示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;查询name标签Elements elements &#x3D; document.select(&quot;name&quot;);&#x2F;&#x2F;查询id值为zhangjie的元素ELements elements &#x3D; document.select(&quot;#zhangjie&quot;);&#x2F;&#x2F;获取student标签并且number属性值为java的age子标签&#x2F;&#x2F;1.获取student标签并且number属性值为javaElements elements &#x3D; document.select(&quot;student[number&#x3D;\&quot;java\&quot;]&quot;);&#x2F;&#x2F;2.获取age子标签Elements elemetns &#x3D; document.select(&quot;student[number&#x3D;\&quot;java\&quot;] &gt; age&quot;);</code></pre><h3 id="xpath"><a class="markdownIt-Anchor" href="#xpath"></a> XPath</h3><p><a href="https://www.w3school.com.cn/xpath/index.asp">参考文档</a></p><ul><li>XPath是一门在 XML 文档中查找信息的语言。XPath 用于在 XML 文档中通过元素和属性进行导航。</li><li>使用Jsoup的xpath需要额外jar包：JsoupXpath-x.x.x.jar</li><li>使用步骤：<ol><li>获取Document对象</li><li>根据Document对象创建JXDocument对象：<ol><li><code>JXDocument jxDocument = new JXDocument(document);</code></li></ol></li><li>集合xpath语法查询<ol><li><code>List&lt;JXNode&gt; jxNodes = jxDocument.selN(&quot;xpath语法&quot;);</code></li></ol></li></ol></li><li>示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;查询所有student标签List&lt;JXNode&gt; jxNodes &#x3D; jxDocuement.selN(&quot;&#x2F;&#x2F;student&quot;);&#x2F;&#x2F;查询所有student标签下的name标签List&lt;JXNode&gt; jxNodes &#x3D; jxDocument.selN(&quot;&#x2F;&#x2F;student&#x2F;name&quot;);&#x2F;&#x2F;查询student标签下带有id属性的name标签且id属性值为zhangjieList&lt;JXNode&gt; jxNodes &#x3D; jxDocument.selN(&quot;&#x2F;&#x2F;student&#x2F;name[@id&#x3D;&#39;zhangjie&#39;]);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 前端 </tag>
            
            <tag> XML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bootstrap</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%89%8D%E7%AB%AF/Bootstrap/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%89%8D%E7%AB%AF/Bootstrap/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="bootstrap概述"><a class="markdownIt-Anchor" href="#bootstrap概述"></a> Bootstrap概述</h1><p><a href="https://www.bootcss.com/">官网</a></p><ul><li>基于HTML，CSS，JavaScript的前端开发框架。<ul><li><strong>框架</strong>：一个半成品软件，开发人员可以在框架基础上，再进行开发，简化编码。</li></ul></li><li>优点：<ul><li>定义了很多<strong>css样式</strong>和<strong>js插件</strong>。</li><li><strong>响应式布局</strong>：同一套页面可以兼容不同分辨率的设备。</li></ul></li><li>快速入门：<ol><li><a href="https://v3.bootcss.com/getting-started/#download">下载Bootstrap</a></li><li>在项目中将三个文件夹复制进来；</li><li>创建html文件，引入必要的资源文件（即下载的文件夹中的文件）<ol><li>jquery的min.js文件需要手动去<a href="https://www.jq22.com/jquery-info122">下载</a>并放到js文件夹下</li><li>输入的寻找资源文件的路径要与当前html所在位置相匹配。</li></ol></li></ol></li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot;&gt;    &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;    &lt;title&gt;Bootstrap 101 Template&lt;&#x2F;title&gt;    &lt;!-- Bootstrap --&gt;    &lt;link href&#x3D;&quot;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;&lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;    &lt;script src&#x3D;&quot;js&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;    &lt;script src&#x3D;&quot;js&#x2F;bootstrap.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;!-- HTML5 shim 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media queries）功能 --&gt;    &lt;!-- 警告：通过 file:&#x2F;&#x2F; 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 --&gt;    &lt;!--[if lt IE 9]&gt;    &lt;script src&#x3D;&quot;dist&#x2F;html5shiv.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script src&#x3D;&quot;dest&#x2F;respond.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;![endif]--&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h1&gt;你好，世界！&lt;&#x2F;h1&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h1 id="响应式布局"><a class="markdownIt-Anchor" href="#响应式布局"></a> 响应式布局</h1><ul><li>同一套页面可以兼容不同分辨率的设备。</li><li>实现：依赖于<strong>栅格系统</strong>。<ul><li>栅格系统：将一行平均分为<strong>12个格子</strong>，可以指定元素占几个格子。</li></ul></li><li>步骤：<ul><li>定义容器。相当于table，通过<strong>class</strong>设置<ul><li>容器分类：<ol><li>container:两边有留白，除非设备特别小。</li><li>container-fluid：每种设备都是占100%</li></ol></li></ul></li><li>定义行。相当于tr ，通过class设置为row</li><li>定义元素。指定该元素在不同的设备上，所占格子的数目。样式<code>col-设备代号-格子数目</code><ul><li>设备代号：<ol><li>xs: 超小屏幕 手机(&lt;768px)</li><li>sm: 小屏幕 平板(&gt;=768px)</li><li>md: 中等屏幕 桌面显示器(&gt;=992px)</li><li>lg: 超大屏幕 大桌面显示器(&gt;=1200px)</li></ol></li></ul></li></ul></li><li>注意：<ul><li>一行中如果格子数目超过12，则<strong>超出部分自动换行</strong></li><li>栅格类属性可以<strong>向上兼容</strong>。栅格类适用于与屏幕宽度大于或者等于分界点大小的设备。</li><li>栅格类属性<strong>不向下兼容</strong>，如果真实设备宽度<strong>小于</strong>了设置栅格类属性的设备代号的最小值，会<strong>一个元素占满一整行</strong></li></ul></li><li>示例：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot;&gt;    &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;    &lt;title&gt;Bootstrap 101 Template&lt;&#x2F;title&gt;    &lt;!-- Bootstrap --&gt;    &lt;link href&#x3D;&quot;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;    &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;    &lt;script src&#x3D;&quot;js&#x2F;jquery-3.5.1.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;    &lt;script src&#x3D;&quot;js&#x2F;bootstrap.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;!-- HTML5 shim 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media queries）功能 --&gt;    &lt;!-- 警告：通过 file:&#x2F;&#x2F; 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 --&gt;    &lt;!--[if lt IE 9]&gt;    &lt;![endif]--&gt;    &lt;style&gt;        .inner &#123;            border:1px solid red;            width: 50px;            height: 50px;        &#125;    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;!--定义容器--&gt;&lt;div class&#x3D;&quot;container-fluid&quot;&gt;    &lt;!--定义行--&gt;    &lt;div class&#x3D;&quot;row&quot;&gt;        &lt;!--定义元素--&gt;        &lt;div class&#x3D;&quot;col-lg-1 col-sm-2 inner&quot;&gt;栅格&lt;&#x2F;div&gt;        &lt;div class&#x3D;&quot;col-lg-1 col-sm-2 inner&quot;&gt;栅格&lt;&#x2F;div&gt;        &lt;div class&#x3D;&quot;col-lg-1 col-sm-2 inner&quot;&gt;栅格&lt;&#x2F;div&gt;        &lt;div class&#x3D;&quot;col-lg-1 col-sm-2 inner&quot;&gt;栅格&lt;&#x2F;div&gt;        &lt;div class&#x3D;&quot;col-lg-1 col-sm-2 inner&quot;&gt;栅格&lt;&#x2F;div&gt;        &lt;div class&#x3D;&quot;col-lg-1 col-sm-2 inner&quot;&gt;栅格&lt;&#x2F;div&gt;        &lt;div class&#x3D;&quot;col-lg-1 col-sm-2 inner&quot;&gt;栅格&lt;&#x2F;div&gt;        &lt;div class&#x3D;&quot;col-lg-1 col-sm-2 inner&quot;&gt;栅格&lt;&#x2F;div&gt;        &lt;div class&#x3D;&quot;col-lg-1 col-sm-2 inner&quot;&gt;栅格&lt;&#x2F;div&gt;        &lt;div class&#x3D;&quot;col-lg-1 col-sm-2 inner&quot;&gt;栅格&lt;&#x2F;div&gt;        &lt;div class&#x3D;&quot;col-lg-1 col-sm-2 inner&quot;&gt;栅格&lt;&#x2F;div&gt;        &lt;div class&#x3D;&quot;col-lg-1 col-sm-2 inner&quot;&gt;栅格&lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h1 id="css样式和js插件"><a class="markdownIt-Anchor" href="#css样式和js插件"></a> css样式和js插件</h1><h2 id="全局css样式"><a class="markdownIt-Anchor" href="#全局css样式"></a> 全局css样式</h2><ul><li>使用时<a href="https://v3.bootcss.com/css/#overview">查阅文档</a>，通过设置<strong>class</strong>属性实现。</li><li>按钮：<ul><li>设置class实现样式，如：<code>class=&quot;btn btn-default&quot;</code></li></ul></li><li>图片：<ul><li>占比，如：<code>class=&quot;img-responsive&quot;</code></li><li>形状等</li></ul></li><li>表格</li><li>表单等。。。</li></ul><h2 id="组件"><a class="markdownIt-Anchor" href="#组件"></a> 组件</h2><ul><li><a href="https://v3.bootcss.com/components/">参考文档</a>,需要在文档中复制一段代码来实现对应的功能。</li><li>导航条；</li><li>分页条等。。。</li></ul><h2 id="js插件"><a class="markdownIt-Anchor" href="#js插件"></a> js插件</h2><ul><li><a href="https://v3.bootcss.com/javascript/">文档</a>,需要在文档中复制一段代码来实现对应的功能。</li><li>轮播图(Carousel)等。。。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> BootStrap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%89%8D%E7%AB%AF/JavaScript/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%89%8D%E7%AB%AF/JavaScript/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="javascript概述"><a class="markdownIt-Anchor" href="#javascript概述"></a> JavaScript概述</h1><p><a href="https://www.w3school.com.cn/js/index.asp">参考资料</a></p><ul><li>概念：一门客户端脚本语言<ul><li>运行在客户端浏览器中。每一个浏览器都有JavaScript的解析引擎。</li><li><strong>脚本语言</strong>；不需要编译，直接就可以被浏览器解析执行。</li></ul></li><li>功能：可以用来<strong>增强用户与html页面的交互过程</strong>，可以控制html元素，让页面有一些动态效果。</li><li>JavaScript发展史：<ol><li>1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为：c–，后来更名为ScriptEase。</li><li>1995年，Netbase（网景）公司，开发出一门客户端脚本语言：LiveScript；之后，该公司请来Sun公司的专家，修改LiveScript，命名为JavaScript。</li><li>1996年，微软抄袭了JavaScript开发出了JScript语言；</li><li>1997年，ECMA（欧洲计算机制造商协会），制定了ECMAScript，就是所有客户端脚本语言的标准。</li></ol></li><li>JavaScript=ECMAScript + JavaScript自己特有的东西(BOM+DOM)。</li></ul><h1 id="ecmascript"><a class="markdownIt-Anchor" href="#ecmascript"></a> ECMAScript</h1><h2 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h2><h3 id="与html结合的方式"><a class="markdownIt-Anchor" href="#与html结合的方式"></a> 与html结合的方式</h3><ol><li>内部JS<ol><li>定义一个<code>&lt;script&gt;&lt;/script&gt;</code>标签，标签体内容就是js代码。</li><li>示例：</li></ol></li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;script&gt;    alert(&quot;hello world&quot;);&lt;&#x2F;script&gt;</code></pre><ol start="2"><li>外部JS<ol><li>定义一个<code>&lt;script&gt;&lt;/script&gt;</code>标签，通过src属性引入外部的js文件。</li><li>示例：</li></ol></li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;script src&#x3D;&quot;js&#x2F;a.js&quot;&gt;&lt;&#x2F;script&gt;</code></pre><ul><li><code>&lt;script&gt;</code>标签可以写在html页面的任何位置，但是定义的位置的先后会<strong>影响执行顺序</strong>。</li><li>同一个html页面<strong>可以定义多个<code>&lt;script&gt;</code>标签</strong>。</li></ul><h3 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h3><ul><li>单行注释：//注释内容</li><li>多行注释：/* 注释内容 */</li></ul><h3 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h3><ul><li>原始数据类型（类似java中的基本数据类型）<ul><li>number:数字。<ul><li>整数</li><li>小数</li><li>NaN(not a number 一个不是数字的数字类型)</li></ul></li><li>string:字符串<ul><li>“abc”,“a”,'a’都是字符串，没有字符类型。</li></ul></li><li>null:一个对象为空的占位符。</li><li>undefined:未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined。</li><li>boolean：布尔值类型，值为true或者false。</li></ul></li><li>引用数据类型：对象。</li></ul><h3 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h3><ul><li>变量定义：一小块存储数据的内存空间</li><li>java是强类型语言，JavaScript是弱类型语言<ul><li>强类型：在开辟变量存储空间时，定义了空间将来存储的数据类型。<strong>只能存储固定类型的数据</strong>。</li><li>弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，<strong>可以存放任意类型的数据</strong>。</li></ul></li><li>语法:<code>var 变量名;</code>或者<code>var 变量名 = 初始化值;</code></li><li>查看数据类型：<code>typeof(变量名);</code>,会返回变量的类型。</li><li>输出数据到页面中<code>document.write(输出的数据);</code>,如：<code>document.write(a+&quot;我是a&quot;+&quot;&lt;br&gt;&quot;);</code></li></ul><h3 id="运算符"><a class="markdownIt-Anchor" href="#运算符"></a> 运算符</h3><ul><li>一元运算符：<ul><li><code>++</code>:自增</li><li><code>--</code>:自减（同java一样，也有放在前后的问题）</li><li><code>+/-</code>:正负号。</li></ul></li><li>算数运算符：<ul><li><code>+</code>:加法</li><li><code>-</code>:减法</li><li><code>*</code>:乘法</li><li><code>/</code>:除法，与java不同的是，除法的结果<strong>可以为小数</strong>.</li><li><code>%</code>:取余运算。</li></ul></li><li>赋值运算符：<ul><li><code>=</code>；赋值</li><li><code>+=</code></li><li><code>-=</code>:与java相同。</li></ul></li><li>比较运算符：<ul><li>类型相同，直接比较，如果是字符串则按照字典顺序<strong>按位逐个比较</strong>，直到得出大小。</li><li>类型不同，<strong>转换后再相比</strong>。</li><li><code>&gt;,&lt;，&gt;=，&lt;=</code>:大于、小于,大于等于，小于等于</li><li><code>===</code>:比较之前先判断类型，如果<strong>类型不相同则直接返回false</strong>。</li></ul></li><li>逻辑运算符：<ul><li><code>&amp;&amp;</code>:与，有短路效果(如果左边能够确定表达式的值，那么右边就不会再运算)</li><li><code>||</code>:或，也有短路效果。</li><li><code>!</code>:非，该运算符要求变量类型是boolean。</li></ul></li><li>三元运算符：<ul><li><code>?:</code>:<ul><li>语法：<code>表达式?值1:值2</code></li><li>判断表达式的值，如果是true则取值1，否则取值2；</li><li>示例：<code>a &gt; b ? 1:0;</code></li></ul></li></ul></li><li>在JavaScript中如果运算数不是运算符所要求的类型，那么js引擎会自动地将运算数进行类型转换。<ul><li>其它类型转number：<ul><li>String转number：会按照字面值转换，如果<strong>字面值不是数字，那么转换为NaN</strong>.（NaN与任何数运算的结果还是NaN）</li><li>boolean转number：true转为1，false转为0。</li><li>其它类型转换为number就是<strong>NaN</strong>。</li></ul></li><li>其它类型转boolean：<ul><li>number转为boolean：<strong>0或NaN</strong>为false，其它为true。</li><li>string转为boolean：<strong>空字符串</strong>为false，其它都为true。空字符串：<code>string str=&quot;&quot;;</code></li><li>null和undefined转为boolean：<strong>都是false</strong>。</li></ul></li></ul></li></ul><h3 id="特殊语法"><a class="markdownIt-Anchor" href="#特殊语法"></a> 特殊语法</h3><ul><li>语句以分号结尾，如果一行只有一条语句，则分号可以省略（但是一般不建议）；</li><li>变量的定义使用var关键字，也可以不使用：（不建议使用）<ul><li>使用var定义的局部变量</li><li>不使用var定义的是全局变量</li></ul></li></ul><h3 id="流程控制语句"><a class="markdownIt-Anchor" href="#流程控制语句"></a> 流程控制语句</h3><ul><li><code>if...else</code>:与java中相同</li><li><code>switch</code>:<ul><li>在java中，switch可以接收的数据类型：byte，int,short ,char ,枚举(1.5之后)，string(1.7之后)；</li><li>在JavaScript中，switch可以接收任意类型的变量。</li></ul></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var a &#x3D; &quot;hello&quot;;switch(a) &#123;  case 1:      alert(&quot;number&quot;);      break;  case &quot;hello&quot;:      alert(&quot;string&quot;);      break;  case undefined:      alert(&quot;undefined&quot;);      break;&#125;</code></pre><ul><li><code>while</code>:与java一样。</li><li><code>for</code>:与java一样</li><li><code>do...while</code>:与java一样。</li></ul><h3 id="示例99乘法表"><a class="markdownIt-Anchor" href="#示例99乘法表"></a> 示例：99乘法表</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;99乘法表&lt;&#x2F;title&gt;    &lt;style&gt;        td&#123;            border: 1px solid ;        &#125;    &lt;&#x2F;style&gt;        &lt;script&gt;        document.write(&quot;&lt;table align&#x3D;&#39;center&#39;&gt;&quot;); &#x2F;&#x2F;在JavaScript的字符串中嵌套html的语句中如果含有双引号，则全部使用单引号，防止和字符串的双引号起冲突        for(var i &#x3D; 1; i &lt;&#x3D; 9; i++) &#123;            document.write(&quot;&lt;tr&gt;&quot;);            for(var j &#x3D; 1; j &lt;&#x3D; i; j++) &#123;                document.write(&quot;&lt;td&gt;&quot;);                document.write(i + &quot;*&quot; + j + &quot;&#x3D;&quot; + i * j + &quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;);&#x2F;&#x2F;&amp;nbsp                document.write(&quot;&lt;&#x2F;td&gt;&quot;);            &#125;            document.write(&quot;&lt;&#x2F;tr&gt;&quot;);        &#125;        document.write(&quot;&lt;&#x2F;table&gt;&quot;);    &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><ul><li>效果：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201214170043.jpg" alt="" /></li><li>在html代码中，使用转义字符<code>&amp;nbsp</code>表示1个空格,在html代码中每输入一个转义字符<code>&amp;nbsp</code>就表示一个空格，输入十个<code>&amp;nbsp</code>，页面中就显示10个空格位置。而在html代码中输入空格，<strong>不管输入多少个空格，最终在页面中显示的空格位置只有一个</strong>。</li><li>在JavaScript的字符串中嵌套html的语句中如果含有双引号，则全部<strong>使用单引号</strong>，防止和字符串的双引号起冲突。</li></ul><h2 id="基本对象"><a class="markdownIt-Anchor" href="#基本对象"></a> 基本对象</h2><h3 id="function对象"><a class="markdownIt-Anchor" href="#function对象"></a> Function对象</h3><ul><li>Function对象：函数（方法）对象</li><li>创建：<ol><li>不常用：<code>var fun = new Function(形式参数列表，方法体);</code></li><li>常用1：<code>function 函数名(形式参数列表) &#123;方法体&#125;</code>示例：</li></ol></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function fun1(a,b) &#123;  alert(a + b);&#125;</code></pre><ol start="3"><li>常用2：<code>var 方法名 = function(形式参数列表) &#123;方法体&#125;</code>示例：</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var fun2 &#x3D; function(a, b) &#123;  alert(a + b);&#125;</code></pre><ul><li>特点：<ul><li>方法定义时，<strong>不用写形参的类型</strong>，也不用写<strong>返回值类型</strong>。</li><li><strong>方法是一个对象</strong>，如果定义名称相同的方法，会覆盖而不会报错。</li><li>在js中，方法的调用只与方法名有关，和<strong>形参列表无关</strong>（即使传入的参数不符合形参列表，也没有问题，如果传少了，则默认传了undefined，如果传多了，则不管多的）。</li><li>在方法声明中有一个隐藏的内置对象（数组对象）<code>arguments</code>,封装了所有传进函数的<strong>参数</strong>。</li></ul></li><li>属性：<ul><li>length:方法对象中<strong>形参</strong>的个数。</li></ul></li><li>调用：<ul><li><code>方法名(实际参数列表);</code></li></ul></li></ul><h3 id="array对象"><a class="markdownIt-Anchor" href="#array对象"></a> Array对象</h3><ul><li>Array:数组对象</li><li>创建：<ol><li><code>var arr = new Array(元素列表);</code></li><li><code>var arr = new Array(默认长度);</code></li><li><code>var arr = [元素列表];</code></li><li><code>var arr = new Array();</code></li></ol></li><li>特点：<ul><li>JS中，数组中元素类型是可变的，如：<code>var arr = [1, &quot;hello&quot;,true];</code></li><li>JS中，数组的长度是可变的，定义时写的只是默认的长度。</li></ul></li><li>方法；<ul><li><code>join(参数)</code>:将数组中的元素按照**指定的分隔符（参数）**拼接为字符串。直接打印数组，会默认按照<code>,</code>为分隔符的方式拼接字符为字符串:<code>document.write(arr);</code>或者没有给join指定参数也是默认为<code>,</code>。返回一个字符串。<ul><li>示例：<code>document.write(arr.join(&quot;--&quot;));</code></li></ul></li><li><code>push();</code>:向数组末尾添加一个或者更多元素，并返回<strong>新的长度</strong>。</li></ul></li></ul><h3 id="boolean对象"><a class="markdownIt-Anchor" href="#boolean对象"></a> Boolean对象</h3><ul><li>基本类型boolean的包装类。</li></ul><h3 id="date对象"><a class="markdownIt-Anchor" href="#date对象"></a> Date对象</h3><ul><li>Date：日期对象；</li><li>创建：<ol><li><code>var date = new Date();</code></li></ol></li><li>方法：<ul><li><code>toLocalString();</code>:返回当前Date对象对应的时间本地字符串格式。</li><li><code>getTime();</code>:获取毫秒值，返回当前日期对象描述的时间到1970年1月1日零点的毫秒值差。</li></ul></li></ul><h3 id="math对象"><a class="markdownIt-Anchor" href="#math对象"></a> Math对象</h3><ul><li>Math:数学对象</li><li>创建：<ol><li>不用创建，直接使用，<code>Math.方法名();</code></li></ol></li><li>方法：<ul><li><code>random();</code>:返回0~1之间的随机数（包含0，不包含1）</li><li><code>round(x);</code>:对数字进行四舍五入取整；</li><li><code>ceil(x)</code>:对数进行上舍入取整；</li><li><code>floor(x);</code>对数进行下舍入取整。</li></ul></li></ul><h3 id="regexp对象"><a class="markdownIt-Anchor" href="#regexp对象"></a> RegExp对象</h3><ul><li>正则表达式对象；</li><li>正则表达式：定义字符串的组成规则；<ul><li>单个字符：<code>[]</code><ul><li>如:<code>[a]</code>:该字符为需要为a；<code>[ab]</code>:该字符可以为a或者b；<code>[a-zA-Z0-9]</code>:该字符可以为大写字母或者小写字母或者0到9的数字。</li><li><strong>特殊符号</strong>代表特殊含义的单个字符<ul><li><code>\d</code>:单个数字字符<code>[0-9]</code></li><li><code>\w</code>:单个字符：<code>[a-zA-Z0-9]</code>;</li></ul></li></ul></li><li>量词符号：<ul><li><code>?</code>:出现0次或者1次；</li><li><code>*</code>:表示0次或者多次；</li><li><code>+</code>:出现1次或者多次；</li><li><code>&#123;m,n&#125;</code>:表示<code>m&lt;=次数 &lt;=n</code><ul><li>m如果缺省，<code>&#123;:n&#125;</code>表示最多n次；</li><li>n如果缺省：<code>&#123;m:&#125;</code>表示最少m次。</li><li>{m}:表示只能出现m次。</li></ul></li></ul></li><li>开始结束符号：<ul><li><code>^</code>:开始</li><li><code>$</code>:结束</li></ul></li></ul></li><li>创建：<ol><li><code>var reg = new RegExp(&quot;正则表达式&quot;);</code><ol><li>该种类型要注意字符串内部的特殊符号需要<strong>转义</strong></li><li>如：<code>\</code>在字符串内需要表达为<code>\\</code>,所以：<code>var reg - new  RegExp(&quot;^\\w(6,12)$);</code></li></ol></li><li><code>var reg = /正则表达式/;</code></li><li>示例：<code>var reg = /^\w(6,12)$/;</code></li></ol></li><li>方法：<ul><li><code>test(参数);</code>:验证指定的字符串是否符合正则定义的规范,返回true或者false。</li><li>示例：</li></ul></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var reg &#x3D; &#x2F;^\w(6,13)$&#x2F;;var username &#x3D; &quot;zhanngsanlijskjdlfkajl&quot;;var flag &#x3D; reg.test(username);</code></pre><h3 id="global对象"><a class="markdownIt-Anchor" href="#global对象"></a> Global对象</h3><ul><li>是一个<strong>全局对象</strong>，这个对象中封装的方法<strong>不需要任何对象</strong>就可以直接调用，如：<code>方法名();</code></li><li>方法：<ul><li>URL码：因为网络协议中不支持中文，所以需要将汉字转为URL码来传输。</li><li><code>encodeURI()</code>:url编码</li><li><code>decodeURI()</code>:URL解码，与encodeURI配套使用。</li><li><code>encodeURICompoent()</code>:也是进行URL编码，但是编码的字符更多（对有些符号也会进行编码）。</li><li><code>decodeURICompoent()</code>:也是进行URL解码，配套使用。</li><li>示例：</li></ul></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var str &#x3D; &quot;张杰&quot;;var encode &#x3D; encodeURI(str);</code></pre><ul><li><code>parseInt()</code>:将字符串转为数字<ul><li>逐一判断每一个字符是否为数字，直到不是数字为止，将前边的数字部分转为number。</li></ul></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var str &#x3D; &quot;123abc&quot;;var number &#x3D; paseInt(str);&#x2F;&#x2F;结果是123</code></pre><ul><li><code>isNaN()</code>:判断一个值是否为NaN<ul><li>NaN六亲不认，连自己都不认，NaN参与的所有<code>==</code>比较，结果都是false。</li><li>因为<code>NaN == NaN</code>结果也是false，所以设计这个方法来判断一个值是否为NaN。</li></ul></li><li><code>eval()</code>:将Javascript的字符串转换为脚本代码来执行。示例：</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var jscode&#x3D;&quot;alert(123)&quot;;eval(jscode);&#x2F;&#x2F;等效于直接写alert（123）；</code></pre><h1 id="bom"><a class="markdownIt-Anchor" href="#bom"></a> BOM</h1><ul><li>概念：Browser Object Model 浏览器对象模型</li><li>功能：将浏览器各个组成部分封装成对象</li><li>组成：<ul><li><strong>Window</strong>：浏览器窗口对象</li><li><strong>History</strong>:历史记录对象</li><li><strong>Location</strong>：地址栏对象</li><li>Screen：显示器屏幕对象</li><li>Navigator:浏览器对象</li></ul></li></ul><h2 id="window对象"><a class="markdownIt-Anchor" href="#window对象"></a> Window对象</h2><ul><li>window<strong>不需要创建</strong>，可以直接使用。也可以不用对象，直接使用方法名来调用。即<code>window.方法名();</code>和<code>方法名()</code>等效。</li><li>方法：<ol><li>与<strong>弹出框</strong>有关的方法：<ol><li><code>alert();</code>:显示一段消息和一个确认按钮的警告框。</li><li><code>confirm();</code>:显示带有一段消息以及确认按钮和取消按钮的对话框；<ol><li>如果用户点击确认按钮，则方法返回true；</li><li>如果用户点击取消按钮，则方法返回false。</li></ol></li><li><code>prompt();</code>:显示可提示用户输入的对话框<ol><li>参数是提示信息</li><li>返回值是获取的用户输入的值。</li></ol></li></ol></li><li>与<strong>打开关闭窗口</strong>有关的方法：<ol><li><code>open();</code>:打开一个新的浏览器窗口<ol><li>参数是新窗口要加载页面的地址；</li><li>返回值是新的窗口的window对象；</li></ol></li><li><code>close();</code>:关闭调用该方法的窗口对象的浏览器窗口<ol><li>谁调用我，我关谁。</li></ol></li></ol></li><li>与<strong>定时器</strong>有关的方式<ol><li><code>setTimeout();</code>：在指定的毫秒数后调用函数或计算表达式；<ol><li>参数：<ol><li><strong>js代码</strong>或者<strong>方法对象</strong></li><li>毫秒值</li></ol></li><li>返回值：唯一标识，用于作为取消定时器的参数</li></ol></li><li><code>clearTimeout()</code>:取消由<code>setTimeout()</code>设置的定时器<ol><li>参数：调用<code>setTimeout()</code>产生的返回值</li></ol></li><li><code>setInterval()</code>:按照指定的<strong>周期</strong>(以毫秒记来调用函数或计算表达式；<ol><li>参数：<ol><li><strong>js代码</strong>或者<strong>方法对象</strong></li><li>毫秒值</li></ol></li></ol></li><li><code>clearInertval()</code>:取消由<code>setInterval()</code>设置的定时器；<ol><li>参数：调用<code>setInterval()</code>产生的返回值</li></ol></li></ol></li></ol></li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;script&gt;    var id &#x3D; setInterval(&quot;fun()&quot;, 2000);    clearInterval(id);    var id2 &#x3D; setInterval(fun, 2000);    function fun()&#123;        alert(&quot;boom&quot;);    &#125;&lt;&#x2F;script&gt;</code></pre><ul><li>属性：<ul><li>获取其它BOM对象<ul><li>history;</li><li>location;</li><li>navigation;</li><li>screen;</li><li>示例：</li><li><code>var h1 = window.history;</code>与<code>var h2 = history;</code>等效。</li></ul></li><li>获取DOM对象<ul><li>document等</li><li>示例：<code>document.getElementById()</code>与<code>window.document.getElementById();</code>等效。</li></ul></li></ul></li></ul><h2 id="location对象"><a class="markdownIt-Anchor" href="#location对象"></a> Location对象</h2><ul><li>创建（获取）<ul><li>通过window对象的属性来获取。<code>var l1 = window.location;</code>与<code>var l2 = location;</code>等效。</li></ul></li><li>方法：<ul><li><code>reload();</code>:重新加载当前文档</li></ul></li><li>属性：<ul><li><code>herf</code>:设置或者返回完整的URL。<ul><li>获取：<code>var href = location.href;</code></li><li>设置：<code>location.herf = &quot;http://baidu.com&quot;;</code></li></ul></li></ul></li></ul><h1 id="dom"><a class="markdownIt-Anchor" href="#dom"></a> DOM</h1><ul><li>概念：Document Object Model 文档对象模型</li><li>功能：将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对<strong>标记语言文档进行CRUD的动态操作</strong>。</li><li>DOM将HTMl表达为一个<strong>树</strong>型结构<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201220211801.jpg" alt="" /></li><li>W3C DOM标准被分为3个不同的部分：<ul><li>核心DOM：针对<strong>任何结构化文档</strong>的标准模型。<ul><li>Document:文档对象</li><li>Element:元素对象</li><li>Attribute:属性对象</li><li>Text：文本对象</li><li>Comment：注释对象</li><li>Node：节点对象，其余5个对象的父对象。</li></ul></li><li>XML DOM：针对<strong>XML文档</strong>的标准模型；</li><li>HTML DOM：针对<strong>HTML文档</strong>的标准模型。</li></ul></li></ul><h2 id="核心dom"><a class="markdownIt-Anchor" href="#核心dom"></a> 核心DOM</h2><h3 id="document对象"><a class="markdownIt-Anchor" href="#document对象"></a> Document对象</h3><ul><li>创建（获取）：在<strong>HTML DOM模型</strong>中可以使用<strong>window对象</strong>来获取<ul><li><code>window.document;</code></li><li><code>document</code>;</li></ul></li><li>获取页面的**元素（标签）**对象<ul><li><code>getElementByID(&quot;id值&quot;);</code>:通过元素的ID获取元素对象，返回<strong>一个</strong>Element对象。因为id值一般是唯一的。</li><li><code>getElementsByTagName(&quot;标签名&quot;);</code>:根据元素名称（即html标签名）获取元素对象们。返回值是一个<strong>数组</strong>。</li><li><code>getElementsByClassName(&quot;class属性值);</code>:根据class属性值来获取元素对象们。返回值是一个数组。</li><li><code>getElmentsByName(&quot;name属性值&quot;);</code>:根据name属性值来获取元素对象们。返回值是一个数组。</li><li>示例：</li></ul></li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;div&gt;div&lt;&#x2F;div&gt;&lt;script&gt;var div &#x3D; document.getElementsByTagName(&quot;div&quot;);alert(div.length);&lt;&#x2F;script&gt;</code></pre><ul><li><strong>创建</strong>其它<strong>DOM对象</strong><ul><li><code>createAttribute(name);</code>：创建具有指定名称的属性节点，并返回新的Attr对象。</li><li><code>createComment();</code>：创建注释节点。</li><li><code>creatElement();</code>：创建<strong>元素节点</strong></li><li><code>createTextNode();</code>:创建文本节点</li><li>示例：<code>var table = document.createElement(&quot;table&quot;);</code></li></ul></li><li>操作Element对象：<ol><li>修改属性值：</li></ol><ul><li>明确获取的对象是什么元素类型；</li><li>通过API查看对象里有哪些属性；</li><li>通过<code>element.属性 = ...</code>的方式修改属性值。</li></ul><ol start="2"><li>修改标签内容：<br />1.获取元素对象<br />2.使用innerHTML属性修改标签体内容</li></ol></li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h1 id&#x3D;&quot;title&quot;&gt;悔创阿里杰克马&lt;&#x2F;h1&gt;&lt;img id&#x3D;&quot;light&quot; src&#x3D;&quot;img&#x2F;off.jpg&quot;&gt;&lt;script&gt;    var light &#x3D; document.getElementById(&quot;light&quot;);    alert(&quot;我要换图片&quot;)；    light.src&#x3D;&quot;img&#x2F;on.jpg&quot;;    var title &#x3D; document.getElementById(&quot;title&quot;);    alert(&quot;我要换标题&quot;);    title.innerHTML&#x3D;&quot;不识妻美刘强东&quot;;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&#96;&#96;&#96;   ### Elment对象* 获取（创建）：通过**doucument**来获取和创建。* 方法：  * &#96;removeAttribute();&#96;:删除属性  * &#96;setAttribute();&#96;:设置属性  * 示例：&#96;&#96;&#96;html&lt;a&gt;试一试&lt;&#x2F;a&gt;&lt;script&gt;var element_a &#x3D; document.getElmentsByTagName(&quot;a&quot;)[0];element_a.setAttribute(&quot;href&quot;, &quot;https:&#x2F;&#x2F;www.baidu.com&quot;);element_a.removeAttribute(&quot;href&quot;);&lt;&#x2F;script&gt;</code></pre><h3 id="node对象"><a class="markdownIt-Anchor" href="#node对象"></a> Node对象</h3><ul><li>节点可以是元素节点，属性节点，文本节点等。</li><li>所有DOM对象都可以被认为是一个节点。</li><li>方法：<ul><li>CRUD DOM树：<ul><li><code>appendChild();</code>:向节点的子节点列表的结尾添加新的子节点。</li><li><code>removeChild();</code>:删除（并返回）当前节点的子节点。</li><li><code>replaceChild();</code>:用新节点替换一个子节点。</li></ul></li></ul></li><li>属性：<ul><li><code>parentNode</code>:返回节点的父节点。</li></ul></li><li>示例：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;    &lt;style&gt;    &lt;!--设置div的样式--&gt;        div &#123;            border : 1px solid red;        &#125;        #div1 &#123;            width: 200px;            height: 200px;        &#125;        #div2 &#123;            width:50px;            height: 20px;        &#125;        #div3 &#123;            width:50px;            height: 20px;        &#125;    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;!--div1的子节点为div2--&gt;&lt;div id&#x3D;&quot;div1&quot;&gt;    &lt;div id&#x3D;&quot;div2&quot;&gt;div2&lt;&#x2F;div&gt;    div1&lt;&#x2F;div&gt;&lt;div id&#x3D;&quot;div3&quot;&gt;div3&lt;&#x2F;div&gt;&lt;!--用超链接来实现按钮的功能--&gt;&lt;!--删除子节点的链接--&gt;&lt;!--将href设置为javascript:void(0);可以去除href跳转的功能，而保留接收点击的功能--&gt;&lt;a href&#x3D;&quot;javascript:void(0);&quot; id&#x3D;&quot;del&quot;&gt;删除子节点&lt;&#x2F;a&gt;&lt;!--添加子节点的链接--&gt;&lt;a href&#x3D;&quot;javascript:void(0);&quot; id&#x3D;&quot;add&quot;&gt; 添加子节点&lt;&#x2F;a&gt;&lt;script&gt;        &#x2F;&#x2F;获取删除字节点的超链接对象    var element_a &#x3D; document.getElementById(&quot;del&quot;);    &#x2F;&#x2F;绑定点击事件，点击事件绑定删除子节点的函数    element_a.onclick &#x3D; function () &#123;        var div1 &#x3D; document.getElementById(&quot;div1&quot;);        var div2 &#x3D; document.getElementById(&quot;div2&quot;);        div1.removeChild(div2);    &#125;    var element_a1 &#x3D; document.getElementById(&quot;add&quot;);    element_a1.onclick &#x3D; function () &#123;        var div1 &#x3D; document.getElementById(&quot;div1&quot;);        var div3 &#x3D; document.getElementById(&quot;div3&quot;);        div1.appendChild(div3);    &#125;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h2 id="动态表格示例"><a class="markdownIt-Anchor" href="#动态表格示例"></a> 动态表格示例</h2><ul><li>可以动态添加和删除表格中的数据。</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;    &lt;style&gt;        div &#123;            text-align:center;            margin:50px;        &#125;        table &#123;            border:1px solid;            margin:auto;            width:500px;        &#125;        td,th&#123;            text-align:center;            border:1px solid;        &#125;    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div&gt;    &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;id&quot; placeholder&#x3D;&quot;请输入编号&quot;&gt;    &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;name&quot; placeholder&#x3D;&quot;请输入姓名&quot;&gt;    &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;gender&quot; placeholder&#x3D;&quot;请输入性别&quot;&gt;    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;添加&quot; id&#x3D;&quot;btn_add&quot;&gt;&lt;&#x2F;div&gt;&lt;table&gt;    &lt;caption&gt;学生信息表&lt;&#x2F;caption&gt;    &lt;tr&gt;        &lt;th&gt;编号&lt;&#x2F;th&gt;        &lt;th&gt;姓名&lt;&#x2F;th&gt;        &lt;th&gt;性别&lt;&#x2F;th&gt;        &lt;th&gt;操作&lt;&#x2F;th&gt;    &lt;&#x2F;tr&gt;    &lt;tr&gt;        &lt;td&gt;1&lt;&#x2F;td&gt;        &lt;td&gt;zhangjie&lt;&#x2F;td&gt;        &lt;td&gt;man&lt;&#x2F;td&gt;        &lt;td&gt;&lt;a href&#x3D;&quot;javascript:void(0);&quot; onclick&#x3D;&quot;del_tr(this)&quot;&gt;delete&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;    &lt;&#x2F;tr&gt;&lt;&#x2F;table&gt;&lt;script&gt;    &#x2F;*        1.添加            1.给添加按钮绑定单击事件            2.获取文本框的内容            3.创建td，设置td中的文本为文本框的内容            4.创建tr            5.将td添加到tr中            6.获取table，将tr添加到table中     *&#x2F;    var btn_add &#x3D; document.getElementById(&quot;btn_add&quot;);    btn_add.onclick &#x3D; function () &#123;        &#x2F;&#x2F;获取输入框的内容value        var id &#x3D; document.getElementById(&quot;id&quot;).value;        var name &#x3D; document.getElementById(&quot;name&quot;).value;        var gender &#x3D; document.getElementById(&quot;gender&quot;).value;        &#x2F;&#x2F;创建td节点        var td_id &#x3D; document.createElement(&quot;td&quot;);        &#x2F;&#x2F;将文本内容添加到节点中        var text_id &#x3D; document.createTextNode(id);        td_id.appendChild(text_id);        var td_name &#x3D; document.createElement(&quot;td&quot;);        var text_name &#x3D; document.createTextNode(name);        td_name.appendChild(text_name);        var td_gender &#x3D; document.createElement(&quot;td&quot;);        var text_gender &#x3D; document.createTextNode(gender);        td_gender.appendChild(text_gender);        var td_a &#x3D; document.createElement(&quot;td&quot;);        var ele_a &#x3D; document.createElement(&quot;a&quot;);        ele_a.setAttribute(&quot;href&quot;,&quot;javascript:void(0);&quot;)        ele_a.setAttribute(&quot;onclick&quot;, &quot;del_tr(this)&quot;);        var text_a &#x3D; document.createTextNode(&quot;delete&quot;);        ele_a.appendChild(text_a);        td_a.appendChild(ele_a);        &#x2F;&#x2F;将td节点添加到tr节点中        var tr &#x3D; document.createElement(&quot;tr&quot;);        tr.appendChild(td_id);        tr.appendChild(td_name);        tr.appendChild(td_gender);        tr.appendChild(td_a);        &#x2F;&#x2F;将tr节点添加到table节点中去。        var table &#x3D; document.getElementsByTagName(&quot;table&quot;)[0];        table.appendChild(tr);    &#125;    function del_tr(obj) &#123;        var table &#x3D; obj.parentNode.parentNode.parentNode;        var tr &#x3D; obj.parentNode.parentNode;        table.removeChild(tr);    &#125;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h2 id="事件"><a class="markdownIt-Anchor" href="#事件"></a> 事件</h2><ul><li>功能：某些组件被执行了某些操作后，触发某些代码的执行。</li><li><strong>事件</strong>：某些操作。如：单击，双击，键盘按下了，鼠标移动了。。。</li><li><strong>事件源</strong>：组件。如：按钮，文本输入框。。。</li><li><strong>监听器</strong>：要执行的代码。<ul><li>监听器中的的<code>this</code>指向引发该监听器的<strong>事件源对象</strong>。</li></ul></li><li><strong>注册监听</strong>：将事件，事件源，监听器<strong>结合</strong>在一起。当事件源发生了某个事件，则触发执行某个监听器代码。</li><li>常见事件：<ul><li>点击事件：<ul><li><code>onclick</code>:单击事件</li><li><code>ondblclick</code>:双击事件</li></ul></li><li>焦点事件：<ul><li><code>onblur</code>:失去焦点<ul><li>一般用于表单校验。</li></ul></li><li><code>onfocus</code>:元素获得焦点</li></ul></li><li>加载事件：<ul><li><code>onload</code>:一张页面或者一幅图像完成加载；<ul><li>一般用在window对象或者body对象上</li></ul></li></ul></li><li>鼠标事件：<ul><li><code>onmousedown</code>:鼠标按钮被按下<ul><li>定义方法时定义一个形参，接收event对象，event对象的button属性可以获取鼠标上哪个键被按下了的信息。</li></ul></li><li><code>onmousesup</code>:鼠标按钮被松开</li><li><code>onmousemove</code>:鼠标按钮被移动</li><li><code>onmouseover</code>:鼠标移到某元素之上</li><li><code>onmouseout</code>:鼠标从某元素上移开</li></ul></li><li>键盘事件：<ul><li><code>onkeydown</code>:某个键盘按键被按下<ul><li>定义方法时定义一个形参，接收event对象，event对象的keycode属性可以获取键盘上哪个键被按下了的信息。</li></ul></li><li><code>onkeyup</code>:某个键盘按键被松开</li><li><code>onkeypress</code>:某个键盘按键被按下并松开</li></ul></li><li>选择和改变<ul><li><code>onchange</code>:域的内容被改变</li><li><code>onselect</code>:文本被选中</li></ul></li><li>表单事件：<ul><li><code>onsubmit</code>:确认按钮被点击<ul><li>可以阻止表单的提交，进行表单校验。<ul><li>监听器方法返回false，表单被阻止提交。</li></ul></li></ul></li><li><code>onreset</code>；重置按钮被点击</li><li>示例：</li></ul></li></ul></li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;script&gt;document.getElementById(&quot;form&quot;).onsubmit &#x3D; function () &#123;  return false;&#125;&#x2F;&#x2F;如果是调用函数&lt;form action&#x3D;&quot;#&quot; id&#x3D;&quot;form&quot; onclick &#x3D; &quot;return checkFalse()&quot;&gt;&lt;&#x2F;form&gt;function checkFalse() &#123;  return false;&#125;&lt;&#x2F;script&gt;</code></pre><ul><li>绑定事件：<ol><li>直接在html标签上，指定事件的属性（操作），属性值就是<strong>js代码</strong>。<ol><li>事件：<code>onclicks</code>– 单击事件</li><li>示例：<code>&lt;img src=&quot;img/on.gif&quot; onclicks=&quot;alert(&quot;我被点了&quot;);&quot;&gt;</code></li></ol></li><li>通过js获取元素对象，指定事件属性，设置一个<strong>函数</strong>。<ol><li>示例：</li></ol></li></ol></li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;img id&#x3D;&quot;light&quot; src&#x3D;&quot;img&#x2F;off.jpg&quot; &gt;&lt;script&gt;    function fun() &#123;      alert(&quot;我被点了&quot;);    &#125;    var light &#x3D; document.getElementById(&quot;light&quot;);    light.onclicks&#x3D;fun;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h2 id="html-dom"><a class="markdownIt-Anchor" href="#html-dom"></a> HTML DOM</h2><ul><li>标签体的设置和获取：innerHTML</li><li>使用html元素对象的属性</li><li>控制样式</li></ul><h3 id="inner-html"><a class="markdownIt-Anchor" href="#inner-html"></a> inner HTML</h3><ul><li>作用：修改标签体内部的内容。</li><li>示例：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div&gt;    div&lt;&#x2F;div&gt;&lt;script&gt;  function fun1() &#123;      &#x2F;&#x2F;获取div元素      var div &#x3D; document.getElementsByTagName(&quot;div&quot;)[0];    &#x2F;&#x2F;将标签内的内容更改      div.innerHTML &#x3D; &quot;更改&quot;      &#x2F;&#x2F;向标签内追加内容      div.innerHTML +&#x3D; &quot;&lt;input type&#x3D;&#39;text&#39;&gt;&quot;;  &#125;fun1();&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h3 id="控制元素的样式"><a class="markdownIt-Anchor" href="#控制元素的样式"></a> 控制元素的样式</h3><ol><li>使用元素的style属性来设置。示例：</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;script&gt;  var div1 &#x3D; document.getElementById(&quot;div1&quot;);  div1.onclick &#x3D; function () &#123;      div1.style.border &#x3D; &quot;1px solid red&quot;;  &#125;&lt;&#x2F;script&gt;</code></pre><ul><li>style后面接的是css的属性，等号后面是css的属性值<br />2.提前定义好类选择器的样式，将元素的className与类选择器的类名相对应来设置样式。示例：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;    &lt;style&gt;        .d1 &#123;            border: 1px solid red;        &#125;    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;div1&quot;&gt;    div&lt;&#x2F;div&gt;&lt;script&gt;  var div1 &#x3D; document.getElementById(&quot;div1&quot;);  div1.onclick &#x3D; function () &#123;      div1.className &#x3D; &quot;d1&quot;;  &#125;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><ul><li>本质是用Js来控制css。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%89%8D%E7%AB%AF/css/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%89%8D%E7%AB%AF/css/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="css概述"><a class="markdownIt-Anchor" href="#css概述"></a> css概述</h1><ul><li>css概念：cascading style sheets,层叠样式表<ul><li>层叠：多个样式可以作用在一个html元素上，同时生效。</li></ul></li><li>作用：<ul><li>功能较直接用html控制样式更加强大；</li><li>将内容展示和样式控制分离<ul><li>降低耦合度，解耦</li><li>让分工协作更容易</li><li>提高开发效率</li></ul></li></ul></li><li>css的使用：css与html结合的方式<ol><li>内联方式：在<strong>标签内</strong>使用style属性指定css代码<ol><li>如：<code>&lt;div style=&quot;color:red;&quot;&gt;hello css&lt;/div&gt;</code>。</li><li>仅限于修改当前标签的内容样式，范围太小，且没有分离，一般不使用。</li></ol></li><li>内部样式：在<strong>head标签内</strong>，定义style标签，style标签的标签体内容就是css代码<ol><li>仅限于修改当前页面的内容</li><li>如：</li></ol></li></ol> <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;style&gt; div&#123;     color:red; &#125; &lt;&#x2F;style&gt;</code></pre><ol start="3"><li>外部样式：</li><li>定义css资源文件</li><li>在<strong>head标签</strong>内，定义<strong>link标签</strong>，引入外部的资源文件。</li><li>如：</li></ol></li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;css&#x2F;a.css&quot;&gt;&lt;!--也可以通过下面方式引入css，但是不常用--&gt;&lt;style&gt;    @import &quot;css&#x2F;a.css&quot;;&lt;&#x2F;style&gt;</code></pre><h1 id="css基本语法"><a class="markdownIt-Anchor" href="#css基本语法"></a> css基本语法</h1><p><a href="https://www.w3school.com.cn/cssref/index.asp">参考手册</a></p><ul><li>格式：</li></ul><pre class="line-numbers language-none"><code class="language-none">选择器 ｛    属性名1：属性值1；    属性名2：属性值2；    ...｝</code></pre><ul><li>选择器：筛选具有相似特征的元素</li><li>每一对属性需要<strong>使用;隔开</strong>，最后一对属性可以不加。</li></ul><h1 id="选择器"><a class="markdownIt-Anchor" href="#选择器"></a> 选择器</h1><h2 id="基础选择器"><a class="markdownIt-Anchor" href="#基础选择器"></a> 基础选择器</h2><ul><li>id选择器： 选择具体的id属性值的元素,一个html页面中的id值唯一。<ul><li>语法：<code>#id属性值&#123;&#125;</code></li></ul></li><li>元素选择器：选择具有相同标签名称的元素,标签名可以自定义。<ul><li>语法：<code>标签名称&#123;&#125;</code></li><li>注意：id选择器的优先级高于元素选择器</li></ul></li><li>类选择器：选择具有相同class属性值的元素<ul><li>语法：<code>.class属性值&#123;&#125;</code></li><li>注意：类选择器的优先级高于元素选择器的优先级，但是低于id选择器的优先级。<strong>同一级的选择器，放在后面的可以覆盖前面选择器设置的相同的属性</strong>。</li></ul></li><li>示例：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;login&lt;&#x2F;title&gt;    &lt;style&gt;        #div1&#123;            color: red;        &#125;        p&#123;          color:green;        &#125;        .class1&#123;          color:blue;        &#125;    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;  &lt;div id&#x3D;&quot;div1&quot;&gt;张杰&lt;&#x2F;div&gt;  &lt;p&gt;张杰2&lt;&#x2F;p&gt;  &lt;p class&#x3D;&quot;class1&quot;&gt;zhangjie&lt;&#x2F;p&gt;  &lt;m class&#x3D;&quot;class1&quot;&gt;张杰&lt;&#x2F;m&gt;&lt;!--自定义的标签--&gt;&lt;&#x2F;body&gt;</code></pre><h2 id="扩展选择器"><a class="markdownIt-Anchor" href="#扩展选择器"></a> 扩展选择器</h2><ul><li>选择所有元素选择器：<ul><li>语法：<code>*&#123;&#125;</code></li></ul></li><li>并集选择器：选择两个选择器的所有内容<ul><li>语法：<code>选择器1，选择器2&#123;&#125;</code></li></ul></li><li>子选择器：筛选选择器1元素下的选择器2元素<ul><li>语法：<code>选择器1 选择器2&#123;&#125;</code></li><li>只有在选择器1元素包裹下的选择器2元素才会被选中。</li><li>示例：如果是<code>div p&#123;&#125;</code></li></ul></li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;div&gt;  &lt;p&gt;zhangjie1&lt;&#x2F;p&gt; &lt;!--只有这一行元素才会被选中--&gt;&lt;&#x2F;div&gt;&lt;p&gt;zhangjie2&lt;&#x2F;p&gt;</code></pre><ul><li>父选择器：筛选选择器2上的父元素选择器1<ul><li>语法：<code>选择器1&gt;选择器2&#123;&#125;</code></li><li>只有其中包裹了选择器2元素的选择器1元素才会被选中。父选择器改变的是选择器1的样式。</li><li>示例：<code>div&gt;p&#123;&#125;</code></li></ul></li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--只有这个包裹了p元素的div元素会被选中--&gt;&lt;div&gt;  &lt;p&gt;zhangjie&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;!--下面这个div就不会被选中--&gt;&lt;div&gt;zhangjie2&lt;&#x2F;div&gt;</code></pre><ul><li>属性选择器：选择元素名称，属性名=属性值的元素<ul><li>语法：<code>元素名称[属性名:&quot;属性值&quot;]&#123;&#125;</code></li><li>一般用来选择input标签元素。</li><li>示例；</li></ul></li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;head&gt;&lt;style&gt;input[type&#x3D;&quot;text&quot;]&#123;  border:2px solid;&#125;&lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;test&quot;&gt;</code></pre><ul><li>伪类选择器：选择一些元素具有的状态<ul><li>语法：<code>元素:状态&#123;&#125;</code></li><li>状态：如<code>&lt;a&gt;</code>标签，具有如下状态<ul><li>link:初始化的状态</li><li>visited:被访问过的状态</li><li>active：正在被访问的状态</li><li>hover:鼠标悬浮状态</li></ul></li><li>示例：</li></ul></li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;style&gt;a:link&#123;  color:pink;&#125;a:hover&#123;  color:red;&#125;a:active&#123;  color:yellow;&#125;a:visited&#123;  color:green;&#125;&lt;&#x2F;style&gt;</code></pre><h1 id="属性"><a class="markdownIt-Anchor" href="#属性"></a> 属性</h1><h2 id="字体-文本"><a class="markdownIt-Anchor" href="#字体-文本"></a> 字体、文本</h2><ul><li>color:字体颜色，如：<code>color:#FF0000;</code>代表红色。</li><li>font-size:字体大小，单位为px，如；<code>font-size:30px;</code></li><li>text-align；文本对齐方式。如：<code>text-align:center;</code></li><li>line-height:行高，单位也为px，整个文本范围所占的高度。如；<code>line-align:100px;</code></li></ul><h2 id="边框"><a class="markdownIt-Anchor" href="#边框"></a> 边框</h2><ul><li>boder:设置边框，是一个复合属性。</li><li>如：<code>border:1px solid red;</code>,表示，边框宽是1个像素，是实线，是红色。</li></ul><h2 id="尺寸"><a class="markdownIt-Anchor" href="#尺寸"></a> 尺寸</h2><ul><li>设置整个标签内容所占的范围大小。</li><li>height：范围的高度，单位为px；如：<code>height:200px;</code></li><li>width:范围的宽度，单位为px：如:<code>width:200px;</code></li></ul><h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><ul><li>background:背景颜色，是一个复合属性。如；<code>background:url(&quot;img/logo.jpg&quot;) no-repeat center;</code>,意思为设置背景图片为logo.jpg 图片不要重复，图片在标签内容范围内居中。</li></ul><h2 id="盒子模型"><a class="markdownIt-Anchor" href="#盒子模型"></a> 盒子模型</h2><ul><li>用来控制布局。</li><li><strong>margin</strong> :外边距，和父盒子的边框的距离。<ul><li>可以用margin-left等属性来设置每一条边距，直接设置margin是设置四条边的边距。</li></ul></li><li><strong>padding</strong>:内边距，和子盒子的边框的距离。<ul><li>默认情况下内边距会影响盒子的大小。</li><li><strong>box-sizing</strong>:需要设置盒子的属性，让width和height就是盒子的大小。如；<code>box-sizing:border-box;</code></li></ul></li><li><strong>float</strong>:浮动属性，让不同盒子在顺序在同一行排列。如；<code>float:left</code>:左浮动；<code>float:right;</code>；有浮动。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%89%8D%E7%AB%AF/HTML/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%89%8D%E7%AB%AF/HTML/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h1><ul><li>最基础的网页开发语言。</li><li>HTML：Hyper Text Markup Language 超文本标记语言。</li><li>超文本：超文本是用超链接的方法，将不同空间的文字信息组织在一起的网状文本。</li><li>标记语言：<ul><li>由标签（&lt;标签内容&gt;）构成的语言，如html，xml</li><li>标记语言不是编程语言，没有逻辑性。</li></ul></li><li>HTML 文档描述网页,HTML 文档包含 HTML 标签和纯文本,HTML 文档也被称为网页</li></ul><h1 id="快速入门"><a class="markdownIt-Anchor" href="#快速入门"></a> 快速入门</h1><ul><li>html文档的后缀名：html或者htm</li><li>标签分为：<ul><li>围堵标签：有开始标签和结束标签。如：<code>&lt;html&gt;&lt;/html&gt;</code></li><li>自闭和标签：开始标签和结束标签在一起。如：<code>&lt;br/&gt;</code></li></ul></li><li>标签可以被嵌套：<ul><li>需要正确嵌套，不能你中有我，我中有你</li><li>错误：<code>&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;</code></li><li>正确：<code>&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;</code></li></ul></li><li>在<strong>开始标签</strong>中可以定义属性。属性是由键值对构成，值需要用引号(单双都可，但是要统一)引起来。</li><li>html的标签不区分大小写，但是建议使用小写</li><li>示例：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;html&gt;    &lt;head&gt;            &lt;title&gt;title&lt;&#x2F;title&gt;    &lt;&#x2F;head&gt;    &lt;body&gt;        &lt;font color&#x3D;&#39;red&#39;&gt;Hello world&lt;&#x2F;font&gt;&lt;br&#x2F;&gt;        &lt;font color&#x3D;&#39;green&#39;&gt;Hello world&lt;&#x2F;font&gt;    &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201208092240.jpg" alt="" /></p><h1 id="标签"><a class="markdownIt-Anchor" href="#标签"></a> 标签</h1><ul><li><a href="https://www.w3school.com.cn/tags/index.asp">参考手册</a></li></ul><h2 id="文件标签"><a class="markdownIt-Anchor" href="#文件标签"></a> 文件标签</h2><ul><li>构成html最基本的标签。</li><li>html:html文档的根标签,<html> 与 </html> 之间的文本描述网页</li><li>head：头标签。用于指定html文档的一些属性，引入外部的资源。</li><li>title:标题标签；</li><li>body；体标签，放网页显示内容.<code>&lt;body&gt;</code> 与 <code>&lt;/body&gt;</code> 之间的文本是<strong>可见</strong>的页面内容。</li><li><code>&lt;!DOCTYPE&gt;</code>:定义文档类型标签,html5中定义文档类型的方式。如：<code>&lt;!DOCTYPE html&gt;</code></li></ul><h2 id="文本标签"><a class="markdownIt-Anchor" href="#文本标签"></a> 文本标签</h2><ul><li>注释：<code>&lt;!--注释内容 --&gt;</code>(后面没有感叹号)</li><li>标题：<code>&lt;h1&gt;标题内容&lt;/h1&gt;</code>共有6级标题。</li><li>定义段落：<code>&lt;p&gt;这是段落内容&lt;/p&gt;</code>,p 元素会自动在其前后创建一些空白。浏览器会自动添加这些空间，您也可以在样式表中规定。</li><li>换行：<code>&lt;br&gt;</code>，如：<code>白日依山尽，&lt;br&gt;黄河入海流</code>,注意这是一个<strong>自闭合标签</strong>无需结束标签。（<code>&lt;br/&gt;</code>具有相同的效果）。</li><li>定义水平线：<code>&lt;hr&gt;</code>或者<code>&lt;hr/&gt;</code>可以定义一条水平线。</li><li>粗体：<code>&lt;b&gt;需要粗体内容&lt;/b&gt;</code>。</li><li>斜体：<code>&lt;i&gt;需要斜体的内容&lt;/i&gt;</code>.</li><li>类似打字机或者等宽的文本效果：<code>&lt;tt&gt;需要等宽显示的内容&lt;tt&gt;</code></li><li>呈现大号字体效果:<code>&lt;big&gt;需要显示大号字体的内容&lt;/big&gt;</code></li><li>呈现小号字体效果:<code>&lt;small&gt;需要显示小号字体的内容&lt;small&gt;</code></li><li>规定文本的字体、字体尺寸、字体颜色:<code>&lt;font color=&quot;red&quot;, size=&quot;5&quot;,face=&quot;楷体&quot;&gt; 我是红色&lt;/font&gt;</code>,face是指的字体。<strong>已经不建议使用，改变样式现在用css</strong></li><li>文本居中：<code>&lt;center&gt;需要居中的内容&lt;/center&gt;</code>,居中是相对于父元素来说的。示例：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;center&gt;&lt;font color&#x3D;&quot;red&quot;, size&#x3D;&quot;5&quot;,face&#x3D;&quot;楷体&quot;&gt; 我是红色&lt;&#x2F;font&gt;&lt;&#x2F;center&gt;</code></pre><ul><li>属性：<ul><li>color:颜色：<ul><li>英文单词：red,green,blue等</li><li>rgb(值1，值2，值3)；rgb分别是红，绿，蓝三种颜色的占比。值的范围：0~255（不常用）</li><li><code>#值1值2值3</code>:值的范围：00~FF之间。效果也是通过三种颜色的占比来配色。如：<code>#FF00FF</code>。</li></ul></li><li>width:<ul><li>数值:width=‘20’,数值的单位，默认是像素px(像素)；</li><li>数值%：width=‘50%’,相对于父元素的占比。</li></ul></li><li>align:对齐方式<ul><li>center:居中</li><li>left：左对齐</li><li>right：右对齐</li></ul></li></ul></li></ul><h2 id="图片标签"><a class="markdownIt-Anchor" href="#图片标签"></a> 图片标签</h2><ul><li><code>&lt;img /&gt;</code>:图片标签是自闭合标签</li><li>属性：src<ul><li>src后输入图片的位置；</li><li>相对路径：<ul><li><code>./...</code>代表当前目录；如：<code>./image/1.jpg</code></li><li><code>../...</code>代表上一级目录：如：<code>../image/2.jpg</code></li></ul></li><li>绝对路径也可以使用</li><li>直接使用链接也可以</li></ul></li><li>示例：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;img src &#x3D; &quot;https:&#x2F;&#x2F;zjpicture.oss-cn-beijing.aliyuncs.com&#x2F;giteePic&#x2F;picgo-master&#x2F;img&#x2F;20201208092240.jpg&quot;&gt;</code></pre><h2 id="列表标签"><a class="markdownIt-Anchor" href="#列表标签"></a> 列表标签</h2><ul><li>有序列表<ul><li>ol:定义有序列表（order list）<ul><li>通过type属性来定义顺序表示的方式，如type=“A”,则用A,B，C。。。表示顺序，type=“I”,则表示用罗马数字表示顺序</li><li>通过start属性来定义从哪里开始计算顺序，如：start=“5”,则顺序从5，6，7，8开始下去。</li></ul></li><li>li：定义<strong>列表的项目</strong>(list)</li></ul></li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;ol&gt;  &lt;li&gt;Coffee&lt;&#x2F;li&gt;  &lt;li&gt;Tea&lt;&#x2F;li&gt;  &lt;li&gt;Milk&lt;&#x2F;li&gt;&lt;&#x2F;ol&gt;</code></pre><p>效果：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201211102931.jpg" alt="" /></p><ul><li>无序列表：<ul><li>ul:定义无序列表<ul><li>通过type属性来定义列表项前面的符号样式：有disc，square，circle三种样式。</li></ul></li><li>li：定义列表的项目</li><li>示例：</li></ul></li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;ul&gt;  &lt;li&gt;Coffee&lt;&#x2F;li&gt;  &lt;li&gt;Tea&lt;&#x2F;li&gt;  &lt;li&gt;Milk&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;</code></pre><p>效果：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201211103137.jpg" alt="" /></p><h2 id="链接标签"><a class="markdownIt-Anchor" href="#链接标签"></a> 链接标签</h2><ul><li><code>&lt;a&gt;&lt;/a&gt;</code>:定义超链接</li><li>属性：<ul><li>href：指定访问资源的url<ul><li>既可以是网页链接</li><li>也可以是本地的资源，如：<code>./5_列表标签.html</code>。</li></ul></li><li>target:<ul><li>“_self”,在当前页面打开链接的网页</li><li>“_blank”:在一个空白标签页打开链接的网页</li></ul></li></ul></li><li>示例：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;a href &#x3D; &quot;https:&#x2F;&#x2F;zjpicture.oss-cn-beijing.aliyuncs.com&#x2F;giteePic&#x2F;picgo-master&#x2F;img&#x2F;20201211103137.jpg&quot; target &#x3D; &quot;_blank&quot;&gt;我是超链接&lt;&#x2F;a&gt;</code></pre><h2 id="div和span"><a class="markdownIt-Anchor" href="#div和span"></a> div和span</h2><ul><li><code>&lt;span&gt;&lt;/span&gt;</code>:没有任何样式，文本信息在<strong>一行展示</strong>，是行内标签，内联标签。</li><li><code>&lt;div&gt;&lt;/div&gt;</code>:没有任何样式，每一个div占满一整行，是块级标签。</li><li>这两个是结合css来控制样式的。</li></ul><h2 id="语义化标签"><a class="markdownIt-Anchor" href="#语义化标签"></a> 语义化标签</h2><ul><li>html5中为了提高程序的可读性，提供了一些标签</li><li>如：<code>&lt;header&gt;</code>是页眉</li><li>如：<code>&lt;footer&gt;</code>是页脚。</li></ul><h2 id="表格标签"><a class="markdownIt-Anchor" href="#表格标签"></a> 表格标签</h2><ul><li>html中的表格只有行的概念。所谓的“列”是行中的单元格。</li><li>table；定义表格<ul><li>width:宽度</li><li>border:边框，会出现两条线，一条是行的边框线，一条是单元格的边框线。数字定义的是边框的宽度（像素为单位）</li><li>cellpadding；定义内容和单元格的距离</li><li>cellspaciing:定义单元格之间的距离。如果指定为0，则单元格的线合并为一条。</li><li>bgcolor:背景色</li><li>align：对齐方式</li></ul></li><li>tr：定义行<ul><li>可以定义每一行的属性，如背景色，对齐方式等。</li></ul></li><li>td:定义单元格<ul><li>属性colspan:合并列</li><li>属性rowspan；合并行</li><li>属性align:也可以设置单元格的对齐方式</li></ul></li><li>th:定义表头单元格</li><li>示例：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;table border&#x3D;&quot;1&quot; width&#x3D;&quot;50%&quot; cellpading&#x3D;&quot;0&quot; cellspacing&#x3D;&quot;0&quot; align&#x3D;&quot;center&quot; bgcolor&#x3D;&quot;red&quot;&gt;  &lt;!-- 表头行--&gt;    &lt;tr&gt;    &lt;!-- 表头单元格 --&gt;        &lt;th&gt;编号&lt;&#x2F;th&gt;        &lt;th&gt;姓名&lt;&#x2F;th&gt;        &lt;th&gt;成绩&lt;&#x2F;th&gt;    &lt;&#x2F;tr&gt;    &lt;tr&gt;        &lt;td&gt;1&lt;&#x2F;td&gt;        &lt;td&gt;小龙女&lt;&#x2F;td&gt;        &lt;td&gt;100&lt;&#x2F;td&gt;    &lt;&#x2F;tr&gt;    &lt;tr&gt;        &lt;td&gt;2&lt;&#x2F;td&gt;        &lt;td&gt;杨过&lt;&#x2F;td&gt;        &lt;td&gt;60&lt;&#x2F;td&gt;    &lt;&#x2F;tr&gt;&lt;&#x2F;table&gt;</code></pre><ul><li>效果：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201212111419.jpg" alt="" /></li><li>caption:表格的标题</li><li>thead,tbody,tfoot；分别定义表格的头部分，体部分和脚部分，与语义标签类似，起到增强代码可读性的作用。</li></ul><h2 id="表单标签"><a class="markdownIt-Anchor" href="#表单标签"></a> 表单标签</h2><ul><li>表单概念：用于采集用户输入的数据，用于和服务器进行交互。</li></ul><h3 id="form标签"><a class="markdownIt-Anchor" href="#form标签"></a> form标签</h3><ul><li>form标签：用于定义表单，可以定义一个范围，范围表示采集用户数据的页面范围。<ul><li>action属性：指定数据提交的url</li><li>method属性：指定提交方式(一共有7种，常用以下两种)<ul><li>get:<ul><li>请求的参数会在地址栏中显示，封装在请求行中。</li><li>请求参数大小有限制</li><li>不安全</li></ul></li><li>post:<ul><li>请求参数不会在地址栏中显示，会封装在请求体中。</li><li>请求参数的大小没有限制</li><li>较为安全。</li></ul></li></ul></li></ul></li><li>表单项中的数据想要被提交，必须<strong>指明name属性</strong>，且要位于form标签的范围之内。</li></ul><h3 id="表单项标签"><a class="markdownIt-Anchor" href="#表单项标签"></a> 表单项标签</h3><h4 id="input标签"><a class="markdownIt-Anchor" href="#input标签"></a> input标签</h4><ul><li>input:可以通过<strong>type</strong>属性值，改变展现元素的格式。<ul><li>type属性：<ul><li>text:文本输入框，是<strong>默认</strong>的type属性值。<ul><li>placeholder；指定输入框的提示信息，当输入框的内容发生变化之后，会自动清空提示信息；</li></ul></li><li>password:密码输入框<ul><li>效果是输入的密码都变为密文，不可见。</li></ul></li><li>radio；单选框<ul><li>要想让多个单选框实现单选的效果，则多个单选框的<strong>name属性值</strong>必须一样。</li><li>一般会给每一个单选框提供<strong>value属性值</strong>，指定其被选中后提交的值。</li><li><strong>checked属性值</strong>可以指定默认值，即没有选择的时候会默认选择的值。设置方式：<code>checked=&quot;checked&quot;</code>或者直接写一个<code>checked</code></li></ul></li><li>checkbox复选框：<ul><li>一般会给每一个单选框提供<strong>value属性值</strong>，指定其被选中后提交的值。</li><li><strong>checked属性值</strong>可以指定默认值，即没有选择的时候会默认选择的值。设置方式：<code>checked=&quot;checked&quot;</code>或者直接写一个<code>checked</code></li></ul></li><li>file；文件选择框</li><li>hidden:隐藏域，用于提交一些信息。</li><li>按钮：<ul><li>submit:提交按钮，可以提交表单,用<strong>value属性</strong>定义按钮显示的内容。</li><li>button:普通按钮，<strong>没有提交表单的功能</strong>。</li><li>image:图片提交按钮，通过<strong>src</strong>属性指定图片。</li></ul></li><li>color：取色器（html5新增的属性）</li><li>date:定义date控件，包括年月日</li><li>datetime-local：定义date和time控件，包括年月日时分。</li><li>email：定义用于输入邮箱地址的输入框，如果输入的数据不符合邮箱格式规范，则会报错无法提交。</li><li>number：定义用于输入数字的输入框，不能输入其它数据类型。</li></ul></li><li>label属性：指定输入项的文字描述信息<ul><li>label的<strong>for属性</strong>值与input的<strong>id属性</strong>值相对应，如果对应了，则点击label区域，会让input输入框获取焦点。</li></ul></li><li>示例：</li></ul></li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;form action&#x3D;&quot;#&quot;, method&#x3D;&quot;post&quot;&gt;    &lt;label for&#x3D;&quot;username&quot;&gt;用户名：&lt;&#x2F;label&gt;&lt;input type&#x3D;&quot;text&quot; name &#x3D; &quot;用户名&quot; id &#x3D; &quot;username&quot; placeholder&#x3D;&quot;请输入用户名&quot;&gt; &lt;br&gt;    &lt;label for&#x3D;&quot;password&quot;&gt;密码：&lt;&#x2F;label&gt;&lt;input type&#x3D;&quot;password&quot; name &#x3D; &quot;password&quot; id&#x3D;&quot;password&quot; placeholder&#x3D;&quot;请输入密码&quot;&gt;&lt;br&gt;    性别：        &lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot; value&#x3D;&quot;male&quot; checked&gt;男        &lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot; value&#x3D;&quot;female&quot;  &gt;女&lt;br&gt;    爱好：        &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot; value&#x3D;&quot;java&quot; checked&gt;java        &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot; value&#x3D;&quot;c&quot; &gt;c&lt;br&gt;    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;登录&quot;&gt;&lt;&#x2F;form&gt;</code></pre><ul><li>效果：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201212175934.jpg" alt="" /></li></ul><h4 id="select标签"><a class="markdownIt-Anchor" href="#select标签"></a> select标签</h4><ul><li>select:下拉列表<ul><li>子元素：option，指定列表项</li><li>属性selected可以指定默认选项,如果不指定默认选项，则显示的是第一个列表项。</li></ul></li><li>示例：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">省份：&lt;select name&#x3D;&quot;province&quot;&gt;          &lt;option value&#x3D;&quot;&quot;&gt;--请选择--&lt;&#x2F;option&gt;          &lt;option value&#x3D;&quot;1&quot; &gt;北京&lt;&#x2F;option&gt;          &lt;option value&#x3D;&quot;2&quot; selected&gt;上海&lt;&#x2F;option&gt;      &lt;&#x2F;select&gt;&lt;br&gt;</code></pre><h4 id="textarea标签"><a class="markdownIt-Anchor" href="#textarea标签"></a> textarea标签</h4><ul><li>textarea:文本域标签<ul><li>cols：指定文本框的列数，每一行有少个字符；</li><li>rows：指定文本框的默认行数，行数如果不够会自动扩充。</li></ul></li></ul><h1 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h1><ul><li>代码：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;login&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;!--定义表单--&gt;    &lt;form action&#x3D;&quot;#&quot; method&#x3D;&quot;post&quot;&gt;            &lt;table border&#x3D;&quot;1&quot; align&#x3D;&quot;center&quot; width&#x3D;&quot;500&quot;&gt;                    &lt;tr&gt;                        &lt;td&gt;&lt;label for&#x3D;&quot;username&quot;&gt;用户名&lt;&#x2F;label&gt;&lt;&#x2F;td&gt;                        &lt;td&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; id&#x3D;&quot;username&quot;&gt;&lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                    &lt;tr&gt;                        &lt;td&gt;&lt;label for&#x3D;&quot;password&quot;&gt;密码&lt;&#x2F;label&gt;&lt;&#x2F;td&gt;                        &lt;td&gt;&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot; id&#x3D;&quot;password&quot;&gt;&lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                    &lt;tr&gt;                        &lt;td&gt;&lt;label for&#x3D;&quot;email&quot;&gt;Email&lt;&#x2F;label&gt;&lt;&#x2F;td&gt;                        &lt;td&gt;&lt;input type&#x3D;&quot;email&quot; name&#x3D;&quot;email&quot; id&#x3D;&quot;email&quot;&gt;&lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                    &lt;tr&gt;                        &lt;td&gt;&lt;label for&#x3D;&quot;name&quot;&gt;姓名&lt;&#x2F;label&gt;&lt;&#x2F;td&gt;                        &lt;td&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;name&quot; id&#x3D;&quot;name&quot;&gt;&lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                    &lt;tr&gt;                        &lt;td&gt;&lt;label for&#x3D;&quot;phonenumber&quot;&gt;手机号&lt;&#x2F;label&gt;&lt;&#x2F;td&gt;                        &lt;td&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;phonenumber&quot; id&#x3D;&quot;phonenumber&quot;&gt;&lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                    &lt;tr&gt;                        &lt;td&gt;&lt;label &gt;性别&lt;&#x2F;label&gt;&lt;&#x2F;td&gt;                        &lt;td&gt;&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot; value&#x3D;&quot;male&quot;&gt;男                            &lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot; value&#x3D;&quot;female&quot;&gt;女                        &lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                    &lt;tr&gt;                        &lt;td&gt;&lt;label for&#x3D;&quot;date&quot;&gt;出生日期&lt;&#x2F;label&gt;&lt;&#x2F;td&gt;                        &lt;td&gt;&lt;input type&#x3D;&quot;date&quot; name&#x3D;&quot;date&quot; id&#x3D;&quot;date&quot;&gt;&lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;                    &lt;tr&gt;                        &lt;td colspan&#x3D;&quot;2&quot; align&#x3D;&quot;center&quot;&gt;&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;注册&quot;&gt;&lt;&#x2F;td&gt;                    &lt;&#x2F;tr&gt;            &lt;&#x2F;table&gt;    &lt;&#x2F;form&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><ul><li>效果<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201212201738.jpg" alt="" /></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java web概念</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/java-web%E6%A6%82%E5%BF%B5/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/java-web%E6%A6%82%E5%BF%B5/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="javaweb"><a class="markdownIt-Anchor" href="#javaweb"></a> JavaWeb</h1><ul><li>使用Java语言开发基于互联网的项目。</li></ul><h1 id="软件架构"><a class="markdownIt-Anchor" href="#软件架构"></a> 软件架构</h1><ul><li>C/S:Cient/Server 客户端/服务器端<ul><li>在用户本地有一个客户端程序，在远程有一个服务器端程序。</li><li>如：QQ等</li><li>优点：<ul><li>用户体验好</li></ul></li><li>缺点：<ul><li>开发，安装，部署，维护麻烦</li></ul></li></ul></li><li>B/S:Brower/Server 浏览器/服务器端<ul><li>只需要一个浏览器，用户通过不同的网址(URL),客户访问不同的服务器端程序</li><li>优点：<ul><li>开发，安装，部署，维护，简单</li></ul></li><li>缺点；<ul><li>如果应用过大，用户体验可能会受到影响；</li><li>对硬件要求过高。</li></ul></li></ul></li></ul><h1 id="bs架构"><a class="markdownIt-Anchor" href="#bs架构"></a> B/S架构</h1><ul><li><p>资源分类：</p><ol><li>静态资源：<ol><li>使用静态网页开发技术发布的资源</li><li>特点:<ol><li>所有用户访问得到的结果是<strong>一样</strong>的；</li><li>如：文本，图片，音频，视频，HTML,CSS,JavaScript（静态开发技术）</li><li>如果用户<strong>请求</strong>的是静态资源，那么服务器会直接将静态资源发送给浏览器，浏览器<strong>内置了静态资源的解析引擎</strong>，可以展示静态资源,称为<strong>响应</strong>。</li></ol></li></ol></li><li>动态资源<ol><li>使用动态网页技术发布的资源</li><li>特点：<ol><li>所有用户访问，得到的结果<strong>可能不一样。</strong></li><li>如：jsp/servlet,php,asp等动态网页开发技术</li><li>如果用户请求的是动态资源，服务器会<strong>执行动态资源，转换为静态资源</strong>再发送给浏览器。</li></ol></li></ol></li></ol></li><li><p>学习动态资源必须先学习静态资源，即静态网页技术三剑客。（HTML，CSS，JavaScript）</p></li><li><p>HTML:用于搭建基础网页，展示页面内容；</p></li><li><p>CSS:用于美化页面，布局页面。</p></li><li><p>JavaScript：控制页面的元素，使页面有动态的效果。</p></li></ul><h1 id="网络通信三要素"><a class="markdownIt-Anchor" href="#网络通信三要素"></a> 网络通信三要素</h1><ol><li>IP：电子设备（计算机）在网络中的唯一标识</li><li>端口：<strong>应用程序</strong>在计算机中的唯一标识，0~65536</li><li>传输协议：规定了数据传输的规则<ol><li>基础协议：<ol><li>tcp：安全协议，三次握手，速度较慢</li><li>udp：不安全协议，速度快</li></ol></li></ol></li></ol><h1 id="web服务器软件"><a class="markdownIt-Anchor" href="#web服务器软件"></a> web服务器软件</h1><ul><li>服务器：安装了服务器软件的计算机；</li><li>服务器软件：接收用户的请求，处理请求，做出响应；</li><li>web服务器软件：也能接收用户的请求，处理请求，做出响应，但有其特点：<ul><li>在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目；</li><li>动态资源必须在web服务器软件上使用，web服务器软件也被称为<strong>web容器</strong>。</li></ul></li><li>常见的java相关的web服务器软件：<ul><li>webLogic：orgcle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费；</li><li>webSphere:IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费；</li><li>JBOSS：JBOSS公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费；</li><li>Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servle/jso、开源，免费。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/JDBC/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/JDBC/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="jdbc概念"><a class="markdownIt-Anchor" href="#jdbc概念"></a> JDBC概念</h1><ul><li>JDBC是java database connectivity的缩写。是使用java语言来操作数据库。JDBC实现了使用统一的java代码来操作所有关系型数据库。</li><li>JDBC是sun公司定义的操作所有关系型数据库的规则，即定义了一套接口。</li><li>每一个数据库厂商实现JDBC接口来操作自己的数据库。这些实现类的jar包就叫做<strong>数据库驱动</strong>。</li><li>MySQL 8.0 以上版本的数据库连接有所不同：<ol><li>MySQL 8.0 以上版本驱动包版本 mysql-connector-java-8.0.16.jar。</li><li><code>com.mysql.jdbc.Driver</code> 更换为 <code>com.mysql.cj.jdbc.Driver</code></li></ol></li></ul><h1 id="jdbc基本使用"><a class="markdownIt-Anchor" href="#jdbc基本使用"></a> JDBC基本使用</h1><h2 id="1导入驱动jar包到项目目录下"><a class="markdownIt-Anchor" href="#1导入驱动jar包到项目目录下"></a> 1.导入驱动jar包到项目目录下</h2><ol><li>mysql的jar包下载:<a href="https://dev.mysql.com/downloads/connector/">官网</a>;下载时选择platformIndependent，选择5.xx的版本</li><li>复制jar包到项目的libs目录下（也可以直接导入），右键-&gt;add as library</li></ol><h2 id="2-注册驱动"><a class="markdownIt-Anchor" href="#2-注册驱动"></a> 2. 注册驱动</h2><ul><li><code>  Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code>,会产生ClsaaNotFoundException的异常。</li><li><code>The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server.</code>:如果对应的数据库服务未开启，或者名字输错了，就会报这个错。</li></ul><h2 id="3-获取数据库的连接对象"><a class="markdownIt-Anchor" href="#3-获取数据库的连接对象"></a> 3. 获取数据库的连接对象</h2><ul><li><code>Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/youth_study&quot;, &quot;root&quot;,&quot;root&quot;);</code><ul><li>参数依次为连接地址，用户名，密码。</li><li>连接地址中，后面是主机名：端口/数据库名</li></ul></li></ul><h2 id="4定义sql"><a class="markdownIt-Anchor" href="#4定义sql"></a> 4.定义sql</h2><ul><li><code>String sql = &quot;update t_branch set college_id = 2 where id = 1&quot;;</code>,定义一个存储sql语句的字符串。</li></ul><h2 id="5获取执行sql语句的对象"><a class="markdownIt-Anchor" href="#5获取执行sql语句的对象"></a> 5.获取执行sql语句的对象</h2><ul><li><code>Statement  stmt = conn.createStatement();</code>conn是数据库的连接对象。</li></ul><h2 id="6执行sql接受返回结果"><a class="markdownIt-Anchor" href="#6执行sql接受返回结果"></a> 6.执行sql，接受返回结果；</h2><ul><li><code> int count = stmt.executeUpdate(sql);</code></li><li><code> System.out.println(count);</code></li></ul><h2 id="7-释放资源"><a class="markdownIt-Anchor" href="#7-释放资源"></a> 7. 释放资源</h2><ul><li><code>conn.close();</code></li><li><code>stmt.close();</code></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;&#x2F;* * JDBC入门 *&#x2F;public class Jdbc1 &#123;    public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;        &#x2F;&#x2F;注册驱动        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);        &#x2F;&#x2F;获取数据库连接对象        Connection conn &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;3306&#x2F;youth_study&quot;, &quot;root&quot;,&quot;root&quot;);        &#x2F;&#x2F;定义sql语句        String sql &#x3D; &quot;update t_branch set college_id &#x3D; 2 where id &#x3D; 1&quot;;        &#x2F;&#x2F; 获取执行sql的对象        Statement  stmt &#x3D; conn.createStatement();        &#x2F;&#x2F; 执行sql        int count &#x3D; stmt.executeUpdate(sql);        &#x2F;&#x2F; 处理结果        System.out.println(count);        &#x2F;&#x2F; 释放资源        conn.close();        stmt.close();    &#125;&#125;</code></pre><h1 id="jdbc对象"><a class="markdownIt-Anchor" href="#jdbc对象"></a> JDBC对象</h1><h2 id="drivermanager"><a class="markdownIt-Anchor" href="#drivermanager"></a> DriverManager</h2><ul><li>驱动管理对象</li><li>功能：<ol><li>注册驱动</li><li>获取数据库的连接</li></ol></li></ul><h3 id="注册驱动"><a class="markdownIt-Anchor" href="#注册驱动"></a> 注册驱动</h3><ul><li>告诉程序该使用哪一个数据库驱动jar包</li><li>方法：<code>static void registerDriver(Driver driver)</code>,注册与给定的驱动程序</li><li>实际使用：<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code></li><li>在com.mysql.jdbc.Driver的源码中存在静态代码块：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">Static &#123;      try &#123;        java.sql.DriverManager.registerDriver(new Driver());      &#125; catch (SQLException E) &#123;        throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);      &#125;&#125;</code></pre><ul><li>通过导入jar包，就会自动注册驱动程序</li></ul><h3 id="获取数据库连接"><a class="markdownIt-Anchor" href="#获取数据库连接"></a> 获取数据库连接</h3><ul><li>让程序连接到具体的数据库；</li><li>方法：<code>static Connection getConnection(String url, String user, String password);</code></li><li>参数：<ul><li>url:指定连接数据库的路径<ul><li>语法：<code>jdbc:mysql://ip地址(域名):端口号/数据库名称</code></li><li>例子：<code>jdbc:mysql://localhost:3306/db1</code></li><li>特例:如果连接的是本机mysql的服务器，并且MySQL服务器的默认端口是3306，则URL可以简写为：<code>jdbc:mysql:///数据库名称</code></li></ul></li><li>user:用户名</li><li>password：用户密码</li></ul></li></ul><h2 id="connection"><a class="markdownIt-Anchor" href="#connection"></a> Connection</h2><ul><li>数据库连接对象</li><li>功能：<ol><li>获取执行sql的对象</li><li>管理事务</li></ol></li></ul><h3 id="获取执行sql的对象"><a class="markdownIt-Anchor" href="#获取执行sql的对象"></a> 获取执行sql的对象</h3><ul><li>创建一个能够接收sql语句的对象；</li><li>方法：<ul><li><code>Statement createStatement();</code></li><li><code>PreparedStatement prepareStatement(String sql);</code></li></ul></li></ul><h3 id="管理事务"><a class="markdownIt-Anchor" href="#管理事务"></a> 管理事务</h3><ul><li>包含处理事务的开启，提交，回滚的方法；</li><li>开启事务：<code>void setAutoCommit(boolean autoCommit);</code>,调用该方法并设置参数为<strong>false</strong>，即可开启事务。（因为设为true则代表着着事务是自动提交，也就没有人的管理，所以也就没有开不开启事务之说）,在执行sql之前开启事务（通常是刚创建连接生成Conneection对象时），示例：<code>conn.setAutoCommit(false);</code></li><li>提交事务：<code>void commit()</code>，在所有sql执行完时提交，示例：<code>conn.commit();</code></li><li>回滚事务：<code>void rollback();</code>，回滚事务的操作一般放在catch块中，即出现异常时才回滚。调用示例：<code>conn.rollback();</code></li></ul><h2 id="statement"><a class="markdownIt-Anchor" href="#statement"></a> Statement</h2><ul><li>用于执行<strong>静态SQL语句</strong>并放回其生成的结果的对象。</li><li><code>boolean execute(String sql);</code>,可以执行任意的sql语句，不常用。</li><li><code>int executeUpdate(String sql);</code>:执行DML（insert， update， delete）语句，也可以执行DDL（create， alter ，drop）语句（但是这些操作一般不会使用java代码实现，所以这个方法常用于执行DML语句）。<ul><li>返回值：该方法的返回值是<strong>执行该sql语句影响的行数</strong>，通过这个返回值来判断sql语句是否执行成功（返回值&gt;0则成功）。</li></ul></li><li><code>ResultSet executeQuery(String sql);</code>:执行DQL（select）语句。</li></ul><h2 id="resultset"><a class="markdownIt-Anchor" href="#resultset"></a> ResultSet</h2><ul><li>结果集对象，封装了查询的结果；</li><li>Result对象可以想象为是一个指向查询结果表的<strong>游标</strong>（类似c语言的指针概念），这个“游标”开始是指向表头的。</li><li><code>boolean next() </code>:使游标指向下一行，并判断当前行是否有数据，如果没有则返回false。</li><li><code>getXxx(参数)</code>:获取某一个数据<ul><li>Xxx；代表返回的数据类型，与要查询的数据的数据类型相匹配、如：<code>int getInt(), String getString()</code>;</li><li>参数：<ol><li>int类型的参数：代表列的编号，从左往右数，从1开始。如：<code>getString(1);</code>表示取出当前游标所指行的第一列的数据</li><li>String类型的参数：代表列的名称。如:<code>getDouble(&quot;balance&quot;)</code>表示取出当前行名为balance列的数据。</li></ol></li></ul></li><li>使用步骤：<ol><li>游标向下移动一行</li><li>判断是否有数据</li><li>获取数据</li><li>如果有多行数据需要输出，则使用循环重复以上三个步骤，可以遍历整个结果集的数据。</li></ol></li></ul><h2 id="preparedstatement"><a class="markdownIt-Anchor" href="#preparedstatement"></a> PreparedStatement</h2><ul><li>是Statement的子类，但是功能更加强大；</li><li>SQL注入问题：在拼接sql语句时，有一些sql的特殊关键字参与字符串的拼接，会造成sql语句的含义改变，导致安全问题。<ul><li>示例：<code>String sql = &quot;select * from user where username = '&quot;+username+&quot;' and password = '&quot;+password+&quot;'&quot;</code>,其中被单双引号包裹的是传进来的字符串参数。(注意这种拼接字符串的特殊格式)。这种直接拼接参数的sql语句也叫做<strong>静态sql语句</strong>。</li><li>如果username = “zhangsan”,password = “a’ or ‘a’ = 'a”,那么拼接上参数的值后的sql语句为：<code>sql = &quot;select * from user where username = '&quot;+&quot;zhangsan&quot;+&quot;' and password = '&quot;+&quot;a' or 'a' = 'a&quot;&quot;'&quot;</code>将双引号合并之后为:<code>sql = &quot;select * from user where username = 'zhangsan' and password = 'a' or 'a' = 'a'&quot;</code>,这个sql语句的含义就和我们原本的想象大不相同了。</li></ul></li><li>解决SQL注入问题：使用PreparedStatement对象替换原来的Statement对象。</li><li><strong>预编译的sql语句</strong>：将sql语句中的参数使用占位符<code>?</code>来代替。</li><li>ParparedStatement类型才是一般情况下通用的JDBC使用方法；</li><li>可以防止sql注入问题，效率更高。</li></ul><h3 id="使用步骤"><a class="markdownIt-Anchor" href="#使用步骤"></a> 使用步骤</h3><ol><li>导入驱动jar包</li><li>注册驱动</li><li>获取数据库连接对象Connection</li><li>定义sql语句：<ol><li>需要参数的地方使用<code>?</code>来代替。如：<code>String sql = &quot;select * from user where username = ? and password = ?</code></li></ol></li><li>获取执行sql语句的PreparedStatement对象：使用Connection.prepareStatement(String sql)方法，如<code>PreparedStatement patmt = conn.prepareStatement(sql);</code></li><li>给<code>?</code>占位符赋上参数的值：</li></ol><ul><li>方法：<code>setXxx(参数1，参数2)</code><ul><li>Xxx是参数的类型；</li><li>参数1是int类型：是参数在sql语句中的相对位置来定的，从左往右，从1开始编号。第一个参数的参数1就是1</li><li>参数2：就是具体的参数。</li><li>示例：<code>pstmt.setString(1,username);</code></li><li><code>pstmt.setString(2, password);</code></li></ul></li></ul><ol start="7"><li>执行sql，接收返回结果，<strong>不需要传递sql语句</strong>（与Statement不同），如：<code>ResultSet rs = pstmt.excuteQuery();</code></li><li>处理结果</li><li>释放资源</li></ol><h1 id="jdbc工具类"><a class="markdownIt-Anchor" href="#jdbc工具类"></a> JDBC工具类</h1><ul><li>作用：将重复的代码封装进一个类中，简化代码的书写。</li><li>抽取的代码：<ul><li>注册驱动的代码；<ul><li>驱动只需注册一次，所以直接在静态代码块中实现</li></ul></li><li>抽取获取连接对象的代码：<ul><li>需求：不传递参数的同时，保证工具类的通用性。</li><li>解决方法：书写<code>.properties</code>配置文件。此处是<code>jdbc.properties</code>文件.在这个文件中将获取连接对象的参数写好,之后再次使用该工具类连接不同的数据库时，只需要修改配置文件即可。<strong>.properties文件是直接放在src文件夹下</strong>。</li></ul></li></ul></li></ul><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">url &#x3D; jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db3user &#x3D; rootpassword &#x3D; rootdriver &#x3D; com.mysql.jdbc.Driver</code></pre><ul><li>抽取释放资源的代码。</li><li>工具类的实现：JDBCUtils类</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.FileReader;import java.io.IOException;import java.net.URL;import java.sql.*;import java.util.Properties;public class JDBCUtils &#123;    private static String url;    private static String user;    private static String password;    private static String driver;    &#x2F;*     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块，只读取一次这些值     *&#x2F;    static &#123;        try &#123;            &#x2F;&#x2F;1. 创建Properties集合类            Properties pro &#x3D; new Properties();            &#x2F;&#x2F;2. 获取src路径下的文件的方式:使用ClassLoader类加载器            &#x2F;&#x2F;获取src文件夹在计算机中的绝对路径            ClassLoader classLoader &#x3D; JDBCUtils.class.getClassLoader();            &#x2F;&#x2F;获取src文件夹下配置文件的url格式的路径            URL res &#x3D; classLoader.getResource(&quot;jdbc.properties&quot;);            &#x2F;&#x2F;将url路径转换为字符串形式            String path &#x3D; res.getPath();            &#x2F;&#x2F;3.加载文件            pro.load(new FileReader(path));            &#x2F;&#x2F;4.获取数据，赋值            url &#x3D; pro.getProperty(&quot;url&quot;);            user &#x3D; pro.getProperty(&quot;user&quot;);            password &#x3D; pro.getProperty(&quot;password&quot;);            driver &#x3D; pro.getProperty(&quot;driver&quot;);            &#x2F;&#x2F;5. 注册驱动            Class.forName(driver);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;    &#x2F;**     * 获取连接     * @return 连接对象     *&#x2F;    public static Connection getConnection() throws SQLException &#123;        return DriverManager.getConnection(url, user, password);    &#125;    &#x2F;**     * 释放资源     * @param stmt     * @param conn     * @param rs     *&#x2F;    public static void close(ResultSet rs, Statement stmt, Connection conn) &#123;        if(rs !&#x3D; null) &#123;            try &#123;                rs.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        if(stmt !&#x3D; null) &#123;            try &#123;                stmt.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;                if(conn !&#x3D; null) &#123;            try &#123;                conn.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><h1 id="数据库连接池"><a class="markdownIt-Anchor" href="#数据库连接池"></a> 数据库连接池</h1><ul><li>概念：<ul><li>在一个容器（集合）中存放数据库连接对象（Connection对象）。</li><li>当系统初始化后，容器被创建，容器中会申请需要使用的连接对象，当用户需要访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。</li><li>优化了之前的在用户需要使用连接对象时才申请连接对象，用户用完就释放的连接对象使用方式，节约资源，提高用户访问数据库的效率。</li></ul></li></ul><h2 id="数据库连接池实现"><a class="markdownIt-Anchor" href="#数据库连接池实现"></a> 数据库连接池实现</h2><ul><li>标准接口；DataSource接口，在javax.sql包下；<ul><li>方法：<ul><li>获取连接：<code>getConnection()</code></li><li>归还连接：<code>Connect.close()</code>。如果连接对象Conneection是从连接池获取的，那么调用Connection.close()方法，则不会关闭连接，而是归还连接到数据连接池中去。</li></ul></li></ul></li><li>具体实现一般是由具体的数据库厂商来完成的，常见的有C3P0、Druid（阿里巴巴实现的）等数据库连接池技术。</li></ul><h3 id="c3p0"><a class="markdownIt-Anchor" href="#c3p0"></a> C3P0</h3><ul><li>步骤；<ol><li>导入三个jar包；c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar 以及数据库的驱动jar包</li><li>第一配置文件<ol><li>名称；c3p0.properties或者c3p0-config.xml</li><li>路径：直接将文件放在src目录下即可。</li></ol></li></ol></li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;c3p0-config&gt;    &lt;!-- 默认配置 --&gt;    &lt;default-config&gt;        &lt;!-- 连接参数 --&gt;        &lt;property name &#x3D;&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt;        &lt;property name &#x3D;&quot;jdbcUrl&quot;&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;youth_study&lt;&#x2F;property&gt;        &lt;property name&#x3D;&quot;user&quot;&gt;root&lt;&#x2F;property&gt;        &lt;property name&#x3D;&quot;password&quot;&gt;root&lt;&#x2F;property&gt;        &lt;!-- 连接池参数 --&gt;        &lt;!-- &lt;property name&#x3D;&quot;automaticTestTable&quot;&gt;con_test&lt;&#x2F;property&gt; --&gt;        &lt;property name&#x3D;&quot;checkoutTimeout&quot;&gt;3000&lt;&#x2F;property&gt;        &lt;!-- &lt;property name&#x3D;&quot;idleConnectionTestPeriod&quot;&gt;30&lt;&#x2F;property&gt; --&gt;        &lt;property name&#x3D;&quot;initialPoolSize&quot;&gt;5&lt;&#x2F;property&gt;        &lt;!-- &lt;property name&#x3D;&quot;maxIdleTime&quot;&gt;30&lt;&#x2F;property&gt; --&gt;        &lt;!-- &lt;property name&#x3D;&quot;maxIdleTimeExcessConnections&quot;&gt;10&lt;&#x2F;property&gt; --&gt;        &lt;!-- &lt;property name&#x3D;&quot;maxConnectionAge&quot;&gt;60&lt;&#x2F;property&gt; --&gt;        &lt;!-- &lt;property name&#x3D;&quot;propertyCycle&quot;&gt;1&lt;&#x2F;property&gt; --&gt;        &lt;property name&#x3D;&quot;maxPoolSize&quot;&gt;10&lt;&#x2F;property&gt;        &lt;!-- &lt;property name&#x3D;&quot;minPoolSize&quot;&gt;5&lt;&#x2F;property&gt; --&gt;        &lt;!-- &lt;property name&#x3D;&quot;maxStatements&quot;&gt;0&lt;&#x2F;property&gt; --&gt;        &lt;!-- &lt;property name&#x3D;&quot;maxStatementsPerConnection&quot;&gt;5&lt;&#x2F;property&gt; --&gt;        &lt;!-- &lt;property name&#x3D;&quot;maxAdministrativeTaskTime&quot;&gt;4&lt;&#x2F;property&gt; --&gt;        &lt;!-- &lt;property name&#x3D;&quot;connectionCustomizerClassName&quot;&gt;com.mchange.v2.c3p0.test.TestConnectionCustomizer&lt;&#x2F;property&gt; --&gt;        &lt;!-- &lt;property name&#x3D;&quot;unreturnedConnectionTimeout&quot;&gt;15&lt;&#x2F;property&gt; --&gt;        &lt;!-- &lt;property name&#x3D;&quot;debugUnreturnedConnectionStackTraces&quot;&gt;true&lt;&#x2F;property&gt; --&gt;        &lt;!-- &lt;property name&#x3D;&quot;dataSourceName&quot;&gt;poop&lt;&#x2F;property&gt; --&gt;        &lt;!-- &lt;property name&#x3D;&quot;driverClass&quot;&gt;org.postgresql.Driver&lt;&#x2F;property&gt; --&gt;        &lt;!-- &lt;property name&#x3D;&quot;jdbcUrl&quot;&gt;jdbc:postgresql:&#x2F;&#x2F;localhost&#x2F;c3p0-test&lt;&#x2F;property&gt; --&gt;    &lt;&#x2F;default-config&gt;        &lt;!-- 指定名称的配置 --&gt;    &lt;named-config name &#x3D; &quot;otherconfig&quot;&gt;        &lt;!-- 连接参数 --&gt;        &lt;property name &#x3D;&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt;        &lt;property name &#x3D;&quot;jdbcUrl&quot;&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;youth_study&lt;&#x2F;property&gt;        &lt;property name&#x3D;&quot;user&quot;&gt;root&lt;&#x2F;property&gt;        &lt;property name&#x3D;&quot;password&quot;&gt;root&lt;&#x2F;property&gt;        &lt;!-- 连接池参数 --&gt;        &lt;property name&#x3D;&quot;checkoutTimeout&quot;&gt;3000&lt;&#x2F;property&gt;        &lt;property name&#x3D;&quot;initialPoolSize&quot;&gt;5&lt;&#x2F;property&gt;        &lt;property name&#x3D;&quot;maxPoolSize&quot;&gt;8&lt;&#x2F;property&gt;    &lt;&#x2F;named-config&gt;&lt;&#x2F;c3p0-config&gt;</code></pre><ol start="3"><li>创建核心对象:数据库连接池对象，<code>ComboPooledDataSource</code></li></ol>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;获取DataSorce，使用默认的c3p0-config.xml配置 DataSource ds &#x3D; new ComboPooledDataSource(); &#x2F;&#x2F;获取DataSource,指定名称配置  DataSource ds &#x3D; new ComboPooledDataSource(&quot;Otherc3p0&quot;);</code></pre><ol start="4"><li>获取连接：getConnection</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">Connection conn &#x3D; ds.getConnection();</code></pre><ol start="5"><li>归还连接</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">conn.close();</code></pre><h3 id="druid"><a class="markdownIt-Anchor" href="#druid"></a> druid</h3><h4 id="使用步骤-2"><a class="markdownIt-Anchor" href="#使用步骤-2"></a> 使用步骤</h4><ol><li>导入jar包：druid-1.0.9.jar</li><li>定义配置文件：<ol><li>是<code>.properties</code>文件</li><li>可以叫任意名称，放在任意目录下，需要手动加载。</li></ol></li></ol><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">driverClassName&#x3D;com.mysql.jdbc.Driverurl&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;youth_studyusername&#x3D;rootpassword&#x3D;root# 初始化连接数量initialSize&#x3D;5# 最大连接数量maxActive&#x3D;10# 最长等待时间maxWait&#x3D;3000</code></pre><ol start="3"><li>加载配置文件</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">Properties pro &#x3D; new Properties(); &#x2F;&#x2F;创建Properties对象InputStream is &#x3D; DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); &#x2F;&#x2F;获取properties文件的输入流pro.load(is); &#x2F;&#x2F;根据输入流来加载配置文件</code></pre><ol start="4"><li>获取数据库连接池对象：<ol><li>通过工厂类来获取，DruidDataSourceFactory,需要将Properties配置文件对象传递给工厂方法。</li></ol></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">DataSource ds &#x3D; DruidDataSourceFactory.createDataSource(pro);;</code></pre><ol start="5"><li>获取连接：getConnnection</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">Connection conn &#x3D; ds.getConnection();System.out.println(conn);</code></pre><h4 id="druid工具类"><a class="markdownIt-Anchor" href="#druid工具类"></a> druid工具类</h4><ol><li>定义一个类JDBCUtils</li><li>提供静态代码块加载配置文件，初始化连接池对象</li><li>提供方法：<ol><li>获取连接方法：通过数据库连接池获取连接</li><li>释放资源</li><li>获取连接池的方法</li></ol></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.Utils;import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import java.io.IOException;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.Properties;&#x2F;** * druid连接池的工具类 *&#x2F;public class JDBCUtils &#123;    &#x2F;&#x2F;1.定义成员变量    private static DataSource ds;    static &#123;        try &#123;            &#x2F;&#x2F;1.加载配置文件            Properties pro &#x3D; new Properties();            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));;            &#x2F;&#x2F;2. 获取DataSource            ds &#x3D; DruidDataSourceFactory.createDataSource(pro);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    &#x2F;**     * 获取连接     *&#x2F;    public static Connection getConnection() throws SQLException &#123;        return ds.getConnection();    &#125;    &#x2F;**     * 释放资源     *&#x2F;    public static void close(ResultSet rs, Statement stmt, Connection conn) &#123;        if (rs !&#x3D; null) &#123;            try &#123;                rs.close();            &#125; catch (SQLException throwables) &#123;                throwables.printStackTrace();            &#125;        &#125;        if (stmt !&#x3D; null) &#123;            try &#123;                stmt.close();            &#125; catch (SQLException throwables) &#123;                throwables.printStackTrace();            &#125;        &#125;        if (conn !&#x3D; null) &#123;            try &#123;                conn.close(); &#x2F;&#x2F;归还连接            &#125; catch (SQLException throwables) &#123;                throwables.printStackTrace();            &#125;        &#125;    &#125;    &#x2F;**     * 释放资源的重载，两个参数     *&#x2F;    public static void close (Statement stmt, Connection conn) &#123;        JDBCUtils.close(null, stmt, conn);    &#125;    &#x2F;**     * 获取连接池     *&#x2F;    public static DataSource getDataSource() &#123;        return ds;    &#125;&#125;</code></pre><ul><li>工具类使用示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.druid;import com.Utils.JDBCUtils;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.Properties;&#x2F;** * 使用工具类 *&#x2F;public class DruidDemo2 &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;把要被释放的资源的定义放在try-catch语块之外，使得释放资源时方便，不会出现没有定义的错误        Connection conn &#x3D; null;        PreparedStatement pstmt &#x3D; null;        try &#123;            &#x2F;&#x2F;1.获取连接            conn &#x3D; JDBCUtils.getConnection();            &#x2F;&#x2F;2. 定义sql            String sql &#x3D; &quot;update t_branch set college_id &#x3D; ? where id &#x3D; ?&quot;;            &#x2F;&#x2F;3. 获取PreparedStatement对象            pstmt &#x3D; conn.prepareStatement(sql);            &#x2F;&#x2F;4.给sql语句里面的参数赋值            pstmt.setInt(1, 333);            pstmt.setInt(2,1);            &#x2F;&#x2F;执行sql语句            int count &#x3D; pstmt.executeUpdate();            &#x2F;&#x2F;结果处理            System.out.println(count);        &#125; catch (SQLException throwables) &#123;            throwables.printStackTrace();        &#125;finally &#123;            &#x2F;&#x2F;释放资源            JDBCUtils.close(pstmt, conn);        &#125;    &#125;&#125;</code></pre><h1 id="spring-jdbc"><a class="markdownIt-Anchor" href="#spring-jdbc"></a> Spring JDBC</h1><ul><li>Spring框架对JDBC的简单封装。提供了一个<strong>JDBCTemplate对象</strong>简化JDBC的开发。</li></ul><h2 id="spring-jdbc的使用步骤"><a class="markdownIt-Anchor" href="#spring-jdbc的使用步骤"></a> Spring JDBC的使用步骤</h2><ol><li>导入jar包<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201207173331.jpg" alt="" /></li><li>创建JDBCTemplate对象。依赖于数据源对象<code>DataSource ds</code><ol><li><code>JDBCTemplate template = new JDBCTemplate(ds);</code></li></ol></li><li>调用JDBCTemplate的方法来完成CRUD的操作：<ol><li><code>update()</code>:执行DML语句，完成增，删，改语句。<ol><li>如果需要往sql语句中传入参数，就使用<code>update(sql,参数1，参数2...)</code>,参数的顺序就是他们在sql语句中从左至右的顺序。</li></ol></li><li><code>queryForMap()</code>:查询结果将结果集封装为Map集合；<ol><li>查询结果集长度只能是1。</li></ol></li><li><code>queryForList()</code>:查询结果将结果集封装为List集合；</li><li><code>query()</code>:查询结果，将结果封装为JavaBean对象；</li><li><code>queryForObject()</code>:查询结果，将结果集封装为对象（一般是基本数据类型）。</li></ol></li><li>使用JDBCTemplat<strong>无需释放资源</strong>（会自动进行）。</li></ol><ul><li>使用示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.JDBCtemplate;import com.Utils.JDBCUtils;import org.springframework.jdbc.core.JdbcTemplate;&#x2F;** * JDBCTemplate入门使用 *&#x2F;public class JdbcTemplateDemo1 &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;1.导入jar包        &#x2F;&#x2F;2.创建JDBCTemplate对象        JdbcTemplate template &#x3D; new JdbcTemplate(JDBCUtils.getDataSource());        &#x2F;&#x2F;3.调用方法        String sql &#x3D; &quot;update t_branch set college_id &#x3D; ? where id &#x3D; ?&quot;;        &#x2F;&#x2F;4,执行sql并传参        int count&#x3D; template.update(sql,555,1);        System.out.println(count);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JDBC </tag>
            
            <tag> Druid </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/docker/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/docker/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="docker概述"><a class="markdownIt-Anchor" href="#docker概述"></a> Docker概述</h1><p><a href="https://www.runoob.com/docker/docker-tutorial.html">参考教程</a></p><ul><li>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。</li><li>Docker的应用场景：<ul><li>Web 应用的自动化打包和发布。</li><li>自动化测试和持续集成、发布。</li><li>在服务型环境中部署和调整数据库或其他的后台应用。</li><li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li></ul></li></ul><h2 id="docker架构"><a class="markdownIt-Anchor" href="#docker架构"></a> Docker架构</h2><ul><li>Docker 包括三个基本概念:<ul><li>镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li><li>容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li><li>仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。</li></ul></li><li>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。</li><li>Docker 容器通过 Docker 镜像来创建。容器与镜像的关系类似于面向对象编程中的对象与类。</li></ul><h1 id="docker安装"><a class="markdownIt-Anchor" href="#docker安装"></a> Docker安装</h1><p><a href="https://www.runoob.com/docker/ubuntu-docker-install.html">参考资料</a></p><h1 id="docker的基础使用"><a class="markdownIt-Anchor" href="#docker的基础使用"></a> Docker的基础使用</h1><h2 id="运行helloworld"><a class="markdownIt-Anchor" href="#运行helloworld"></a> 运行helloworld</h2><ul><li>命令：<code>docker run ubuntu:15.10 /bin/echo &quot;Hello world&quot;</code><ul><li>docker: Docker 的二进制执行文件。</li><li>run: 与前面的 docker 组合来运行一个容器。</li><li>ubuntu:15.10 指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。</li><li>/bin/echo “Hello world”: 在启动的容器里执行的命令。</li></ul></li><li>以上命令完整的意思可以解释为：Docker 以 ubuntu15.10 镜像创建一个新容器，然后在容器里执行 bin/echo “Hello world”，然后输出结果。</li></ul><h2 id="运行交互式容器"><a class="markdownIt-Anchor" href="#运行交互式容器"></a> 运行交互式容器</h2><ul><li>我们通过 docker 的两个参数 -i -t，让 docker 运行的容器实现&quot;对话&quot;的能力；<ul><li>-t: 在新容器内指定一个伪终端或终端。</li><li>-i: 允许你对容器内的标准输入 (STDIN) 进行交互。</li></ul></li><li>命令示例：<code>docker run -i -t ubuntu:15.10</code>，-i，-t两个参数必须同时使用，如果只使用-t则会只有一个终端界面，但是输入命令不会有反应。</li><li>我们可以通过运行 exit 命令或者使用 CTRL+D 来退出容器。</li></ul><h2 id="启动容器后台模式"><a class="markdownIt-Anchor" href="#启动容器后台模式"></a> 启动容器（后台模式）</h2><ul><li>命令:<code>docker run -d ubuntu:15.10 /bin/echo &quot;helloworld&quot;</code><ul><li>在输出中，我们没有看到期望的 “hello world”，而是一串长字符串2b1b7a428627c51ab8810d541d759f072b4fc75487eed05812646b8534a2fe63。这个长字符串叫做容器 ID，对每个容器来说都是唯一的，我们可以通过容器 ID 来查看对应的容器发生了什么。</li></ul></li><li>确认容器有在运行，可以通过 docker ps 来查看：<ul><li>输出详情介绍：<ul><li>CONTAINER ID: 容器 ID。</li><li>IMAGE: 使用的镜像。</li><li>COMMAND: 启动容器时运行的命令。</li><li>CREATED: 容器的创建时间。</li><li>STATUS: 容器状态。<ul><li>状态有7种：<ul><li>created（已创建）</li><li>restarting（重启中）</li><li>running 或 Up（运行中）</li><li>removing（迁移中）</li><li>paused（暂停）</li><li>exited（停止）</li><li>dead（死亡）</li></ul></li></ul></li><li>PORTS: 容器的端口信息和使用的连接类型（tcp\udp）。</li><li>NAMES: 自动分配的容器名称。</li></ul></li></ul></li><li>在宿主主机内使用 docker logs 命令，查看容器内的标准输出：<ul><li>示例：<code>docker logs 2b1b7a428627</code>(这串数字是容器id的前面一部分)</li></ul></li><li>我们使用 docker stop 命令来停止容器：<ul><li>示例：<code>docker stop 2b1b7a428627</code></li></ul></li></ul><h1 id="docker容器使用"><a class="markdownIt-Anchor" href="#docker容器使用"></a> Docker容器使用</h1><h2 id="docker客户端"><a class="markdownIt-Anchor" href="#docker客户端"></a> Docker客户端</h2><ul><li>docker 客户端非常简单 ,我们可以直接输入 <code>docker </code>命令来查看到 Docker 客户端的所有命令选项。</li><li>可以通过命令 <code>docker &lt;command&gt; --help </code>更深入的了解指定的 Docker 命令使用方法。例如我们要查看 docker stats 指令的具体使用方法：<code>docker stats --help</code></li></ul><h2 id="容器的使用"><a class="markdownIt-Anchor" href="#容器的使用"></a> 容器的使用</h2><h3 id="获取镜像"><a class="markdownIt-Anchor" href="#获取镜像"></a> 获取镜像</h3><ul><li>如果我们本地没有 ubuntu 镜像，我们可以使用 docker pull 命令来载入 ubuntu 镜像：<code>docker pull ubuntu</code></li></ul><h3 id="启动容器"><a class="markdownIt-Anchor" href="#启动容器"></a> 启动容器</h3><ul><li>以下命令使用 ubuntu 镜像启动一个容器，参数为以命令行模式进入该容器：<code> docker run -it ubuntu /bin/bash</code>;</li><li>参数说明：<ul><li>-i: 交互式操作。</li><li>-t: 终端。</li><li>ubuntu: ubuntu 镜像。</li><li>/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。（省略/bin/bash也能达到同样的效果）</li></ul></li><li>要退出终端，直接输入 exit;</li><li>docker的许多命令都需要使用<code>sudo</code>权限；</li></ul><h3 id="启动已停止的容器"><a class="markdownIt-Anchor" href="#启动已停止的容器"></a> 启动已停止的容器</h3><ul><li>查看所有的容器命令：<code>docker ps -a</code>,不加参数名，则只有表头，没有具体容器的信息。</li><li>查看最后一次创建的容器<code>docker ps -l</code>。</li><li>使用 docker start 启动一个已停止的容器：<code>docker start b750bbbcfd88</code>,最后那串数字是容器id的开头一部分，终端会自动识别出整个容器ID。但是这样容器启动后并不会输出相应的数据，我们能看见的只是终端上<strong>打印出的容器id</strong>.</li></ul><h3 id="后台运行"><a class="markdownIt-Anchor" href="#后台运行"></a> 后台运行</h3><ul><li>在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过参数<code>-d</code> 指定容器的运行模式为后台运行。</li><li>加了<code>-d</code> 参数默认不会进入容器，想要进入容器需要使用指令 <code>docker exec</code></li><li>后台运行的指令成功后，终端只会打印容器的id。示例:<code>docker run -itd --name ubuntu-test ubuntu /bin/bash</code></li></ul><h3 id="停止容器"><a class="markdownIt-Anchor" href="#停止容器"></a> 停止容器</h3><ul><li>停止容器的命令如下：<code>docker stop &lt;容器 ID&gt;</code></li><li>停止的容器和正在运行的容器可以通过 docker restart 重启：<code>docker restart &lt;容器 ID&gt;</code></li></ul><h3 id="进入容器"><a class="markdownIt-Anchor" href="#进入容器"></a> 进入容器</h3><ul><li>在使用 -d 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：</li><li><code>docker attach</code>：<ul><li>示例：<code>docker attach 1e560fca3906 </code>,没有参数之类的东西，直接使用容器id进入即可。</li></ul></li><li><code>docker exec</code>：推荐大家使用 docker exec 命令，因为使用此命令在退出容器终端后，不会导致容器的停止。<ul><li>示例：<code>docker exec -it 243c32535da7 /bin/bash</code>,就像普通打开一个容器一样，docker exec命令后要有完整的参数，容器id和运行的命令（此处的/bin/bash）不可省略，退出终端仍然使用exit。</li></ul></li></ul><h3 id="导出和导入容器"><a class="markdownIt-Anchor" href="#导出和导入容器"></a> 导出和导入容器</h3><ul><li>如果要导出本地某个容器，可以使用<code>docker export</code> 命令。<ul><li>示例:<code>docker export 1e560fca3906 &gt; ./test/ubuntu.tar</code>,导出容器 1e560fca3906 快照到本地文件 ubuntu.tar。</li></ul></li><li>可以使用<code>docker import</code> 从容器快照文件中再导入为镜像，以下实例将快照文件 ubuntu.tar 导入到镜像 test/ubuntu:v1:<code>cat test/ubuntu.tar | sudo docker import - ubuntu1</code>.</li><li>此外，也可以通过指定 URL 或者某个目录来导入，例如：<code>docker import http://example.com/exampleimage.tgz example/imagerepo</code></li><li>导出和导入的实际上都是镜像，要使用的话，还需根据镜像创建容器。</li></ul><h3 id="删除容器"><a class="markdownIt-Anchor" href="#删除容器"></a> 删除容器</h3><ul><li>删除容器使用 docker rm 命令，删除的容器必须是终止的，否则会报错。<ul><li>示例：<code>docker rm -f 1e560fca390</code>,这串数字是容器id。</li></ul></li><li>下面的命令可以清理掉所有处于终止状态的容器:<code>docker container prune</code></li></ul><h2 id="web应用使用"><a class="markdownIt-Anchor" href="#web应用使用"></a> web应用使用</h2><h3 id="运行一个web应用"><a class="markdownIt-Anchor" href="#运行一个web应用"></a> 运行一个web应用</h3><ul><li>我们尝试使用 docker 构建一个 web 应用程序。我们将在docker容器中运行一个 Python Flask 应用来运行一个web应用。</li><li>载入镜像：<code>docker pull training/webapp</code></li><li>后台运行：<code>docker run -d -P training/webapp python app.py</code><ul><li>参数说明:<ul><li>-d:让容器在后台运行。</li><li>-P:将容器内部使用的网络端口随机映射到我们使用的主机上。</li></ul></li></ul></li></ul><h3 id="查看web应用容器"><a class="markdownIt-Anchor" href="#查看web应用容器"></a> 查看web应用容器</h3><ul><li>使用<code>sudo docker ps -a</code>来查看web应用容器。<ul><li>这里多了端口信息。</li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">PORTS0.0.0.0:32769-&gt;5000&#x2F;tcp</code></pre><ul><li>Docker 开放了 5000 端口（默认 Python Flask 端口）映射到主机端口 32769 上。这时我们可以通过浏览器访问WEB应用. 在浏览器地址栏输入<code>localhost:32769</code>即可访问web应用。</li><li>我们也可以通过<code>-p</code> 参数来设置不一样的端口：<code> docker run -d -p 5000:5000 training/webapp python app.py</code>容器内部的 5000 端口映射到我们本地主机的 5000 端口上。</li><li>查看端口号的快捷方式：<code>docker port &lt;容器id&gt;/&lt;容器名&gt;</code>来直接查看容器的端口的映射情况。</li></ul><h3 id="查看web应用的日志信息"><a class="markdownIt-Anchor" href="#查看web应用的日志信息"></a> 查看web应用的日志信息</h3><ul><li><code>docker logs &lt;容器id&gt;/&lt;容器名&gt;</code> 可以查看容器内部的标准输出。示例：</li></ul><pre class="line-numbers language-none"><code class="language-none">docker logs -f bf08b7f2cd89 * Running on http:&#x2F;&#x2F;0.0.0.0:5000&#x2F; (Press CTRL+C to quit)192.168.239.1 - - [09&#x2F;May&#x2F;2016 16:30:37] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 200 -192.168.239.1 - - [09&#x2F;May&#x2F;2016 16:30:37] &quot;GET &#x2F;favicon.ico HTTP&#x2F;1.1&quot; 404 -</code></pre><ul><li>-f: 让 docker logs 像使用 tail -f 一样来输出容器内部的标准输出。</li></ul><h3 id="查看web应用容器的进程"><a class="markdownIt-Anchor" href="#查看web应用容器的进程"></a> 查看web应用容器的进程</h3><ul><li>我们还可以使用 <code>docker top &lt;容器id&gt;/&lt;容器名&gt; </code> 来查看容器内部运行的进程。</li></ul><h3 id="检查web应用程序"><a class="markdownIt-Anchor" href="#检查web应用程序"></a> 检查web应用程序</h3><ul><li>使用<code>docker inspect &lt;容器id&gt;/&lt;容器名&gt;</code> 来查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息.</li></ul><h1 id="docker镜像使用"><a class="markdownIt-Anchor" href="#docker镜像使用"></a> Docker镜像使用</h1><ul><li>当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。</li></ul><h2 id="列出镜像列表"><a class="markdownIt-Anchor" href="#列出镜像列表"></a> 列出镜像列表</h2><ul><li>我们可以使用 <code>docker images</code> 来列出本地主机上的镜像。</li></ul><pre class="line-numbers language-none"><code class="language-none">runoob@runoob:~$ docker images           REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              14.04               90d5884b1ee0        5 days ago          188 MBphp                 5.6                 f40e9e0f10c8        9 days ago          444.8 MBnginx               latest              6f8d099c3adc        12 days ago         182.7 MBmysql               5.6                 f2e8d6c772c0        3 weeks ago         324.6 MBhttpd               latest              02ef73cf1bc0        3 weeks ago         194.4 MBubuntu              15.10               4e3b13c8a266        4 weeks ago         136.3 MBhello-world         latest              690ed74de00f        6 months ago        960 Btraining&#x2F;webapp     latest              6fae60ef3446        11 months ago       348.8 MB</code></pre><ul><li>各个选项说明:<ul><li>REPOSITORY：表示镜像的仓库源</li><li>TAG：镜像的标签<ul><li>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</li><li>如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。</li></ul></li><li>IMAGE ID：镜像ID</li><li>CREATED：镜像创建时间</li><li>SIZE：镜像大小</li></ul></li></ul><h2 id="获取新镜像"><a class="markdownIt-Anchor" href="#获取新镜像"></a> 获取新镜像</h2><ul><li>当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 <code>docker pull &lt;镜像名&gt;:&lt;标签&gt;</code>命令来下载它。</li></ul><h2 id="查找镜像"><a class="markdownIt-Anchor" href="#查找镜像"></a> 查找镜像</h2><ul><li>我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： <a href="https://hub.docker.com/">https://hub.docker.com/</a></li><li>我们也可以使用<code>docker search &lt;镜像名&gt;</code> 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 <code>docker search httpd</code> 来寻找适合我们的镜像。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201125085937.jpg" alt="" /></li><li>选项说明：<ul><li>NAME: 镜像仓库源的名称</li><li>DESCRIPTION: 镜像的描述</li><li>OFFICIAL: 是否 docker 官方发布</li><li>stars: 类似 Github 里面的 star，表示点赞、喜欢的意思。</li><li>AUTOMATED: 自动构建。</li></ul></li></ul><h2 id="删除镜像"><a class="markdownIt-Anchor" href="#删除镜像"></a> 删除镜像</h2><ul><li>镜像删除使用<code>docker rmi &lt;镜像名&gt;:&lt;标签&gt;</code> 命令，比如我们删除 hello-world 镜像：<code>docker rmi hello-world</code>,省略标签，则默认只会删除标签为latest的镜像。</li></ul><h2 id="创建镜像"><a class="markdownIt-Anchor" href="#创建镜像"></a> 创建镜像</h2><ul><li>当我们从 docker 镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改。<ol><li>从<strong>已经创建的容器中更新镜像</strong>，并且提交这个镜像;</li><li>使用 <strong>Dockerfile 指令</strong>来创建一个新的镜像;</li></ol></li></ul><h3 id="更新镜像"><a class="markdownIt-Anchor" href="#更新镜像"></a> 更新镜像</h3><ul><li>更新镜像之前，我们需要使用镜像来<strong>创建一个容器</strong>。</li><li>示例：<ul><li><code>docker run -t -i ubuntu:15.10 /bin/bash</code></li><li>在运行的容器内使用 apt-get update 命令进行更新。</li><li>在完成操作之后，输入 exit 命令来退出这个容器。</li><li>此时 ID 为 e218edb10161 的容器，是按我们的需求更改的容器。我们可以通过命令<code>docker commit</code>来提交容器副本。</li><li><code>docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2</code></li></ul></li><li><code>docker commit</code>的各个参数说明：<ul><li>-m: 提交的描述信息</li><li>-a: 指定镜像作者</li><li>e218edb10161：容器 ID</li><li>runoob/ubuntu:v2: 指定要创建的目标镜像名</li></ul></li></ul><h3 id="构建镜像"><a class="markdownIt-Anchor" href="#构建镜像"></a> 构建镜像</h3><ul><li>我们使用命令<code>docker build</code> ， 从零开始来创建一个新的镜像。为此，我们需要创建一个<code>Dockerfile</code>文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。</li><li>示例：</li></ul><pre class="line-numbers language-none"><code class="language-none">runoob@runoob:~$ cat Dockerfile FROM    centos:6.7MAINTAINER      Fisher &quot;fisher@sudops.com&quot;RUN     &#x2F;bin&#x2F;echo &#39;root:123456&#39; |chpasswdRUN     useradd runoobRUN     &#x2F;bin&#x2F;echo &#39;runoob:123456&#39; |chpasswdRUN     &#x2F;bin&#x2F;echo -e &quot;LANG&#x3D;\&quot;en_US.UTF-8\&quot;&quot; &gt;&#x2F;etc&#x2F;default&#x2F;localEXPOSE  22EXPOSE  80CMD     &#x2F;usr&#x2F;sbin&#x2F;sshd -D</code></pre><ul><li>每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。</li><li>第一条FROM，指定使用哪个<strong>镜像源</strong></li><li>RUN 指令告诉docker 在镜像内执行命令，安装了什么。。。</li><li>然后，我们使用Dockerfile 文件，通过 docker build 命令来构建一个镜像。</li></ul><pre class="line-numbers language-none"><code class="language-none">runoob@runoob:~$ docker build -t runoob&#x2F;centos:6.7 .Sending build context to Docker daemon 17.92 kBStep 1 : FROM centos:6.7 ---&gt; d95b5ca17cc3Step 2 : MAINTAINER Fisher &quot;fisher@sudops.com&quot; ---&gt; Using cache ---&gt; 0c92299c6f03Step 3 : RUN &#x2F;bin&#x2F;echo &#39;root:123456&#39; |chpasswd ---&gt; Using cache ---&gt; 0397ce2fbd0aStep 4 : RUN useradd runoob......</code></pre><ul><li>参数说明：<ul><li>-t ：指定要创建的目标镜像名</li><li>. ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径</li></ul></li></ul><h2 id="设置镜像标签"><a class="markdownIt-Anchor" href="#设置镜像标签"></a> 设置镜像标签</h2><ul><li>我们可以使用<code>docker tag</code>命令，为镜像添加一个新的标签。</li><li>示例：<code>docker tag 860c279d2fec runoob/centos:dev</code></li><li><code>docker tag 镜像ID 用户名称/镜像源名(repository name):新的标签名(tag)</code></li></ul><h1 id="docker容器连接"><a class="markdownIt-Anchor" href="#docker容器连接"></a> Docker容器连接</h1><ul><li>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</li></ul><h2 id="网络端口映射"><a class="markdownIt-Anchor" href="#网络端口映射"></a> 网络端口映射</h2><ul><li>创建了一个 python 应用的容器：<code>docker run -d -P training/webapp python app.py</code></li><li>我们使用 <code>-P</code> 参数创建一个容器，使用 docker ps 可以看到容器端口 5000 绑定主机端口 32768。</li></ul><pre class="line-numbers language-none"><code class="language-none">runoob@runoob:~$ docker psCONTAINER ID    IMAGE               COMMAND            ...           PORTS                     NAMESfce072cc88ce    training&#x2F;webapp     &quot;python app.py&quot;    ...     0.0.0.0:32768-&gt;5000&#x2F;tcp   grave_hopper</code></pre><ul><li>我们也可以使用 <code>-p</code> 标识来指定容器端口绑定到主机端口。</li><li>两种方式的区别是:<ul><li><code>-P</code> :是容器内部端口<strong>随机</strong>映射到主机的高端口。</li><li><code>-p</code> : 是容器内部端口<strong>绑定</strong>到指定的主机端口,需要自己指定映射关系(如果不指定，则会报错）。</li><li><code>docker run -d -p 5000:5000 training/webapp python app.py</code></li></ul></li><li>另外，我们可以指定容器绑定的<strong>网络地址</strong>，比如绑定 127.0.0.1：<code> docker run -d -p 127.0.0.1:5001:5000 training/webapp python app.py</code>.</li><li>上面的例子中，默认都是绑定 tcp 端口，如果要绑定 UDP 端口，可以在端口后面加上 <code>/udp</code>。<code>docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</code>。</li></ul><h2 id="docker容器互联"><a class="markdownIt-Anchor" href="#docker容器互联"></a> Docker容器互联</h2><ul><li>端口映射并不是唯一把docker 连接到另一个容器的方法。docker 有一个连接系统允许将多个容器连接在一起，共享连接信息。docker 连接会创建一个父子关系，其中父容器可以看到子容器的信息。</li></ul><h3 id="容器命名"><a class="markdownIt-Anchor" href="#容器命名"></a> 容器命名</h3><ul><li>当我们创建一个容器的时候，docker 会<strong>自动对它进行命名</strong>。另外，我们也可以使用 <code>--name</code>标识来命名容器，例如：<code>docker run -d -P --name runoob training/webapp python app.py</code></li></ul><h3 id="新建网络"><a class="markdownIt-Anchor" href="#新建网络"></a> 新建网络</h3><ul><li>创建一个新的 Docker 网络:<code>docker network create -d bridge test-net</code></li><li>参数说明：<ul><li>-d：参数指定 Docker 网络类型，有 bridge、overlay。</li><li><code>docker nerwork create</code>是固定的指令</li><li><code>test-net</code>是网络的名称。</li></ul></li><li>通过<code>docker network ls</code>来查看已经存在的网络。</li></ul><h3 id="连接容器"><a class="markdownIt-Anchor" href="#连接容器"></a> 连接容器</h3><ul><li>运行一个容器并连接到新建的 test-net 网络:<code>docker run -itd --name test1 --network test-net ubuntu /bin/bash</code><ul><li><code>--network</code>参数指定要连接的网络名。</li></ul></li><li>打开新的终端，再运行一个容器并加入到 test-net 网络:<code>docker run -itd --name test2 --network test-net ubuntu /bin/bash</code></li><li>下面通过 <code>ping</code> 来证明 test1 容器和 test2 容器建立了互联关系。<ul><li>如果 test1、test2 容器内中无 ping 命令，则在容器内执行以下命令安装 ping（即学即用：可以在一个容器里安装好，提交容器到镜像，在以新的镜像重新运行以上两个个容器）。</li></ul></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apt-get updateapt install iputils-ping</code></pre><ul><li><p>在test1容器内输入<code>ping test2</code>（test2中同理），即可连接。</p></li><li><p>如果有多个容器之间需要互相连接，推荐使用 Docker Compose。</p></li></ul><h3 id="配置dns"><a class="markdownIt-Anchor" href="#配置dns"></a> 配置DNS</h3><ul><li>我们可以在宿主机的 /etc/docker/daemon.json 文件中增加以下内容来设置全部容器的 DNS：</li></ul><pre class="line-numbers language-none"><code class="language-none">&#123;  &quot;dns&quot; : [    &quot;114.114.114.114&quot;,    &quot;8.8.8.8&quot;  ]&#125;</code></pre><ul><li>设置后，启动容器的 DNS 会自动配置为 114.114.114.114 和 8.8.8.8。配置完，需要重启 docker 才能生效。</li><li>查看容器的 DNS 是否生效可以使用以下命令，它会输出容器的 DNS 信息：<code>docker run -it --rm  ubuntu  cat etc/resolv.conf</code></li><li>如果只想在<strong>指定的容器设置 DNS</strong>，则可以使用以下命令：<code>docker run -it --rm -h host_ubuntu  --dns=114.114.114.114 --dns-search=test.com ubuntu</code></li><li>参数说明：<ul><li>–rm：容器退出时自动清理容器内部的文件系统。</li><li>-h HOSTNAME 或者 --hostname=HOSTNAME： 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts。</li><li>–dns=IP_ADDRESS： 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。</li><li>–dns-search=DOMAIN： 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索` host，还会搜索 <a href="http://host.example.com">host.example.com</a>。</li></ul></li><li>如果在容器启动时没有指定 --dns 和 --dns-search，Docker 会默认用宿主主机上的 /etc/resolv.conf 来配置容器的 DNS。</li></ul><h1 id="docker仓库管理"><a class="markdownIt-Anchor" href="#docker仓库管理"></a> Docker仓库管理</h1><ul><li>仓库（Repository）是集中存放镜像的地方。以下介绍一下 Docker Hub。当然不止 docker hub，只是远程的服务商不一样，操作都是一样的。</li></ul><h2 id="dockerhub"><a class="markdownIt-Anchor" href="#dockerhub"></a> DockerHub</h2><ul><li>目前 Docker 官方维护了一个公共仓库 Docker Hub。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</li></ul><h3 id="注册"><a class="markdownIt-Anchor" href="#注册"></a> 注册</h3><ul><li>在 <a href="https://hub.docker.com">DockerHub</a> 免费注册一个 Docker 账号。</li></ul><h3 id="登录和退出"><a class="markdownIt-Anchor" href="#登录和退出"></a> 登录和退出</h3><ul><li>登录需要输入用户名和密码，登录成功后，我们就可以从 docker hub 上拉取自己账号下的全部镜像。<code>docker login</code>;</li><li>退出 docker hub 可以使用以下命令：<code>docker logout</code></li></ul><h3 id="查找和拉取镜像"><a class="markdownIt-Anchor" href="#查找和拉取镜像"></a> 查找和拉取镜像</h3><ul><li>你可以通过 docker search 命令来查找官方仓库中的镜像，并利用 docker pull 命令来将它下载到本地。</li><li>查找：<code>docker search &lt;镜像名&gt;</code>,必须带有镜像名；</li><li>拉取：<code>docker pull &lt;镜像名&gt;</code>.</li></ul><h3 id="推送镜像"><a class="markdownIt-Anchor" href="#推送镜像"></a> 推送镜像</h3><ul><li>在登录进了dockerhub的前提下：</li><li>首先需要将本地的镜像名改为<code>(dockerhub的用户名)/镜像名</code>的格式。示例：<code>docker tag ubuntu:18.04 zestaken/ubuntu:18.04</code>(其中zestaken是我的dockerhub用户名)。</li><li>之后再使用<code>docker push &lt;镜像名&gt;</code>将镜像推送到dockerhub。</li><li>被自己推送到自己仓库的镜像可以直接使用<code>docker pull &lt;镜像名&gt;</code>拉取下来，但是search不能够搜到(因为开启这个功能需要花钱升级dockerhub账号到pro版）。</li></ul><h1 id="dockerfile"><a class="markdownIt-Anchor" href="#dockerfile"></a> Dockerfile</h1><h1 id="dockermachine"><a class="markdownIt-Anchor" href="#dockermachine"></a> Dockermachine</h1><h1 id="docker安装的ubuntu问题"><a class="markdownIt-Anchor" href="#docker安装的ubuntu问题"></a> docker安装的Ubuntu问题</h1><ul><li>通过镜像安装的ubuntu容器为纯净的环境，其好多命令执行不了，即缺少很多可执行脚本，安装即可~~~</li></ul><p>执行一切安装之前请先执行 apt-get update</p><ol><li>lsb_release</li></ol><p>apt-get install lsb-release</p><ol start="2"><li>ifconfig</li></ol><p>apt install net-tools</p><ol start="3"><li>ping</li></ol><p>apt install iputils-ping</p><ol start="4"><li>sudo</li></ol><p>apt-get install sudo</p><ol start="5"><li>vim</li></ol><p>apt-get install vim</p><ol start="6"><li>add-apt-repository</li></ol><p>sudo apt-get install software-properties-common</p><p>同理可安装git ,Python等</p><p>（</p><p>apt-get install git python-virtualenv libssl-dev libffi-dev build-essential libpython-dev python2.7-minimal authbind<br />）</p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux虚拟文件系统</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Linux/linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Linux/linux%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="vfs虚拟文件系统基本概念"><a class="markdownIt-Anchor" href="#vfs虚拟文件系统基本概念"></a> VFS虚拟文件系统基本概念</h1><ul><li>VFS: Virtual File System ( Virtual Filesystem Switch)概念：<ul><li><strong>逻辑文件系统(实际文件系统)</strong>  如EXT2、MINIX、MSDOS等.</li><li>VFS为逻辑文件系统提供<strong>统一的接口</strong>，<strong>屏蔽</strong>实际文件系统的实现细节.</li><li>VFS的所有数据结构在<strong>系统运行以后建立，并在卸载时删除</strong>。</li><li>VFS必须<strong>与实际的文件系统相接合</strong>,才能实现文件管理功能。</li></ul></li><li>VFS的功能：<ul><li>对逻辑文件系统的<strong>数据结构进行抽象</strong>；</li><li>接受用户<strong>系统调用</strong> 如open, write等；</li><li>支持<strong>多种逻辑文件系统</strong>之间相互访问；</li><li>接受<strong>内核其他子系统</strong>的操作请求，特别是内存管理子系统。</li></ul></li><li>linux文件系统逻辑关系：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201120114340.jpg" alt="" /></li></ul><h1 id="unix文件系统"><a class="markdownIt-Anchor" href="#unix文件系统"></a> Unix文件系统</h1><ul><li>Unix文件系统采用<strong>统一命名空间</strong>，所有安装的文件系统都作为<strong>根文件系统树的枝叶</strong>出现在系统中。</li><li>文件通过<strong>目录</strong>组织起来，VFS将目录视为文件，可以对其进行文件的操作。<ul><li>目录是一种特殊的文件。它用于创建、保持对文件系统中文件的访问路径。</li></ul></li><li><strong>索引节点（inode）</strong>：<ul><li>文件的相关信息，被称为文件的<strong>元数据</strong>，被存储在一个单独的数据结构中，该结构被称为<strong>索引结点</strong>。</li><li>Inode中存放描述文件的详细信息，如文件在外存的地址等。</li><li>在访问装配的文件系统时，这些文件系统的inode 节点被不断的读出/写入。</li><li>VFS文件系统维护一个inode节点的缓存,以加速对所有装配的文件系统的访问。</li></ul></li><li><strong>超级块</strong>；<ul><li>文件系统的<strong>控制信息</strong>存储在超级块中，超级块是一种包含文件系统信息的数据结构。</li></ul></li></ul><h1 id="vfs对象及其数据结构"><a class="markdownIt-Anchor" href="#vfs对象及其数据结构"></a> VFS对象及其数据结构</h1><ul><li>VFS使用<strong>面向对象</strong> 的设计思路，使用一组<strong>数据结构</strong>来表示通用文件对象。</li><li>每个主要类型中都包含一个操作对象，这个操作对象描述针对给主要对象的方法。</li><li>VFS中四个主要的对象类型：<ol><li>超级块对象：代表一个具体的已安装的文件系统。<ol><li>操作对象：super_operations对象，其中描述了<strong>内核</strong>针对特定<strong>文件系统</strong>所能调用的方法。</li><li>各种文件系统都<strong>必须实现超级块对象</strong>，超级块对象由<strong>super_block</strong>结构体表示，存储在&lt;linux/fs.h&gt;中。</li></ol></li><li>索引节点对象：代表一个具体文件。<ol><li>操作对象：inode_operations对象，其中描述了<strong>内核</strong>针对特定<strong>文件</strong>所能调用的方法。</li><li>索引节点对象不一定在文件系统中实现，索引节点在文件被访问时才<strong>在内存中创建</strong>。</li><li>一个索引节点对象代表内存中的一个文件，也可以是设备或者管道这样的特殊文件。</li><li>索引节点由<strong>inode结构体</strong>表示，它定义在文件&lt;linux/fs.h&gt;中。</li></ol></li><li>目录项对象：代表一个目录项，是路径的一个组成部分。（目录项不是目录，目录是另一种形式的文件）。<ol><li>操作对象：dentry_operations对象，描述<strong>内核</strong>针对特定<strong>目录</strong>所能调用的方法。</li><li>在路径中，**每一个部分（包括普通文件）**都是一个目录项对象。如：<code>/bin/vi</code>中，<code>/</code>,<code>bin</code>,<code>vi</code>都属于目录项对象。</li><li>与超级块和索引节点对象不同，目录项对象<strong>没有对应的磁盘数据结构</strong>，VFS在执行目录操作时在现场根据字符串形式的路径名创建目录项对象。</li><li>目录项对象由<strong>dentry结构体</strong>表示，它定义在文件&lt;linux/dentry.h&gt;中。</li></ol></li><li>文件对象：代表由进程已打开的文件。<ol><li>操作对象：file_operations对象，描述<strong>进程</strong>针对已打开文件所能调用的方法。</li><li>进程<strong>直接处理的是文件</strong>，而不是超级块，目录项或者索引节点。</li><li>多个进程可以同时操作同一个文件，一个文件可以同时有多个文件对象。</li><li>类似于目录项对象，文件对象<strong>没有实际的磁盘数据结构</strong>。</li><li>文件对象由<strong>file结构体</strong>表示，定义在文件&lt;linux/fs.h&gt;中。</li></ol></li></ol></li></ul><h1 id="和文件系统相关的数据结构"><a class="markdownIt-Anchor" href="#和文件系统相关的数据结构"></a> 和文件系统相关的数据结构</h1><ul><li>除了以上4种VFS基础对象之外，内核还使用一些标准数据结构来管理文件系统的其它相关数据。</li><li><strong>file_system_type</strong>:用来描述各种特定文件系统类型，如ext3,ext4或UDF；<ul><li>因为linux支持各种不同的文件系统，所以需要一个数据结构来描述各种文件系统的功能和行为。</li><li>file_system_type结构体被定义在文件&lt;linux/fs.h&gt;中。</li><li>每个文件系统对应一个file_system_type结构。</li></ul></li><li><strong>vfsmount</strong>:用来描述一个安装文件系统的实例；</li></ul><h1 id="和进程有关的数据结构"><a class="markdownIt-Anchor" href="#和进程有关的数据结构"></a> 和进程有关的数据结构</h1><ul><li>每一个进程都有自己的一组打开的文件。通过三个数据结构将VFS层和进程精密连接在了一起。这三个数据结构是<strong>file_struct</strong>,<strong>fs_struct</strong>,<strong>namespace</strong>.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里巴巴MySql规范</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4MySql%E8%A7%84%E8%8C%83/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4MySql%E8%A7%84%E8%8C%83/index.html</url>
      
        <content type="html"><![CDATA[<ul><li>表达是与否概念的字段，必须使用 is_xxx的方式命名，数据类型是 unsigned tinyint（ 1表示是，0表示否）;</li><li>任何字段如果为<strong>非负数，必须是 unsigned</strong>。</li><li>表名、字段名必须使用<strong>小写字母或数字</strong>,单词之间用下划线分隔；禁止出现数字开头，禁止两个下划线中间只出现数字;</li><li>表名不使用复数名词;</li><li>禁用保留字，如 desc、range、match、delayed等，请参考 MySQL官方保留字;</li><li><strong>小数类型</strong>为 decimal，禁止使用 float和 double。<ul><li>说明：float和 double在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal的范围，建议将数据拆成整数和小数分开存储。</li></ul></li><li>表必备三字段：id, gmt_create, gmt_modified。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201123111656.png" alt="" />```</li><li>说明：其中 id必为主键，类型为 unsigned bigint、单表时自增、步长为 1。gmt_create,gmt_modified的类型均为 date_time类型。</li><li>gmt_create和gmt——modifed的设置示例：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 创建学院表create table t_college (    &#96;id&#96;  bigint unsigned primary key auto_increment comment &#39;学院id&#39;,   &#96;name&#96; varchar (60) not null comment &#39;学院名称&#39;,     &#96;gmt_create&#96; datetime null default current_timestamp comment &#39;记录创建时间&#39;,     &#96;gmt_modified&#96; datetime null default current_timestamp on update current_timestamp comment &#39;记录最近修改时间&#39;     ); </code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ IDEA</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/IntelliJ-IDEA/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/IntelliJ-IDEA/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="项目结构"><a class="markdownIt-Anchor" href="#项目结构"></a> 项目结构</h1><ul><li>项目（project）-&gt;模块（module）-&gt; 包（package） -&gt;代码（.java）（module和project均需要在头部选项<code>File</code>中创建）</li><li>src文件夹存放源代码。</li><li>.idea文件夹和.iml文件是IDEA对项目的配置文件。与项目内容无关。</li><li>对包的命名遵循域名颠倒过来(全是小写字母）。如<code>com.zhangjie</code>，这个命名会生成两个文件夹，一个是com文件夹，com文件夹下包含zhangjie文件夹。<code>.</code>起到分开不同包文件夹的作用。</li><li>IDEA是实时保存的，写到哪保存到哪。</li><li>IDEA编译java文件生成的.class文件是默认保存在out文件夹的，但是这个文件夹默认是隐藏的。</li><li>External Libraries下面是jar包。</li></ul><h1 id="idea配置"><a class="markdownIt-Anchor" href="#idea配置"></a> IDEA配置</h1><ul><li>字体：File-&gt;settings-&gt;Editor-&gt;Font</li><li>自动补全：File-&gt;settings-&gt;keymap(齿轮下选择Duplicate不改变原来的快捷键，即复制一遍)</li></ul><h1 id="快捷操作"><a class="markdownIt-Anchor" href="#快捷操作"></a> 快捷操作</h1><ul><li>使用缩写再加上enter可以生成一些常用代码段。如<code>psvm</code>可以快捷生成<code>public static void main(String[] args)&#123;&#125;</code>.</li><li><code>ALT + Enter</code>可以自动修复代码。</li><li><code>crtl + y</code>删除当前行，<code>ctrl + d</code>复制当前行。</li><li><code>ctrl + alt + l</code>格式化当前代码的排版。</li><li><code>ctrl + /</code>可以对光标所在行（也可以人为选中）前面加上//注释符。<code>ctrl + shift + /</code>生成/**/多行注释符。</li><li><code>alt + insert</code>可以自动添加方法。</li><li><code>alt + shift + 上下箭头</code>可以移动光标所在行。</li><li><code>ctrl + shit + F10</code>可以运行代码，<code>ctrl + shift + F9</code>调试代码。</li><li><code>shift + F6</code>可以对选中的文件进行重命名,所有用到该文件（如变量）的地方都会同时进行重命名。</li><li><code>ctrl + o</code>添加override的方法。</li><li><code>ctrl</code>按住ctrl再点击调用的方法名，可以直接去看该方法定义的源代码。</li></ul><h1 id="idea报错"><a class="markdownIt-Anchor" href="#idea报错"></a> idea报错</h1><ul><li>同一个包内的类不能使用：参见<a href="https://www.cnblogs.com/wanghongsen/p/12574807.html">blog</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 杂技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Mysql/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Mysql/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据库简介"><a class="markdownIt-Anchor" href="#数据库简介"></a> 数据库简介</h1><p><a href="https://dev.mysql.com/doc/refman/8.0/en/">mysql8.0官方文档</a></p><ul><li>特点：<ol><li>持久化保存数据；</li><li>可以实现结构化查询，方便管理。</li></ol></li><li>DB:数据库（database），存储数据的仓库，保存了有组织的数据。</li><li>DBMS:数据库管理系统。数据库是通过DBMS来创建和管理的容器。常见数据库管理系统：MYSQL，Oracle，DB2,SqlServer。</li><li>SQL：结构化查询语言（StructureQuery Language），专门用来与数据库通信。几乎所有DBMS都支持SQL。</li><li>数据存储数据：<ol><li>将数据存入表中，表再放入库中。一个数据库中可以有多个表，每个表有一个名字，表名具有唯一性。</li><li>表具有一些特性，这些特性定义了数据在表中如何存储，类似java中的“类”。</li><li>表由列组成，这些列也称为<strong>字段</strong>，每一列类似java中的属性。</li><li>表中的数据是按行存储的，每一行类似java中的对象。</li></ol></li></ul><h1 id="mysql的安装"><a class="markdownIt-Anchor" href="#mysql的安装"></a> MySQL的安装</h1><ul><li>MySQL的特点：<ol><li>开放源代码；</li><li>性能高</li><li>容易安装和使用。</li></ol></li><li>DBMS的分类：<ol><li>基于共享文件系统的（如：Access）</li><li>基于客户机-服务器的DBMS（如；MySQL，oracle，sqlsever）。</li></ol></li><li>MySQL下载安装：<ol><li>社区版（免费）</li><li>企业版（收费）</li><li>下载地址：<a href="https://devmysql.com/downloads/installer/">https://devmysql.com/downloads/installer/</a></li><li>跟随安装指导进行配置。</li></ol></li></ul><h1 id="mysql在ubuntu上的安装"><a class="markdownIt-Anchor" href="#mysql在ubuntu上的安装"></a> MySQL在ubuntu上的安装</h1><ol><li>安装：<code>sudo apt-get install mysql-server</code></li><li>配置：<code>sudo mysql_secure_installation</code></li></ol><h1 id="mysql服务的启动"><a class="markdownIt-Anchor" href="#mysql服务的启动"></a> MySQL服务的启动</h1><ul><li>在Windows上：<ol><li>搜索服务，点击打开；</li><li>在cmd输入<code>services.msc</code>启动；</li><li>在管理员cmd输入<code>net start &lt;本机mysql的名字&gt;</code>或者<code>net stop &lt;本机mysql的名字&gt;</code>启动或者关闭。(本机mysql服务的名字叫MYSQL)</li></ol></li><li>在linux上：<ol><li>启动：<code>sudo service mysql start</code></li><li>关闭：<code>sudo service mysql stop</code></li><li>重启：<code>sudo service mysql restart</code></li></ol></li></ul><h1 id="mysql的登录"><a class="markdownIt-Anchor" href="#mysql的登录"></a> MySQL的登录</h1><ul><li>登录本地用户：<code>mysql -uroot -proot</code>，-u后面接的是用户名，-p后面接的是root用户的密码。<code>mysql -uroot -p</code>,会在之后输入密码。(在linux上登录root用户需要使用sudo)</li><li>登录远程用户：<code>mysql -h127.0.0.1 -p</code> -h后面接的是连接目标的ip。</li><li>登录：<code>mysql --host=IP --user=用户名 --passward=连接目标的密码</code></li><li>Mysql设置远程连接权限，<a href="https://blog.csdn.net/mxskymx/article/details/88765072">参考文档</a></li></ul><h1 id="退出mysql"><a class="markdownIt-Anchor" href="#退出mysql"></a> 退出MySQL</h1><ul><li>输入<code>exit</code></li></ul><h1 id="mysql的目录结构"><a class="markdownIt-Anchor" href="#mysql的目录结构"></a> MySQL的目录结构</h1><p>1.MySQL的安装目录：</p><ol><li>bin：二进制可执行文件，包括很多命令的执行程序。</li><li>data：存放mysql的日志文件，数据文件等。</li><li>include：放置.h头文件；</li><li>lib：所需的jar包；</li><li>share：错误信息存放<br />2.MySQL的数据目录：（在c盘下的programdata下）</li><li>数据库及其中的数据；</li><li>my.ini是MySQL的配置文件。</li></ol><h1 id="sqlyog图形化界面"><a class="markdownIt-Anchor" href="#sqlyog图形化界面"></a> SQLyog图形化界面</h1><ul><li>可以使用sql语句控制，也可以直接使用鼠标控制。</li></ul><h1 id="sql语句"><a class="markdownIt-Anchor" href="#sql语句"></a> SQL语句</h1><h2 id="sql的简介"><a class="markdownIt-Anchor" href="#sql的简介"></a> SQL的简介</h2><ul><li>SQL：结构化查询语言（StructureQuery Language），专门用来与数据库通信。几乎所有DBMS都支持SQL。可以用来操作所有的关系型数据库。</li></ul><h2 id="sql的通用语法"><a class="markdownIt-Anchor" href="#sql的通用语法"></a> SQL的通用语法</h2><ul><li>SQL可以单行或者多行书写，以分号结尾。</li><li>使用空格和缩进来规范格式。</li><li>Mysql的SQL语句不区分大小写。，关键字建议使用大写。</li><li>注释：<ol><li>单行注释：<code>-- </code>或者<code># </code>之后写注释内容。（–注释符后面有空格。#可以没有空格，是MySQL特有的。）</li></ol></li></ul><h2 id="sql的分类"><a class="markdownIt-Anchor" href="#sql的分类"></a> SQL的分类</h2><ul><li>DDL（data definition language）：操作数据库和表；</li><li>DML（Data Manipulation Language）；增删改表中的数据。</li><li>DQL（Data Query Language）:查询表中的数据。</li><li>DCL（Data control Language）:数据控制语言，控制访问权限和安全级别等。</li></ul><h2 id="ddl"><a class="markdownIt-Anchor" href="#ddl"></a> DDL</h2><h3 id="操作数据库crud"><a class="markdownIt-Anchor" href="#操作数据库crud"></a> 操作数据库（CRUD）</h3><ol><li>C（creat）:创建；<ol><li>创建数据库：<code>creat database 数据库名称;</code></li><li>判断数据库不存在，再创建：<code>creat database if not exists 数据库名称;</code></li><li>创建数据库，并指定字符集：<code>creat database 数据库名称 character set 字符集名;</code></li></ol></li><li>R（Retrieve）：查询；<ol><li>查询已经存在的数据库：<code>show databases;</code></li><li>查看某个数据库的字符集：<code>show creat database 数据库名称;</code>(同时也是查询数据库的创建语句)</li></ol></li><li>U（Update）：修改；<ol><li>修改数据库的字符集：<code>alter database 数据库名称 character set 字符集名称;</code></li></ol></li><li>D(Delete):删除；<ol><li>删除数据库：<code>drop database 数据库名称;</code>。</li><li>判断数据库存在，再删除：<code>drop database if exists 数据库名称;</code></li></ol></li><li>使用数据库。<ol><li>查询当前正在使用的数据库名称:<code>select database();</code></li><li>使用数据库：<code>use 数据库名称;</code></li></ol></li></ol><h3 id="操作表crud"><a class="markdownIt-Anchor" href="#操作表crud"></a> 操作表（CRUD）</h3><ol><li>C（creat）:创建；<ol><li>创建语法:<code>creat table 表名（列名1， 数据类型1， 列名2 数据类型2， ... 列名n 数据类型n）;</code><strong>创建表时，至少有一个列，否则创建会直接失败</strong></li><li>复制：<code>creat table 表名（即将创建） like 表名（被复制的）</code></li></ol></li><li>R（Retrieve）：查询；<ol><li>查询数据库中所有表的名称：<code>show tables;</code></li><li>查询表结构：<code>desc 表名;</code></li></ol></li><li>U（Update）：修改；<ol><li>修改表名：<code>alter table 表名 rename to 新表名;</code></li><li>修改表的字符集：<code>alter table 表名 character set 字符集名称;</code></li><li>添加一列：<code>alter table 表名 add 列名 数据类型;</code></li><li>修改列名称 类型：<code>alter table 表名 modify 列名 新数据类型;</code>（仅修改列的数据类型）或者<code>alter table 表名 change 列名 新列名 新数据类型;</code></li><li>删除列：<code>alter table 表名 drop 列名;</code></li></ol></li><li>D(Delete):删除；<ol><li>删除数据库中的表;·drop table 表名;`</li><li>判断表存在后再修改:<code>drop table if exists 表名;</code></li></ol></li></ol><h3 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h3><ul><li>MySQL支持多种类型的SQL数据类型：数值，日期和时间类型，字符串（字符和字节）类型，空间类型和 JSON数据类型等</li><li>数据类型描述使用以下约定：<ul><li>M表示整数类型的<strong>最大显示宽度</strong>。M表示整数类型的最大显示宽度。对于浮点和定点类型， M是可以存储的总位数（精度）。对于字符串类型， M是最大长度。允许的最大值M取决于数据类型。</li><li>D适用于浮点和定点类型，并指示<strong>小数点后面的位数</strong>。最大可能值为30，但不应大于 M-2。</li><li>[ ]表示类型定义的<strong>可选部分</strong>,例如：int[(M)],但是可以不填整型的宽度。</li><li><a href="https://blog.csdn.net/yuzhiqiang_1993/article/details/81453569?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160592530619724838553623%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160592530619724838553623&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-81453569.pc_first_rank_v2_rank_v28p&amp;utm_term=mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&amp;spm=1018.2118.3001.4449">借鉴博客</a></li></ul></li></ul><h4 id="数值类型"><a class="markdownIt-Anchor" href="#数值类型"></a> 数值类型</h4><h5 id="整型"><a class="markdownIt-Anchor" href="#整型"></a> 整型</h5><ul><li><code>TINYINT[(M)] [UNSIGNED] [ZEROFILL]</code>： <strong>范围非常小的整数</strong>，有符号的范围是 -128到127，无符号的范围是0到 255</li><li><code>SMALLINT[(M)] [UNSIGNED] [ZEROFILL]</code> ：范围较小的整数，有符号的范围是 -32768到32767，无符号的范围是0到 65535</li><li><code>MEDIUMINT[(M)] [UNSIGNED] [ZEROFILL]</code>: 中等大小的整数，有符号的范围是 -8388608到8388607，无符号的范围是0到 16777215。</li><li><code>INT[(M)] [UNSIGNED] [ZEROFILL]</code>: 正常大小的整数，有符号的范围是 -2147483648到 2147483647。无符号的范围是 0到4294967295。</li><li><code>BIGINT[(M)] [UNSIGNED] [ZEROFILL]</code>: 大整数，有符号的范围是 -9223372036854775808到 9223372036854775807，无符号的范围是0到 18446744073709551615。</li></ul><h5 id="浮点型"><a class="markdownIt-Anchor" href="#浮点型"></a> 浮点型</h5><ul><li><code>FLOAT[(M,D)] [UNSIGNED] [ZEROFILL]</code>：一个小的（单精度）浮点数。允许值是-3.402823466E+38 到-1.175494351E-38， 0以及1.175494351E-38 到3.402823466E+38,M是总位数，D是小数点后面的位数。</li><li><code>DOUBLE[(M,D)] [UNSIGNED] [ZEROFILL]</code>：正常大小（双精度）浮点数。允许值是 -1.7976931348623157E+308到-2.2250738585072014E-308，0以及 2.2250738585072014E-308到 1.7976931348623157E+308。</li><li><strong>M是总位数，D是小数点后面的位数</strong>，float和double在不指定精度时，默认会按照<strong>实际的精度</strong>来显示。</li></ul><h5 id="定点型"><a class="markdownIt-Anchor" href="#定点型"></a> 定点型</h5><ul><li><code>DECIMAL[(M[,D])] [UNSIGNED] [ZEROFILL]</code>:常用于存储<strong>精确的小数</strong>，<strong>M是总位数</strong>，<strong>D是小数点后的位数</strong>。小数点和（负数） -符号不计入 M。如果 <strong>D为0，则值没有小数点或小数部分</strong>。最大位数（M）为 65. 最大支持小数（D）为30.<strong>如果D省略，则默认值为0.如果M省略，则默认值为10</strong>,如果二者都省略，则默认为decimal(10,0)。M的范围是1到65。D范围为0到30，且不得大于M。</li></ul><h5 id="时间类型"><a class="markdownIt-Anchor" href="#时间类型"></a> 时间类型</h5><ul><li><code>TIME</code>: 范围是’-838:59:59.000000’ 到’838:59:59.000000’;<ul><li>TIME的完整的显示为 <code>D HH:MM:SS</code>:</li><li>D：表示天数，当指定该值时，存储时小时会先乘以该值</li><li>HH：表示小时</li><li>MM：表示分钟</li><li>SS:表示秒</li><li>示例：</li></ul></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">INSERT time_db() VALUES(&#39;22:14:16&#39;);--   -2表示间隔了2两天INSERT time_db() VALUES(&#39;-2 22:14:16&#39;);-- 有冒号从小时开始INSERT time_db() VALUES(&#39;14:16&#39;);-- 没有冒号且没有天数则数据从秒开始INSERT time_db() VALUES(&#39;30&#39;);-- 有天数也从小时开始INSERT time_db() VALUES(&#39;3 10&#39;);-- 直接使用数字代替也可以INSERT time_db() VALUES(253621);</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201121142312.png" alt="" /></p><ul><li><code>DATE</code>: 支持的范围是 '1000-01-01’到 ‘9999-12-31’;<ul><li>示例：</li></ul></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">INSERT date_db() VALUES(20180813);INSERT date_db() VALUES(“2018-06-1”);INSERT date_db() VALUES(“2018-4-1”);INSERT date_db() VALUES(“2018-04-07”);</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201121142549.png" alt="" /></p><ul><li><code>DATETIME</code>: <strong>日期和时间组合</strong>。支持的范围是 '1000-01-01 00:00:00.000000’到 ‘9999-12-31 23:59:59.999999’;<ul><li>示例：</li></ul></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">INSERT datetime_db() VALUES(20180102235432);INSERT datetime_db() VALUES(&quot;2015-04-21 21:14:32&quot;);INSERT datetime_db() VALUES(&quot;2015-04-23&quot;);</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201121142737.png" alt="" /></p><ul><li><code>TIMESTAMP</code>: 时间戳。范围是’1970-01-01 00:00:01.000000’UTC到’2038-01-19 03:14:07.999999’UTC。与datetime类型有差不多，只是范围较小。<ul><li>示例：</li></ul></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">INSERT timestamp_db() VALUES(20020121);INSERT timestamp_db() VALUES(20020121142554);INSERT timestamp_db() VALUES(&quot;2015-12-16 21:14:15&quot;);INSERT timestamp_db() VALUES(&quot;2015-12-17&quot;);INSERT timestamp_db() VALUES(NULL);INSERT timestamp_db() VALUES(CURRENT_TIMESTAMP);INSERT timestamp_db() VALUES();</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201121143202.png" alt="" /></p><ul><li><code>YEAR</code>: 范围是 1901到2155;<ul><li>示例：</li></ul></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">INSERT year_db() VALUES(&quot;1993&quot;);INSERT year_db() VALUES(1993);</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201121143340.png" alt="" /></p><h5 id="字符串类型"><a class="markdownIt-Anchor" href="#字符串类型"></a> 字符串类型</h5><h6 id="char和varchar"><a class="markdownIt-Anchor" href="#char和varchar"></a> char和varchar</h6><ul><li><code>CHAR[(M)]</code>: 一个<strong>固定长度</strong>的字符串，在存储时始终<strong>用空格填充</strong>指定长度。 M表示以字符为单位的列长度。M的范围为0到255.如果<strong>M省略，则长度为1</strong>，存储时占用M个字节</li><li><code>VARCHAR(M)</code>:<strong>可变长度</strong>的字符串，M 表示字符的最大列长度，M的范围是0到65,535，存储时占用L+1（L&lt;=M,L为实际字符的长度）个字节,此处的参数<strong>M是必须指定的</strong>。</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 创建表CREATE TABLE str_db(a CHAR(4),b VARCHAR(4));-- 插入数据INSERT str_db() VALUES(&quot;&quot;,&quot;&quot;);INSERT str_db() VALUES(&quot;ab&quot;,&quot;ab&quot;);INSERT str_db() VALUES(&quot;abcd&quot;,&quot;abcd&quot;);INSERT str_db() VALUES(&quot;abcdefg&quot;,&quot;abcdefg&quot;);&#x2F;&#x2F;在严格模式下，改条数据会插入失败，非严格模式则会对数据进行截取</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201123110639.png" alt="" /></p><ul><li>char的参数M规定的是字符串必须的长度，不够长度用空格来补充；</li><li>varchar的参数M规定的是字符串最长的长度，没有超出最长的长度就存储字符串原来的长度。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201123110718.png" alt="" /></li></ul><h6 id="text系列"><a class="markdownIt-Anchor" href="#text系列"></a> text系列</h6><ul><li><code>TINYTEXT[(M)]</code>: 不能有默认值，占用L+1个字节，L&lt;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">2^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>;</li><li><code>TEXT[(M)]</code>: 不能有默认值，占用L+2个字节，L&lt;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup><mn>6</mn></mrow><annotation encoding="application/x-tex">2^16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mord">6</span></span></span></span>;</li><li><code>MEDIUMTEXT[(M)]</code>: 不能有默认值，占用L+3个字节，L&lt;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup><mn>4</mn></mrow><annotation encoding="application/x-tex">2^24</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">4</span></span></span></span>;</li><li><code>LONGTEXT[(M)]</code>: 不能有默认值，占用L+4个字节，L&lt;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup><mn>2</mn></mrow><annotation encoding="application/x-tex">2^32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord">2</span></span></span></span>;<ul><li>TEXT系列的存储范围比VARCHAR要大，当VARCHAR不满足时可以用TEXT系列中的类型。需要注意的是TEXT系列类型的字段不能有默认值，在检索的时候不存在大小写转换，没有CHAR和VARCHAR的效率高</li></ul></li></ul><h6 id="enum枚举类型"><a class="markdownIt-Anchor" href="#enum枚举类型"></a> enum枚举类型</h6><ul><li><code>ENUM('value1','value2',...)</code>: ENUM是一个字符串对象，其值从允许值列表中选择，它只能有一个值，从值列表中选择,最多可包含65,535个不同的元素;</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TABLE enum_db (  gender ENUM(&quot;男&quot;,&quot;女&quot;));INSERT enum_db() VALUES(&quot;男&quot;);INSERT enum_db() VALUES(1); 也可以使用编号插入值，等同于&quot;男&quot;，序号从1开始INSERT enum_db() VALUES(&quot;女&quot;);INSERT enum_db() VALUES(2);等同于&quot;女&quot;</code></pre><h6 id="set"><a class="markdownIt-Anchor" href="#set"></a> set</h6><p>在ENUM中我们只能从允许值列表中给字段插入一个值，而在SET类型中可以给字段插入多个值</p><ul><li><code>SET('value1','value2',...)</code>: 字符串对象，该对象可以有零个或多个值，最多可包含64个不同的成员;<ul><li>在ENUM中我们只能从允许值列表中给字段插入一个值，而在SET类型中可以给字段插入多个值.</li></ul></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TABLE set_db (a SET(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;));INSERT set_db() VALUES(&#39;1&#39;)INSERT set_db() VALUES(&#39;1,2,3&#39;)</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201123111656.png" alt="" /></p><h2 id="dml"><a class="markdownIt-Anchor" href="#dml"></a> DML</h2><ol><li>添加数据：<ol><li>添加语法：<code>insert into 表名 （列名1， 列名2，... ，列名n）value（值1，值2，...,值n）;</code><ol><li>列名和值要一一对应；</li><li>如果表名后不给列名，在提供和列数相同个数值的前提下，会默认依次给所有列添加值，否则会报错。<br />2.删除数据：</li></ol></li><li>删除语法：<code>delete from where 条件；</code>如果没有加条件，就会删除表中所有的数据。示例：<code>delete from where id=1;</code></li><li>删除表，然后再创建一个一模一样的空表：<code>truncate table 表名;</code><br />3.修改数据：</li><li>修改语法：<code>update 表名 set 列名1 = 值1，列名2 =值2 ... where 条件;</code>,示例：<code>update stu set age = 19， score = 12 where id = 1;</code>。如果不加任何条件则会将表中所有的数据全部修改。</li></ol></li></ol><h2 id="dql"><a class="markdownIt-Anchor" href="#dql"></a> DQL</h2><p>1.排序查询：</p><ol><li>排序基础语法：<code>order by 子句</code></li><li><code>order by 排序字段1 排序方式1, 排序字段2 排序方式2, ... 排序字段n 排序方式n;</code></li><li>示例：<code>select * from stu order by id desc;</code></li><li>位于后面的排序字段的优先级较低，则当当前面的条件值一样时，才会去判断之后的条件来排序。</li><li>排序方式：<ol><li>ASC：升序排列，如果不指定排序方式，默认升序；</li><li>DESC：降序排列；<br />2.聚合函数：将一列数据作为一个整体，进行<strong>纵向</strong>的计算。聚合函数会默认排除为null的项。<br />1.count：计算个数；</li></ol><ul><li>示例:<code>select count(列名) from 表名;</code>,会忽略为null的项。</li><li><code>select count(ifnull(列名，0)) from 表名;</code>，会将值为null的项的值转为0，再计数。</li><li><code>select count(*) from 表名;</code>,会综合所有列来计数（除非有一行都为null）<br />2.max：计算最大值；<br />3.min;计算最小值；<br />4.sum：求和；<br />5.avg：计算平均值。</li></ul></li></ol><ul><li>适用于count的特殊方法也会适用于其他函数（除了<code>*</code>）<br />3.分组查询</li></ul><ol><li>语法：<code>group by 分组字段</code>，可以增加条件：<code>where 条件 group by 分组字段;</code>（分组前进行限定，如果不满足条件，则不参与分组。where后不可以跟聚合函数进行判断）或者`group by 分组字段 having 条件</li><li>示例：<code>select sex avg(math), count(id) from student group by sex;</code>,有条件：<code>select sex from student where math&gt;70 group by sex;</code>(math&gt;70 才能有被分组的资格)，<code>select sex feom student group by sex having count(id) &gt; 2;</code>(id的个数要大于2，才会参与分组)。</li><li>分组后查询的字段：只能是被查询的字段，或者是聚合函数。<br />4.分页查询</li><li>分页语法：<code>limit 分页索引，每页显示的条数</code>（limit是mysql的方言）</li><li>分页索引的计算：开始的索引 - （当前的页码 -1）* 每页的条数。</li><li>示例：<code>select * from stu limit 0,3;</code>(第一页)， <code>selct  * from stu limit 3,3;</code>(第二页)</li></ol><h3 id="dql查询表中的数据"><a class="markdownIt-Anchor" href="#dql查询表中的数据"></a> DQL查询表中的数据</h3><ul><li>查询所有数据：<code>select * from 表名</code>(将表中的所有数据查询出来)</li><li>总语法：<code>select 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件限定 order by 排序子句 limit 分页限定</code></li></ul><h4 id="基础数据查询"><a class="markdownIt-Anchor" href="#基础数据查询"></a> 基础数据查询</h4><ul><li>查询指定列：<code>select 列名1，列名2 from 表名</code>.示例：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select       name, -- 姓名      age,  -- 年龄from      student; --学生表</code></pre><ul><li>去除重复的结果集显示某列的内容:<code>select distinct 需去重的列名1，需去重的列名2 from 表名</code>（必须去重的所有的列的数据完全一样才会去掉）</li><li>计算列的的结果再显示：<code>select 列名1， 列名2，列名1 + 列名2 form 表明;</code>(如果某一列的数据为null，则计算结果都为null)<ul><li>一般可以使用四则运算进行运算（只有数值型计算）。</li><li>ifnull函数：<code>ifnull(表达式1，表达式2);</code>表达式1：需要判断是否为null的字段；表达式2；被查询字段为null后替代的值。</li></ul></li><li>给列起别名：<code> select 列名1 as 别名1 form 表名</code>或者省略as<code>select 列名1 别名1 form 表名</code>(列名和别名之间用空格)</li></ul><h4 id="条件查询"><a class="markdownIt-Anchor" href="#条件查询"></a> 条件查询</h4><ul><li>where子句后跟条件；</li><li>运算符：<ul><li><code>&gt;, &lt;, &gt;= , &lt;=, =(没有==，=就是等于) , !=, &lt;&gt;(也是不等号）</code></li><li><code>between...and...(在两者之间，包含边界0</code></li><li>逻辑运算符：<code>and(与&amp;&amp;相同),or(与||相同)，not(与!相同)</code></li><li><code>in(数据1，数据2，数据3，...)</code>数据等于数据1，或者数据2，或者数据3都可以。</li><li><code>is null, is not null</code>null值不能被直接查询，只能使用这两个特殊语句判断。</li><li><code>like</code>:模糊查询<ul><li>占位符:<ul><li><code>_</code>：单个任意字符；</li><li><code>%</code>:多个任意字符；</li></ul></li><li>示例：<ul><li><code>select name from stu where name like '马%';</code>(name中第一个字是马)</li><li><code>select name from stu where name like '_化_</code>（name中第二个字是化）</li><li>`select naem from stu where name like ‘%德%’(name中含马)</li><li><code>select name from stu where name like '___'</code>(name为三个字)</li></ul></li></ul></li></ul></li></ul><h2 id="dcl"><a class="markdownIt-Anchor" href="#dcl"></a> DCL</h2><ul><li>管理用户，授权。对应DBA(数据库管理员)</li><li>管理用户：<ul><li>添加用户：<ul><li>创建用户并设置账户密码：<code>creat user '用户名'@'主机名' identified by '密码';</code></li></ul></li><li>查询用户：<ul><li>切换到mysql数据库<code>use mysql;</code></li><li>查询user表：<code>select * from user;</code>,通配符%表示可以在任意主机上使用该用户。<code>localhost 127.0.0.1 ::1</code>三者都表示本地机。</li></ul></li><li>删除用户：<ul><li><code>drop user '用户名'@'主机名';</code></li></ul></li><li>修改用户的密码（在已经登录用户的条件下）：<ul><li>`update user set password = password(‘新密码’) where user = ‘用户名’;</li><li><code>set password for '用户名'@'主机名' = password('新密码');</code></li><li>使用password()函数，将密码进行加密之后存储。</li></ul></li></ul></li><li>授权：<ul><li>查询权限：<code>show grants for '用户名'@'主机名';</code></li><li>授予权限：<code>grant 权限列表 on 数据库名.表名 to '用户名'@'主机名';</code><ul><li>示例：<code>grant select,delete,update on db3.account to 'zhangsan'@'%';</code></li><li>授予所有库和表的所有权限：<code>grant all on *.* to 'zhangsan'@'%';</code></li></ul></li><li>撤销权限：<code>revote 权限列表 on 数据库名.表名 from '用户名'@'主机名';</code></li></ul></li></ul><h2 id="约束"><a class="markdownIt-Anchor" href="#约束"></a> 约束</h2><h3 id="约束概念"><a class="markdownIt-Anchor" href="#约束概念"></a> 约束概念</h3><ul><li>约束：对表中的数据进行限定，从而保证数据的正确性，有效性和完整性。</li><li>约束的分类：<ol><li>主键约束：primary key</li><li>非空约束：not null</li><li>唯一约束：unique</li><li>外键约束：foreign key</li></ol></li></ul><h3 id="非空约束-not-null"><a class="markdownIt-Anchor" href="#非空约束-not-null"></a> 非空约束 NOT NULL</h3><ul><li>在创建表时添加约束：<ul><li>示例：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TABLE stu1(id INT,NAME VARCHAR(20) NOT NULL -- name必须为非空，才能加入表中);</code></pre></li><li>创建表完成后添加或删除约束：<ul><li>示例：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER TABLE stu1 MODIFY NAME VARCHAR(20); -- 将原来有约束的name改为没有not null的ALTER TABLE stu1 MODIFY NAME VARCHAR(20) NOT NULL; -- 给name添加not null约束</code></pre></li></ul><h3 id="唯一约束-unique"><a class="markdownIt-Anchor" href="#唯一约束-unique"></a> 唯一约束 UNIQUE</h3><ul><li>创建表时添加约束：<ul><li>示例：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">   CREATE TABLE stu1(   id INT,   NAME VARCHAR(20) UNIQUE -- name必须为是唯一没有重复的，才能加入表中   );* 创建表完成后添加或者删除约束：   * 示例：   &#96;&#96;&#96;sql   ALTER TABLE stu1 DROP INDEX NAME VARCHAR(20); -- 删除创建表时的唯一约束（使用DROP INDEX 而不是MODIFY）   ALTER TABLE stu1 MODIFY NAME VARCHAR(20) UNIQUE; -- 添加唯一约束，仍然使用MODIFY</code></pre></li><li>MySQL中多个null不认为是重复的</li></ul><h3 id="主键约束primary-key"><a class="markdownIt-Anchor" href="#主键约束primary-key"></a> 主键约束：PRIMARY KEY</h3><ul><li>主键约束：非空且唯一，一张表中只能有一个字段为主键，主键就是表中记录的唯一标识。</li><li>创建时添加主键，示例：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create table stu (   id int primary key, -- 给id添加主键约束   name varchar(20))</code></pre><ul><li>删除主键约束，示例：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">alter table stu1  drop primary key;</code></pre><ul><li>因为一个表中的主键是唯一的，所以无需指定特定的列。</li><li>创建完表之后，添加主键，示例：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">alter table stu1 modify id int primary key;</code></pre><ul><li><strong>自动增长</strong>：<ul><li>如果某一列是数值类型的，使用auto_increment可以完成值的自动增长。一般和主键联合在一起使用。</li><li>创建表时添加主键约束，并且实现主键的自增长，示例：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create table stu1 (   id int primary key auto_increment, -- 给id添加主键约束，并自动增长。   name varchar(20));</code></pre></li><li>使用自动增长：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">insert into stu1 values(null, &#39;name1&#39;); -- 每次执行此操作，如果不指定id的值，就会自动根据上一行的数据加一来作为本行的id值</code></pre><ul><li>删除自动增长：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">alter table stu1 modify id int; -- 能够去除自动增长，但是不能这样删除主键</code></pre><ul><li>创建完表后添加自动增长：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">alter table stu modify id int auto_increment;</code></pre><h3 id="外键约束foreign-key"><a class="markdownIt-Anchor" href="#外键约束foreign-key"></a> 外键约束：FOREIGN KEY</h3><ul><li>联系两个表某些列，之后关联的两列的删除添加操作都是相互制约的,从而保证数据的正确性。</li><li>创建表时添加外键：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create table 表名 (   ...   外键列(和其它表有关系的列)   constanit  外键名称 foreign key (外键列的名称) references 主表名称(主表的列（一般为主键列）名称))示例：creat table department (   id int primary key,   name varchar(20))create table empolyee (   id int primary key,   dep_id int -- 外键对应主表的主键（外键列）   constraint emp_dept_fk foreign key (dep_id) references department(id))</code></pre><ul><li>删除外键：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">alter table employee drop foreign key emp_dept_key;</code></pre><ul><li>创建表之后添加外键：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">alter table employee add constraint emp_dept_fk foreign key (dep_id) references department(id);</code></pre><ul><li><strong>级联操作</strong>:修改有外键连接的两个表的列中的数据，操作会自动同步给关联的另一个列。<ul><li>添加级联操作语法：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER TABLE 表名 ADD CONSTRAINT 外键名称        FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELTE CASCADE;</code></pre><ul><li>级联更新：ON UPDATE CASADE;</li><li>级联删除：ON DELTE CASCADE;</li></ul></li></ul><h1 id="数据库的设计"><a class="markdownIt-Anchor" href="#数据库的设计"></a> 数据库的设计</h1><ul><li><a href="https://blog.csdn.net/guangod/article/details/88714091?biz_id=102&amp;utm_term=%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-88714091&amp;spm=1018.2118.3001.4449">参考blog</a></li></ul><h2 id="多表关系"><a class="markdownIt-Anchor" href="#多表关系"></a> 多表关系</h2><ol><li>一对一关系（使用较少）<ol><li>如：人与身份证</li><li>实现：一对一关系实现，可以在任意一方添加<strong>唯一外键</strong>指向另一方的主键。可以直接合成一张表。</li></ol></li><li>一对多关系<ol><li>如：部门和员工</li><li>实现：在“多”的一方建立外键，指向“一”的一方的主键。</li></ol></li><li>多对多关系：<ol><li>如：课程与学生</li><li>实现：多对多关系需要借助<strong>中间表</strong>，中间表至少包含两个字段，这两个字段（这两个字段是<strong>联合</strong>的）作为第三张表的外键，分别指向两张表的主键。</li></ol></li></ol><h2 id="数据库设计的范式"><a class="markdownIt-Anchor" href="#数据库设计的范式"></a> 数据库设计的范式</h2><ul><li>范式概念：设计数据库时需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求。<ul><li>设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。（前三种足矣。）</li></ul></li><li>范式分类：<ol><li>第一范式（1NF）：每一列都是不可分割的原子数据项。（数据库中创建表的基本要求）<ol><li>存在严重的数据冗余问题</li><li>数据添加存在问题</li><li>数据删除存在问题**</li></ol></li><li>第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于候选码（在1NF的基础上消除了非主属性对主码的<strong>部分依赖</strong>，解决了数据冗余问题）<ol><li>概念：<ol><li>函数依赖：A-&gt;B，如果通过A属性（属性组）的值，可以确定唯一B属性的值，则称B依赖于A</li><li>完全函数依赖：A-&gt;B,如果A是一个属性组，则B的值的确定需要依赖于A属性组中所有的属性值</li><li>部分函数依赖：A-&gt;B,如果A是一个属性组，则B属性值的确定只需要依赖于A属性组中某一些属性值即可。</li><li>传递函数依赖：A-&gt;B, B-&gt;C,如果通过A属性（属性值）的值，可以唯一确定B属性的值，在通过B属性（属性组）的值可以确定唯一的C属性的值，则称C传递函数依赖于A.</li><li>码：如果在一张表中，如果一个属性或者属性组，被其它所有属性完全依赖，则称这个属性（属性组）为该表的码。</li><li>主属性：码属性组中的所有属性。</li><li>非主属性：除了码属性组的属性。</li></ol></li></ol></li><li>第三范式（3NF）：在2NF的基础上，任何非主属性不依赖于其它非主属性（在2NF的基础上消除传递依赖，解决了数据添加和删除存在的问题）</li></ol></li></ul><h2 id="触发器"><a class="markdownIt-Anchor" href="#触发器"></a> 触发器</h2><p>…</p><h1 id="数据库的备份和还原"><a class="markdownIt-Anchor" href="#数据库的备份和还原"></a> 数据库的备份和还原</h1><ul><li>语法：<code>mysqldump -u用户名 -p密码 数据库名称 &gt; 备份保存的路径</code>（保存到以.sql结尾的文件）</li><li>还原：<ol><li>登录数据库；<code>mysql -u用户名 -p密码;</code></li><li>创建一个新数据库；<code>create database 新数据库名;</code></li><li>使用数据库:<code>use 数据库名;</code></li><li>执行备份的文件:<code>source 文件路径;</code></li></ol></li></ul><h1 id="多表查询"><a class="markdownIt-Anchor" href="#多表查询"></a> 多表查询</h1><h2 id="多表查询的基本概念"><a class="markdownIt-Anchor" href="#多表查询的基本概念"></a> 多表查询的基本概念</h2><ul><li>查询基本语法：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select   列名列表from   表的列表（可以写多个表）where   ...(条件)</code></pre><ul><li>示例：<code>select * from table1, table2;</code>。不加任何条件查询多个表的结果是：所有表的组合（两个表时是笛卡尔积）。</li></ul><h2 id="多表查询的分类"><a class="markdownIt-Anchor" href="#多表查询的分类"></a> 多表查询的分类</h2><ol><li>内连接查询</li><li>外连接查询</li><li>子查询</li></ol><h3 id="内连接查询"><a class="markdownIt-Anchor" href="#内连接查询"></a> 内连接查询</h3><ol><li>隐式内连接：使用where条件来消除多个表组合后的无用信息。</li></ol><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select       * from       table1, table2 where       table1.&#96;id1&#96; &#x3D; &#96;table.id2&#96;; -- 组合后不满足的这个条件的行都会被去掉select       table1.name, table2.name -- 要查询两个表里的同名列，需要在列名前面加上表名的限定。from       table1, table2 where             table1.&#96;id1&#96; &#x3D; table2.&#96;id2&#96;; select       t1.name, t2.name from       table1 t1, table2 t2 -- 通过取别名来简化对表名的书写。where       t1.&#96;id1&#96; &#x3D; t2.&#96;id2&#96;; </code></pre><ol start="2"><li>显式内连接：<ul><li>语法：<code>select 字段列表 from 表名1 inner join 表名2 on 条件;</code></li><li>同样支持对表取别名来简化书写</li></ul></li></ol><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select      * from      table1inner join      table2  -- 两个表是分开放的on       table1.&#96;id1&#96; &#x3D; table2.&#96;id2&#96;;select      * from      table1 t1join              -- inner可以省略      table2 t2on       t1.&#96;id1&#96; &#x3D; t2.&#96;id2&#96;;</code></pre><h3 id="外连接查询"><a class="markdownIt-Anchor" href="#外连接查询"></a> 外连接查询</h3><ol><li>左外连接：<ul><li>语法：<code>select 字段列表 from 表1 left outer join 表2 on 条件;</code>(outer同样是可以省略的)</li><li>查询的是左表所有数据以及左表和右表数据交集部分。from后面的是左表，join后面是右表。</li></ul></li><li>右外连接：<ul><li>语法：<code>select 字段列表 from 表1 right outer join 表2 on 条件;</code>(outer同样是可以省略的)</li><li>查询的是右表所有数据以及左表和右表数据交集部分。from后面的是左表，join后面是右表。</li></ul></li></ol><h3 id="子查询"><a class="markdownIt-Anchor" href="#子查询"></a> 子查询</h3><ul><li>查询中嵌套查询，嵌套的查询称为子查询。</li><li>示例：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"># 查询工资最高的员工的信息需完成两步操作：一：查询最高的工资；二：查询最高工资对应的员工信息select      * from       table1 -- 外层查询整个表的员工信息where       table1.&#96;salary&#96; &#x3D; (select max(salary) from table1); -- 嵌套一个子查询语句在条件里，完成最高工资的限定</code></pre><h4 id="子查询的不同结果"><a class="markdownIt-Anchor" href="#子查询的不同结果"></a> 子查询的不同结果</h4><ul><li>子查询结果是<strong>单行单列</strong>的：<ul><li>子查询结果可以作为条件，使用判断运算符去判断,如：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">table1.&#96;salary&#96; &#x3D; (select max(salary) from table1);</code></pre></li><li>子查询结果是<strong>多行单列</strong>的：<ul><li>子查询可以作为条件，使用运算符<code>in</code>（是否在这个集合中）去判断，如：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">table.&#96;id&#96; in (select id from table1 where name &#x3D; &#39;1&#39; or name &#x3D; &#39;2&#39;);</code></pre></li><li>子查询的结果是<strong>多行多列</strong>的：<ul><li>子查询可以作为一张虚拟表，参与查询，如：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"># 查询员工的入职日期是&#96;2011-11-11&#96;日之后的员工信息和部门信息-- 子查询方式 select       * from        dept t1,(select * from emp where emp.&#96;join_date&#96; &gt; &#39;2011-11-11&#39;) t2   -- 子查询结果作为一张表参与查询 where       t1.id &#x3D; t2.dept_id; -- 普通内连接 select       *  from       emp t1, dept t2 where       t1.&#96;dept_id&#96; &#x3D; t2.&#96;id&#96; and t1.&#96;join_date&#96; &gt; &#39;2011-11-11&#39;;</code></pre></li></ul><h1 id="事务"><a class="markdownIt-Anchor" href="#事务"></a> 事务</h1><h2 id="事务的基本介绍"><a class="markdownIt-Anchor" href="#事务的基本介绍"></a> 事务的基本介绍</h2><ul><li>事务概念：如果一个包含多个步骤的业务操作，被事务管理，那么这些操作<strong>要么同时成功，要么同时失败</strong>。</li><li>基本操作；<ol><li>开启事务：start transaction；</li><li>回滚：rollback；</li><li>提交：commit。</li></ol></li><li>示例：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"># 实现张三给李四的账户上转去500：1.张三的账户减五百 2.李四的账户加500 （如果这两步中有任何一步出错了的话，事务管理机制保证账户信息不被修改）start transaction; -- 开启事务update account set money &#x3D; money - 500 where name &#x3D; &#39;zhangsan&#39;; -- 张三的账户减500update account set money &#x3D; money +500 where name &#x3D; &#39;lisi&#39;; -- 李四的账户加500-- 如果两步执行完没有异常，则提交，提交后的数据库改变才真正生效commit;-- 如果执行出错，则回滚，数据库的状态维持启动事务时的状态rollback;</code></pre><ul><li>在MySQL中，事务是默认自动提交的<ul><li>自动提交：<ul><li>一条DML（增删改）语句会自动提交一次事务</li></ul></li><li>手动提交：<ul><li>需要先开启事务，再提交</li></ul></li><li>修改事务的默认提交方式：<ul><li>查看默认提交方式：<code>select @@autocommit;</code>,结果为1代表自动提交</li><li>设置默认提交方式：<code>set @@autocommit = 0;</code>，改为0代表手动提交</li></ul></li></ul></li><li>在oracle中，事务是默认手动提交的。</li></ul><h2 id="事务的四大特征"><a class="markdownIt-Anchor" href="#事务的四大特征"></a> 事务的四大特征</h2><ol><li>原子性：是不可分割的最小单位，要么同时成功，要么同时失败。</li><li>持久性：事务一旦提交或者回滚后，数据库会持久化地保存数据。</li><li>隔离性：多个事务之间相互独立。</li><li>一致性：事务操作前后，数据总量不变。（即如果事务执行到中途出错了，则整个数据库都回滚到事务开始前的状态。）</li></ol><h2 id="事务的隔离级别"><a class="markdownIt-Anchor" href="#事务的隔离级别"></a> 事务的隔离级别</h2><ul><li>概念：理论上多个事务之间是隔离的，相互独立。如果多个事务操作同一批数据，那么这些事务之间就不是隔离的了，会引发一些问题，设置不同的隔离级别来解决这些问题。</li><li>存在的问题：<ol><li>脏读：一个事务，读取到了另一个事务中<strong>没有提交</strong>的数据。</li><li>不可重复读（虚读）：在同一个事务中，两次读到的数据不一样。(原因可能是其它事务在两次查询之间的时间修改了数据库)</li><li>幻读：一个事务操作（DML）数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。</li></ol></li><li>隔离级别：隔离级别从小到大安全性越来越高，但是效率越来越低。<ol><li>read uncommited：读未提交<ol><li>产生的问题：脏读，不可重复读，幻读。</li></ol></li><li>read commited:读已提交（oracle默认）<ol><li>产生的问题：不可重复读，幻读</li></ol></li><li>repeatable read：可重复读（MySQL默认）<ol><li>产生的问题：幻读</li></ol></li><li>serializable：串行化（一个事务在操作一个表时，其它事务是不可以操作这个表，类似给这个表“加锁”）<ol><li>可以解决所有问题。</li></ol></li></ol></li><li>数据库查询隔离级别：<code>select @@tx_isolation;</code></li><li>数据库设置隔离级别：<code>set global transaction isolation level 级别字符串;</code></li></ul><h1 id="易错语法"><a class="markdownIt-Anchor" href="#易错语法"></a> 易错语法</h1><ul><li>语句括号内部少逗号，最后一行多了逗号:</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 创建学生表create table &#96;student&#96; (    &#96;id&#96; int primary key auto_increment comment &#39;学生id&#39;, -- 学生id&#96;name&#96; varchar (30) not null comment &#39;学生姓名&#39;, -- 学生姓名&#96;phone&#96; varchar (36) not null comment &#39;学生电话&#39;, -- 学生电话&#96;youth_league_branch_name&#96; varchar (60) not null comment &#39;所属团支部名称&#39;, -- 所属团支部名称&#96;study_time&#96; datetime not null comment &#39;学习时间&#39;  -- 学习时间 # 少了逗号    &#96;gmt_create&#96; datetime null default current_timestamp comment &#39;记录创建时间&#39;, -- 记录创建时间    &#96;gmt_modified&#96; datetime null default current_timestamp on update current_timestamp comment &#39;记录最近修改时间&#39;, -- 记录最近修改时间    &#96;youth_league_branch_id&#96; int not null, -- 所属团支部id # 多了逗号); 修改：-- 创建学生表create table &#96;student&#96; (    &#96;id&#96; int primary key auto_increment comment &#39;学生id&#39;, -- 学生id&#96;name&#96; varchar (30) not null comment &#39;学生姓名&#39;, -- 学生姓名&#96;phone&#96; varchar (36) not null comment &#39;学生电话&#39;, -- 学生电话&#96;youth_league_branch_name&#96; varchar (60) not null comment &#39;所属团支部名称&#39;, -- 所属团支部名称&#96;study_time&#96; datetime not null comment &#39;学习时间&#39;,  -- 学习时间    &#96;gmt_create&#96; datetime null default current_timestamp comment &#39;记录创建时间&#39;, -- 记录创建时间    &#96;gmt_modified&#96; datetime null default current_timestamp on update current_timestamp comment &#39;记录最近修改时间&#39;, -- 记录最近修改时间    &#96;youth_league_branch_id&#96; int not null -- 所属团支部id ); </code></pre><ul><li>在<code>student</code>外面加上引号是为了设置大小写敏感，否则所有的大写都会被自动转换为小写。</li></ul><p>JSON parse error: Cannot deserialize value of type <code>java.util.Date</code> from String “2020-11-24”: expected format “yyyy-MM-dd HH:mm:ss”; nested exception is com.fasterxml.jackson.databind.exc.InvalidFormatException: Cannot deserialize value of type <code>java.util.Date</code> from String “2020-11-24”: expected format “yyyy-MM-dd HH:mm:ss” at [Source: (PushbackInputStream); line: 1, column: 30] (through reference chain: com.zw.admin.server.model.TSchedule[“deadline”])</p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Servlet/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Servlet/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="servlet简介"><a class="markdownIt-Anchor" href="#servlet简介"></a> servlet简介</h1><ul><li>Servlet：即Server Applet。</li><li>Servlet其实就是一个遵循Servlet开发的<strong>java类</strong>。Servlet是由<strong>服务器调用的，运行在服务器端</strong>。Servlet<strong>没有main方法</strong>，它的创建、使用、销毁都由Servlet容器(即web服务器）进行管理（如Tomcat：提供了Servlet功能的服务器称作Servlet容器）。即虽然没有main方法，但是通过Servlet容器可以自动调用。</li><li>servelet用来实现对服务器的动态资源的控制。</li><li>servelet就是一个<strong>接口</strong>，定义了java类被浏览器访问的规则。</li><li>我们需要自定义一个类，这个类<strong>实现servelet接口，复写其方法</strong>。</li><li>Servlet带给我们最大的作用就是能够<strong>处理浏览器带来HTTP请求</strong>，并<strong>返回一个响应</strong>给浏览器，从而实现<strong>浏览器和服务器的交互</strong>。servlet是作用于服务器这一端。</li></ul><h1 id="快速入门"><a class="markdownIt-Anchor" href="#快速入门"></a> 快速入门</h1><h2 id="idea上配置tomcat"><a class="markdownIt-Anchor" href="#idea上配置tomcat"></a> IDEA上配置tomcat</h2><ul><li>使用的ide是IDEA，需要先在IDEA上配置Tomcat。(需要IDEA的utilmate版).<ol><li>点击Run—EDit Configurations…<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201010165243.jpg" alt="" /><br />2.点击左侧“+”号，找到Tomcat Server—Local。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201010165641.jpg" alt="" /><br />3.找到tomcat存放位置并配置到idea中：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201010165926.jpg" alt="" /></li></ol></li><li>IDEA会为每一个tomcat部署的项目单独建立一份配置文件<ul><li>查看控制台的log找到这个配置文件的存储位置：<code>CATALINA_BASE:     /home/zestaken/.cache/JetBrains/IntelliJIdea2020.2/tomcat/Tomcat_9_0_411_tomcat3</code></li></ul></li><li>WEB-INF目录下的资源不能被浏览器直接访问。</li></ul><h2 id="编写servlet程序的步骤"><a class="markdownIt-Anchor" href="#编写servlet程序的步骤"></a> 编写servlet程序的步骤</h2><ol><li>创建<strong>javaEE</strong>项目</li><li>定义一个类，实现Servlet接口：<code>public class ServletDemo1 implements Servlet</code></li><li>实现接口中的抽象方法</li><li>配置servlet，在web.xml中</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- 配置Servlet --&gt;&lt;servlet&gt;        &lt;servlet-name&gt;demo1&lt;&#x2F;servlet-name&gt;        &lt;servlet-class&gt;web.ServletDemo1&lt;&#x2F;servlet-class&gt;    &lt;&#x2F;servlet&gt;        &lt;servlet-mapping&gt;        &lt;servlet-name&gt;demo1&lt;&#x2F;servlet-name&gt;        &lt;url-pattern&gt;&#x2F;demo1&lt;&#x2F;url-pattern&gt;    &lt;&#x2F;servlet-mapping&gt;</code></pre><h1 id="执行原理解析过程"><a class="markdownIt-Anchor" href="#执行原理解析过程"></a> 执行原理/解析过程</h1><ol><li>当服务器接受到浏览器的请求后，会解析URL路径，获取访问的<strong>Servlet</strong>的资源路径。</li><li>查找web.xml文件，是否有对应的<code>&lt;url-pattern&gt;</code>标签内容。</li><li>如果有，则再找到对应的<code>&lt;servlet-class&gt;</code>全类名。</li><li>tomcat会将字节码文件加载进内存，并且创建其对象。</li><li>调用其方法。</li></ol><h1 id="生命周期"><a class="markdownIt-Anchor" href="#生命周期"></a> 生命周期</h1><ul><li>方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">import javax.servlet.*;import java.io.IOException;public class ServletDemo1 implements Servlet &#123;    &#x2F;**     * 初始化方法     * 在servlet被创建时执行，只会执行一次     * @param servletConfig     * @throws ServletException     *&#x2F;    @Override    public void init(ServletConfig servletConfig) throws ServletException &#123;        System.out.println(&quot;init&quot;);    &#125;    &#x2F;**     * 获取ServletConfig对象     * ServletConfig：Servlet的配置对象     * @return     *&#x2F;    @Override    public ServletConfig getServletConfig() &#123;        return null;    &#125;    &#x2F;**     * 提供服务的方法     * 每一次Servlet被访问时，执行，可以执行多次（每刷新一次页面都会执行一次）     * @param servletRequest     * @param servletResponse     * @throws ServletException     * @throws IOException     *&#x2F;    @Override    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;        System.out.println(&quot;service&quot;);    &#125;    &#x2F;**     * 获取Servlet的一些信息，版本，作者等。     * @return     *&#x2F;    @Override    public String getServletInfo() &#123;        return null;    &#125;    &#x2F;**     * 销毁方法     * 在服务器正常关闭时执行一次。     *&#x2F;    @Override    public void destroy() &#123;        System.out.println(&quot;destroy&quot;);    &#125;&#125;</code></pre><ul><li>生命周期<ol><li>被创建：执行init方法，只执行一次,一般用于<strong>加载资源</strong>.<ol><li>Servlet被创建的时间<ol><li>默认情况下，第一次被访问时（即在浏览器中访问该页面时），Servlet被创建</li><li>可以在web.xml配置执行Servlet的创建时间：<ul><li>在<code>&lt;servlet&gt;</code>标签下配置<ol><li>第一次被访问时创建:<code>&lt;load-on-startup&gt;</code>的值为负数</li><li>在服务器启动时创建：<code>&lt;load-on-startup&gt;</code>的值为0或者正数。</li></ol></li></ul></li></ol></li><li>Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的<ol><li>多个用户同时访问时，可能存在线程安全问题。</li><li>解决：尽量不再在Servlet中定义成员变量，即使定义了，也不要修改它。</li></ol></li></ol></li><li>提供服务：执行service方法，可执行多次<ol><li>每次被访问Servlet时，Service方法都会被调用一次。</li></ol></li><li>被销毁：执行destroy方法，只执行一次<ol><li>Servlet被销毁时执行。</li><li>服务器关闭时，Servlet被销毁</li><li>只有服务器正常关闭时，才会执行destroy方法</li><li>destroy方法在Servlet被销毁之前执行，一般用于<strong>释放资源</strong>。</li></ol></li></ol></li></ul><h1 id="注解配置"><a class="markdownIt-Anchor" href="#注解配置"></a> 注解配置</h1><ul><li>Servlet3.0之后，**支持注解配置，可以不用写web.xml了。</li><li>步骤：<ol><li>创建JavaEE项目，选择Servlet的版本3.0以上，<strong>可以不创建web.xml</strong>(也可以创建，因为注解配置会覆盖web.xml的配置)</li><li>定义一个类，实现Servlet接口;</li><li>复写方法;</li><li>在类上使用<code>@WebServlet</code>注解，进行配置：<ol><li><code>@WebServlet(loadOnStartup=&quot;资源路径名&quot;)</code>与<code>@WebServlet(value=&quot;资源路径名&quot;)</code>与<code>@WebServlet(&quot;资源路径名&quot;)</code>等效。</li></ol></li></ol></li><li><code>@WebServlet</code>注解的具体内容：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package javax.servlet.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface WebServlet &#123;    String name() default &quot;&quot;;    String[] value() default &#123;&#125;;    String[] urlPatterns() default &#123;&#125;;    int loadOnStartup() default -1;    WebInitParam[] initParams() default &#123;&#125;;    boolean asyncSupported() default false;    String smallIcon() default &quot;&quot;;    String largeIcon() default &quot;&quot;;    String description() default &quot;&quot;;    String displayName() default &quot;&quot;;&#125;</code></pre><h2 id="urlparttern的配置"><a class="markdownIt-Anchor" href="#urlparttern的配置"></a> urlparttern的配置</h2><ul><li>一个Servlet可以定义多个访问路径，<code>@WebServlet(&#123;&quot;/d4&quot;.&quot;/dd4&quot;&#125;)</code>,如果只有一个路径，则大括号可以省略。</li><li>路径的定义规则：<ol><li><code>/xxx</code>;</li><li><code>/xxx/xxx</code>:多层路径，目录结构(不止可以写两层，可以写更多层)</li><li><code>*.xxx</code>:不管.之前写的是什么，只要最后的后缀一样即可访问。一般是<code>*.do</code>形式。</li></ol></li><li>通配符<code>*</code>:<code>*</code>所占的位置输入任何名字都可以，但是优先级很低（即如果有那个名字的资源，则访问那个资源）。</li></ul><h1 id="servlet的体系结构"><a class="markdownIt-Anchor" href="#servlet的体系结构"></a> Servlet的体系结构</h1><ul><li>Servlet接口：最上层。</li><li>GenericServlet:实现了Servlet接口的<strong>抽象类</strong>,处于第二层。<ul><li>将Servlet接口中的其他的方法都做了默认空实现，只将service()方法作为抽象。</li><li>将来定义Servlet的类时，可以继承GenericServlet，实现<strong>service()方法即可</strong>。（但是不常用）</li></ul></li><li>HttpServlet：继承自GenricServlet的<strong>抽象类</strong>,处于第三层。<ul><li>所有方法都没有要求实现。</li><li>对http协议的一种封装，简化操作。</li><li>使用：<ul><li>定义类继承HttpServlet</li><li>复写doGet()/doPost()等方法。</li></ul></li></ul></li></ul><h1 id="javaweb的目录结构"><a class="markdownIt-Anchor" href="#javaweb的目录结构"></a> JAVAWEB的目录结构</h1><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201009104107.png" alt="" /></p><ul><li>bbs目录代表一个web应用</li><li>bbs目录下的html,jsp文件可以直接被浏览器访问</li><li>WEB-INF目录下的资源是<strong>不能直接被浏览器访问</strong>的</li><li><code>web.xml</code>文件是web程序的<strong>主要配置文件</strong>。</li><li>所有的<strong>classes</strong>文件都放在classes目录下</li><li><strong>jar文件</strong>放在lib目录下。</li></ul><h1 id="request对象和resoponse对象"><a class="markdownIt-Anchor" href="#request对象和resoponse对象"></a> Request对象和Resoponse对象</h1><h2 id="服务器与客户端交互流程"><a class="markdownIt-Anchor" href="#服务器与客户端交互流程"></a> 服务器与客户端交互流程</h2><ol><li>tomcat服务器会根据请求url中的资源路径创建对应的<strong>实现Servlet的类的对象</strong>;</li><li>tomcat<strong>服务器</strong>会创建<strong>request</strong>和<strong>response</strong>对象，request对象中封装请求的消息数据;</li><li>tomcat将request和response对象传递给<strong>service</strong>方法，并且调用service方法;</li><li>程序员通过request对象<strong>获取请求的消息数据</strong>，通过response对象**设置响应的消息数据;</li><li>服务器在给浏览器做出响应之前会从<strong>response对象</strong>中拿程序员设置的响应消息数据。</li></ol><h2 id="request对象"><a class="markdownIt-Anchor" href="#request对象"></a> Request对象</h2><ul><li>原理：<ul><li>request对象和reponse对象是由服务器创建的;</li><li>request对象获取请求消息，response对象设置响应消息。</li></ul></li><li>request对象的继承体系结构：<ol><li>ServletRequest:最上层接口;</li><li>HttpServletRequest:继承自ServletRequest的接口;</li><li>org.apache.catalina.connector.RequestFacade：tomcat实现的实现了HttpServlet接口的类。</li></ol></li></ul><h3 id="request功能"><a class="markdownIt-Anchor" href="#request功能"></a> request功能</h3><h4 id="获取请求消息数据"><a class="markdownIt-Anchor" href="#获取请求消息数据"></a> 获取请求消息数据</h4><ol><li>获取请求行数据：（get方式就放在doget方法中，POST方法则放在dopost方法中）</li><li><strong>获取虚拟目录</strong>：<code>/tomcat3_war_exploded</code></li><li><code>String getContextPath();</code></li><li><strong>获取请求的URI或URL</strong>:<ol><li><code>String getRequestURI();</code>:获取URI，如：<code>/tomcat3_war_exploded/ServletDemo3</code></li><li><code>String getRequestURL();</code>获取URL，如：<code>http://localhost:8080/tomcat3_war_exploded/ServletDemo3</code></li><li>URI和URL都是<strong>统一资源定位符</strong>,但是URI表示的范围比URL大。</li></ol></li><li>获取Servlet路径：<code>/ServletDemo3</code><ol><li><code>String getServletPath();</code></li></ol></li><li>获取get方式请求参数：<ol><li><code>String getQueryString();</code>,如：<code>name=%22zhangsan%22&amp;age=13</code></li></ol></li><li>获取请求头数据：<ol><li><code>String getHeader(String name)</code>:通过请求头的名称获取请求头的数据;</li><li><code>Enumeration&lt;String&gt; getHeaderName()</code>:获取所有的请求头数据;</li></ol></li><li>获取请求体数据：<ol><li>请求体：只有POST方式才有。</li><li>步骤：<ol><li>获取流对象：<ol><li><code>BufferedReader getReader();</code>获取字符输入流，只能操作字符数据;</li><li><code>ServletInputStream getInputStream()</code>:获取字节输入流，可以操作所有类型的数据；</li></ol></li><li>从流对象中将数据拿出来</li></ol></li></ol></li></ol><h4 id="获取请求参数的通用方式"><a class="markdownIt-Anchor" href="#获取请求参数的通用方式"></a> 获取请求参数的通用方式</h4><ul><li>不论是get还是post方式都可以使用。（如果doget和dopost的代码完全一样的话，在doget里写<code>this.doPost()</code>即可)</li></ul><ol><li><strong>根据参数名称来获取参数值</strong>:<code>String getParameter(String name)</code>，如果一个参数有多个值的话，则无法获取完。</li><li>根据参数名称来获取参数值的数组：<code>String[] getParameterValues(String name)</code>;</li><li>获取所有请求的参数名称：<code>Enumeration&lt;String&gt; getParameterNames()</code>;</li><li><strong>获取所有参数的Map集合</strong>：<code>Map&lt;String, String[]&gt; getParameterMap()</code>。</li></ol><ul><li>获取请求参数的中文乱码问题：<ul><li>get方式：tomcat 8 已经将get方式乱码问题解决了;</li><li>post方式：在获取参数前，设置request的编码<code>request.setCharacterEncoding(&quot;utf-8&quot;);</code></li></ul></li></ul><h4 id="请求转发forward"><a class="markdownIt-Anchor" href="#请求转发forward"></a> 请求转发(forward)</h4><ul><li>在服务器内部之间的资源跳转方式。</li><li>步骤：<ol><li>通过request对象来获取请求转发器对象：<code>RequestDispatcher getRequestDispatcher(String path)</code></li><li>使用RequestDispatcher对象来进行转发：<code>forward(ServletRequest request, ServletResponse response)</code></li><li>示例：<code>request.getRequestDispathcher(&quot;/ServletDemo4&quot;).forward(request,response)</code></li></ol></li><li>特点：<ul><li>浏览器地址栏路径不会发生变化;</li><li>只能转发到当前服务器内部资源中;</li><li>转发是一次请求（即多个资源共用一次请求的信息）。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210106131528.png" alt="" /></li></ul></li></ul><h4 id="共享数据"><a class="markdownIt-Anchor" href="#共享数据"></a> 共享数据</h4><ul><li>域对象：一个有作用范围的对象，可以在范围内共享数据;</li><li>request域：代表<strong>一次请求</strong>的范围，一般用于请求转发的多个资源中共享数据;</li><li>request共享数据的方法：<ul><li>存储数据：<code>void setAttribute(String name, Object obj)</code>;</li><li>通过键获取值：<code>Object getAttribute(String name)</code>;</li><li>通过键移除值对：<code>void removeAttribute(String name)</code>;</li></ul></li></ul><h4 id="获取servletcontext对象"><a class="markdownIt-Anchor" href="#获取servletcontext对象"></a> 获取ServletContext对象</h4><ul><li>request对象获取ServletContext对象的方法：<code>ServletContext getServletContext();</code></li></ul><h2 id="response对象"><a class="markdownIt-Anchor" href="#response对象"></a> Response对象</h2><ul><li>功能：设置响应消息</li><li>设置<strong>响应消息</strong>:<ul><li><code>setStatus(int sc)</code></li></ul></li><li>设置<strong>响应头</strong>:<ul><li><code>setHeader(String name , String value)</code></li></ul></li><li>设置<strong>响应体</strong>:<ol><li>获取输出流：<ol><li>字符输出流：<code>PrintWrtier getWriter()</code></li><li>字节输出流：<code>ServletOutputStream getOutputStream()</code></li></ol></li><li>使用输出流：将数据输出到客户端浏览器。</li></ol></li></ul><h3 id="使用案例"><a class="markdownIt-Anchor" href="#使用案例"></a> 使用案例</h3><h4 id="重定向redirect"><a class="markdownIt-Anchor" href="#重定向redirect"></a> 重定向（redirect)</h4><ul><li>资源的跳转方式</li><li>方式一：逐步设置响应状态码和响应头</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet(&quot;&#x2F;ServletDemo2&quot;)public class ServletDemo2 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;     System.out.println(&quot;demo2&quot;);    resp.setStatus(302);    resp.setHeader(&quot;location&quot;, &quot;&#x2F;tomcat3_war_exploded&#x2F;ServletDemo3&quot;);    &#125;&#125;@WebServlet(&quot;&#x2F;ServletDemo3&quot;)public class ServletDemo3 extends HttpServlet &#123;    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;    &#125;    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        System.out.println(&quot;demo3&quot;);    &#125;&#125;</code></pre><ul><li>方式二：直接使用<code>sendRedirect</code>方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@WebServlet(&quot;&#x2F;ServletDemo2&quot;)public class ServletDemo2 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;     System.out.println(&quot;demo2&quot;);     &#x2F;&#x2F;动态获取虚拟目录     String contextPath &#x3D; req.getContextPath();     resp.sendRedirect(contextpath+&quot;&#x2F;ServletDemo3&quot;);    &#x2F;&#x2F; resp.sendRedirect(&quot;&#x2F;tomcat3_war_exploded&#x2F;ServletDemo3&quot;);    &#125;&#125;@WebServlet(&quot;&#x2F;ServletDemo3&quot;)public class ServletDemo3 extends HttpServlet &#123;    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;    &#125;    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        System.out.println(&quot;demo3&quot;);    &#125;&#125;</code></pre><ul><li>转发的特点：<ul><li>浏览器地址栏路径不会发生变化;</li><li>只能转发到当前服务器内部资源中;</li><li>转发是一次请求（即多个资源共用一次请求的信息），可以使用request对象来共享数据。</li></ul></li><li>重定向的特点：<ul><li>浏览器地址栏路径<strong>会发生变化</strong>;</li><li>重定向可以访问**其他站点（服务器）**资源;</li><li>重定向是<strong>两次请求</strong>。<strong>不能使用request对象来共享数据</strong>。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210106130407.png" alt="" /></li></ul></li><li>动态方式获取<strong>虚拟目录</strong>。<code>String contextPath = request.getContextPath();</code></li><li>路径写法：<ul><li>相对路径：<ul><li>不以<code>/</code>开头，以<code>.</code>开头;</li><li>规则：<ul><li><code>./</code>：当前目录下;</li><li><code>../</code>：上一级目录下;</li></ul></li></ul></li><li>绝对路径：<ul><li>以<code>/</code>开头的路径;</li><li>给客户端浏览器使用的绝对路径需要加<strong>虚拟目录</strong>(项目的访问路径);<ul><li>建议虚拟目录动态获取;</li><li>如：重定向中使用的路径是<code>/tomcat3_war_exploded/ServletDemo3</code></li></ul></li><li>给服务器使用，不需要加虚拟目录;<ul><li>如转发中使用的路径：<code>/ServletDemo3</code></li></ul></li></ul></li></ul></li></ul><h4 id="服务器输出字符数据到浏览器"><a class="markdownIt-Anchor" href="#服务器输出字符数据到浏览器"></a> 服务器输出字符数据到浏览器</h4><ul><li>步骤：<ol><li>获取字符输出流：<code>PrintWriter pw = response.getWriter();</code>(获取的流的默认编码是ISO-8859-1)</li><li>输出数据：<code>pw.write(&quot;你好 response&quot;)</code></li><li>流对象是由response创建的，会随着response的关闭而关闭，不用再人为的close。</li></ol></li><li>中文乱码问题：<ul><li>原因：因为浏览器使用的字符集和服务器使用的字符集不一致导致的。</li><li>需要在<strong>获取字符输出流之前</strong>返回一个告诉浏览器服务器返回消息使用的字符集和格式：<ul><li>通过设置content-type头的内容来解决：<code>response.setHeader(&quot;content-type&quot;, &quot;text/html;charset=utf-8&quot;);</code></li><li>response对象有一个内置的简化方法：<code>responde.setContentType(&quot;text/html;charset=utf-8&quot;);</code></li></ul></li></ul></li></ul><h4 id="服务器输出字节数据到浏览器"><a class="markdownIt-Anchor" href="#服务器输出字节数据到浏览器"></a> 服务器输出字节数据到浏览器</h4><ul><li>步骤：<ol><li>获取字节输出流：<code>ServletOutputStream sos = response.getOutputStream();</code></li><li>输出数据：<code>sos.write(&quot;你好&quot;.getBytes(&quot;utf-8&quot;));</code></li></ol></li><li>还是需要在<strong>获取字节输出流之前</strong>通知浏览器字符集的设置。</li></ul><h4 id="服务器验证码"><a class="markdownIt-Anchor" href="#服务器验证码"></a> 服务器验证码</h4><ul><li>验证码的作用：防止恶意重复提交表单。（机器人）</li><li>实现的功能，服务器自动生成验证码图片，并且对图片进行美化。</li><li>步骤：<ol><li>创建图片</li><li>美化图片（增加验证码的内容）</li><li>输出图片到浏览器上</li></ol></li><li>示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">    &#x2F;&#x2F;图片长宽设置    int width &#x3D; 100;    int height &#x3D; 50;        &#x2F;&#x2F;1.创建一对象，在内存中创建图片（验证码的图片）    BufferedImage image &#x3D; new BufferedImage(width, height,BufferedImage.TYPE_INT_RGB);    &#x2F;&#x2F;2.美化图片    Graphics g &#x3D; image.getGraphics();&#x2F;&#x2F;获取画笔对象    g.setColor(Color.PINK);&#x2F;&#x2F;设置画笔颜色    g.fillRect(0,0,width,height);&#x2F;&#x2F;填充背景色    g.setColor(Color.BLACK);&#x2F;&#x2F;设置画笔颜色    g.drawRect(0,0,width-1, height - 1);&#x2F;&#x2F;画边框    String str &#x3D; &quot;QWERTYUIOOOOOPASDFGHJKKLZXCVBNMMqwertyuiopasdfghjklzxcvbnm0123456789&quot;;&#x2F;&#x2F;设置可以写到验证码图片上的字符    Random random &#x3D; new Random();&#x2F;&#x2F;获取生成随机数的对象    &#x2F;&#x2F;将随即字符写到图片上去    for(int i &#x3D; 1; i &lt; 5; i++) &#123;        int index &#x3D; random.nextInt(str.length());&#x2F;&#x2F;获取在字符串大小范围内的随机索引值        char ch &#x3D; str.charAt(index);        g.drawString(ch+&quot;&quot;, width&#x2F;5*i ,height&#x2F;2);    &#125;        &#x2F;&#x2F;画干扰线    g.setColor(Color.GREEN);    &#x2F;&#x2F;生成随机坐标来划线    for(int i &#x3D; 0; i &lt; 10; i++) &#123;        int x1 &#x3D; random.nextInt(width);        int x2 &#x3D; random.nextInt(width);        int y1 &#x3D; random.nextInt(height);        int y2 &#x3D; random.nextInt(height);        g.drawLine(x1,y1,x2,y2);    &#125;    &#x2F;&#x2F;3.将图片输出到浏览器上    ImageIO.write(image, &quot;jpg&quot;, resp.getOutputStream());&#125;</code></pre><h1 id="servletcontext对象"><a class="markdownIt-Anchor" href="#servletcontext对象"></a> ServletContext对象</h1><ol><li>概念:代表整个web应用（一个web应用里只有唯一的一个ServletContext对象），可以和程序的容器（服务器）来通信;</li><li>获取ServletContext对象：<ol><li>通过Request对象来获取:<code>request.getServletContext();</code></li><li>通过HttpServlet获取（我们创建的Servlet类都是从这里继承的）：<code>this.getServletContext();</code></li></ol></li><li>方法：<ol><li>获取MIME类型：<ol><li>MIME类型：在互联网通信过程中定义的一种文件数据类型，格式为：<code>大类型/小类型</code>，如：<code>text/html</code>,<code>image/jpeg</code>.</li><li>获取的方法：<code>String getMIMEType(String file)</code>,参数是文件名称;</li></ol></li><li>作为域对象：<ol><li>ServletContext对象的范围：所有用户所有请求的数据;</li><li><code>setAttribute(String name, Object value);</code></li><li><code>getAttribute(String name)</code></li><li><code>removeAttribute(String name)</code></li></ol></li><li>获取文件的真实（服务器）路径：<ol><li>我们经常需要使用的是一个文件部署到服务器上的路径，而不是该文件在本地工作空间的路径;</li><li>方法：<code>String getRealPath(String path)</code></li><li>参数：文件在本地工作空间的相对路径<ol><li>在web目录下的资源：<code>/文件名</code></li><li>在WEB_INF目录下的资源：<code>/WEB-INF/文件名</code></li><li>在源文件（src目录或者java目录下）的资源：<code>/WEB-INF/classes/文件名</code></li></ol></li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Tomcat/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Tomcat/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="tomcat简介"><a class="markdownIt-Anchor" href="#tomcat简介"></a> Tomcat简介</h1><ul><li>Tomcat 服务器是一个免费的开放源代码的<strong>Web 应用服务器</strong>，属于轻量级应用<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a>，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。Tomcat是一个使别人能够访问我写的页面的一个程序。</li><li>Tomcat与servlet以及数据库的关系：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201008164643.png" alt="" /></li></ul><h1 id="tomcat的安装"><a class="markdownIt-Anchor" href="#tomcat的安装"></a> Tomcat的安装</h1><ul><li><p>Tomcat需要jdk的支持，需要先在电脑上装上jdk，Tomcat会在环境变量中去寻找jdk的支持。</p></li><li><p>去<a href="https://tomcat.apache.org">官网</a>下载Windows系统的tomcat安装器：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201008165449.jpg" alt="" /></p></li><li><p>找到Tomcat安装目录的bin目录中的startup.bat文件，打开得到如下界面：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201008170319.jpg" alt="" /></p></li><li><p>之后再浏览器地址栏输入http://localhost:8080成功显示出如下界面，则证明Tomcat的配置成功了。<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201008170513.jpg" alt="" /></p></li><li><p>如果要卸载，则删除目录即可。</p></li></ul><h1 id="tomcat的基础知识"><a class="markdownIt-Anchor" href="#tomcat的基础知识"></a> Tomcat的基础知识</h1><h2 id="链接url简介"><a class="markdownIt-Anchor" href="#链接url简介"></a> 链接URL简介</h2><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201008173307.png" alt="" /></p><h2 id="tomcat的目录结构"><a class="markdownIt-Anchor" href="#tomcat的目录结构"></a> Tomcat的目录结构</h2><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201008173457.png" alt="" /></p><ul><li>conf文件：<ul><li><code>server.xml</code>该文件用于配置server相关的信息，比如tomcat启动的端口号，配置主机(Host)</li><li><code>web.xml</code>文件配置与web应用（web应用相当于一个web站点）</li><li><code>tomcat-user.xml</code>配置用户名密码和相关权限.</li></ul></li><li>work文件：<ul><li>work工作目录：该目录用于存放<strong>jsp被访问后生成对应的server文件和.class文件</strong></li></ul></li></ul><h2 id="启动"><a class="markdownIt-Anchor" href="#启动"></a> 启动</h2><ul><li>bin/startup.bat:运行该文件</li><li>访问；浏览器输入：<ul><li><code>http://localhost:8080</code> 访问自己</li><li><code>http://别人的IP地址：8080</code> 访问别人</li><li>8080是Tomcat的默认端口号。</li><li>可能遇到的问题：<ul><li>黑窗口一闪而过：<ul><li>原因：没有配置好JAVA_HOME</li></ul></li><li>启动报错：<ol><li>原因：端口号被占用</li><li>解决方案：<ol><li>找到占用的端口号对应的进程，杀死该进程<ol><li>找到进程：<code>netstat -ano</code></li><li>杀死进程：<code>taskkill /pid 进程号 -t -f</code></li></ol></li><li>修改自身的端口号<ol><li>修改conf/server.xml下的默认端口号</li></ol></li></ol></li></ol></li></ul></li></ul></li></ul><h2 id="关闭"><a class="markdownIt-Anchor" href="#关闭"></a> 关闭</h2><ul><li>正常关闭<ul><li>bin/shutdown.bat</li><li>ctrl+c</li></ul></li><li>强制关闭<ul><li>点击启动窗口的x</li></ul></li></ul><h2 id="动态项目和静态项目"><a class="markdownIt-Anchor" href="#动态项目和静态项目"></a> 动态项目和静态项目</h2><ul><li>目录结构：<ul><li>java动态项目：<ul><li>项目名称<ul><li>WEB-INF<ul><li>web.xml:该项目的核心配置文件</li><li>classes目录：放置了字节码文件</li><li>lib目录：放置项目依赖的jar包</li></ul></li></ul></li></ul></li></ul></li></ul><h1 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h1><ul><li>部署项目的方式<ol><li>直接将项目放到webapps目录下<ol><li>创建一个项目目录，在这个目录中放置资源文件，启动这个项目需要使用在端口地址后增加<code>/项目目录名/资源文件名</code>，<ol><li><code>/项目目录名</code>:项目的的访问路径-&gt;<strong>虚拟项目</strong>。</li></ol></li><li>简化部署：将项目打包成一个war包，直接放到webapps目录下，tomcat会自动解压缩这个包。</li></ol></li><li>配置虚拟目录法</li></ol></li></ul><h2 id="webapps目录部署项目"><a class="markdownIt-Anchor" href="#webapps目录部署项目"></a> webapps目录部署项目</h2><ul><li><p><strong>在webapps中建立了web1目录</strong>，下面放置我们的html文件，jsp文件，图片等等，<strong>则web1就被当做web应用管理起来</strong>。示例：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201009103542.jpg" alt="" /></p><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201009103533.jpg" alt="" /></p><ul><li>注意路径是严格大小写的，路径出错是无法显示的。</li></ul></li><li><p>web站点的目录规范：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201009104107.png" alt="" /></p><ul><li><p>作用：我有多个html文件，想把其中的一个html文件作为我web站点的首页。如果没有WEB-INF目录下的web.xml文件支持，是无法解决我的需求的。这个规范是约定熟成的。</p></li><li><p>web.xml使helloworld2.html做首页示例：</p><ul><li>新建一个WEB-INF目录<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201009151532.jpg" alt="" /></li><li>在WEB-INF目录下创建一个web.xml</li><li>web.xml我们不可能会写，所以可以<strong>在webapps目录下其他的站点中抄一份过来</strong>【复制ROOT/WEB-INF/web.xml的文件到自己的站点中】</li><li>在web.xml中添加以下代码</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;welcome-file-list&gt;      &lt;welcome-file&gt;helloworld2.html&lt;&#x2F;welcome-file&gt;&lt;&#x2F;welcome-file-list&gt;</code></pre><ul><li>最终的web.xml如图：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201009151441.jpg" alt="" /></li><li>在浏览器输入<code>localhost:8080/web1/</code>得：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201009151224.jpg" alt="" /><ul><li>因为已经规定了首页为helloworld2.html所以无需指明具体的html文件。</li></ul></li></ul></li></ul></li></ul><h2 id="配置虚拟目录"><a class="markdownIt-Anchor" href="#配置虚拟目录"></a> 配置虚拟目录</h2><ul><li><p>虚拟目录的作用：</p><ul><li>如果把所有web站点的目录都放在webapps下，可能导致<strong>磁盘空间不够用</strong>，也<strong>不利于对web站点目录的管理</strong>【如果存在非常多的web站点目录】</li><li>把<strong>web站点的目录分散到其他磁盘管理就需要配置虚拟目录【默认情况下，只有webapps下的目录才能被Tomcat自动管理成一个web站点】</strong></li><li>把web应用所在目录交给web服务器管理，这个过程称之为虚拟目录的映射。</li></ul></li><li><p>虚拟目录的配置方法一（不推荐使用）：</p><ul><li>在其他地方创建一个web站点目录，并创建WEB-INF目录和一个html文件。<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201009152314.jpg" alt="" /></li><li>找到Tomcat目录下**/conf/server.xml**文件</li><li>在server.xml中的<Host>节点下添加如下代码。<strong>path表示的是访问时输入的web项目名，docBase表示的是站点目录的绝对路径</strong><code> &lt;Context path=&quot;/web&quot; docBase=&quot;C:\03Temporary\web&quot;/&gt;</code></li><li>最后访问配置好的站点:<code>localhost:8080/web/helloworld.html</code>.<ul><li>注：需要重启tomcat，配置文件才能生效。</li></ul></li></ul></li><li><p>虚拟目录的配置方法二（最推荐部署项目的方法）：</p><ul><li><p>进入到conf/Catalina/localhost文件下，创建一个xml文件，<strong>该文件的名字就是站点的名字。</strong>（此处名为<code>hello3.xml</code>）</p></li><li><p>xml文件中的内容：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;Context docBase&#x3D;&quot;C:\03Temporary\web1&quot; &#x2F;&gt;  </code></pre></li><li><p>输入<code>localhost:8080/hello3/helloworld.html</code>来访问页面。结果如图：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201009181521.jpg" alt="" /></p></li><li><p>修改文件后就会<strong>立即生效</strong>，不需要重启服务器，是一种热部署的方式。</p></li></ul></li></ul><h1 id="将tomcat集成到idea"><a class="markdownIt-Anchor" href="#将tomcat集成到idea"></a> 将Tomcat集成到IDEA</h1><ul><li>实际操作界面和教程完全不同，如何解决？</li></ul><h1 id="配置临时域名"><a class="markdownIt-Anchor" href="#配置临时域名"></a> 配置临时域名</h1><p>访问Tomcat服务器有好几种方式：</p><ul><li><p>使用localhost域名访问【localhost代表本机】</p></li><li><p>使用ip地址127.0.0.1访问【该ip地址也是本机】</p></li><li><p>使用机器名称访问【只限用于本机上或者局域网】</p></li><li><p>使用本机IP地址访问【<strong>在cmd中输入ipconfig可以查询到本机IP地址</strong>】</p></li><li><p>还可以为机器配置临时域名。</p></li><li><p>示例：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201009183154.jpg" alt="" /></p></li></ul><p>配置临时域名的步骤：</p><ul><li><p>打开到C:Windows/System32/drivers/etc下，找到hosts文件，在其中添加<code>127.0.0.1 localhost</code>和<code>127.0.0.1 zhangjie</code>两行。<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201009182837.jpg" alt="" /></p></li><li><p>在浏览器中输入<code>zhangjie:8080/hello3/helloworld.html</code>访问失败d是因为没有保存修改后的hosts文件，保存后可以正常运行。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201010074530.jpg" alt="" /></p></li></ul><h1 id="配置虚拟主机"><a class="markdownIt-Anchor" href="#配置虚拟主机"></a> 配置虚拟主机</h1><h3 id="什么是虚拟主机"><a class="markdownIt-Anchor" href="#什么是虚拟主机"></a> 什么是虚拟主机？</h3><ul><li><strong>多个不同域名的网站共存于一个Tomcat中</strong></li></ul><h3 id="为什么需要用到虚拟主机"><a class="markdownIt-Anchor" href="#为什么需要用到虚拟主机"></a> 为什么需要用到虚拟主机？</h3><ul><li>例子：我现在开发了4个网站，有4个域名。如果我不配置虚拟主机，一个Tomcat服务器运行一个网站，我就需要4台电脑才能把4个网站运行起来。</li></ul><p>配置虚拟主机的步骤：</p><ul><li><p>在tomcat的server.xml文件中添加主机名，添加内容如下：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;&#x2F;Host&gt;      &lt;Host name&#x3D;&quot;zhang&quot; appBase&#x3D;&quot;C:\03Temporary\web1&quot;&gt;                    &lt;Context path&#x3D;&quot;&#x2F;web1&quot; docBase&#x3D;&quot;C:\03Temporary\web1&quot;&#x2F;&gt;      &lt;&#x2F;Host&gt;</code></pre></li><li><p>之后在浏览器输入<code>zhang:8080/hello3/helloworld.html</code>来访问。结果失败。。。</p></li></ul><h1 id="tomcat的结构体系"><a class="markdownIt-Anchor" href="#tomcat的结构体系"></a> Tomcat的结构体系</h1><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201009184720.png" alt="" /></p><h1 id="浏览器访问web资源的流程图"><a class="markdownIt-Anchor" href="#浏览器访问web资源的流程图"></a> 浏览器访问WEB资源的流程图</h1><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201009184857.png" alt="" /></p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Nginx/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Nginx/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="nginx概述"><a class="markdownIt-Anchor" href="#nginx概述"></a> Nginx概述</h1><p><a href="http://nginx.org/en/docs/">官方文档</a></p><ul><li>Nginx(engine x)是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</li><li>Nginx的应用场景：<ol><li>http服务器：Nginx是一个http服务器，可以独立提供http服务，可以用作网页静态服务器。</li><li>虚拟主机：可以实现在一台服务器虚拟出多个网站。</li><li>反向代理，负载均衡：当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要使用多台服务器集群时，可以使用Nginx做反向代理，并且多台服务器可以平均分担负载（即负载均衡），不会出现某台服务器负载高而宕机，而另外的某台服务器闲置的情况。</li></ol></li></ul><h1 id="nginx在linux下的安装"><a class="markdownIt-Anchor" href="#nginx在linux下的安装"></a> Nginx在linux下的安装</h1><p><a href="https://www.nginx.cn/install">参考文档</a></p><ol><li>准备编译环境(Ubuntu系列）：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apt-get install build-essentialapt-get install libtool</code></pre><ol start="2"><li>安装PCRE库：<ol><li><a href="https://ftp.pcre.org/pub/pcre/">官网下载</a></li><li>解压到<code>/usr/local/src</code>下，需要sudo权限（在这个目录下的操作大多都需要sudo权限）sd</li><li>运行configure文件，生成makefile文件</li><li><code>make</code></li><li><code>sudo make install</code>,需要sudo权限。</li></ol></li><li>安装Zlib库：<ol><li><a href="http://zlib.net/">官网下载</a></li><li>解压到<code>/usr/local/src</code>下，需要sudo权限</li><li>运行configure文件，生成makefile文件</li><li><code>make</code></li><li><code>sudo make install</code>,需要sudo权限</li></ol></li><li>安装ssl<ol><li><a href="https://www.openssl.org/source/">官网下载</a></li><li>解压到<code>/usr/local/src</code>下，需要sudo权限</li></ol></li><li>安装Nginx<ol><li><a href="http://nginx.org/en/download.html">官网下载</a></li><li>解压到<code>/usr/local/src</code>下，需要sudo权限</li><li>运行configure文件，生成makefile文件，不过要配置一些参数(其中依赖库的版本要与自己安装的对应）：</li></ol></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;configure --sbin-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;nginx \--conf-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;nginx.conf \--pid-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;nginx.pid \--with-http_gzip_static_module \--with-http_stub_status_module \--with-file-aio \--with-http_realip_module \--with-http_ssl_module \--with-pcre&#x3D;&#x2F;usr&#x2F;local&#x2F;src&#x2F;pcre-8.44 \--with-zlib&#x3D;&#x2F;usr&#x2F;local&#x2F;src&#x2F;zlib-1.2.11 \--with-openssl&#x3D;&#x2F;usr&#x2F;local&#x2F;src&#x2F;openssl-1.1.1i</code></pre><ol start="4"><li><code>make -j2</code>，用两个线程编译，这一步用时稍微要久一点</li><li><code>make install</code>。</li></ol><ul><li>安装好后，会在<code>/usr/local</code>目录下生成nginx目录</li><li>直接运行nginx目录下的nginx文件，即可启动nginx服务器，默认为80端口，可直接用本机的ip地址访问该服务器。</li></ul><h1 id="常用控制命令"><a class="markdownIt-Anchor" href="#常用控制命令"></a> 常用控制命令</h1><ul><li><code>./nginx -s stop</code>:中止服务器，非正常关闭;</li><li><code>./nginx -s quit</code>:正常关闭服务器;</li><li><code>./nginx -s reload</code>:重新加载服务器的配置文件(在服务器启动的情况下才能重新加载)</li><li><code>./nginx -s reopen</code>:重新打开日志文件</li></ul><h1 id="nginx部署静态页面"><a class="markdownIt-Anchor" href="#nginx部署静态页面"></a> Nginx部署静态页面</h1><ul><li>在<code>/usr/local/nginx</code>目录下，创建一个存储静态资源的目录，比如说<code>/usr/local/nginx/data</code></li><li>之后修改<code>/usr/local/nginx</code>目录下的<code>nginx.conf</code>文件的server模块。</li></ul><pre class="line-numbers language-conf" data-language="conf"><code class="language-conf">http &#123;    include       mime.types;    default_type  application&#x2F;octet-stream;    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    #access_log  logs&#x2F;access.log  main;    sendfile        on;    #tcp_nopush     on;    #keepalive_timeout  0;    keepalive_timeout  65;    #gzip  on;    server &#123;        listen       80;# 默认端口号        server_name  localhost; # 域名或者ip        #charset koi8-r;        #access_log  logs&#x2F;host.access.log  main;        location &#x2F; &#123;             root    data # 默认访问资源目录             index  index.html index.htm; #默认访问资源文件名        &#125;        #error_page  404              &#x2F;404.html;        # redirect server error pages to the static page &#x2F;50x.html        #        error_page   500 502 503 504  &#x2F;50x.html; # 错误资源        location &#x3D; &#x2F;50x.html &#123;            root   html;        &#125;        # proxy the PHP scripts to Apache listening on 127.0.0.1:80        #        #location ~ \.php$ &#123;        #    proxy_pass   http:&#x2F;&#x2F;127.0.0.1;        #&#125;        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000        #        #location ~ \.php$ &#123;        #    root           html;        #    fastcgi_pass   127.0.0.1:9000;        #    fastcgi_index  index.php;        #    fastcgi_param  SCRIPT_FILENAME  &#x2F;scripts$fastcgi_script_name;        #    include        fastcgi_params;        #&#125;        # deny access to .htaccess files, if Apache&#39;s document root        # concurs with nginx&#39;s one        #        #location ~ &#x2F;\.ht &#123;        #    deny  all;        #&#125;    &#125;</code></pre><h1 id="配置虚拟主机"><a class="markdownIt-Anchor" href="#配置虚拟主机"></a> 配置虚拟主机</h1><ul><li>虚拟主机可以理解为在同一个服务器里面部署多个项目。</li><li>只需要在<code>nginx.conf</code>文件中，增加<code>server</code>模块即可。</li><li>端口绑定：<ul><li>即修改server模块中的listen选项，用不同的端口号来访问不同的资源。</li></ul></li><li>域名绑定：<ul><li>一个ip可以对应多个域名，所以本机的ip地址可以设置多个对应的域名（需要修改本机的hosts文件）</li><li>然后修改server模块的server_name为不同的域名，即可以用不同的域名来访问不同的资源。</li></ul></li></ul><h1 id="nginx的反向代理和负载均衡"><a class="markdownIt-Anchor" href="#nginx的反向代理和负载均衡"></a> Nginx的反向代理和负载均衡</h1><ul><li><strong>正向代理(代理)</strong>:意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后<strong>代理向原始服务器转交请求并将获得的内容返回给客户端</strong>。客户端才能使用正向代理。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210203122231.jpeg" alt="" /></li><li><strong>反向代理</strong>:反向代理服务器位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户<strong>直接访问反向代理服务器就可以获得目标服务器的资源</strong>。同时，用户不需要知道目标服务器的地址，也无须在用户端作任何设定。反向代理服务器通常可用来作为Web加速，即使用反向代理作为Web服务器的前置机来降低网络和服务器的负载，提高访问效率。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210203122317.jpeg" alt="" /></li></ul><h2 id="配置nginx的反向代理"><a class="markdownIt-Anchor" href="#配置nginx的反向代理"></a> 配置Nginx的反向代理</h2><ul><li>修改<code>nginx.conf</code>配置文件;</li></ul><pre class="line-numbers language-conf" data-language="conf"><code class="language-conf">http &#123;  include       mime.types;  default_type  application&#x2F;octet-stream;  #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;  #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;  #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;  #access_log  logs&#x2F;access.log  main;  sendfile        on;  #tcp_nopush     on;  #keepalive_timeout  0;  keepalive_timeout  65;  #gzip  on;  upstream tomcat1 &#123; # tomcat1是为被代理服务器自己取的名字     server 192.168.177.129:8080 # 被代理服务器的ip地址和端口  &#125;  server &#123;      listen       80;# 默认端口号      server_name  localhost; # 域名或者ip      #charset koi8-r;      #access_log  logs&#x2F;host.access.log  main;      location &#x2F; &#123;           root    data # 默认访问资源目录           proxy_pass   http:&#x2F;&#x2F;tomcat1; # 被代理服务器的的名字作为后面部分          index  index.html index.htm; #默认访问资源文件名      &#125;      #error_page  404              &#x2F;404.html;      # redirect server error pages to the static page &#x2F;50x.html      #      error_page   500 502 503 504  &#x2F;50x.html; # 错误资源      location &#x3D; &#x2F;50x.html &#123;          root   html;      &#125;      # proxy the PHP scripts to Apache listening on 127.0.0.1:80      #      #location ~ \.php$ &#123;      #    proxy_pass   http:&#x2F;&#x2F;127.0.0.1;      #&#125;      # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000      #      #location ~ \.php$ &#123;      #    root           html;      #    fastcgi_pass   127.0.0.1:9000;      #    fastcgi_index  index.php;      #    fastcgi_param  SCRIPT_FILENAME  &#x2F;scripts$fastcgi_script_name;      #    include        fastcgi_params;      #&#125;      # deny access to .htaccess files, if Apache&#39;s document root      # concurs with nginx&#39;s one      #      #location ~ &#x2F;\.ht &#123;      #    deny  all;      #&#125;  &#125;</code></pre><h2 id="配置nginx的负载均衡"><a class="markdownIt-Anchor" href="#配置nginx的负载均衡"></a> 配置Nginx的负载均衡</h2><ul><li>修改<code>nginx.conf</code>的配置文件：</li></ul><pre class="highlight"><code class="conf">  http &#123;    include       mime.types;    default_type  application/octet-stream;    #log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '    #                  '$status $body_bytes_sent &quot;$http_referer&quot; '    #                  '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';    #access_log  logs/access.log  main;    sendfile        on;    #tcp_nopush     on;    #keepalive_timeout  0;    keepalive_timeout  65;    #gzip  on;    #如果配置了多台服务器在这里面，nginx会按照权重值分配对这三台服务器的访问，如果没有设置，则权重值默认为1    upstream tomcats &#123; # tomcats是为被代理服务器自己取的名字       server 192.168.177.129:8080 weight = 2; # 被代理服务器的ip地址和端口       server 192.168.177.129:8081;# 被代理服务器的ip地址和端口       server 192.168.177.129:8082; # 被代理服务器的ip地址和端口    &#125;    server &#123;        listen       80;# 默认端口号        server_name  localhost; # 域名或者ip        #charset koi8-r;        #access_log  logs/host.access.log  main;        location / &#123;             root    data # 默认访问资源目录             proxy_pass   http://tomcats; # 被代理服务器的的名字作为后面部分            index  index.html index.htm; #默认访问资源文件名        &#125;        #error_page  404              /404.html;        # redirect server error pages to the static page /50x.html        #        error_page   500 502 503 504  /50x.html; # 错误资源        location = /50x.html &#123;            root   html;        &#125;        # proxy the PHP scripts to Apache listening on 127.0.0.1:80        #        #location ~ \.php$ &#123;        #    proxy_pass   http://127.0.0.1;        #&#125;        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000        #        #location ~ \.php$ &#123;        #    root           html;        #    fastcgi_pass   127.0.0.1:9000;        #    fastcgi_index  index.php;        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;        #    include        fastcgi_params;        #&#125;        # deny access to .htaccess files, if Apache's document root        # concurs with nginx's one        #        #location ~ /\.ht &#123;        #    deny  all;        #&#125;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux的ssh远程登录</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Linux/Linux%E7%9A%84ssh%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Linux/Linux%E7%9A%84ssh%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="法一windows通过登录工具远程登录linux"><a class="markdownIt-Anchor" href="#法一windows通过登录工具远程登录linux"></a> 法一：Windows通过登录工具远程登录linux</h1><ol><li><p>linux中启动ssh服务</p><ul><li>安装ssh服务：<code>sudo apt-get install openssh-server   </code></li><li>启动ssh服务: <code>sudo /etc/init.d/ssh start  </code></li></ul></li><li><p>windows中安装putty</p></li></ol><ul><li>直接去<a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/">官网</a>下载安装</li></ul><ol start="3"><li>在linux中安装net-tools来查看局域网ip</li></ol><ul><li>使用命令<code>sudo apt-get install net-tools</code>。</li><li>使用命令<code>ifconfig</code>来查看ip。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201007114241.jpg" alt="" /></li></ul><ol start="4"><li>启动putty<ul><li>在putty中输入局域网IP</li><li>之后开启一个黑色终端界面，在里面输入用户名和密码，连接到linux。<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201007115016.jpg" alt="" /></li></ul></li></ol><h1 id="法二ssh通过账号密码登录远程linux服务器"><a class="markdownIt-Anchor" href="#法二ssh通过账号密码登录远程linux服务器"></a> 法二：ssh通过账号密码登录远程linux服务器</h1><ul><li><code>ssh 账号@服务器地址</code>,如：<code>ssh zhangjie@106.14.197.71</code></li><li>前提是双方的ssh服务都启动。</li></ul><h1 id="法三使用公钥ssh远程登录到linux"><a class="markdownIt-Anchor" href="#法三使用公钥ssh远程登录到linux"></a> 法三：使用公钥ssh远程登录到linux</h1><ul><li>不用输入密码即可登录，可应用于自动登录。</li><li>在客户端中使用<code>ssh-keygen</code>来生成ssh秘钥和公钥</li><li>将公钥部署到linux服务器上去。命令为<code>ssh-copy-id -i ~/.ssh/id_rsa.pub  root@111.111.111.111</code></li><li>在客户端中使用<code>ssh root@111.111.111.111 -p 22</code>即可登录linux服务器。<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201007172656.jpg" alt="" /></li></ul><h1 id="查看linux的网络情况"><a class="markdownIt-Anchor" href="#查看linux的网络情况"></a> 查看linux的网络情况</h1><ul><li>使用<code>ifconfig</code>命令可以查看本机的网络情况。<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201007115709.jpg" alt="" /></li></ul><h1 id="top查看工具"><a class="markdownIt-Anchor" href="#top查看工具"></a> top查看工具</h1><ul><li>top 工具是我们常用的一个查看工具，能实时的查看我们系统的一些关键信息的变化。</li></ul><ul><li>top 是一个在前台执行的程序，所以执行后便进入到这样的一个交互界面，正是因为交互界面我们才可以实时的获取到系统与进程的信息。在交互界面中我们可以通过一些指令来操作和筛选。</li><li>常用交互命令：</li></ul><table><thead><tr><th>常用交互命令</th><th>解释</th></tr></thead><tbody><tr><td>q</td><td>退出程序</td></tr><tr><td>I</td><td>切换显示平均负载和启动时间的信息</td></tr><tr><td>P</td><td>根据 CPU 使用百分比大小进行排序</td></tr><tr><td>M</td><td>根据驻留内存大小进行排序</td></tr><tr><td>i</td><td>忽略闲置和僵死的进程，这是一个开关式命令</td></tr><tr><td>k</td><td>终止一个进程，系统提示输入 PID 及发送的信号值。一般终止进程用 15 信号，不能正常结束则使用 9 信号。安全模式下该命令被屏蔽。</td></tr></tbody></table><ul><li>示例：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200715105949.jpg" alt="img" /></li><li>top 显示的第一排，</li></ul><table><thead><tr><th>内容</th><th>解释</th></tr></thead><tbody><tr><td>top</td><td>表示当前程序的名称</td></tr><tr><td>10:59:28</td><td>表示当前的系统的时间</td></tr><tr><td>up 7 :06</td><td>表示该机器已经启动了多长时间</td></tr><tr><td>1 user</td><td>表示当前系统中只有一个用户</td></tr><tr><td>load average: 0.00,0.00,0.00</td><td>分别对应 1、5、15 分钟内 cpu 的平均负载</td></tr></tbody></table><ul><li>top 的第二行数据，基本上第二行是进程的一个情况统计</li></ul><table><thead><tr><th>内容</th><th>解释</th></tr></thead><tbody><tr><td>Tasks: 384 total</td><td>进程总数</td></tr><tr><td>1 running</td><td>1 个正在运行的进程数</td></tr><tr><td>383 sleeping</td><td>383 个睡眠的进程数</td></tr><tr><td>0 stopped</td><td>没有停止的进程数</td></tr><tr><td>0 zombie</td><td>没有僵尸进程数</td></tr></tbody></table><ul><li>top 的第三行数据，这一行基本上是 CPU 的一个使用情况的统计了</li></ul><table><thead><tr><th>内容</th><th>解释</th></tr></thead><tbody><tr><td>Cpu(s): 0.1 us</td><td>用户空间进程占用 CPU 百分比</td></tr><tr><td>0.2 sy</td><td>内核空间运行占用 CPU 百分比</td></tr><tr><td>0.0 ni</td><td>用户进程空间内改变过优先级的进程占用 CPU 百分比</td></tr><tr><td>99.7 id</td><td>空闲 CPU 百分比</td></tr><tr><td>0.0 wa</td><td>等待输入输出的 CPU 时间百分比</td></tr><tr><td>0.0 hi</td><td>硬中断(Hardware IRQ)占用 CPU 的百分比</td></tr><tr><td>0.0 si</td><td>软中断(Software IRQ)占用 CPU 的百分比</td></tr><tr><td>0.0 st</td><td>(Steal time) 是 hypervisor 等虚拟服务中，虚拟 CPU 等待实际 CPU 的时间的百分比</td></tr></tbody></table><ul><li>top 的第四行数据，这一行基本上是内存的一个使用情况的统计了：</li></ul><table><thead><tr><th>内容</th><th>解释</th></tr></thead><tbody><tr><td>3908.4 total</td><td>物理内存总量</td></tr><tr><td>436.1 free</td><td>空闲内存总量</td></tr><tr><td>1253.8 used</td><td>使用的物理内存总量</td></tr><tr><td>2218.6 buff/cache</td><td>用作内核缓存的内存量</td></tr></tbody></table><ul><li>top 的第五行数据，这一行基本上是交换区的一个使用情况的统计了</li></ul><table><thead><tr><th>内容</th><th>解释</th></tr></thead><tbody><tr><td>2048.0 total</td><td>交换区总量</td></tr><tr><td>2048.0 free</td><td>空闲交换区总量</td></tr><tr><td>0.0 used</td><td>使用的交换区总量</td></tr><tr><td>2379.4 avail Mem</td><td>缓冲的交换区总量,内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖</td></tr></tbody></table><ul><li>再下面就是进程的一个情况了</li></ul><table><thead><tr><th>列名</th><th>解释</th></tr></thead><tbody><tr><td>PID/进程号</td><td>进程 id</td></tr><tr><td>USER</td><td>该进程的所属用户</td></tr><tr><td>PR</td><td>该进程执行的优先级 priority 值</td></tr><tr><td>NI</td><td>该进程的 nice 值</td></tr><tr><td>VIRT</td><td>该进程任务所使用的虚拟内存的总数</td></tr><tr><td>RES</td><td>该进程所使用的物理内存数，也称之为驻留内存数</td></tr><tr><td>SHR</td><td>该进程共享内存的大小</td></tr><tr><td>S</td><td>该进程进程的状态: S=sleep R=running Z=zombie</td></tr><tr><td>%CPU</td><td>该进程 CPU 的利用率</td></tr><tr><td>%MEM</td><td>该进程内存的利用率</td></tr><tr><td>TIME+</td><td>该进程活跃的总时间</td></tr><tr><td>COMMAND</td><td>该进程运行的名字</td></tr></tbody></table><ul><li>注意：<ul><li>NICE 值叫做静态优先级，是用户空间的一个优先级值，其取值范围是-20 至 19。这个值越小，表示进程”优先级”越高，而值越大“优先级”越低。nice 值中的 -20 到 19，中 -20 优先级最高， 0 是默认的值，而 19 优先级最低。</li><li>PR 值表示 Priority 值叫动态优先级，是进程在内核中实际的优先级值，进程优先级的取值范围是通过一个宏定义的，这个宏的名称是 MAX_PRIO，它的值为 140。Linux 实际上实现了 140 个优先级范围，取值范围是从 0-139，这个值越小，优先级越高。而这其中的 0 - 99 是实时进程的值，而 100 - 139 是给用户的。其中 PR 中的 100 to 139 值部分有这么一个对应 PR = 20 + (-20 to +19)，这里的 -20 to +19 便是 nice 值，所以说两个虽然都是优先级，而且有千丝万缕的关系，但是他们的值，他们的作用范围并不相同</li><li>VIRT 任务所使用的虚拟内存的总数，其中包含所有的代码，数据，共享库和被换出 swap 空间的页面等所占据空间的总数</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>junit单元测试</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Java/junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Java/junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="junit简介"><a class="markdownIt-Anchor" href="#junit简介"></a> junit简介</h1><ul><li>JUnit 是一个 Java 编程语言的单元测试框架。JUnit 在测试驱动的开发方面有很重要的发展，是起源于 JUnit 的一个统称为 xUnit 的单元测试框架之一。</li></ul><h1 id="在idea中配置junit"><a class="markdownIt-Anchor" href="#在idea中配置junit"></a> 在IDEA中配置junit</h1><ul><li>安装JUnit Generator V2.0插件。<code>File--&gt;settings--&gt;Plguins</code>.</li></ul><h1 id="junit的基本使用"><a class="markdownIt-Anchor" href="#junit的基本使用"></a> junit的基本使用</h1><ul><li><p>测试方法必须使用 <code>@Test</code> 修饰</p></li><li><p>测试方法必须使用<code>public void</code>进行修饰，<strong>不能带参数</strong></p></li><li><p>一般使用单元测试会新建一个<strong>test 目录存放测试代码</strong>，在生产部署的时候只需要将 test 目录下代码删除即可</p></li><li><p>测试单元中的每个方法必须可以<strong>独立测试</strong>，方法间不能有任何依赖</p></li><li><p>测试类一般使用 <strong>Test 作为类名的后缀</strong></p></li><li><p>测试方法使一般用<strong>test 作为方法名的前缀</strong></p><h2 id="常用注解"><a class="markdownIt-Anchor" href="#常用注解"></a> 常用注解</h2></li><li><p>@Test:将一个普通方法修饰成一个<strong>测试方法</strong>.</p></li><li><p>@Before：会在每一个测试方法被<strong>运行前</strong>执行一次</p></li><li><p>@After：会在每一个测试方法<strong>运行后</strong>被执行一次</p></li><li><p>@Ignore：所修饰的测试方法会被测试运行器忽略.</p></li></ul><h2 id="基本调用方法"><a class="markdownIt-Anchor" href="#基本调用方法"></a> 基本调用方法</h2><ul><li>在需要测试的类中，使用<code>alt + insert</code>可以调用出一个窗口，在这个窗口中点击junit即可。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Junit </tag>
            
            <tag> Java </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-链表</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/LeetCode-%E9%93%BE%E8%A1%A8/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/LeetCode-%E9%93%BE%E8%A1%A8/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-删除中间结点-面试题0203"><a class="markdownIt-Anchor" href="#1-删除中间结点-面试题0203"></a> 1. 删除中间结点 面试题02.03</h1><ul><li>题目：</li></ul><hr /><p>实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。</p><p>示例：</p><p>输入：单向链表a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f中的节点c<br />结果：不返回任何数据，但该链表变为a-&gt;b-&gt;d-&gt;e-&gt;f</p><ul><li>java解法</li></ul><hr /><ul><li>因为只知道当前结点以及这个结点之后的所有结点，所以无法直接删除当前结点。</li><li>可以将当前结点后的一个结点的值赋给当前结点，然后删除之后的结点，达到删除当前结点的等效效果。（我变成你，再杀了你，就相当于杀了我自己）。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">class ListNode &#123;    int val;    ListNode next;    ListNode(int x) &#123;        val &#x3D; x;    &#125;&#125;class Solution &#123;    public  void deleteNode(ListNode node) &#123;        node.val &#x3D; node.next.val;        node.next &#x3D; node.next.next;    &#125;    public static void main(String[] args) &#123;        ListNode node1 &#x3D; new ListNode(1);        ListNode node2 &#x3D; new ListNode(2);        ListNode node3 &#x3D; new ListNode(3);        ListNode node4 &#x3D; new ListNode(4);        ListNode node5 &#x3D; new ListNode(5);        node1.next &#x3D; node2;        node2.next &#x3D; node3;        node3.next &#x3D; node4;        node4.next &#x3D; node5;        node5.next &#x3D; null;        System.out.print(node1.val);        for(ListNode node &#x3D; node2; node !&#x3D; null; node &#x3D; node.next) &#123;            System.out.print(&quot;-&gt;&quot;+node.val);        &#125;        System.out.println();        Solution solution &#x3D; new Solution();        solution.deleteNode(node3);        System.out.print(node1.val);        for(ListNode node &#x3D; node2; node !&#x3D; null; node &#x3D; node.next) &#123;            System.out.print(&quot;-&gt;&quot;+node.val);        &#125;    &#125;&#125;</code></pre><h1 id="2-二进制链表转整数-1290"><a class="markdownIt-Anchor" href="#2-二进制链表转整数-1290"></a> 2. 二进制链表转整数 1290</h1><ul><li>题目</li></ul><hr /><p>给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。</p><p>请你返回该链表所表示数字的 十进制值 。</p><p></p><p>示例 1：</p><p>输入：head = [1,0,1]<br />输出：5<br />解释：二进制数 (101) 转化为十进制数 (5)</p><ul><li>java解法</li></ul><hr /><ul><li>法一：<ul><li>根据数字读取顺序确定对应位的权重</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;public class BtoD  &#123;    public int binaryToDecimal(SinglyLinkedList head) &#123;        int nums &#x3D; 0;        int result &#x3D; 0;        int temp &#x3D; 0;        int index &#x3D; 1;        SinglyLinkedList node &#x3D; head;        for( nums &#x3D; 0; node !&#x3D; null; node &#x3D; node.next, nums++);        node &#x3D; head;        for(; node !&#x3D; null; ) &#123;            temp &#x3D; nums; &#x2F;&#x2F;数字是第几位            &#x2F;&#x2F;算出对应位的权重            for(index &#x3D; 1; temp - 1 &gt; 0; temp--) &#123;                index *&#x3D; 2;            &#125;            result +&#x3D; index * node.val;            node &#x3D; node.next;            nums--;        &#125;        return result;    &#125;    public static void main(String[] args) &#123;        Scanner in &#x3D; new Scanner(System.in);        System.out.println(&quot;请输入一串二进制数字，以-1结束：&quot;);        int temp &#x3D; in.nextInt();        SinglyLinkedList fnode  &#x3D; new SinglyLinkedList(temp);        SinglyLinkedList head &#x3D; fnode; &#x2F;&#x2F;保存头结点        temp &#x3D; in.nextInt();        while (temp !&#x3D; -1) &#123;            SinglyLinkedList lnode &#x3D; new SinglyLinkedList(temp);            fnode.next &#x3D; lnode;            fnode &#x3D; lnode; &#x2F;&#x2F;使当前结点始终为链表末尾的结点            temp &#x3D; in.nextInt();        &#125;        BtoD converse &#x3D; new BtoD();        System.out.println(&quot;十进制的结果为：&quot; + converse.binaryToDecimal(head));    &#125;&#125;</code></pre><ul><li>法二：<ul><li>使用ArrayList，将链表中的数字依次存入集合中，再根据集合的索引确定对应位的权重</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">class ListNode &#123;    int val;    ListNode next;    ListNode(int x) &#123;        val &#x3D; x;    &#125;&#125;class Solution &#123;    public int getDecimalValue(ListNode head) &#123;        ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;Integer&gt;();        &#x2F;&#x2F;存入集合        for(ListNode node &#x3D; head; node !&#x3D; null; node &#x3D; node.next) &#123;            list.add(node.val);        &#125;        int n &#x3D; list.toArray().length - 1;        int decimalValue &#x3D; 0;                &#x2F;&#x2F;确定对应位权重并计算出结果        for(int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123;            decimalValue +&#x3D; list.get(i) * (int)Math.pow(2,n - i);        &#125;        return  decimalValue;    &#125;    public static void main(String[] args) &#123;            ListNode node1 &#x3D; new ListNode(1);            ListNode node2 &#x3D; new ListNode(0);            ListNode node3 &#x3D; new ListNode(1);            node1.next &#x3D; node2;            node2.next &#x3D; node3;            node3.next &#x3D; null;            Solution solution &#x3D; new Solution();            System.out.println(solution.getDecimalValue(node1));    &#125;&#125;</code></pre><ul><li>法三：使用位运算<ul><li>当一个数进行左移或右移时候(每左移一位相当于乘上了一个2），如果是正数的情况下，空位补0，如：10 左移一位置，那么就变成 100，利用这个性质，结合这个题目，我们可知道如果将位移后出现的空位再加上我们所获得的值，就可以计算出对应的十进制。</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int getDecimalValue(ListNode head) &#123;    int sum &#x3D; 0;    for(ListNode node &#x3D; head; node !&#x3D; null; node &#x3D; node.next) &#123;        sum &#x3D; (sum &lt;&lt; 1) + node.val;    &#125;    return  sum;&#125;</code></pre><h1 id="3-链表中倒数第k个结点-剑指-offer-22"><a class="markdownIt-Anchor" href="#3-链表中倒数第k个结点-剑指-offer-22"></a> 3. 链表中倒数第k个结点 剑指 Offer 22</h1><ul><li>题目：</li></ul><hr /><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><p></p><p>示例：</p><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</p><p>返回链表 4-&gt;5.</p><ul><li>Java解法</li></ul><hr /><ul><li>法一：数出链表的总结点个数，然后推出正序的排名。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static int kthtoLast(SinglyLinkedList head, int k) &#123;        int nums &#x3D; 1;        SinglyLinkedList node &#x3D; head;                &#x2F;&#x2F;得出当前链表的总结点个数        while (node.next !&#x3D; null) &#123;             node &#x3D; node.next;            nums++;        &#125;        int index &#x3D; nums - k + 1; &#x2F;&#x2F;根据逆序排名得出正序排名                &#x2F;&#x2F;找到要求的结点        node &#x3D; head;        for (int i &#x3D; 1; i &lt; index; i++) &#123;            node &#x3D; node.next;        &#125;        return node.val;    &#125;</code></pre><p>测试代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) &#123;        Scanner in &#x3D; new Scanner(System.in);        System.out.println(&quot;请输入一串数字，以-1结束：&quot;);        SinglyLinkedList head &#x3D; new SinglyLinkedList();        KthtoLast.getIn(head);        System.out.println(&quot;输入要返回倒数第几个数：&quot;);        int k &#x3D; in.nextInt();        KthtoLast reverse &#x3D; new KthtoLast();        System.out.println(&quot;结果为: &quot; + reverse.kthtoLast(head, k));    &#125;&#125;</code></pre><ul><li>法二：使用ArrayList来记录链表中节点的相对位置。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">class ListNode &#123;    int val;    ListNode next;    ListNode(int x) &#123;        val &#x3D; x;    &#125;&#125;class Solution &#123;    public ListNode getKthFromEnd(ListNode head, int k) &#123;        ArrayList&lt;ListNode&gt; list &#x3D; new ArrayList&lt;&gt;();        for(ListNode node &#x3D; head; node !&#x3D; null; node &#x3D; node.next) &#123;            list.add(node);        &#125;        int n &#x3D; list.toArray().length - k;        return list.get(n);    &#125;    public static void main(String[] args) &#123;        ListNode head &#x3D; new ListNode(1);        ListNode node1 &#x3D; head;        for(int i &#x3D; 2; i &lt;&#x3D; 6; i++) &#123;            ListNode node &#x3D; new ListNode(i);            node1.next &#x3D; node;            node1 &#x3D; node1.next;        &#125;        Solution solution &#x3D; new Solution();        ListNode node &#x3D; solution.getKthFromEnd(head,3);        System.out.println(node.val);    &#125;&#125;</code></pre><ul><li>法三：<ul><li>若只遍历一次，可使用两个指针，第一个指针先走k-1步，之后第二个指针再跟上，始终保持k-1步的距离，这样当第一个指针遍历完成时，第二个指针所在就是倒数第K个节点。</li><li>注意代码鲁棒性：<ol><li>链表为空</li><li>链表节点少于K</li><li>k为零</li></ol></li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">class ListNode &#123;    int val;    ListNode next;    ListNode()&#123;&#125;;    ListNode(int x) &#123;        val &#x3D; x;    &#125;&#125;class Solution &#123;    public ListNode getKthFromEnd(ListNode head, int k) &#123;        int i &#x3D; 0;        ListNode slow &#x3D; head;        for(ListNode fast &#x3D; head; fast.next !&#x3D; null; fast &#x3D; fast.next) &#123;            i++;            if(i &gt; k - 1) &#123;                slow &#x3D; slow.next;            &#125;        &#125;        return  slow;    &#125;    public static void main(String[] args) &#123;        ListNode head &#x3D; new ListNode(1);        ListNode node1 &#x3D; head;        for(int i &#x3D; 2; i &lt;&#x3D; 6; i++) &#123;            ListNode node &#x3D; new ListNode(i);            node1.next &#x3D; node;            node1 &#x3D; node1.next;        &#125;        Solution solution &#x3D; new Solution();        ListNode node &#x3D; solution.getKthFromEnd(head,3);        System.out.println(node.val);    &#125;&#125;</code></pre><h1 id="4-从尾到头打印链表-剑指offer-06"><a class="markdownIt-Anchor" href="#4-从尾到头打印链表-剑指offer-06"></a> 4. 从尾到头打印链表 剑指offer 06.</h1><ul><li>题目：</li></ul><hr /><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1,3,2]输出：[2,3,1]</code></pre><ul><li><p>Java解法</p><hr /></li><li><p>法一：</p><ul><li>每次遍历到相对的最后一个结点，通过一个计数变量来判断是否到达了最后一个结点。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"> public static int[] reversePrint(SinglyLinkedList head) &#123;         SinglyLinkedList node &#x3D; new SinglyLinkedList();         int nums &#x3D; 1;         int i &#x3D; 0;         node &#x3D; head;          &#x2F;&#x2F;计算链表中有多少个元素         &#x2F;&#x2F;注意判断链表为空的情况         if(node &#x3D;&#x3D; null)&#123;             nums &#x3D; 0;         &#125;         else &#123;             while (node.next !&#x3D; null) &#123;                 node &#x3D; node.next;                 nums++;             &#125;         &#125;          int[] result &#x3D; new int[nums];          node &#x3D; head;          if(nums &#x3D;&#x3D; 0) &#123;             return result;&#x2F;&#x2F;当链表为空时直接返回一个空数组         &#125;         else &#123;             do &#123;                 &#x2F;&#x2F;每次从第一个结点开始遍历到最后一个结点，将最后一个结点的值存入数组中                 &#x2F;&#x2F;如果有三个数，只需循环两次便可达到最后一个结点                 for(int j &#x3D; 1; j &lt; nums; j++) &#123;                     node &#x3D; node.next;                 &#125;                 result[i] &#x3D; node.val;                 node &#x3D; head;                 i++;                 &#x2F;&#x2F;将链表的长度减一，表示最后一个结点已经被输出了                 nums--;             &#125; while(nums !&#x3D; 0);              return result;         &#125; &#125; &#x2F;&#x2F;测试代码 @Test public void testReversePrint() throws Exception &#123;     &#x2F;&#x2F;设置测试链表为｛1， 3， 2｝     SinglyLinkedList head &#x3D; new  SinglyLinkedList();     head.val &#x3D; 1;     SinglyLinkedList node1 &#x3D; new SinglyLinkedList();     head.next &#x3D; node1;     node1.val&#x3D; 3;     SinglyLinkedList node2 &#x3D; new SinglyLinkedList();   node2.val &#x3D; 2;    node1.next &#x3D; node2;    int[] result &#x3D; new int[3];    result &#x3D; SinglyLinkedList.reversePrint(head);    &#x2F;&#x2F;预期结果为｛2，3，1｝    int[] exp &#x3D; &#123;2, 3, 1&#125;;    &#x2F;&#x2F;断言判断结果是否为｛2， 3，1｝    Assert.assertArrayEquals(result, exp);&#125; </code></pre></li><li><p>法二：先获取链表的长度，再使用一个定长的数组，但是对数组的赋值是从逆向开始的。这样避免了对链表的逆转。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">class ListNode &#123;    int val;    ListNode next;    ListNode(int x) &#123;        val &#x3D; x;    &#125;&#125;class Solution &#123;    public int[] reversePrint(ListNode head) &#123;        int n &#x3D; 0;        for(ListNode node &#x3D; head; node !&#x3D; null; node &#x3D; node.next) &#123;            n++;        &#125;        int[] result &#x3D; new int[n];        ListNode node &#x3D; head;        for(int t &#x3D; n; t &gt; 0; t--) &#123;            result[t - 1] &#x3D; node.val;            node &#x3D; node.next;        &#125;        return result;    &#125;    public static void main(String[] args) &#123;        ListNode head &#x3D; new ListNode(1);        ListNode node1 &#x3D; head;        for(int i &#x3D; 2; i &lt;&#x3D; 6; i++) &#123;            ListNode node &#x3D; new ListNode(i);            node1.next &#x3D; node;            node1 &#x3D; node1.next;        &#125;        Solution solution &#x3D; new Solution();        int[] result &#x3D; solution.reversePrint(head);        for(int i : result) &#123;            System.out.println(i);        &#125;    &#125;&#125;</code></pre><ul><li>法三：使用栈,利用栈的先进后出特性，将压入栈的元素自然弹出，就达到来逆序的效果</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">class ListNode &#123;    int val;    ListNode next;    ListNode(int x) &#123;        val &#x3D; x;    &#125;&#125;class Solution &#123;    public int[] reversePrint(ListNode head) &#123;        Stack&lt;ListNode&gt; stack &#x3D; new Stack&lt;&gt;();        for(ListNode node &#x3D; head; node !&#x3D; null; node &#x3D; node.next) &#123;            stack.push(node);        &#125;        int n &#x3D; stack.size();        int[] result &#x3D; new int[n];        for(int i &#x3D; 0; i &lt; n; i++) &#123;            result[i] &#x3D; stack.pop().val;        &#125;        return result;    &#125;    public static void main(String[] args) &#123;        ListNode head &#x3D; new ListNode(1);        ListNode node1 &#x3D; head;        for(int i &#x3D; 2; i &lt;&#x3D; 6; i++) &#123;            ListNode node &#x3D; new ListNode(i);            node1.next &#x3D; node;            node1 &#x3D; node1.next;        &#125;        Solution solution &#x3D; new Solution();        int[] result &#x3D; solution.reversePrint(head);        for(int i : result) &#123;            System.out.println(i);        &#125;    &#125;&#125;</code></pre><ul><li>法四：使用ArrayList集合记录链表中的节点，再反向遍历该集合，将值存到数组中。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">class ListNode &#123;    int val;    ListNode next;    ListNode(int x) &#123;        val &#x3D; x;    &#125;&#125;class Solution &#123;    public int[] reversePrint(ListNode head) &#123;        ArrayList&lt;ListNode&gt; list &#x3D; new ArrayList&lt;&gt;();        for(ListNode node &#x3D; head; node !&#x3D; null; node &#x3D; node.next) &#123;            list.add(node);        &#125;        int[] result &#x3D; new int[list.toArray().length];        int j &#x3D; 0;        for(int i &#x3D; list.toArray().length - 1; i &gt;&#x3D; 0; i--) &#123;            result[j] &#x3D; list.get(i).val;            j++;        &#125;        return result;    &#125;    public static void main(String[] args) &#123;        ListNode head &#x3D; new ListNode(1);        ListNode node1 &#x3D; head;        for(int i &#x3D; 2; i &lt;&#x3D; 6; i++) &#123;            ListNode node &#x3D; new ListNode(i);            node1.next &#x3D; node;            node1 &#x3D; node1.next;        &#125;        Solution solution &#x3D; new Solution();        int[] result &#x3D; solution.reversePrint(head);        for(int i : result) &#123;            System.out.println(i);        &#125;    &#125;&#125;</code></pre><h1 id="5-移除重复节点-面试题0201"><a class="markdownIt-Anchor" href="#5-移除重复节点-面试题0201"></a> 5. 移除重复节点 面试题02.01</h1><ul><li><p>题目</p><hr /><p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p><p>示例1:</p><p>输入：[1, 2, 3, 3, 2, 1]<br />输出：[1, 2, 3]</p></li><li><p>Java解法</p><hr /><ul><li>法一：<ul><li>将链表中的元素在逐个遍历时存入一个数组中，在遍历时进行比对，如果出现相同元素值，则跳过该元素</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;删除链表中重复结点的方法    public SinglyLinkedList removeDuplicateNodes(SinglyLinkedList head) &#123;        SinglyLinkedList node &#x3D; head;        int nums &#x3D; 0;        &#x2F;&#x2F;计算链表中元素的个数        while(node !&#x3D; null) &#123;            node &#x3D; node.next;            nums++;        &#125;        &#x2F;&#x2F;注意排除链表为一个空链表的情形（即head为一个null）        if(nums &#x3D;&#x3D; 0) &#123;            return head;        &#125;        &#x2F;&#x2F;用于储存已经读出的元素值的数组        int[] temp &#x3D; new int[nums];        int i &#x3D; 0;        int j &#x3D; 0;        &#x2F;&#x2F;遍历数组并跳过重复结点,将遍历的结果存入数组中        node &#x3D; head;        while(node !&#x3D; null) &#123;            if(i &#x3D;&#x3D; 0) &#123;                temp[i] &#x3D; node.val;                node &#x3D; node.next;                i++;            &#125;            else &#123;                for( j &#x3D; i - 1; j &gt;&#x3D; 0; j--) &#123;                    if(node.val &#x3D;&#x3D; temp[j]) &#123;                        node &#x3D; node.next;                        nums--;                        break;                    &#125;                &#125;                if(j &gt;&#x3D; 0) &#123;                    continue;                &#125;                else &#123;                    temp[i] &#x3D; node.val;                    node &#x3D; node.next;                    i++;                &#125;            &#125;        &#125;        &#x2F;&#x2F;将数组中的结果重新存入链表中        node &#x3D; head;        for(i &#x3D; 0; i &lt; nums - 1; i++) &#123;            node.val &#x3D; temp[i];            node &#x3D; node.next;        &#125;        &#x2F;&#x2F;最后一个结点需要单独赋值，因为需要将它的next设为null        node.val &#x3D; temp[nums - 1];        node.next &#x3D; null;        return head;    &#125;&#x2F;&#x2F;测试用例&#x2F;** * * Method:  removeDuplicateNodes(SinglyLinkedList head) * *&#x2F;@Testpublic void testRemoveDuplicateNodes() throws Exception &#123;    &#x2F;&#x2F;创建测试链表为｛1，2，3， 3， 2，1｝    SinglyLinkedList head &#x3D; new  SinglyLinkedList();    head.val &#x3D; 1;    SinglyLinkedList node1 &#x3D; new SinglyLinkedList();    head.next &#x3D; node1;    node1.val&#x3D; 2;    SinglyLinkedList node2 &#x3D; new SinglyLinkedList();    node2.val &#x3D; 3;    node1.next &#x3D; node2;    SinglyLinkedList node3 &#x3D; new SinglyLinkedList();    node3.val &#x3D; 3;    node2.next &#x3D; node3;    SinglyLinkedList node4 &#x3D; new SinglyLinkedList();    node4.val &#x3D; 2;    node3.next &#x3D; node4;    SinglyLinkedList node5 &#x3D; new SinglyLinkedList();    node5.val &#x3D; 1;    node4.next &#x3D; node5;    head &#x3D; head.removeDuplicateNodes(head);    SinglyLinkedList node &#x3D; head;    int nums &#x3D; 0;    &#x2F;&#x2F;计算链表中元素的个数    while(node !&#x3D; null) &#123;        node &#x3D; node.next;        nums++;    &#125;    &#x2F;&#x2F;用于储存读出的元素值的数组    int[] temp &#x3D; new int[nums];    int i &#x3D; 0;    int j &#x3D; 0;    &#x2F;&#x2F;遍历数组,将遍历的结果存入数组中    node &#x3D; head;    while(node !&#x3D; null) &#123;        temp[i] &#x3D; node.val;        node &#x3D; node.next;        i++;    &#125;    &#x2F;&#x2F;预期结果    int[] exp &#x3D; &#123;1, 2, 3&#125;;    Assert.assertArrayEquals(temp, exp);&#125;</code></pre><ul><li>法二：<ul><li>将已经出现的元素值存入ArrayList集合中，设置双指针，遍历集合，当出现重复元素时，利用双指针跳过当前节点。</li></ul></li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">class ListNode &#123;    int val;    ListNode next;    ListNode(int x) &#123;        val &#x3D; x;    &#125;&#125;class Solution &#123;    public ListNode removeDuplicateNodes(ListNode head) &#123;        ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();        ListNode front &#x3D; head;        ListNode cur &#x3D; head;        OUT:        while(cur !&#x3D; null) &#123;            for(int i : list) &#123;                if(i &#x3D;&#x3D; cur.val) &#123;                    &#x2F;&#x2F;如果是重复元素，保持front指针不动，只移动当前元素指针cur                    front.next &#x3D; cur.next;                    cur &#x3D; cur.next;                    continue OUT;                &#125;            &#125;            list.add(cur.val);            front &#x3D; cur;            cur &#x3D; cur.next;        &#125;        return  head;    &#125;    public static void main(String[] args) &#123;        ListNode node1 &#x3D; new ListNode(1);        ListNode node2 &#x3D; new ListNode(2);        ListNode node3 &#x3D; new ListNode(3);        ListNode node4 &#x3D; new ListNode(3);        ListNode node5 &#x3D; new ListNode(2);        ListNode node6 &#x3D; new ListNode(1);        node1.next &#x3D; node2;        node2.next &#x3D; node3;        node3.next &#x3D; node4;        node4.next &#x3D; node5;        node5.next &#x3D; node6;        node6.next &#x3D; null;        Solution solution &#x3D; new Solution();        solution.removeDuplicateNodes(node1);        for(ListNode node &#x3D; node1; node !&#x3D; null; node &#x3D; node.next) &#123;            System.out.println(node.val);        &#125;    &#125;&#125;</code></pre><ul><li>法三：<ul><li>哈希表:思路与法二类似，只是哈希表不能存储重复元素，判断无需遍历，速度提升。</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public ListNode removeDuplicateNodes(ListNode head) &#123;         if (head &#x3D;&#x3D; null) &#123;            return head;        &#125;        Set&lt;Integer&gt; occurred &#x3D; new HashSet&lt;Integer&gt;();        occurred.add(head.val);        ListNode pos &#x3D; head;        &#x2F;&#x2F; 枚举前驱节点        while (pos.next !&#x3D; null) &#123;            &#x2F;&#x2F; 当前待删除节点            ListNode cur &#x3D; pos.next;            if (occurred.add(cur.val)) &#123;                pos &#x3D; pos.next;            &#125; else &#123;                pos.next &#x3D; pos.next.next;            &#125;        &#125;        pos.next &#x3D; null;        return head;    &#125;&#125;</code></pre><h1 id="6-反转链表-206"><a class="markdownIt-Anchor" href="#6-反转链表-206"></a> 6. 反转链表 206</h1><ul><li><a href="https://leetcode-cn.com/problems/reverse-linked-list/">题目</a></li></ul><hr /><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p><p>示例1:<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/igLWdV.jpg" alt="igLWdV" /></p><pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1,2,3,4,5]输出：[5,4,3,2,1]</code></pre><p>示例2:<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/HOrmk9.jpg" alt="HOrmk9" /></p><pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1,2]输出：[2,1]</code></pre><p>示例3:</p><pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; []输出：[]</code></pre><p>提示：<br />链表中节点的数目范围是<code> [0, 5000]</code><br /><code>-5000 &lt;= Node.val &lt;= 5000</code></p><h2 id="java解法"><a class="markdownIt-Anchor" href="#java解法"></a> Java解法</h2><ul><li>法一：迭代遍历法。从头遍历每个节点，并记录当前节点的前一节点和后一节点，然后使当前节点的next指向前一节点，然后当前节点移动到后一节点，直到当前节点为空。<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/jBZsRi.png" alt="jBZsRi" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ReverseLinkedList206 &#123;    public ListNode reverseList(ListNode head) &#123;        &#x2F;&#x2F;定义前一节点和后一节点        ListNode pre &#x3D; null; &#x2F;&#x2F; pre开始为null，因为head之前没有节点        ListNode next;        while(head !&#x3D; null) &#123;            &#x2F;&#x2F;记录当前节点的下一节点            next &#x3D; head.next;            &#x2F;&#x2F;当前节点的下一节点变为pre            head.next &#x3D; pre;            &#x2F;&#x2F;同时移动当前节点和对应的前一节点到下一节点            pre &#x3D; head;            head &#x3D; next;        &#125;        &#x2F;&#x2F;最后返回pre        &#x2F;&#x2F;因为，head此时指向空，pre是其前一位正好指向原链表的最后一节点，即新链表的头节点        return pre;    &#125;&#125;</code></pre><ul><li>法二：递归的思想。逆向思考，假设当前节点的之后的节点都已经完成的反转，每一次递归只要考虑当前节点和之后已经反转好的链表之间的反向连接问题即可，每一次递归返回已经完成反转连接的当前节点。<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/SeBJuw.png" alt="SeBJuw" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ReverseLinkedList206 &#123;    &#x2F;**     * 递归解法     * @param head     * @return     *&#x2F;    public ListNode reverseList(ListNode head) &#123;        &#x2F;&#x2F;当当前节点或其下一节点为null时返回        if(head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) &#123;            return head;        &#125;        &#x2F;&#x2F;逆向考虑，每次调用本方法说明当前节点的前面节点都已经完成了反转        &#x2F;&#x2F;现在只需将当前节点和前面反转好的链表反向连接好就行        ListNode nextHead &#x3D; reverseList1(head.next);        head.next.next &#x3D; head;        &#x2F;&#x2F;因为是逆向思考，所以反转后当前节点的下一节点始终为null，前面的情况并不清楚        head.next &#x3D; null;        return nextHead;&#125;</code></pre><h1 id="7-合并两个有序链表-21"><a class="markdownIt-Anchor" href="#7-合并两个有序链表-21"></a> 7. 合并两个有序链表 21</h1><ul><li><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">题目</a></li></ul><hr /><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br />示例1:<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/Ohem7h.jpg" alt="Ohem7h" /></p><pre class="line-numbers language-none"><code class="language-none">输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]输出：[1,1,2,3,4,4]</code></pre><p>示例2:</p><pre class="line-numbers language-none"><code class="language-none">输入：l1 &#x3D; [], l2 &#x3D; []输出：[]</code></pre><p>示例3:</p><pre class="line-numbers language-none"><code class="language-none">输入：l1 &#x3D; [], l2 &#x3D; [0]输出：[0]</code></pre><p>提示：<br />两个链表的节点数目范围是 <code>[0, 50]</code><br /><code>-100 &lt;= Node.val &lt;= 100</code><br />l1 和 l2 均按 非递减顺序 排列</p><h2 id="java解法-2"><a class="markdownIt-Anchor" href="#java解法-2"></a> Java解法</h2><ul><li>法一：非递归解法。遍历两个链表，比较大小之后加入合并链表后。注意，如果有一条链表遍历完成了，可以直接将另一条链表的剩余部分直接连在合并链表后。<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/tI6YFk.png" alt="tI6YFk" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MergeTwoSortedLists21 &#123;    &#x2F;**     * 非递归解法     * @param l1     * @param l2     * @return     *&#x2F;    public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;        &#x2F;&#x2F;设置一个头节点，便于链表的创建        ListNode head &#x3D; new ListNode();        &#x2F;&#x2F;指向合并链表的当前节点        ListNode cur &#x3D; head;        &#x2F;&#x2F;指向l1, l2的当前节点        ListNode cur1 &#x3D; l1;        ListNode cur2 &#x3D; l2;        if(l1 &#x3D;&#x3D; null &amp;&amp; l2 &#x3D;&#x3D; null) &#123;            return null;        &#125;        &#x2F;&#x2F;临时存储两个链表的当前节点的值        int val1;        int val2;        &#x2F;&#x2F;当两个链表都不为空时        while(cur1 !&#x3D; null &amp;&amp; cur2 !&#x3D; null) &#123;            val1 &#x3D; cur1.val;            val2 &#x3D; cur2.val;            if(val1 &lt;&#x3D; val2) &#123;                &#x2F;&#x2F;如果val1不大于val2                &#x2F;&#x2F;将l1的当前节点连在合并链表末尾节点后，                cur.next &#x3D; cur1;                &#x2F;&#x2F;相应移动当前节点指针，l2的当前节点指针不变                cur &#x3D; cur1;                cur1 &#x3D; cur1.next;            &#125; else &#123;                cur.next &#x3D; cur2;                cur &#x3D; cur2;                cur2 &#x3D; cur2.next;            &#125;        &#125;        &#x2F;&#x2F;如果有一个链表提前遍历完了，直接将另一个链表的剩余部分连在合并链表后        if(cur1 &#x3D;&#x3D; null &amp;&amp; cur2 !&#x3D; null) &#123;            cur.next &#x3D; cur2;        &#125; else if(cur2 &#x3D;&#x3D; null &amp;&amp; cur1 !&#x3D; null) &#123;            cur.next &#x3D; cur1;        &#125;        &#x2F;&#x2F;头节点是虚拟的，从它的下一节点开始才有值        return head.next;    &#125;&#125;</code></pre><ul><li>法二：递归解法。比较两个链表的头节点，将头节点较小的头部截取，将截取之后的链表与另一个链表合并后，再连在该头节点之后。<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/HnPiyE.png" alt="HnPiyE" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 递归解法 * @param l1 * @param l2 * @return *&#x2F;public ListNode mergeTwoLists1(ListNode l1, ListNode l2) &#123;    &#x2F;&#x2F;当有链表为空时，直接返回非空链表    if(l2 &#x3D;&#x3D; null) &#123;        return l1;    &#125;    if(l1 &#x3D;&#x3D; null) &#123;        return l2;    &#125;    &#x2F;&#x2F;当l2的头节点比l1小时，将    if(l1.val &gt; l2.val) &#123;        &#x2F;&#x2F;因为l2的头节点较小，所以将l2之后的节点和l1合并然后将其连在当前头节点之后        l2.next &#x3D; mergeTwoLists1(l1, l2.next);        return l2;    &#125;    l1.next &#x3D; mergeTwoLists1(l2, l1.next);    return l1;&#125;</code></pre><h1 id="8-两两交换链表中的节点-24"><a class="markdownIt-Anchor" href="#8-两两交换链表中的节点-24"></a> 8. 两两交换链表中的节点 24</h1><ul><li><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">题目</a></li></ul><hr /><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br />你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br />示例1:<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/zEFNJ0.jpg" alt="zEFNJ0" /></p><pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1,2,3,4]输出：[2,1,4,3]</code></pre><p>示例2:</p><pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; []输出：[]</code></pre><p>示例3:</p><pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1]输出：[1]</code></pre><p>提示：<br />链表中节点的数目在范围 <code>[0, 100] </code>内<br /><code>0 &lt;= Node.val &lt;= 100</code></p><h2 id="java解法-3"><a class="markdownIt-Anchor" href="#java解法-3"></a> Java解法</h2><ul><li>法一：通过“指针”变化来转换节点之间的相对位置<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/2DxNqn.png" alt="2DxNqn" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SwapNodesInPairs24 &#123;    public ListNode swapPairs(ListNode head) &#123;        &#x2F;&#x2F;设置一个前导节点，便于连接两组交换的元素        ListNode pre &#x3D; new ListNode();        pre.next &#x3D; head;        ListNode cur &#x3D; head;        ListNode head1 &#x3D; head;        if(head !&#x3D; null &amp;&amp; head.next !&#x3D; null) &#123;            head1 &#x3D; head.next;        &#125;        &#x2F;&#x2F;遍历整个链表，然后每次处理连续两位        while (cur !&#x3D; null &amp;&amp; cur.next !&#x3D; null) &#123;                ListNode temp1;                temp1 &#x3D;  cur.next;                pre.next &#x3D; temp1;                cur.next &#x3D; temp1.next;                temp1.next &#x3D; cur;                &#x2F;&#x2F;每次移动前导节点指针2位                pre &#x3D; pre.next.next;                &#x2F;&#x2F;每次将当前节点指针移动到前导节点指针之后                cur &#x3D; pre.next;        &#125;        return head1;    &#125;&#125;</code></pre><h1 id="9-相交链表-160"><a class="markdownIt-Anchor" href="#9-相交链表-160"></a> 9. 相交链表 160</h1><ul><li><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">题目</a></li></ul><hr /><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。<br />图示两个链表在节点 c1 开始相交：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/1UHBvW.jpg" alt="1UHBvW" /><br />题目数据 保证 整个链式结构中不存在环。<br />注意，函数返回结果后，链表必须 保持其原始结构。<br />示例1：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/tcmvgZ.jpg" alt="tcmvgZ" /></p><pre class="line-numbers language-none"><code class="language-none">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3输出：Intersected at &#39;8&#39;解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</code></pre><p>示例 2：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/jJzS6t.jpg" alt="jJzS6t" /></p><pre class="line-numbers language-none"><code class="language-none">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1输出：Intersected at &#39;2&#39;解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</code></pre><p>示例3:<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/45jteX.jpg" alt="45jteX" /></p><pre class="line-numbers language-none"><code class="language-none">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2输出：null解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null 。</code></pre><p>提示：</p><pre class="line-numbers language-none"><code class="language-none">listA 中节点数目为 mlistB 中节点数目为 n0 &lt;&#x3D; m, n &lt;&#x3D; 3 * 1041 &lt;&#x3D; Node.val &lt;&#x3D; 1050 &lt;&#x3D; skipA &lt;&#x3D; m0 &lt;&#x3D; skipB &lt;&#x3D; n如果 listA 和 listB 没有交点，intersectVal 为 0如果 listA 和 listB 有交点，intersectVal &#x3D;&#x3D; listA[skipA + 1] &#x3D;&#x3D; listB[skipB + 1]</code></pre><h2 id="java解法-4"><a class="markdownIt-Anchor" href="#java解法-4"></a> Java解法</h2><ul><li>法一：遍历一个链表，将其节点与另一个链表中所有节点对比，如果与另一个链表中的某个节点相同，则该节点就是相交节点。时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>级别，很慢。<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/9REX8i.png" alt="9REX8i" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class IntersectionOfTwoLinkedLists160 &#123;    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;        &#x2F;&#x2F;如果两个链表头节点就相交        if(headA &#x3D;&#x3D; headB) &#123;            return headA;        &#125;        &#x2F;&#x2F;如果有一个链表为空        if(headA &#x3D;&#x3D; null || headB &#x3D;&#x3D; null) &#123;            return null;        &#125;        ListNode cur1 &#x3D; headA;        ListNode cur2 &#x3D; headB;        &#x2F;&#x2F;遍历链表对比节点        while (cur1 !&#x3D; null) &#123;            while(cur2 !&#x3D; null) &#123;                if(cur1 !&#x3D; cur2) &#123;                    cur2 &#x3D; cur2.next;                &#125;else &#123;                    return cur1;                &#125;            &#125;            &#x2F;&#x2F;每次都从另一个链表的头节点开始            cur2 &#x3D; headB;            cur1 &#x3D; cur1.next;        &#125;        return null;    &#125;&#125;</code></pre><h1 id="10-回文链表-234"><a class="markdownIt-Anchor" href="#10-回文链表-234"></a> 10. 回文链表 234</h1><ul><li><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">题目</a></li></ul><hr /><p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。<br />示例1：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210924090500.png" alt="" /></p><pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1,2,2,1]输出：true</code></pre><p>示例2：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210924090534.png" alt="" /></p><pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1,2]输出：false</code></pre><p>提示：<br />链表中节点数目在范围<code>[1, 105] </code>内<br /><code>0 &lt;= Node.val &lt;= 9</code></p><h2 id="java解法-5"><a class="markdownIt-Anchor" href="#java解法-5"></a> Java解法</h2><ul><li>法一：回文的实质是链表前后对称。对称问题的关键在于找到对称轴。找到对称轴后利用栈的压栈和出栈来比较前后两部分是否相同。需要注意的是链表结点数为奇数和偶数的对称轴情况不太相同。<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210924094116.png" alt="" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class PalindromeLinkedList234 &#123;    public boolean isPalindrome(ListNode head) &#123;        Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;();        &#x2F;&#x2F;统计链表结点的数量        ListNode node &#x3D; head;        int count &#x3D; 0;        while (node !&#x3D; null) &#123;            count++;            node &#x3D; node.next;        &#125;        count -&#x3D; 1;        &#x2F;&#x2F;将链表结点数量为奇数和偶数分别处理        if(count % 2 &#x3D;&#x3D; 0) &#123;            &#x2F;&#x2F;链表结点数量为奇数            &#x2F;&#x2F;找到链表的“对称轴”，将前半部分结点的压栈，然后遍历后半部分，与出栈的值比较            ListNode node1 &#x3D; head;            for(int i &#x3D; 0; i &lt; count &#x2F; 2; i++) &#123;                stack.push(node1.val);                node1 &#x3D; node1.next;            &#125;            &#x2F;&#x2F;奇数个结点，以中间结点为对称轴，不用比较其值，直接跳过            node1 &#x3D; node1.next;            for(int i &#x3D; 1 + count &#x2F; 2; i &lt;&#x3D; count; i++) &#123;                int val &#x3D; stack.pop();                if(val &#x3D;&#x3D; node1.val) &#123;                    node1 &#x3D; node1.next;                &#125; else &#123;                    return false;                &#125;            &#125;        &#125; else &#123;            &#x2F;&#x2F;链表结点数量为偶数            ListNode node2 &#x3D; head;            for(int i &#x3D; 0; i &lt;&#x3D; count &#x2F; 2; i++) &#123;                stack.push(node2.val);                node2 &#x3D; node2.next;            &#125;            for(int i &#x3D; 1 + count &#x2F; 2; i &lt;&#x3D; count; i++) &#123;                int val &#x3D; stack.pop();                if(val &#x3D;&#x3D; node2.val) &#123;                    node2 &#x3D; node2.next;                &#125; else &#123;                    return false;                &#125;            &#125;        &#125;        return true;    &#125;&#125;</code></pre><ul><li>法二：将链表值复制到数组，同时从数组两端向中间遍历，比较值是否相同。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Maven/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Web%E5%90%8E%E7%AB%AF/Maven/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="maven是什么"><a class="markdownIt-Anchor" href="#maven是什么"></a> maven是什么？</h1><p><a href="https://mvnrepository.com/">中央仓库内容查询</a><br /><a href="https://www.runoob.com/maven/maven-tutorial.html">参考文档</a></p><ul><li>maven是基于POM（project object model:项目对象模型）的软件项目管理工具。</li><li>Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。Maven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。</li><li>Maven 可以统一<strong>管理所有的依赖jar包</strong>，甚至是不同的版本。程序员也可以动态地将自己写好的模块打包成jar包让它管理。需要的时候，可以直接通过简单的描述文件告诉 Maven，它会自动帮助程序员找出来，集成到项目中。并且它提供了中央仓库，能帮我们自动下载构件。</li><li>maven可以进行对指定目录下的代码进行单元测试，检测代码质量。</li><li>Maven的作用：<ol><li>构建工程</li><li>管理Jar包</li><li>编译代码</li><li>自动运行单元测试</li><li>部署项目等</li></ol></li></ul><h1 id="maven的安装"><a class="markdownIt-Anchor" href="#maven的安装"></a> maven的安装</h1><ul><li>参见：<a href="https://www.runoob.com/maven/maven-setup.html">菜鸟教程</a></li></ul><h1 id="maven-依赖管理"><a class="markdownIt-Anchor" href="#maven-依赖管理"></a> Maven-依赖管理</h1><ul><li>依赖管理：即对项目的jar包的管理</li><li>核心思想：将项目中所需的jar包放到jar包仓库中，而不是直接放在项目中。</li></ul><h1 id="maven-pom"><a class="markdownIt-Anchor" href="#maven-pom"></a> Maven POM</h1><ul><li><strong>POM</strong>( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元，是一个<strong>XML文件</strong>，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。执行任务或目标时，Maven会在当前目录中查找POM。它读取POM，获取所需的配置信息，然后执行目标。</li><li><strong>父（Super）POM</strong>是Maven默认的 POM。所有的POM都继承自一个父 POM（无论是否显式定义了这个父 POM）。父 POM 包含了一些可以被继承的默认设置。因此，当Maven发现需要下载POM中的依赖时，它会到Super POM 中配置的<a href="https://mvnrepository.com/">默认仓库</a> 去下载。</li><li>POM的文件（xml）中的标签解读<a href="https://www.runoob.com/maven/maven-pom.html">菜鸟教程</a></li></ul><h1 id="maven构建生命周期"><a class="markdownIt-Anchor" href="#maven构建生命周期"></a> maven构建生命周期</h1><ul><li><p>生命周期概述：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200922005205.jpg" alt="" /></p></li><li><p>默认生命周期：</p></li></ul><p>|阶段|处理|命令｜描述|<br />|-|-|-|-|<br />|验证 validate|验证项目||验证项目是否正确且所有必须信息是可用的|<br />|编译 compile|执行编译|mvn compile|源代码编译在此阶段完成|<br />|测试 Test|测试|mvn test|使用适当的单元测试框架（例如JUnit）运行测试。|<br />|包装 package|打包|mvn package|创建JAR/WAR包如在 pom.xml 中定义提及的包|<br />|检查 verify|检查||对集成测试的结果进行检查，以保证质量达标|<br />|安装 install|安装|mvn install|安装打包的项目到本地仓库，以供其他项目使用|<br />|部署 deploy|部署|mvn deploy|拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程|</p><ul><li>当执行到后面的生命周期时，前面的生命周期一定已经执行了。</li><li>清理生命周期；清除项目编译信息：<code>mvn clean</code></li></ul><h1 id="maven的仓库"><a class="markdownIt-Anchor" href="#maven的仓库"></a> Maven的仓库</h1><ul><li>Maven 仓库能帮助我们管理构件（主要是JAR），它就是放置所有JAR文件（WAR，ZIP，POM等等）的地方。即jar不是放在项目中，而是放在仓库中，实际使用的时候，maven通过jar包的坐标在<strong>仓库</strong>中定位jar包。</li><li>Maven 仓库有三种类型：<ol><li>本地（local）</li><li>中央（central）</li><li>远程（remote）</li></ol></li><li>本地仓库：<ul><li>运行 Maven 的时候，Maven 所需要的任何构件都是直接从本地仓库获取的。如果本地仓库没有，它会首先尝试从远程仓库下载构件至本地仓库，然后再使用本地仓库的构件。</li><li>Maven本地仓库默认被创建在<code> %USER_HOME%</code>目录下。要<strong>修改默认位置</strong>，在 <code>%M2_HOME%\conf</code> 目录中的Maven的settings.xml文件中定义另一个路径。当你运行Maven命令，Maven将下载依赖的文件到你指定的路径中。</li></ul>  <pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;settings xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;SETTINGS&#x2F;1.0.0&quot;xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;SETTINGS&#x2F;1.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;settings-1.0.0.xsd&quot;&gt;    &lt;localRepository&gt;C:&#x2F;MyLocalRepository&lt;&#x2F;localRepository&gt;&lt;&#x2F;settings&gt;</code></pre></li><li>中央仓库：<ul><li>这个仓库由 Maven 社区管理。</li><li>不需要配置。</li><li>需要通过网络才能访问。</li><li>要浏览中央仓库的内容，maven社区提供了一个URL：<code>http://search.maven.org/#browse</code>。使用这个仓库，开发人员可以搜索所有可以获取的代码库。</li></ul></li><li>远程仓库（私服）：<ul><li>如果 Maven 在中央仓库中也找不到依赖的文件，它会停止构建过程并输出错误信息到控制台。为避免这种情况，Maven 提供了远程仓库的概念，它是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的jar文件。</li></ul></li><li>依赖的搜索顺序：<ol><li>步骤 1 － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。</li><li>步骤 2 － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中以备将来引用。</li><li>步骤 3 － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。</li><li>步骤 4 － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库以备将来引用，否则 Maven将停止处理并抛出错误（无法找到依赖的文件）。</li></ol></li></ul><h1 id="maven插件命令"><a class="markdownIt-Anchor" href="#maven插件命令"></a> Maven插件（命令）</h1><ul><li>每个生命周期中都包含着一系列的阶段(phase)。这些 phase 就相当于 Maven 提供的统一的接口，然后这些 phase 的实现由 Maven 的插件来完成。</li><li>Maven 生命周期的每一个阶段的具体实现都是由 Maven 插件实现的。Maven 实际上是一个依赖插件执行的框架，每个任务实际上是由插件完成。Maven 插件通常被用来：1.创建 jar 文件 2.创建 war 文件 3.编译代码文件 4.代码单元测试 5.创建工程文档 6.创建工程报告。</li><li>插件的执行：<code>&lt;code&gt;mvn [plugin-name]:[goal-name]&lt;/code&gt;</code></li><li>常用插件：</li></ul><table><thead><tr><th>插件</th><th>描述</th></tr></thead><tbody><tr><td>clean</td><td>构建之后清理目标文件。删除目标目录。</td></tr><tr><td>compiler</td><td>编译 Java 源文件。</td></tr><tr><td>surefile</td><td>运行 JUnit 单元测试。创建测试报告。</td></tr><tr><td>jar</td><td>从当前工程中构建 JAR 文件。</td></tr><tr><td>war</td><td>从当前工程中构建 WAR 文件。</td></tr><tr><td>javadoc</td><td>为工程生成 Javadoc。</td></tr><tr><td>antrun</td><td>从构建过程的任意一个阶段中运行一个 ant 任务的集合。</td></tr></tbody></table><ul><li>插件是在 pom.xml 中使用 plugins 元素定义的。每个插件可以有多个目标。</li></ul><h1 id="maven的目录结构"><a class="markdownIt-Anchor" href="#maven的目录结构"></a> maven的目录结构</h1><ul><li>核心代码部分；</li><li>配置文件部分：jar包之外的部分。</li><li>测试代码部分；</li><li>测试配置文件部分。</li><li>maven标准目录结构：<ul><li>src/main/java:核心代码部分</li><li>src/main/resources:配置文件部分</li><li>src/test/java：测试代码部分</li><li>src/test/resources:测试配置文件</li><li>src/main/webapp:页面资源，js，css，图片等。</li></ul></li></ul><h1 id="pomxml"><a class="markdownIt-Anchor" href="#pomxml"></a> pom.xml</h1><ul><li>项目对象模型：<ul><li>项目自身信息</li><li>项目运行所依赖的jar包信息</li><li>项目运行环境信息，比如jdk信息。</li></ul></li><li>依赖管理模型：（dependency）<ul><li>管理jar包</li><li>设置jar包的作用域来解决jar包冲突<ul><li>不同的作用域的区别：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210201200309.jpg" alt="" /></li></ul></li></ul></li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependencies&gt;    &lt;!-- 在这里添加你的依赖 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;ldapjdk&lt;&#x2F;groupId&gt;  &lt;!-- 库名称，也可以自定义 --&gt;        &lt;artifactId&gt;ldapjdk&lt;&#x2F;artifactId&gt;    &lt;!--库名称，也可以自定义--&gt;        &lt;version&gt;1.0&lt;&#x2F;version&gt; &lt;!--版本号--&gt;        &lt;scope&gt;system&lt;&#x2F;scope&gt; &lt;!--作用域--&gt;        &lt;systemPath&gt;$&#123;basedir&#125;\src\lib\ldapjdk.jar&lt;&#x2F;systemPath&gt; &lt;!--项目根目录下的lib文件夹下--&gt;    &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt;</code></pre><ul><li>插件（plugins）<ul><li>生命周期的每一个过程都对应底层的一个插件<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20210201130751.jpg" alt="" /></li></ul></li><li>修改运行环境：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;! 将服务器环境改为tomcat7--&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.tomcat.maven&lt;&#x2F;groupId&gt;                &lt;artifactId&gt;tomcat7-maven-plugin&lt;&#x2F;artifactId&gt;                &lt;version&gt;2.2&lt;&#x2F;version&gt;                &lt;configuration&gt;                    &lt;port&gt;8080&lt;&#x2F;port&gt;                &lt;&#x2F;configuration&gt;            &lt;&#x2F;plugin&gt;        &lt;&#x2F;plugins&gt;    &lt;&#x2F;build&gt;</code></pre><h1 id="maven配置阿里云镜像"><a class="markdownIt-Anchor" href="#maven配置阿里云镜像"></a> Maven配置阿里云镜像</h1><ul><li>因为Maven官方的中央仓库是国外的，访问很慢，所以换为Aliyun镜像。<br />在settings.xml文件中找到<mirrors></mirrors>标签对,进行修改：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">1 &lt;mirrors&gt;2      &lt;mirror&gt;3         &lt;id&gt;nexus-aliyun&lt;&#x2F;id&gt;4         &lt;mirrorOf&gt;*&lt;&#x2F;mirrorOf&gt;5         &lt;name&gt;Nexus aliyun&lt;&#x2F;name&gt;6         &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&lt;&#x2F;url&gt;7      &lt;&#x2F;mirror&gt; 8 &lt;&#x2F;mirrors&gt;</code></pre><h1 id="maven导入非resources目录下的配置文件资源过滤问题"><a class="markdownIt-Anchor" href="#maven导入非resources目录下的配置文件资源过滤问题"></a> Maven导入非resources目录下的配置文件(资源过滤问题)</h1><ul><li>在pom.xml文件中配置：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;build&gt;    &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;            &lt;includes&gt;                &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;            &lt;&#x2F;includes&gt;            &lt;filtering&gt;false&lt;&#x2F;filtering&gt;        &lt;&#x2F;resource&gt;        &lt;resource&gt;            &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;            &lt;includes&gt;                &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;            &lt;&#x2F;includes&gt;            &lt;filtering&gt;false&lt;&#x2F;filtering&gt;        &lt;&#x2F;resource&gt;    &lt;&#x2F;resources&gt;&lt;&#x2F;build&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 后端 </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-数组</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/LeetCode-%E6%95%B0%E7%BB%84/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/LeetCode-%E6%95%B0%E7%BB%84/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码地址"><a class="markdownIt-Anchor" href="#代码地址"></a> 代码地址</h1><p><a href="https://github.com/zestaken/newblog/tree/master/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/LeetCode/Code/src/main/java/array">github</a></p><h1 id="1-一维数组的动态和-1480"><a class="markdownIt-Anchor" href="#1-一维数组的动态和-1480"></a> 1. 一维数组的动态和 1480</h1><ul><li>题目：</li></ul><hr /><p>给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。</p><p>请返回 nums 的动态和。</p><p>示例 1：</p><p>输入：nums = [1,2,3,4]<br />输出：[1,3,6,10]<br />解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。</p><h2 id="java解法"><a class="markdownIt-Anchor" href="#java解法"></a> Java解法</h2><ul><li>法一：<ul><li>设置一个新数组，每一项为前面所有项之和；</li><li>通过双重循环实现。</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Sums &#123;    public static int[] runningSums(int nums[]) &#123;        int[] sums &#x3D; new int[nums.length];        for(int i &#x3D; 0 ; i &lt; nums.length; i++) &#123;            for(int j &#x3D; 0; j &lt;&#x3D; i; j++) &#123;                sums[i] +&#x3D; nums[j];            &#125;        &#125;        return sums;    &#125;    public static void main(String[] args) &#123;        int[] nums &#x3D; &#123;1, 2, 3, 4,5&#125;;        int[] sums &#x3D; Sums.runningSums(nums);       for(int i : sums) &#123;           System.out.println(i);       &#125;    &#125;&#125;</code></pre><ul><li>法二：<ul><li>动态求和过程中，每一项都是前一项与自身之和。</li><li>第一个元素没有前一个元素，对它没有操作，所以直接从第二个元素开始遍历求和。</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Sums &#123;    public static int[] runningSums (int[] nums) &#123;        for(int i &#x3D; 1; i &lt; nums.length; i++) &#123;&#x2F;&#x2F;            if(i &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;                continue;&#x2F;&#x2F;            &#125;因为0是无需操作的，所以直接从1开始就好了            nums[i] +&#x3D; nums[i-1] ;        &#125;        return nums;    &#125;    public static void main(String[] args) &#123;        int[] nums &#x3D; &#123;1, 2, 3,4&#125;;        int[] sums &#x3D; Sums.runningSums(nums);        for (int i : sums) &#123;            System.out.println(i);        &#125;    &#125;&#125;</code></pre><h1 id="2-拥有糖果最多的孩子-1431"><a class="markdownIt-Anchor" href="#2-拥有糖果最多的孩子-1431"></a> 2. 拥有糖果最多的孩子 1431</h1><ul><li>题目：</li></ul><hr /><p>给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。</p><p>对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。</p><p></p><p>示例 1：</p><p>输入：candies = [2,3,5,1,3], extraCandies = 3<br />输出：[true,true,true,false,true]<br />解释：<br />孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。<br />孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。<br />孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。<br />孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。<br />孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。</p><ul><li>java解法</li></ul><hr /><ul><li>先找到拥有糖果数量最多的孩子，将加上补充的糖果数后的与这个最大比较</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Candy &#123;    public static boolean[] isMax(int kids[], int extraCandies) &#123;        &#x2F;&#x2F;找出原有最多的数        int max &#x3D; 0;        for(int i &#x3D; 0; i &lt; kids.length; i++) &#123;            if(max &lt; kids[i]) &#123;                max &#x3D; kids[i];            &#125;        &#125;        &#x2F;&#x2F;设置判别数组        boolean[] isMax &#x3D; new boolean[kids.length];        for(int i &#x3D; 0; i &lt; kids.length; i++) &#123;            if(kids[i] + extraCandies &gt;&#x3D; max) &#123;                isMax[i] &#x3D; true;            &#125; else&#123;                isMax[i] &#x3D; false;            &#125;        &#125;        return isMax;    &#125;    public static void main(String[] args) &#123;        int[] kids &#x3D; &#123;2, 3, 5, 1, 3&#125;;        int extraCandies &#x3D; 3;        boolean[] isMax &#x3D; Candy.isMax(kids, extraCandies);        for(boolean i : isMax) &#123;            System.out.println(i);        &#125;    &#125;&#125;</code></pre><h1 id="3-重新排列数组-1470"><a class="markdownIt-Anchor" href="#3-重新排列数组-1470"></a> 3. 重新排列数组 1470</h1><ul><li>题目：</li></ul><hr /><ol start="1470"><li>重新排列数组<br />给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,…,xn,y1,y2,…,yn] 的格式排列。</li></ol><p>请你将数组按 [x1,y1,x2,y2,…,xn,yn] 格式重新排列，返回重排后的数组。</p><p>示例 1：</p><p>输入：nums = [2,5,1,3,4,7], n = 3<br />输出：[2,3,5,4,1,7]<br />解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7]</p><ul><li>Java解法：</li></ul><hr /><ul><li>法一：设置一个额外的数组，用来将重排后的数据记录；</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Resort1470 &#123;    public static int[] resort(int[] nums1)&#123;        int n &#x3D; nums1.length &#x2F; 2;        int[] nums2 &#x3D; new int[nums1.length];        for(int i &#x3D; 0 ,j &#x3D; 0; j &lt; n;  i++, j++) &#123;            nums2[i] &#x3D; nums1[j];            nums2[++i] &#x3D; nums1[n + j];        &#125;            return nums2;    &#125;    public static void main(String[] args) &#123;        int[] nums1 &#x3D; &#123;2,5,1,3,4,7&#125;;        int[] nums2 &#x3D; Resort1470.resort(nums1);        for(int i : nums2) &#123;            System.out.println(i);        &#125;    &#125;&#125;</code></pre><h1 id="4-左旋转字符串-剑指offer-58-ii"><a class="markdownIt-Anchor" href="#4-左旋转字符串-剑指offer-58-ii"></a> 4. 左旋转字符串 剑指offer 58-II</h1><ul><li>题目：</li></ul><hr /><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。</p><p></p><p>示例 1：</p><p>输入: s = “abcdefg”, k = 2<br />输出: “cdefgab”</p><ul><li>Java解法：</li></ul><hr /><ul><li>将该字符串分为两个子串，然后再反向连接起来</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;public class ReverseLeftWords &#123;    public String reverseLeftWords(String s, int n) &#123;         String str1 &#x3D; s.substring(0, n); &#x2F;&#x2F;读入从0到n（但是不包括下标为n的）         String str2 &#x3D; s.substring(n); &#x2F;&#x2F;从n开始到最后（包括下标为n的）         String  s1 &#x3D; str2 + str1;&#x2F;&#x2F;反向连接，达到左旋转的效果         return s1;&#x2F;&#x2F; return s.substring(n) + s.substring(o, n);    &#125;    public static void main(String[] args) &#123;        String s &#x3D; &quot; &quot;;        int n;        Scanner in &#x3D; new Scanner(System.in);        System.out.println(&quot;请输入字符：&quot;);        s &#x3D; in.nextLine();        System.out.println(&quot;请输入从哪里开始转：&quot;);        n &#x3D; in.nextInt();        var reverse &#x3D; new ReverseLeftWords();        s &#x3D; reverse.reverseLeftWords(s, n);        for(int i &#x3D; 0; i &lt; s.length(); i++) &#123;            System.out.print(s.charAt(i) + &quot; &quot;);        &#125;    &#125;&#125;</code></pre><ul><li>数组形式解法：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ReverseLeftWords &#123;    public static char[] reverseLeftWords(char[] nums, int n) &#123;        char[] nums1 &#x3D; new char[n];        char[] nums2 &#x3D; new char[nums.length];        for(int i &#x3D; 0; i &lt; nums.length; i++) &#123;            if(i &lt; n) &#123;                nums1[i] &#x3D; nums[i];            &#125;else &#123;                nums2[i - n] &#x3D; nums[i];            &#125;        &#125;        for(int i &#x3D; 0; i &lt; n; i++) &#123;            nums2[nums.length - n + i] &#x3D; nums1[i];        &#125;        return nums2;    &#125;    public static void main(String[] args) &#123;       char[] nums &#x3D; &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;&#125;;       char[] nums2 &#x3D; ReverseLeftWords.reverseLeftWords(nums, 2);       for(char i : nums2) &#123;           System.out.println(i);       &#125;    &#125;&#125;</code></pre><h1 id="5-好数对的数目-1512"><a class="markdownIt-Anchor" href="#5-好数对的数目-1512"></a> 5. 好数对的数目 1512</h1><ul><li>题目</li></ul><hr /><p>给你一个整数数组 nums 。</p><p>如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i &lt; j ，就可以认为这是一组 好数对 。</p><p>返回好数对的数目。</p><p></p><p>示例 1：</p><p>输入：nums = [1,2,3,1,1,3]<br />输出：4<br />解释：有 4 组好数对，分别是 (0,3), (0,4), (3,4), (2,5) ，下标从 0 开始.</p><ul><li>java解法</li></ul><hr /><ul><li>法一：双重循环遍历数组，外层为数组这个计数循环，内层取寻找与当前元素相同的元素（但是只找当前位置之后的，避免重复计算）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;public class NumPairs1512 &#123;    public static int numIdenticalPairs(int[] nums) &#123;        int ans &#x3D; 0;        for(int i &#x3D; 0; i &lt; nums.length; i++) &#123;            for(int j &#x3D; 1; j &lt; nums.length; j++) &#123; &#x2F;&#x2F;每次统计相同的元素都是从当前位置向后遍历，这样就不会有重复的情况                if(nums[i] &#x3D;&#x3D; nums[i+j]) &#123;                    ans++;                &#125;            &#125;        &#125;        return ans;    &#125;    public static void main(String[] args) &#123;        int[] nums &#x3D; &#123;1,2,3,1,1,3&#125;;        System.out.println(Solution.numIdenticalPairs(nums));    &#125;&#125;</code></pre><h1 id="6-两个数组的交集-ii-350"><a class="markdownIt-Anchor" href="#6-两个数组的交集-ii-350"></a> 6. 两个数组的交集 II 350</h1><ul><li><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">题目</a>：</li></ul><hr /><p>给定两个数组，编写一个函数来计算它们的交集。</p><p>示例 1：</p><pre class="line-numbers language-none"><code class="language-none">输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]输出：[2,2]</code></pre><p>示例 2:</p><pre class="line-numbers language-none"><code class="language-none">输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]输出：[4,9]</code></pre><p>说明：</p><p>输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。<br />我们可以不考虑输出结果的顺序。<br />进阶：</p><p>如果给定的数组已经排好序呢？你将如何优化你的算法？<br />如果 nums1 的大小比 nums2 小很多，哪种方法更优？<br />如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</p><h2 id="java题解"><a class="markdownIt-Anchor" href="#java题解"></a> Java题解</h2><ul><li>法一：遍历一个数组，将每个数出现的次数存入哈希表中，之后再遍历另一个数组并查找哈希表<ul><li>代码：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Intersect350 &#123;public int[] intersect(int[] nums1, int[] nums2) &#123;    &#x2F;&#x2F;用哈希表存次数    HashMap&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;Integer, Integer&gt;();    &#x2F;&#x2F;遍历一个数组，获取每个元素值以及出现次数    for(int i : nums1) &#123;        if(!map.containsKey(i)) &#123;            &#x2F;&#x2F;初始计数为1            map.put(i, 1);        &#125; else &#123;            int count &#x3D; map.get(i);            &#x2F;&#x2F;第二次出现计数加一            count++;            map.put(i, count);        &#125;    &#125;    int[] res &#x3D; new int[(nums1.length &gt; nums2.length)?nums2.length:nums1.length];    int index &#x3D; 0;    for(int i : nums2) &#123;        if(map.containsKey(i)) &#123;            int count &#x3D; map.get(i);            &#x2F;&#x2F;每出现一次计数减一，只在计数大于0时存入结果中，以保证出现次数与最少的数组相同            count--;            map.put(i, count);            if(count &gt;&#x3D; 0) &#123;                res[index] &#x3D; i;                index++;            &#125;        &#125;    &#125;    return Arrays.copyOfRange(res, 0, index);&#125;</code></pre></li><li>法二：先对两个数组进行排序，然后设置两个指针指向数组元素，每次相等的时候两个指针同时移动，不相等的时候较小的移动<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210714205354.png" alt="" /></li><li>代码：<pre class="line-numbers language-java" data-language="java"><code class="language-java">    &#x2F;&#x2F;先排序（升序）Arrays.sort(nums1);Arrays.sort(nums2);&#x2F;&#x2F;存储结果数组int[] res &#x3D; new int[(nums1.length &gt; nums2.length)?nums2.length:nums1.length];int count1 &#x3D; 0;int count2 &#x3D; 0;int index &#x3D; 0;while (true) &#123;    if(nums1[count1] &#x3D;&#x3D; nums2[count2]) &#123;        &#x2F;&#x2F;如果相等则双指针均前移        res[index] &#x3D; nums1[count1];        index++;        count1++;        count2++;    &#125; else if(nums1[count1] &lt; nums2[count2]) &#123;        count1++;    &#125; else &#123;        count2++;    &#125;    if(count1 &gt;&#x3D; nums1.length || count2 &gt;&#x3D; nums2.length) &#123;        break;    &#125;&#125;return Arrays.copyOfRange(res, 0, index);</code></pre></li></ul></li></ul><h1 id="7-找到所有数组中消失的数字-448"><a class="markdownIt-Anchor" href="#7-找到所有数组中消失的数字-448"></a> 7. 找到所有数组中消失的数字 448</h1><ul><li><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">题目</a></li></ul><hr /><p>给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。</p><pre class="line-numbers language-none"><code class="language-none">示例 1：输入：nums &#x3D; [4,3,2,7,8,2,3,1]输出：[5,6]示例 2：输入：nums &#x3D; [1,1]输出：[2]</code></pre><p>提示：</p><p>n == nums.length<br />1 &lt;= n &lt;= 105<br />1 &lt;= nums[i] &lt;= n</p><p>进阶：你能在不使用额外空间且时间复杂度为 O(n) 的情况下解决这个问题吗? 你可以假定返回的数组不算在额外空间内。</p><h2 id="java解法-2"><a class="markdownIt-Anchor" href="#java解法-2"></a> java解法</h2><ul><li>法一：排序后双指针扫描确定<ul><li>结果：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/EEorl6.png" alt="EEorl6" /></li><li>代码：</li></ul>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123;    &#x2F;&#x2F;用于存储所有数字    ArrayList&lt;Integer&gt; all &#x3D; new ArrayList&lt;&gt;();    &#x2F;&#x2F;存储消失的数字    ArrayList&lt;Integer&gt; disappear &#x3D; new ArrayList&lt;&gt;();    int length &#x3D; nums.length;    &#x2F;&#x2F;将范围内所有数字存入all集合    for(int i &#x3D; 1; i &lt;&#x3D; length; i++) &#123;        all.add(i);    &#125;    &#x2F;&#x2F;对数组进行排序后，通过双指针扫描两个数组确定消失的数字    Arrays.sort(nums);    &#x2F;&#x2F;双指针扫描两个数组&#x2F;集合    for(int j &#x3D; 0, i &#x3D; 0; j &lt; length &amp;&amp; i &lt; length; ) &#123;        &#x2F;&#x2F;all指针数字大于原数组指针数字，则原数组指针前移，all不变        if(all.get(j) &gt; nums[i]) &#123;            i++;            &#x2F;&#x2F;判断边界，防止原数组扫描结束后all中剩余元素未被扫描            if(i &gt;&#x3D; length) &#123;                for(int t &#x3D; j; t &lt; length; t++) &#123;                    disappear.add(all.get(t));                &#125;            &#125;        &#125; else if(all.get(j) &#x3D;&#x3D; nums[i]) &#123;&#x2F;&#x2F; 两个指针同时迁移            j++;            i++;            &#x2F;&#x2F;判断边界，防止原数组扫描结束后all中剩余元素未被扫描（all数组不可能在原数组之前扫描完）            if(i &gt;&#x3D; length) &#123;                for(int t &#x3D; j; t &lt; length; t++) &#123;                    disappear.add(all.get(t));                &#125;            &#125;        &#125; else if(all.get(j) &lt; nums[i]) &#123; &#x2F;&#x2F;all指针小于原数组指针数字则前移all指针，原数组不变            disappear.add(all.get(j));            j++;        &#125;    &#125;    return disappear;&#125;</code></pre></li><li>法二：利用数组脚标可对应连续整数，通过修改原数组指定位置的值来筛选没有出现过的数。不用排序，所以时间复杂度减少<ul><li>结果：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/XfqEaq.png" alt="XfqEaq" /></li><li>代码：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123;    ArrayList&lt;Integer&gt; ans &#x3D; new ArrayList&lt;&gt;();    int length &#x3D; nums.length;    for(int n : nums) &#123;        int index &#x3D; (n - 1) % length;&#x2F;&#x2F;因为会加长度，导致有些位置上的数超过length，所以需要取模        &#x2F;&#x2F;出现了的数字对应的位置的值加上长度        nums[index] +&#x3D; length;    &#125;        &#x2F;&#x2F;再次遍历数组，如果值不大于长度length，则说明该位置脚标对应的值没有出现过    for(int i &#x3D; 0; i &lt; length; i++) &#123;        if(nums[i] &lt;&#x3D; length) &#123;            ans.add(i + 1);        &#125;    &#125;    return ans;&#125;</code></pre></li></ul><h1 id="8-旋转图像-48"><a class="markdownIt-Anchor" href="#8-旋转图像-48"></a> 8. 旋转图像 48</h1><ul><li><a href="https://leetcode-cn.com/problems/rotate-image/">题目</a></li></ul><hr /><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。<br />你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><pre class="line-numbers language-none"><code class="language-none">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]输出：[[7,4,1],[8,5,2],[9,6,3]]输入：matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]输入：matrix &#x3D; [[1]]输出：[[1]]输入：matrix &#x3D; [[1,2],[3,4]]输出：[[3,1],[4,2]]</code></pre><p>提示：</p><p>matrix.length == n<br />matrix[i].length == n<br />1 &lt;= n &lt;= 20<br />-1000 &lt;= matrix[i][j] &lt;= 1000</p><h2 id="java解法-3"><a class="markdownIt-Anchor" href="#java解法-3"></a> java解法</h2><ul><li>法一：通过一圈一圈找到四个依次换位置的元素，来依次移动这些元素的值，来达到借助一个中间值变量实现原地旋转的效果。关键在于如何确定这些元素的下标的变化规律。<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210719214209.png" alt="" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Rotate48 &#123;    public void rotate(int[][] matrix) &#123;        &#x2F;&#x2F;从外向内一圈圈找，用times表示在第几圈        int times &#x3D; 0;        &#x2F;&#x2F;nums表示矩阵的列数（行数）        int nums &#x3D; matrix.length;        while(times &lt;&#x3D; (nums &#x2F; 2)) &#123; &#x2F;&#x2F;比如4x4矩阵就是两圈，3x3也是两圈            &#x2F;&#x2F;在每一圈中再确定依次交换值的四个元素            int len &#x3D; nums - times * 2; &#x2F;&#x2F;len是圈的范围，每缩小一圈减少两个            for(int i &#x3D; 0; i &lt; len - 1; i++) &#123;                &#x2F;&#x2F;确定每一圈第一个元素的位置并用临时变量存储其值                &#x2F;&#x2F;通过i来将第一个元素右移一位，其它三个元素顺势右移，遇到边界就贴着边界转换方向接着移                int temp &#x3D; matrix[times][times + i];                &#x2F;&#x2F;将上一个元素的值由其下一位元素的值来替代                matrix[times][times + i] &#x3D; matrix[times + len - 1 - i][times];                matrix[times + len - 1 - i][times] &#x3D; matrix[times + len - 1][times + len - 1 - i];                matrix[times + len - 1][times + len - 1 - i] &#x3D; matrix[times + i][times + len - 1];                matrix[times + i][times + len - 1] &#x3D; temp;                &#x2F;&#x2F;虽然看起来复杂，但是每一个元素又一个坐标都是不随i的变化而变化，只要关注i对其有影响的坐标，顺势移动即可            &#125;            &#x2F;&#x2F;进入下一圈            times++;        &#125;    &#125;&#125;</code></pre><h1 id="9-搜索二维矩阵-ii-240"><a class="markdownIt-Anchor" href="#9-搜索二维矩阵-ii-240"></a> 9. 搜索二维矩阵 II 240</h1><ul><li><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">题目</a></li></ul><hr /><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</p><p>每行的元素从左到右升序排列。<br />每列的元素从上到下升序排列。</p><pre class="line-numbers language-none"><code class="language-none">输入：matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 5输出：true输入：matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 20输出：false</code></pre><p>提示：</p><p>m == matrix.length<br />n == matrix[i].length<br />1 &lt;= n, m &lt;= 300<br />-109 &lt;= matix[i][j] &lt;= 109<br />每行的所有元素从左到右升序排列<br />每列的所有元素从上到下升序排列<br />-109 &lt;= target &lt;= 109</p><h2 id="java解法-4"><a class="markdownIt-Anchor" href="#java解法-4"></a> Java解法</h2><ul><li>法一：从矩阵右上角开始寻找，直到超出矩阵边界，则目标不存在。当前元素比目标小，则下移，当前元素比目标大则左移。用一个元素的眼光来看，这个元素的左侧的元素的较小，下方的元素比自己小，从递归的观点来看，对每一个元素都这样处理。如果开始从左上角开始，没有选择较小元素的余地，一旦遇见比目标的元素，只能回退<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210719232725.png" alt="" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean searchMatrix(int[][] matrix, int target) &#123;    &#x2F;&#x2F;从右上角开始搜索    int lines &#x3D; matrix.length;    int rows &#x3D; matrix[0].length;    for(int i &#x3D; 0, j &#x3D; rows - 1; i &lt; lines &amp;&amp; 0 &lt;&#x3D; j; ) &#123;        if(matrix[i][j] &gt; target) &#123;            &#x2F;&#x2F;比目标大，向左横向移动            j--;            if(j &lt; 0) &#123;                return false;            &#125;        &#125;else if(matrix[i][j] &lt; target) &#123;            &#x2F;&#x2F;比目标小，向下移动            i++;            if(i &gt;&#x3D; lines) &#123;                return false;            &#125;        &#125; else if (matrix[i][j] &#x3D;&#x3D; target) &#123;            return true;        &#125;    &#125;    return false;&#125;</code></pre><h1 id="10-最多能完成排序的块-769"><a class="markdownIt-Anchor" href="#10-最多能完成排序的块-769"></a> 10. 最多能完成排序的块 769</h1><ul><li><a href="https://leetcode-cn.com/problems/max-chunks-to-make-sorted/">题目</a></li></ul><hr /><p>数组arr是[0, 1, …, arr.length - 1]的一种排列，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。</p><p>我们最多能将数组分成多少块？</p><pre class="line-numbers language-none"><code class="language-none">示例 1:输入: arr &#x3D; [4,3,2,1,0]输出: 1解释:将数组分成2块或者更多块，都无法得到所需的结果。例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。示例 2:输入: arr &#x3D; [1,0,2,3,4]输出: 4解释:我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。</code></pre><p>注意:</p><p>arr 的长度在 [1, 10] 之间。<br />arr[i]是 [0, 1, …, arr.length - 1]的一种排列。</p><h2 id="java解法-5"><a class="markdownIt-Anchor" href="#java解法-5"></a> Java解法</h2><ul><li>法一：值为连续整数，将值与下标对应，当目前最大值与下标对应时，将数组分为左边一定比目前最大值都小，右边一定比当前最大值都大，可以划分<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/ZYfn0h.png" alt="ZYfn0h" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;连续整数的一个排列，用下标与值对应  public int maxChunksToSorted(int[] arr) &#123;      int max &#x3D; arr[0];      int count &#x3D; 0;      int length &#x3D; arr.length;      for(int i &#x3D; 0; i &lt; length; i++) &#123;          if(arr[i] &gt;&#x3D; max) &#123;              max &#x3D; arr[i];          &#125;          &#x2F;&#x2F;每当最大值与下标相等则说明前面的数据全是比最大值小的而之后全是比最大值大的          &#x2F;&#x2F;如果只能分为一块，说明最大值在最前面出现，最后总能遇到自己的下标，而使count加一          if(max &#x3D;&#x3D; i) &#123;              count++;          &#125;      &#125;      return count;  &#125;</code></pre><h1 id="11-区域和检索-数组不可变-303"><a class="markdownIt-Anchor" href="#11-区域和检索-数组不可变-303"></a> 11. 区域和检索 - 数组不可变 303</h1><ul><li><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/">题目</a></li></ul><hr /><p>给定一个整数数组 nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点。<br />实现 NumArray 类：</p><pre class="line-numbers language-none"><code class="language-none">NumArray(int[] nums) 使用数组 nums 初始化对象int sumRange(int i, int j) 返回数组 nums 从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点（也就是 sum(nums[i], nums[i + 1], ... , nums[j])）</code></pre><p>示例：</p><pre class="line-numbers language-none"><code class="language-none">输入：[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;][[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]输出：[null, 1, -1, -3]解释：NumArray numArray &#x3D; new NumArray([-2, 0, 3, -5, 2, -1]);numArray.sumRange(0, 2); &#x2F;&#x2F; return 1 ((-2) + 0 + 3)numArray.sumRange(2, 5); &#x2F;&#x2F; return -1 (3 + (-5) + 2 + (-1)) numArray.sumRange(0, 5); &#x2F;&#x2F; return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))</code></pre><p>提示：</p><pre class="line-numbers language-none"><code class="language-none">0 &lt;&#x3D; nums.length &lt;&#x3D; 104-105 &lt;&#x3D; nums[i] &lt;&#x3D; 1050 &lt;&#x3D; i &lt;&#x3D; j &lt; nums.length最多调用 104 次 sumRange 方法</code></pre><h2 id="java解法-6"><a class="markdownIt-Anchor" href="#java解法-6"></a> Java解法</h2><ul><li>法一：构造一个前缀和数组，存储每个位置对应的前缀之后，以后计算中间的和，只需要使用两个前缀和相减即可。虽然感觉构造一个前缀和数组时间复杂度很大，但是可以一次计算，永久使用。（既然他要用一个数组来构造一个对象，想必也是为了这个目的）注意，为了防止越界而使前缀和数组和源数组向后错一位。<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/1293N6.png" alt="1293N6" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class NumArray &#123;    private int[] partialSum;    public NumArray(int[] nums) &#123;        &#x2F;&#x2F;初始默认值为0        partialSum &#x3D; new int[nums.length + 1];        &#x2F;&#x2F;构造前缀和数组        for(int i &#x3D; 0; i &lt; nums.length;i++) &#123;            &#x2F;&#x2F;向后推一位存储            partialSum[i + 1] &#x3D; partialSum[i] + nums[i];        &#125;    &#125;    public int sumRange(int left, int right) &#123;        &#x2F;&#x2F;两边相减得到中间的和，因为前缀和数组向后推了一位，所以下标也要向后推一位        &#x2F;&#x2F;正常是right - (left - 1)        &#x2F;&#x2F;向后推一位的目的是防止计算第一位的前缀时超出边界        return partialSum[right + 1] - partialSum[left];    &#125;&#125;</code></pre><h1 id="12-二维区域和检索-矩阵不可变-304"><a class="markdownIt-Anchor" href="#12-二维区域和检索-矩阵不可变-304"></a> 12. 二维区域和检索 - 矩阵不可变 304</h1><ul><li><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">题目</a></li></ul><hr /><p>给定一个二维矩阵 matrix，以下类型的多个请求：</p><p>计算其子矩形范围内元素的总和，该子矩阵的左上角为<code> (row1, col1)</code> ，右下角为 <code>(row2, col2)</code> 。<br />实现 NumMatrix 类：<br /><code>NumMatrix(int[][] matrix)</code> 给定整数矩阵 matrix 进行初始化<br /><code>int sumRegion(int row1, int col1, int row2, int col2)</code> 返回左上角<code> (row1, col1)</code> 、右下角 <code>(row2, col2) </code>的子矩阵的元素总和。</p><p>示例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/n4dUJm.jpg" alt="n4dUJm" /></p><pre class="line-numbers language-none"><code class="language-none">输入: [&quot;NumMatrix&quot;,&quot;sumRegion&quot;,&quot;sumRegion&quot;,&quot;sumRegion&quot;][[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]输出: [null, 8, 11, 12]解释:NumMatrix numMatrix &#x3D; new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]]);numMatrix.sumRegion(2, 1, 4, 3); &#x2F;&#x2F; return 8 (红色矩形框的元素总和)numMatrix.sumRegion(1, 1, 2, 2); &#x2F;&#x2F; return 11 (绿色矩形框的元素总和)numMatrix.sumRegion(1, 2, 2, 4); &#x2F;&#x2F; return 12 (蓝色矩形框的元素总和)</code></pre><p>提示：</p><pre class="line-numbers language-none"><code class="language-none">m &#x3D;&#x3D; matrix.lengthn &#x3D;&#x3D; matrix[i].length1 &lt;&#x3D; m, n &lt;&#x3D; 200-105 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 1050 &lt;&#x3D; row1 &lt;&#x3D; row2 &lt; m0 &lt;&#x3D; col1 &lt;&#x3D; col2 &lt; n最多调用 104 次 sumRegion 方法</code></pre><h2 id="java解法-7"><a class="markdownIt-Anchor" href="#java解法-7"></a> Java解法</h2><ul><li>法一：一维前缀和叠加，设置一个二维的前缀和数组，前缀和数组的每一行，都是当行数组的一维前缀和数组。<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/img/20210906220738.png" alt="" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">private int[][] partialSum;public NumMatrix(int[][] matrix) &#123;    &#x2F;&#x2F;初始化前缀和数组    partialSum &#x3D; new int[matrix.length][matrix[0].length + 1];    &#x2F;&#x2F;计算前缀和    for(int i &#x3D; 0; i &lt; matrix.length; i++) &#123;        for(int j &#x3D; 0; j &lt; matrix[0].length; j++) &#123;            partialSum[i][j+1] &#x3D; partialSum[i][j] + matrix[i][j];        &#125;    &#125;&#125;public int sumRegion(int row1, int col1, int row2, int col2) &#123;    int sum &#x3D; 0;    &#x2F;&#x2F;逐行扫描，每一行依次用前缀和相减计算中间和    for(int i &#x3D; row1; i &lt;&#x3D; row2; i++) &#123;        sum +&#x3D; (partialSum[i][col2 + 1] - partialSum[i][col1]);    &#125;    return sum;&#125;</code></pre><ul><li>法二：二维前缀和（积分图）<ul><li>结果：</li><li>代码：</li></ul></li></ul><h1 id="13-和为k的子数组-560"><a class="markdownIt-Anchor" href="#13-和为k的子数组-560"></a> 13. 和为K的子数组 560</h1><ul><li><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">题目</a></li></ul><hr /><p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。<br />示例1:</p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [1,1,1], k &#x3D; 2输出：2</code></pre><p>示例2:</p><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [1,2,3], k &#x3D; 3输出：2</code></pre><p>提示：</p><pre class="line-numbers language-none"><code class="language-none">1 &lt;&#x3D; nums.length &lt;&#x3D; 2 * 104-1000 &lt;&#x3D; nums[i] &lt;&#x3D; 1000-107 &lt;&#x3D; k &lt;&#x3D; 107</code></pre><h2 id="java解法-8"><a class="markdownIt-Anchor" href="#java解法-8"></a> Java解法</h2><ul><li>法一：一边计算当前元素的前缀和，一边查找与当前前缀和差值为0的前面的前缀和。将每次计算得到的前缀和存入哈希表中，哈希表的键为前缀和，值为前缀和目前出现的次数。<ul><li>结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/sT7AHQ.png" alt="sT7AHQ" /></li><li>代码：</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SubarraySumEqualsK560 &#123;    public int subarraySum(int[] nums, int k) &#123;        &#x2F;&#x2F;存储子数组计数结果        int res &#x3D; 0;        &#x2F;&#x2F;创建前缀和数组        Map&lt;Integer, Integer&gt; hashPartialSums &#x3D; new HashMap&lt;&gt;();        &#x2F;&#x2F;添加一个0的和，保证从0到当前位置的连续数组和为k能被统计        hashPartialSums.put(0, 1);        &#x2F;&#x2F;存储当前前缀和        int partialSum &#x3D; 0;        &#x2F;&#x2F;初始化前缀和数组        for(int i &#x3D; 0; i &lt; nums.length; i++) &#123;            &#x2F;&#x2F;计算当前前缀和            partialSum &#x3D; partialSum + nums[i];            &#x2F;&#x2F;将当前前缀和及其所出现的次数存入哈希表中            int count &#x3D; hashPartialSums.getOrDefault(partialSum, 0);            &#x2F;&#x2F;查看哈希表中是否存在与当前前缀和差为k的值（这个值肯定是由这个数组前面的元素产生的，只用考虑差值为k），如果有则记录次数            if(hashPartialSums.containsKey(partialSum - k)) &#123;                res +&#x3D; hashPartialSums.get(partialSum - k);            &#125;            &#x2F;&#x2F;当前前缀和次数加一，之所以在检索之后再增加计数            &#x2F;&#x2F; 是因为计算差值不能将自己与自己的差值算上，次数不加，说明只查找当前元素之前            count++;            hashPartialSums.put(partialSum, count);        &#125;        return res;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Java/java/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Java/java/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="java概述"><a class="markdownIt-Anchor" href="#java概述"></a> java概述</h1><p><a href="https://docs.oracle.com/en/java/javase/15/docs/api/index.html">官方文档</a></p><ul><li>java EE：java企业版；java SE：java标准版；java ME：java微型版。</li><li>java<strong>不支持指针</strong>。</li><li>Application：java应用程序；Applet：java小应用程序（嵌入到web页面中，要依赖HTML文件和web浏览器，且没有main()方法）</li><li>Java可以编写Web服务程序。</li><li>Java特性：<ul><li>平台无关性；</li><li>相对C++的简洁性。</li><li>java提供内存管理机制，会自动收集内存垃圾。</li><li>多线程</li><li>分布式：适用于网络</li><li><strong>面向对象</strong>。</li></ul></li><li>封装：将对象内的<strong>数据和代码</strong>联编起来，形成一个对象。</li><li>多态性：一个接口，有多个内在的实现。</li><li>继承：某一对象直接使用另一对象的所有属性和方法的过程。</li><li>JDK：（Java Development Kit)<ul><li>Sun免费提供的Java SE，如：JDK1.8</li><li>GPL许可的Java平台的实现：OpenJDK。</li></ul></li><li>Java程序基本结构：<ul><li><code>.java</code>:源程序文件<ul><li>一个包声明package语句；</li><li>任意数量的import语句；</li><li>类和接口声明</li></ul></li><li><code>.class</code>:经编译后的字节代码程序文件。</li></ul></li><li>Java中的字符使用的是<strong>Unicode标准</strong>，支持汉字在内的多种文字,16位存储，且无符号。</li><li>Java符号：<ol><li>关键字；</li><li>标识符：<ol><li>必须由字母、下划线或美元符开头；</li><li>由字母，数字，下划线和美元符组成；</li><li>不能与关键字同名</li></ol></li><li>常量；</li><li>运算符</li><li>分隔符</li></ol></li><li>取名习惯：<ul><li>类和接口名用<strong>名词</strong>，大小写混写，<strong>第一个字母大写</strong>，如：<code>class WorldTool</code></li><li>方法名用<strong>动词</strong>，大小写混写，<strong>第一个字母小写</strong>，如：<code>depositAccount()</code></li><li>变量用名词或形容词等，大小写混写，<strong>第一个字母小写</strong>，如：<code>currentCustomer</code></li><li>常量符号用<strong>全部大写</strong>，并用<strong>下划线将词分隔</strong>，如：<code>PERSON_COUNT</code></li></ul></li></ul><h1 id="输入和输出"><a class="markdownIt-Anchor" href="#输入和输出"></a> 输入和输出</h1><ul><li>使用<code>Scanner in = new Scanner(System.in);</code>可以定义一个可以接受输入的东西<code>in</code>（名字是任取的。）。之后要接受输入时，就使用形如<code>in.nextline()``in.nextint()</code>的语句。（其中line与int表示接受的输入的数据类型，line是字符串，int是整型）。</li><li>使用<code> System.out.println();</code>可以直接输出字符串并且在每一次输出后都换行，还有<code>System.out.print()</code>，它与前者的区别是在每一次输出后不换行。</li><li><code>System.out.prinf()</code>这个输出的用法与c语言中的printf()类似，可以有<code>System.out.printf(&quot;%.2f&quot;,i)</code>这样的类似c语言的格式限制。</li><li>Java的注释和c语言一样，可以用<code>//</code>和<code>/**/</code>，还有<code>/** */</code>用来为注释javadoc标明。</li></ul><h1 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h1><ul><li>变量的定义：&lt;类型名称&gt; &lt;变量名&gt;;</li><li>变量的名字(又叫做标识符）只能由字母，数字和下划线组成，且数字不可以出现在第一个位置上。Java的内置的关键字不可以用作变量名。</li><li>Java是一种强类型语言，变量在使用前必须声明，且变量具有确定的类型。</li><li>所有被声明的成员变量都是有默认值的。例如：数字类型的默认值为0,引用类型的默认值为<strong>null</strong>，布尔值为<strong>false</strong>。不过方法中<strong>局部变量声明后不会进行默认的初始化</strong>,所以必须进行明确初始化。</li></ul><h1 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h1><ul><li>类似变量的定义声明，常量只需要在定义时在类型前加上关键词<code>final</code>。常量只能在定义时赋值初始化，之后不能再赋值。</li><li>可以在类中定义final类型的实例字段。如果在定义时没有给final类型的变量赋值，那么就可以在<strong>构造器</strong>（也只有在构造器中，其他方法不行）中为它赋值</li><li><strong>变量的作用域</strong>：总的来说，Java中变量的作用域就是在它被定义的花括号之内。如，在for循环内部定义的就只在该循环内有效，在函数内部定义的就只在函数内部有效。</li><li>常量符号命名规范：全部大写，并用下划线将词分隔，如:<code>PERSON_COUNT</code>.</li></ul><h1 id="运算"><a class="markdownIt-Anchor" href="#运算"></a> 运算</h1><h2 id="赋值"><a class="markdownIt-Anchor" href="#赋值"></a> 赋值</h2><ul><li>同c语言一样，Java依旧使用<code>=</code>来进行赋值。</li><li>在定义变量的时候可以进行赋值（此时叫做变量的初始化）。</li><li>赋值运算是自右向左。</li></ul><h3 id="复合赋值"><a class="markdownIt-Anchor" href="#复合赋值"></a> 复合赋值</h3><ul><li>同c语言一样，Java中也有复合赋值，即<code>+=, -=, *=, /=</code>。用法与c语言完全一致。<code>a += b + c</code>与<code>a = a + (b + c)</code>完全相同。</li></ul><h2 id="四则运算"><a class="markdownIt-Anchor" href="#四则运算"></a> 四则运算</h2><ul><li>当浮点数和整数放在一起运算时，Java会将整数先转化为浮点数，之后进行浮点数的运算。</li><li><code>+，-，*,/ , %</code>的运算优先级和惯常的优先级一致。特别的，<code>%</code>对于小数也可以使用。</li><li>赋值号<code>=</code>的优先级很低，以保持和正常思维一样的运算顺序。</li><li>Java中同样有<code>i++, ++i</code>这种运算，用法与c语言完全相同。</li></ul><h2 id="位运算"><a class="markdownIt-Anchor" href="#位运算"></a> 位运算</h2><ul><li>位运算是用来处理整型数据的。</li><li>位运算符包括<code>&amp;(and), |(or), ^(xor), ~(not)，&gt;&gt;, &lt;&lt;, &gt;&gt;&gt;</code>.</li><li><code>&amp;, |, ^, ~</code>是对每一位进行和，或，异或，非的运算。</li><li><code>&gt;&gt;,&lt;&lt;</code>是将位左移或者右移。<code>&gt;&gt;</code>用符号位填充高位。<ul><li>位运算是将值转换位2进制来进行移位，如：<code>1 &lt;&lt; 1</code>,表示将1的二进制数左移一位，结果是2。</li></ul></li><li><code>&gt;&gt;&gt;</code>进行左移，但是用0来填充高位。</li></ul><h2 id="单目运算符"><a class="markdownIt-Anchor" href="#单目运算符"></a> 单目运算符</h2><ul><li>取正<code>+</code>和取负<code>-</code>,运算优先级高于普通的双目运算符。</li><li><code>++</code>和<code>--</code>java也同样使用。</li><li><code>~</code>:按位求补。</li></ul><h2 id="条件运算符"><a class="markdownIt-Anchor" href="#条件运算符"></a> 条件运算符</h2><ul><li><code>expreBool?expression1 : expression2</code>：条件为true则执行表达式1，否则执行2.</li><li>如：<code>int c = (a &gt; b)? 1 : 2;</code></li></ul><h1 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h1><h2 id="整型"><a class="markdownIt-Anchor" href="#整型"></a> 整型</h2><ul><li>整数类型不能表达有小数部分的数。整数与整数的运算结果还是整数。</li><li>Java中所有的数字都是<strong>有符号</strong>的，没有无符号类型。</li><li><code>int</code>型：32位 ，如果整型常量后面没有L，则默认为int型</li><li><code>long</code>型：64位</li><li><code>short</code>型：16位</li></ul><h3 id="整数型常量"><a class="markdownIt-Anchor" href="#整数型常量"></a> 整数型常量</h3><ul><li>三种形式<ol><li>十进制整数：是由不以0开头，0~9数字构成的数据；</li><li>八进制整数：是由<strong>以0开头</strong>，0~7数字组成的数据：012（与十进制数字10值相等）；</li><li>十六进制整数：是由<strong>0x或者0X</strong>开头，0<sub>9数字及A</sub>F的字母组成的数据：0x1F（与十进制数字31相等）</li></ol></li></ul><h2 id="浮点型"><a class="markdownIt-Anchor" href="#浮点型"></a> 浮点型</h2><ul><li>浮点数就是通常所说的小数。</li><li><code>double</code>型的浮点数：12.23d/12.23D/12.23（不带字母时默认小数为double类型）  64位存储</li><li><code>float</code>:12.23f/12.23F 32位存储</li><li>带指数的数：如<code>2E2</code>,他的结果是200，即E2代表科学计数法的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">10^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>,虽然<strong>结果为整数但是仍然是double类型</strong>。</li></ul><h2 id="布尔类型"><a class="markdownIt-Anchor" href="#布尔类型"></a> 布尔类型</h2><ul><li>Java中的布尔类型是用<code>boolean</code>定义的，其含义与用法与c语言中的bool类型一致。但是整型与boolean是严格区分的，即将boolean类型变量赋为0或者1是不行的。</li></ul><h2 id="字符类型"><a class="markdownIt-Anchor" href="#字符类型"></a> 字符类型</h2><ul><li>单个字符类型是char，其字符字面量是用<strong>单引号</strong>来表示的，如’a’,'4’等。Java中的字符使用的是Unicode标准，支持汉字在内的多种文字,16位存储，且无符号。</li><li>类似C语言中的字符类型，可以对字符变量进行加减运算。如<code>i = 'A' - 'D'</code>中的i为3，也可以强制将字符类型转换为int类型。</li><li><strong>逃逸字符</strong>：有些没有办法打印出来的字符，这些字符由一个反斜杠<code>\</code>开头，后面跟上一个字符，由这两个字符合起来组成一个字符。常见逃逸字符：</li></ul><table><thead><tr><th>字符</th><th>意义</th></tr></thead><tbody><tr><td>\b</td><td>回退一格</td></tr><tr><td>\t</td><td>到下一个表格位</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>&quot;</td><td>双引号</td></tr><tr><td>'</td><td>单引号</td></tr><tr><td><code>\\</code></td><td>反斜杠本身</td></tr></tbody></table><h2 id="包裹类型"><a class="markdownIt-Anchor" href="#包裹类型"></a> 包裹类型</h2><ul><li>每种基础类型（如，int，double，char）都有对应的包裹类型。</li><li>包裹类型除了具有和基础类型一样的功能外（如定义变量），还有许多可以实现的功能。如<code>Integer.MAX_VALUE</code>,可以得到int类型的最大值。即使用包裹类型可以调用许多java内置的方法。</li><li>包裹类型的第一个字母是大写的。</li><li>各种基础类型对应的包裹类型。</li></ul><table><thead><tr><th>基础类型</th><th>包裹类型</th></tr></thead><tbody><tr><td>int</td><td>Integer</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h2 id="引用类型"><a class="markdownIt-Anchor" href="#引用类型"></a> 引用类型</h2><ul><li>引用类型（数组，class或interface）在声明变量时是<strong>不会为变量（即对象）分配存储空间</strong>的，所以即使声明了也不可直接使用，需要使用<strong>new运算符为引用类型的分配存储空间，完成初始化</strong>之后才能正常使用。</li></ul><h2 id="字符串变量"><a class="markdownIt-Anchor" href="#字符串变量"></a> 字符串变量</h2><ul><li><p><strong>字符串字面量</strong>：用<strong>双引号</strong>括起来的0或者多个字符为一个字符串字面量。如：“hello”</p><ul><li>字符串字面量可以直接调用String类型的方法,如：<code>&quot;hello&quot;.toUpperCase();</code></li><li>字符串字面量就是String类型的一个<strong>匿名对象</strong>。</li></ul></li><li><p><strong>字符串类型</strong>：<code>String</code>是字符串类型（第一个字母为大写，是一种包裹类型），String是一个类，String类型的变量是字符串的管理者而非所有者（就和数组变量和数组一样。）</p></li><li><p><strong>字符串变量的创建</strong>：</p><ul><li><p>法一：<code>String s = new String(字符串字面量)</code>.用字符串字面量初始化字符串变量。也可以直接初始化一个字面量，如<code>String s = &quot;hello&quot;</code>。</p><ul><li><p>相同内容的字符串字面量在内存中默认是同一个字符串对象。</p></li><li><p>但是同样的字符串字面量传递给String类构造器之后构造出来的就不是一个对象了。</p></li><li><p>示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String s1 &#x3D; &quot;zhangjie&quot;;String s2 &#x3D; &quot;zhangjie&quot;;String s3 &#x3D; new String(&quot;zhangjie&quot;);s1 &#x3D;&#x3D; s2;&#x2F;&#x2F;trues1 &#x3D;&#x3D; s3;&#x2F;&#x2F;false&#x2F;&#x2F;&#x3D;&#x3D;用于对象之间，只会判断引用的是否是同一个对象，不会管内容是否相同</code></pre></li></ul></li><li><p>法二：使用<code>StringBuider &lt;字符串名&gt; = new StringBuilder();</code>可以创建一个空的字符串(但是这样创建的不是String类型，而是StringBuilder类型的变量了，使用<code>&lt;字符串名&gt;.append(ch)</code>或者&lt;字符串名&gt;.append(str)`来给字符串追加内容。(更多方法请查阅java.lang.StringBuilder)</p></li></ul></li><li><p><strong>字符串的连接</strong>：使用<code>+</code>可以将两个字符串连接起来，如果<code>+</code>两边的不是字符串类型，它会自动将非字符串类型的转为字符串类型。</p></li><li><p><strong>字符串的读入</strong>：使用<code>in.nextline()</code>能直接读入一个字符串，字符串之间以回车为表示。（使用<code>in.next()</code>可以读入单词，每个单词之间用空格隔开。）</p></li><li><p>字符串是<strong>只读</strong>的变量，不可以通过赋值来修改。</p></li><li><p><strong>String[]<strong>代表的是</strong>字符串数组</strong>，即一个元素类型为String类型的数组。注意与String类型的区分。</p></li></ul><h3 id="字符串的操作"><a class="markdownIt-Anchor" href="#字符串的操作"></a> 字符串的操作</h3><ul><li><p>字符串的数据是对象，可以通过<code>.</code>来调用其方法来实现对字符串的操作。</p></li><li><p><strong>字符串的比较</strong>：<code>s.compareTo(s1)</code>;</p></li><li><p><strong>获得字符串的长度</strong>：<code>s.length()</code>;</p></li><li><p><strong>访问字符串中的单个字符</strong>：<code>s.charAt(3)</code>.(3是字符的索引，类似数组，但不可直接像访问数组中元素一样使用a[i]这样的访问)。</p></li><li><p><strong>判断两个字符串是否相同</strong>：<code>s.equals(s1)</code>.</p><ul><li><code>==</code>用于对象之间，只会判断引用的是否是同一个对象，不会管内容是否相同;</li><li>而<code>equal()</code>判断是否相同的依据是它们的内容是否相同。</li></ul></li><li><p><strong>获得字符串的子串</strong>：<code>s.substring(2,4)</code>或者<code>s.substring(2)</code>,括号中是字符的索引，单独的2代表从索引为2以后开始的子串，但是（2，4）代表从索引为2字符以后开始，到索引为4字符之前。</p></li><li><p><strong>寻找字符串中的字符</strong>：<code>s.indexOf(c)</code>或者<code>s.indexOf(c,n)</code>或者<code>s.indexOf(s1)</code>。括号中只有字符c代表找到字符串中c字符所在位置的索引。（c，n）表示从n位置开始寻找c字符，s1为字符串变量，（s1）能找到字符串s1所在的位置。还可以从右边开始找<code>s.lastIndexOf(同普通的)</code>.</p><h2 id="stringbuffer"><a class="markdownIt-Anchor" href="#stringbuffer"></a> StringBuffer</h2><ul><li><strong>StringBuffer</strong>是线程安全的可变字符序列。每个字符串缓冲区都有一定的容量。只要字符串缓冲区所包含的字符序列的长度没有超出此容量，就无需分配新的内部缓冲区数组。如果内部缓冲区溢出，则此容量自动增大。从 JDK 5 开始，为该类补充了一个单个线程使用的等价类，即 StringBuilder。与该类相比，通常应该优先使用StringBuilder类，因为它支持所有相同的操作，但由于它是异步的，所以速度更快。</li></ul></li></ul><h2 id="强制类型转换"><a class="markdownIt-Anchor" href="#强制类型转换"></a> 强制类型转换</h2><ul><li>Java同c语言一样，有很多隐式转换。例如整型在某些条件下会自动转为浮点型。</li><li>但是浮点型不会自动转换为整型（<strong>大不会自动转小</strong>）。我们可以进行强制类型转换。例如：<code>int a = (int)(32 /5 .0)</code>。</li></ul><h2 id="var声明局部变量"><a class="markdownIt-Anchor" href="#var声明局部变量"></a> var声明局部变量</h2><ul><li>当变量的类型可以<strong>从它的初始值中推导出来</strong>时，可以使用var关键字来声明，而无需指明其类型。如：<code>Employee harry = new Employee();</code>可以写作<code>var harry = new Employee();</code>。</li><li>var关键字只能用于方法中的局部变量，<strong>参数和实例字段</strong>的类型必须明确声明。</li></ul><h1 id="关系运算"><a class="markdownIt-Anchor" href="#关系运算"></a> 关系运算</h1><ul><li>关系运算符：<code>==, &gt;, &lt;, &gt;=, &lt;=, !=</code>与C语言一致。</li><li>关系运算符的优先级比算术运算符低，但是比赋值运算高。例如：<code>7 &gt; 3 + 2</code>。</li><li>判等和判不等<code>==, !=</code>的优先级比<code>&lt;, &lt;=, &gt;, &gt;=</code>低.例如：<code>5 &gt; 3 == 6 &gt; 4</code>是可行的（但是和c语言一样，尽量不要连续使用关系运算。）</li><li><code>&lt;, &gt;, &gt;=, &lt;=</code>是不能连续使用的，例如：<code>a &gt; b &gt; c</code>是和你的想象完全不同的。</li></ul><h2 id="浮点数的比较"><a class="markdownIt-Anchor" href="#浮点数的比较"></a> 浮点数的比较</h2><ul><li>整型是可以与浮点数进行比较的。</li><li>浮点数的运算有误差。所以判断两个浮点数是否相等是用<code>Math.abs(a -b) &lt; 1e-6</code>.先用<code>Math.abs(a - b)</code>算出两个浮点数之间的差值，在让这个差值和一个很小的数比较。<code>1e-6</code>表示的是1的负6次方。</li></ul><h1 id="控制语句"><a class="markdownIt-Anchor" href="#控制语句"></a> 控制语句</h1><h2 id="条件语句"><a class="markdownIt-Anchor" href="#条件语句"></a> 条件语句</h2><h3 id="if语句"><a class="markdownIt-Anchor" href="#if语句"></a> if语句</h3><ul><li>与c语言类似，只有一个语句时可以不用花括号（但是建议不管多少语句都用花括号），但是有多条语句时必须括起来。</li><li>类似c语言，Java中的if语句同样可以与else连用，进行级联条件判断。</li></ul><h3 id="swich语句"><a class="markdownIt-Anchor" href="#swich语句"></a> swich语句</h3><ul><li>Java中同样有switcl-case语句。用法也与c语言相同。</li><li>示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">switch (控制表达式) &#123;    case 常量：        语句        ...        break;    case 常量：        语句        ...        break；    ...    default:        语句        ...&#125;</code></pre><ul><li>控制表达式，只能是<strong>整型</strong>或者与整型相容（如byte short char）的结果，布尔型也不行；</li><li>每个case后面都要有<strong>break</strong>语句。</li><li>如果所有的case都不匹配，就执行default后面的语句；如果没有设置default语句，就什么也不做。(default后面直接接冒号，<strong>没有条件</strong>。default后面的语句<strong>不用</strong>放break来终止。）</li></ul><h2 id="循环语句"><a class="markdownIt-Anchor" href="#循环语句"></a> 循环语句</h2><h3 id="while"><a class="markdownIt-Anchor" href="#while"></a> while</h3><ul><li>与c语言中的while基本一致。 while是<strong>当条件满足时</strong>执行循环内的语句。</li><li>与c语言一样，Java中也有<code>do-while</code>循环，这个循环至少执行一次。do-while循环是一直执行直到while语句中的条件<strong>不满足</strong>。（while判断之后要接<code>;</code>）</li></ul><h3 id="for循环"><a class="markdownIt-Anchor" href="#for循环"></a> for循环</h3><ul><li>Java中也有for循环，用法与c语言基本相似。</li><li>但是Java可以在循环条件语句中定义变量，并且在for循环中定义的变量只能在for循环中使用，在循环体外并没有那个变量的定义。例如：<code>for(int i =  1; i &lt;= n; i = i + 1 )&#123;&#125;</code>。（for循环适合有明确结束条件的循环。）</li><li><code>break</code>语句在Java中与c语言中一致，用于跳出循环。</li><li><code>continue</code>语句也是与c语言一样，用于到达循环尾。(但是continue语句<strong>不会跳过for循环的步进语句</strong>，例如：<code>for(int i = 0; i &lt;= n; i++)&#123;continue;&#125;</code>， 每次continue语句之后还是要执行i++之后再开启下一轮循环。)。</li><li><strong>循环的标号</strong>：可以在循环前设置一个标号（例如;<code>out:</code>）来标示循环。使用<code>break  标号</code>和<code>continue 标号</code>可以使break和continue对标号标示的循环起作用。示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">OUt:for(int i &#x3D; 0; i &lt;&#x3D; n1; i++)&#123;    for(int j &#x3D; 0; j &lt;&#x3D; n2; j++)&#123;        break OUT;    &#125;&#125;</code></pre><p>OUT标示的循环是最外层的循环，使用<code>break OUT</code>能直接跳出最外层的循环。</p><ul><li><strong>for-each</strong>循环：形如:<code>for (int i : numbers)&#123;&#125;</code>,意思是每一次循环，一次将数组numbers中的元素值赋给变量i。常用于遍历数组（foreach循环不能用于遍历字符串，即java中字符串与数组没有c语言中那么亲密的关系）。<strong>接收数组中元素的变量必须是在for中定义的</strong>。 示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">int[] numbers &#x3D; new int[100];&#x2F;&#x2F; 依次遍历数组中每个元素，并在数组遍历完之后停止循环。for (int i : numbers) &#123;    if (i &#x3D;&#x3D; 23) &#123;        System.out.println(&quot;numbers数组中有23这个数&quot;)；        break；    &#125;&#125;&#x2F;&#x2F;错误使用int i;for(i : numbers) &#123;    System.out.println(i);&#125;</code></pre><h1 id="逻辑类型"><a class="markdownIt-Anchor" href="#逻辑类型"></a> 逻辑类型</h1><ul><li>关系运算的结果是一个逻辑值，true或者false。这个值保存在一个对应的逻辑类型的变量中，这个类型是boolean。与c语言的布尔类型一样，Java中的布尔类型也只有true和false这两种值。</li></ul><h2 id="逻辑运算"><a class="markdownIt-Anchor" href="#逻辑运算"></a> 逻辑运算</h2><ul><li><strong>!</strong>:逻辑非。</li><li><strong>&amp;&amp;</strong>：逻辑与。</li><li><strong>||</strong>：逻辑或。三者都与c语言中的逻辑运算的用法一致。</li></ul><h1 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h1><ul><li>数组定义：形如<code>int[] numbers = new int[100]</code>。<strong>动态初始化</strong>格式范式：<code>&lt;类型&gt;[] &lt;名字&gt; = new &lt;类型&gt;[元素个数]</code>（同c语言一样，数组的下标是从0开始的，后面方括号中是数组中元素的个数(可以为变量，但是必须有）。但是实际只有numbers[99], 而没有numbers[100].)</li><li>数组一旦创建，<strong>不能被改变大小</strong>。</li><li>数组本身是一个<strong>引用数据类型</strong>。</li><li>数组中的所有元素是<strong>同一类型</strong>。</li><li>java中的每个数组有一个内部成员length,这个变量中存储了数组中元素的个数（即创建数组时确定的元素个数）。使用示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">int[] numbers &#x3D; new int[100];for(int i &#x3D; 0; i &lt; numbers.length; i++) &#123;    ...&#125;</code></pre><ul><li>数组的<strong>直接（静态）初始化</strong>：形如：<code>int[] numbers = new int[] &#123;1, 2, 3, 4, 5&#125;;</code>也可以省略书写<code>int[] numbers = &#123;1, 2,3&#125;;</code></li><li>初始化的语句可以拆分为两个步骤：<code>int[] array; array = new int[5]</code>或者<code>int[] array; array = new int[] &#123;1, 2, 3&#125;;</code>声明不能创建数组对象本身，只能创建一个引用。数组对象由new语句创建。</li><li>数组变量之间可以做赋值。例如：<code>int[] numbers = &#123;1, 2, 3, 4, 5&#125;; int[] b = numbers;</code>.数组变量的实质与c语言类似，是指向实际存储空间的“指针”，但是Java中不使用指针的概念，可以把数组变量看作是实际存储空间的管理者。所以数组变量之间的赋值，其实质是将对实际存储空间的管理权共享了出去，而不是把整个数组复制过去。因此，如果改变了b数组中，某个元素的值，numbers数组中相应的元素也会跟着改变。如<code>b [2] = 3;</code>之后会有<code>numbers[2] == 3</code>.</li><li><strong>拷贝</strong>数组元素到另一个数组中：<code>var a = new X[list.size]; list.toArray(a)</code>。将list数组的元素拷贝到a数组中去。（适用于各种类型的数组，包括泛型数组列表）</li><li>对数组对象的操作需要使用<strong>Arrays</strong>类中的方法。</li><li>main函数必须带的参数<code>String[] args</code>是main函数接收命令行参数的字符串类型的数组。</li><li>数组变量之间的比较，是在比较两个数组变量是否管理同一个数组，而不是比较两个数组是否是每个元素都对应相等。</li><li>刚创建的int类型数组，数组中的元素<strong>默认</strong>都是0。double类型为0.0,boolean类型为false等。</li><li><strong>二维数组</strong>：定义形如<code>int[][] numbers = new int[3][5];</code>;与c语言类似，通常理解为矩阵。二维数组初始化：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">int[][] numbers &#x3D; &#123;    &#123;1, 2, 3, 4&#125;, &#x2F;&#x2F;每一行用逗号，分隔。    &#123;5, 6, 7&#125;, &#x2F;&#x2F;第二行比第一行少了一个元素，编译器会自动补上0；&#125;;&#x2F;&#x2F;别忘了最后的分号。</code></pre><ul><li><p>二维数组中仍然有length变量表示数组的长度。<code>numbers.length</code>表示数组的的行数。而每一行有多少个元素需要用<code>numbers[i].length</code>。</p></li><li><p>多维数组的实质是元素类型为数组的一维数组。</p><ul><li><p>必须对前面的维的数组（即低维数组）初始化，才能对它后面的维依次进行初始化。</p></li><li><p>可以每一维元素分步初始化，来创建非矩形的数组。</p></li><li><p>示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int[][] numbers &#x3D; new int[2][];numbers[0] &#x3D; new int[5];numbers[1] &#x3D; new int[8];</code></pre></li></ul></li></ul><h1 id="math类"><a class="markdownIt-Anchor" href="#math类"></a> Math类</h1><ul><li>Math类提供的很多数学操作，如取绝对值等。</li><li><code>abs</code>提供取绝对值操作，<code>.round</code>提供四舍五入的操作，<code>.random</code>提供取随机数（0到1之间）的操作，<code>.pow</code>可以进行幂运算。</li><li>使用示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">Math.abs(-12); &#x2F;&#x2F;结果为12Math.round(10.2343); &#x2F;&#x2F;结果为10Math.random(); Math.pow(2, 3); &#x2F;&#x2F;结果为2的3次方：8</code></pre><h1 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h1><h2 id="方法定义"><a class="markdownIt-Anchor" href="#方法定义"></a> 方法定义</h2><ul><li>方法可以接收0个或者多个参数，做一件事，并返回0个或者一个值。</li><li>方法定义：函数头（函数名，返回类型，参数表），函数体。函数定义示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static boolean sum(int a, int b) &#123;    ...    return true;  &#125;</code></pre><h2 id="方法调用"><a class="markdownIt-Anchor" href="#方法调用"></a> 方法调用</h2><ul><li>方法单独调用格式：<code>方法名（参数）</code>,注意，即使方法不需要参数，也需要括号。</li><li>方法可能会有返回值，此时需要有对应的变量来接收返回值。void类型的方法是没有返回值的。</li><li>传递给方法的参数类型要匹配，如果类型不匹配，则在某些情况下方法会自动转换。（条件是方法需要的类型比实际传进来的参数类型“宽”，如double类型比int类型宽。）。</li><li>传递给方法的参数，实际是传的<strong>值</strong>，即没有传进去变量本身，而只是变量值的一个副本。在方法内部是无法修改传进来的参数的值的。<ul><li><strong>基本类型</strong>：在方法调用时，实际参数将其存储单元的数据赋值给形式参数；</li><li><strong>引用类型</strong>：在方法调用，引用类型虽然也是将其复制给形式参数，但是实际引用的对象却并没有发生改变，所以形式变量对引用中的对象值改变<strong>会影响</strong>到实际参数引用的对象值。</li></ul></li><li>方法调用流程：<ol><li>找到方法定义；</li><li>参数传递；</li><li>执行方法体；</li><li>带着返回值回到方法的调用处。</li></ol></li></ul><h2 id="方法的本地变量"><a class="markdownIt-Anchor" href="#方法的本地变量"></a> 方法的本地变量</h2><ul><li><p>同c语言一样，Java方法内部定义的变量在方法外部是不可见的。方法内部定义的本地变量，只在方法内部有效。</p></li><li></li></ul><h1 id="类与对象"><a class="markdownIt-Anchor" href="#类与对象"></a> 类与对象</h1><h2 id="类的初始化"><a class="markdownIt-Anchor" href="#类的初始化"></a> 类的初始化</h2><h2 id="类与对象的基本定义"><a class="markdownIt-Anchor" href="#类与对象的基本定义"></a> 类与对象的基本定义</h2><ul><li><strong>类</strong>：定义同一类事物，Java中所有的代码都位于某个类里。（类的第一个字母要大写）<ul><li>类包括三个部分：类声明，类成员，类的构造器（方法）。</li></ul></li><li>类定义示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Hero &#123;         String name; &#x2F;&#x2F;姓名         float hp; &#x2F;&#x2F;血量         float armor; &#x2F;&#x2F;护甲         int moveSpeed; &#x2F;&#x2F;移动速度&#125;</code></pre><ul><li><strong>对象</strong>：类就像是一个模板，根据这个模板可以创建很多同一类的东西，这些根据类创建出来的东西就是对象。由类构造对象的过程叫做<strong>实例化</strong>。对象创建示例:</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Hero &#123;         String name; &#x2F;&#x2F;姓名         float hp; &#x2F;&#x2F;血量         float armor; &#x2F;&#x2F;护甲         int moveSpeed; &#x2F;&#x2F;移动速度         public static void main(String[] args) &#123;        Hero garen &#x3D;  new Hero(); &#x2F;&#x2F;对象的创建类似于数组或者String类型的变量的创建。        garen.name &#x3D; &quot;盖伦&quot;;        garen.hp &#x3D; 616.28f;        garen.armor &#x3D; 27.536f;        garen.moveSpeed &#x3D; 350;                 Hero teemo &#x3D;  new Hero();        teemo.name &#x3D; &quot;提莫&quot;;        teemo.hp &#x3D; 383f;        teemo.armor &#x3D; 14f;        teemo.moveSpeed &#x3D; 330;    &#125;       &#125; &#x2F;&#x2F;英雄是一个大类，而具体的每个英雄则是一个对象</code></pre><ul><li><strong>属性（成员变量）</strong>：类中定义的变量就是类的属性(类中的数据又叫做<strong>实例字段</strong>），类中的属性就像一种东西的各种属性。属性可以是基本类型（如int等）也可以是<strong>类类型</strong>（如String等）.属性名称一般是小写，但是如果由两个及以上单词组成，则从第二个单词开始，首字母大写。<ul><li>类中的实例字段只能由自己类中的方法来直接访问。换句话说，成员变量的作用域在类中是<strong>全局</strong>的，能被类中所有的方法所访问。</li><li>所有对象的实例字段描述了对象当前状况的信息，这就是对象的<strong>状态</strong>。</li></ul></li><li><strong>方法</strong>：类中的东西不仅具有属性，它还会做事情，能做的事情就是类中的方法。（方法的实质是在类中定义的函数）.方法的命名方法与属性一样。方法与属性的调用方法都是通过在对象后使用<code>.</code>。<ul><li>通常的类没有main方法，却有自己的实例字段和方法。要想构建一个完成的程序，会使用多个类，但是<strong>只有一个类有main方法</strong>。</li></ul></li><li>示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Hero &#123;    String name; &#x2F;&#x2F;姓名          float hp; &#x2F;&#x2F;血量          float armor; &#x2F;&#x2F;护甲          int moveSpeed; &#x2F;&#x2F;移动速度     &#x2F;&#x2F;Hero方法:坑队友    void keng()&#123;        System.out.println(&quot;坑队友！&quot;);    &#125;&#125;</code></pre><h2 id="对象变量"><a class="markdownIt-Anchor" href="#对象变量"></a> 对象变量</h2><ul><li>不是基本类型而是类类型的变量，又叫做<strong>对象变量</strong>，对象变量可以用来引用该类的对象。</li><li>对象的生命周期：<ol><li>创建：声明，实例化；</li><li>使用：通过对象名对成员的访问；</li><li>销毁：实例开销的回收，由JVM自动完成，对象在被作为垃圾收集前自动调用从Object继承的<code>finalize()</code>方法来清楚自己所占用的资源。</li></ol></li><li>对象的创建时用<code>new Hero()</code>,但是创建的对象需要一个变量来接收才能使用，于是<code>Hero h = new Hero()</code>，此时的<code>=</code>不再是对于基本类型的赋值的意思，而是<strong>指向</strong>的意思。这个Hero类型的变量h就又叫做引用。（用c语言指针的概念来理解：就是h指向刚创建的Hero对象，但是Java中没有指针这个概念，所以只是一种理解）</li><li>对象变量可以<strong>赋值</strong>，如<code>Date deadline = birthday</code>(birthday也是一个对象变量，现在这两个对象变量引用同一个对象)。对象变量可以赋值为<strong>null</strong>，代表这个对象变量当前没有引用任何对象。</li><li>对象变量的值除了用new操作符，使用构造器获得外，还可以调用返回对象的引用的方法来赋值。如`DayOfWeek weekday = date.getDayOfWeek();</li><li>根据引用的概念，对象的创建又可以写为：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Hero &#123;          String name; &#x2F;&#x2F;姓名          float hp; &#x2F;&#x2F;血量          float armor; &#x2F;&#x2F;护甲          int moveSpeed; &#x2F;&#x2F;移动速度          public static void main(String[] args) &#123;        &#x2F;&#x2F;创建一个对象,但是没有引用。        new Hero();                 &#x2F;&#x2F;使用一个引用来指向这个对象        Hero h &#x3D; new Hero();             &#125;        &#125;</code></pre><ul><li>（类比c语言的指针），可以有多个引用指向同一个对象，但是一个引用不能同时指向多个对象。</li></ul><h2 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h2><ul><li>如果另一类东西有已经定义的某一类东西全部属性，则可以通过继承来避免属性的重复定义。</li><li>继承的特性：<ol><li><strong>单一继承性</strong>：子类只能有<strong>一个超类</strong>。</li><li>子类<strong>不能继承超类的构造器</strong>，只能通过<code>super()</code>来调用超类的构造器。</li><li>子类的构造器<strong>首先要调用超类的构造器</strong>。</li><li>子类的成员<strong>隐藏和覆盖超类中相同的成员</strong>。（多态性）</li><li>超类的对象可以对子类的实例进行引用。（多态性）</li><li>由<strong>abstract修饰的类必须被继承</strong>。</li><li>由<strong>final修饰的类不能被继承</strong>。</li></ol></li><li>继承是一种<code>is-a</code>关系，即子类包含于父类中，子类的特性（字段和方法）<strong>更多</strong>。例如：人类是一个父类，而男人可以作为人类的一个子类。</li><li>父类又称为：超类、基类；子类又称为：派生类、孩子类。</li><li>子类从父类那里继承了<strong>方法</strong>和<strong>字段</strong>：<ul><li>子类只可以访问从超类继承下来的三种访问权限设定的成员：<strong>public,protected以及缺省的</strong>。</li><li>如果是在父类中用private修饰的<strong>私有字段</strong>和<strong>私有方法</strong>（大多数时候是私有字段），虽然被子类继承，但是子类却<strong>无法访问</strong>。</li></ul></li><li>根据对象的多态性，可以将<strong>子类对象赋给父类引用变量</strong>，但是反之不行。因为如果将父类对象赋给子类的引用变量，如果这个变量调用子类特有的方法就会出错。但是父类中的方法，子类对象都具有，所以不会出错。<ul><li>超类引用子类的的实例，只能调用超类中定义了的方法；</li><li>对于被覆盖的方法，java运行时是根据实例的类型来选择调用哪个方法。即如果用超类引用子类的实例，调用被子类覆盖了的方法，那么执行的是子类中重新定义的方法。</li></ul></li><li>继承是通过关键字<code>extends</code>来实现的。示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Item &#123;    String name;    int price;&#125;&#x2F;&#x2F; 非继承的写法，武器是一种物品。public class Weapon&#123;    String name;    int price;    int damage; &#x2F;&#x2F;攻击力 &#125;&#x2F;&#x2F;继承的写法public class Weapon extends Item&#123; &#x2F;&#x2F; 通过extends来实现继承    int damage; &#x2F;&#x2F;攻击力         public static void main(String[] args) &#123;        Weapon infinityEdge &#x3D; new Weapon();        infinityEdge.damage &#x3D; 65; &#x2F;&#x2F;damage属性在类Weapon中新设计的                 infinityEdge.name &#x3D; &quot;无尽之刃&quot;;&#x2F;&#x2F;name属性，是从Item中继承来的，就不需要重复设计了        infinityEdge.price &#x3D; 3600;             &#125;     &#125;</code></pre><h3 id="方法覆盖重写"><a class="markdownIt-Anchor" href="#方法覆盖重写"></a> 方法覆盖（重写）</h3><ul><li>父类中的某些方法可能对子类不适用，此时就需要在子类中重新写一个<strong>名字相同（方法名，参数，返回数据类型都相同）但是实现不同</strong>的方法。</li><li>注：方法过载是在一个类中具有相同方法名不同参数的方法。</li></ul><h3 id="super"><a class="markdownIt-Anchor" href="#super"></a> super</h3><ul><li>super关键字可以在子类中调用父类的方法。</li><li>super关键字可以在子类中调用父类的构造器。如<code>super(name,salry)</code>。具体调用父类的哪个构造器是由参数的数目和类型决定的。</li><li>另外，经常是在子类的构造器中调用父类的构造器来节省部分代码，但是<strong>super调用构造器的语句只能作为子类构造器的第一个语句</strong>出现。</li></ul><h3 id="继承层次"><a class="markdownIt-Anchor" href="#继承层次"></a> 继承层次</h3><ul><li>由一个公共父类派生出来的所有类的集合称为<strong>继承层次</strong>。</li><li>在继承层次中从某个特定的类到其祖先的路径称为该类的<strong>继承链</strong>。</li></ul><h3 id="阻止继承final类与方法"><a class="markdownIt-Anchor" href="#阻止继承final类与方法"></a> 阻止继承：final类与方法</h3><ul><li>被声明为final的类，是不能被继承的。声明格式<code>public final class Hello &#123;...&#125;</code>。</li><li>方法也可以被声明为final，这代表这个方法不能在子类中被<strong>覆盖（重写）</strong>。final类中的所有方法都被自动声明为final类型的方法（但是不会将字段自动变为final类型）。</li><li>字段被声明为final类型就与继承没有关系。final字段是指，该字段在对象构造出来初始化之后就不能被修改了。</li></ul><h3 id="对象引用的强制类型转换"><a class="markdownIt-Anchor" href="#对象引用的强制类型转换"></a> 对象引用的强制类型转换</h3><ul><li>在继承层次内才能进行对象引用的强制类型转换。</li><li>只能将父类强制类型转换为子类，并且应该使用instanceof检查要转换的两个类型之间是否为父子类关系。</li><li>示例：<code>boss = (Manger) staff[1]</code>。</li></ul><h3 id="对象包装器与自动装箱"><a class="markdownIt-Anchor" href="#对象包装器与自动装箱"></a> 对象包装器与自动装箱</h3><ul><li>所有的基本类型都有一个与之对应的类。（如：Integer类对应基本类型int）。这些类称为<strong>包装器</strong>。</li><li>包装器有：<code>Integer, Long, Float, Double, Short, Byte, Character, Boolean</code>。</li><li>包装器是<strong>不可变</strong>的类，包装器被构造之后，就不允许更改包装在其中的值。包装器是<strong>final</strong>类型的类，不能派生子类。</li><li>包装器的用途：将基本类型如int转换为对象。如：ArrayList<Integer>`。因为尖括号中必须是普通的类，所以不能使用int，此时可以用Integer达到相同的效果。</li><li><strong>自动装箱</strong>：在声明为包装器类的地方使用对应的基本类型，会自动将该基本类型的元素转换为对应的包装器类，这种特性叫做自动装箱。如：<code>list.add(3)</code>将自动转换成<code>list.add(Integer.valueOf(3))</code>。</li><li><strong>自动拆箱</strong>：在声明为基本类型的地方使用对应的包装器类，会自动将该包装器类的元素转换为对应的基本类型。</li><li>包装器中还有很多基本静态方法。如<code>int x = Integer.parseInt(s)</code>可以将s字符串转换为整型数值。</li></ul><h3 id="参数数量可变的方法"><a class="markdownIt-Anchor" href="#参数数量可变的方法"></a> 参数数量可变的方法</h3><ul><li>示例：<code>public PrintStream printf(String fmt, Object...args)</code>。其中<code>...</code>是java代码的一部分。，表明这个方法可以接收任意数量的对象。实际上这个方法接收两个参数，一个是格式字符串fmt，一个是<code>Object[]</code>数组。<code>Object[]</code>数组中保存着其它所有参数。</li></ul><h3 id="反射"><a class="markdownIt-Anchor" href="#反射"></a> 反射</h3><ul><li>暂时略。</li></ul><h2 id="方法重载方法过载"><a class="markdownIt-Anchor" href="#方法重载方法过载"></a> 方法重载(方法过载)</h2><ul><li>方法重载指的是<strong>方法名一样，但是参数不一样</strong>。每次调用该名字的方法时，会自动根据对应的参数类型以及数量来调用对应的方法。</li><li><strong>多态性</strong>的表现。</li><li>参数的名称，数量以及类型在重载中都是可以随便修改的。</li><li>但是方法重载不能修改方法的<strong>返回值类型</strong>。</li><li>示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ADHero extends Hero &#123;    public void attack() &#123;        System.out.println(name + &quot; 进行了一次攻击 ，但是不确定打中谁了&quot;);    &#125;     public void attack(Hero h1) &#123;        System.out.println(name + &quot;对&quot; + h1.name + &quot;进行了一次攻击 &quot;);    &#125;     public void attack(Hero h1, Hero h2) &#123;        System.out.println(name + &quot;同时对&quot; + h1.name + &quot;和&quot; + h2.name + &quot;进行了攻击 &quot;);    &#125; &#x2F;&#x2F;可以给类似的方法设置同样的名字。    public static void main(String[] args) &#123;        ADHero bh &#x3D; new ADHero();        bh.name &#x3D; &quot;赏金猎人&quot;;         Hero h1 &#x3D; new Hero();        h1.name &#x3D; &quot;盖伦&quot;;        Hero h2 &#x3D; new Hero();        h2.name &#x3D; &quot;提莫&quot;;         bh.attack(h1);        bh.attack(h1, h2);    &#125; &#125;</code></pre><ul><li>方法重载还可以通过设置<strong>可变数量的参数</strong>来实现。可变数量的参数通过数组来实现。示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ADHero extends Hero &#123;     public void attack() &#123;        System.out.println(name + &quot; 进行了一次攻击 ，但是不确定打中谁了&quot;);    &#125;     &#x2F;&#x2F; 可变数量的参数    public void attack(Hero... heros) &#123; &#x2F;&#x2F;Hero是类型，方法的形参需要设置...&lt;数组名&gt;来表示这个函数是接受可变参数的        for (int i &#x3D; 0; i &lt; heros.length; i++) &#123;            System.out.println(name + &quot; 攻击了 &quot; + heros[i].name);&#x2F;&#x2F;数组设置的参数调用方法与普通数组一样。         &#125;    &#125;     public static void main(String[] args) &#123;        ADHero bh &#x3D; new ADHero();        bh.name &#x3D; &quot;赏金猎人&quot;;         Hero h1 &#x3D; new Hero();        h1.name &#x3D; &quot;盖伦&quot;;        Hero h2 &#x3D; new Hero();        h2.name &#x3D; &quot;提莫&quot;;         bh.attack(h1);        bh.attack(h1, h2);     &#125; &#125;</code></pre><h2 id="构造方法"><a class="markdownIt-Anchor" href="#构造方法"></a> 构造方法</h2><ul><li>实例化：通过一个类创建一个对象的过程叫做实例化。</li><li><strong>构造方法（构造器）</strong>：实例化是通过调用构造方法来实现的。构造方法同其他方法一样具有一样具有参数和语句体，但是<strong>没有返回类型</strong>。构造方法不是成员方法，不能用对象来调用它。<strong>构造方法的名字与类的名字一样</strong>，包括大小写也一样。</li><li>每个类可以有<strong>一个以上</strong>的构造器（构造器的方法过载）。</li><li><strong>不要</strong>在构造方法（类中的其它方法也一样）中使用与实例字段同名的局部变量。</li><li>构造方法之间可以<strong>通过<code>this()</code>来相互调用</strong>。</li><li>示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Hero &#123;     String name;     float hp;     float armor;     int moveSpeed;     &#x2F;&#x2F; 方法名和类名一样（包括大小写）    &#x2F;&#x2F; 没有返回类型    public Hero() &#123;        System.out.println(&quot;实例化一个对象的时候，必然调用构造方法&quot;);    &#125;         public static void main(String[] args) &#123;        &#x2F;&#x2F;实例化一个对象的时候，必然调用构造方法        Hero h &#x3D; new Hero();&#x2F;&#x2F;new 后面跟的是构造方法，只是构造方法的名字与类的名字是相同的。    &#125;&#125;</code></pre><ul><li>如果在定义类中没有对构造方法的定义，则编译器在编译时会自动给类加上一个无参的，语句体为空的构造方法。但如果已经手动定义了一个有参的构造器，就<strong>不会</strong>再自动生成这个默认无参的构造器，此时再使用无参的构造器构造对象就是非法的。</li><li>构造方法总是通过<code>new</code>来调用的，如果使用的是没有参数的构造方法，则直接是<code>new &lt;类名&gt;()</code>来调用，如果有参数则需加上参数列表<code>new &lt;类名&gt;(参数列表)</code>，另外，构造方法与普通方法一样，是可以进行方法重载的。示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Hero &#123;           String name; &#x2F;&#x2F;姓名           float hp; &#x2F;&#x2F;血量           float armor; &#x2F;&#x2F;护甲           int moveSpeed; &#x2F;&#x2F;移动速度           &#x2F;&#x2F;带一个参数的构造方法    public Hero(String heroname)&#123;         name &#x3D; heroname;    &#125;         &#x2F;&#x2F;带两个参数的构造方法    public Hero(String heroname,float herohp)&#123;         name &#x3D; heroname;        hp &#x3D; herohp;    &#125;           public static void main(String[] args) &#123;        Hero garen &#x3D;  new Hero(&quot;盖伦&quot;); &#x2F;&#x2F;调用构造方法创建对象时需要加上参数了。        Hero teemo &#x3D;  new Hero(&quot;提莫&quot;,383);    &#125;     &#125;</code></pre><h3 id="静态代码块-初始化块"><a class="markdownIt-Anchor" href="#静态代码块-初始化块"></a> 静态代码块、初始化块</h3><ul><li>静态代码块：类中用static关键修饰的块（又名<strong>类初始化块</strong>）：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class 类名称 &#123;    static &#123;        &#x2F;&#x2F;静态代码块的内容    &#125;&#125;</code></pre><ul><li><p>静态代码块特性：</p><ul><li>当<strong>第一次</strong>用到本类时，静态代码块执行<strong>唯一的一次</strong>；再次使用该类时，不会再执行静态代码块。</li><li>静态内容总是优先于非静态，所以<strong>静态代码块比构造方法先执行</strong>。</li><li>一个类中可以有多个静态初始化块；</li><li>静态初始化块的执行要早于普通初始化块；</li><li>用途：用来一次性地对静态成员变量进行赋值，比如需要通过计算来初始化static变量时可以声明一个static块。</li></ul></li><li><p>初始化块：没有static修饰的普通块</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class InitDemo1&#123;&#123;System.out.println(&quot;我是普通初始化块&quot;);&#125;&#125;</code></pre></li><li><p>初始化块特性：</p><ul><li>初始化块没有名字，不能被调用，它在对象创建时隐式执行，每次创建该类的对象都会执行初始化块。</li><li>一个类里可以有多个初始化块，多个初始化块之间有顺序：在前面的初始化块先执行，后边的初始化块后执行。</li><li>初始化块先于构造器先执行。</li></ul></li><li><p>在父子类中，执行顺序是：</p><p>爷爷类的静态初始化(静态属性初始化) &gt;  父类静态初始化块(静态属性初始化）&gt; 子类静态初始化块（静态属性初始化）&gt; 爷爷类普通初始化块(普通属性初始化)&gt;爷爷类构造器&gt;<br />父类普通初始化块(普通属性初始化)&gt;父类构造器&gt;<br />子类普通初始化块(普通属性初始化)&gt;子类构造器</p></li></ul><h2 id="this"><a class="markdownIt-Anchor" href="#this"></a> this</h2><ul><li>this可以顾名思义，this这个关键字代表当前对象，就相当于当前对象的名字，实际使用于类定义的内部。示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Hero &#123;         String name; &#x2F;&#x2F;姓名         float hp; &#x2F;&#x2F;血量         float armor; &#x2F;&#x2F;护甲         int moveSpeed; &#x2F;&#x2F;移动速度     &#x2F;&#x2F;打印内存中的虚拟地址    public void showAddressInMemory()&#123;        System.out.println(&quot;打印this看到的虚拟地址：&quot;+this); &#x2F;&#x2F;this在类内部使用，因为此时类没有名字，如果要用其中的属性很不方便，所以设置this来表示当前：“对象”，相当于类的一个虚拟名字。    &#125;         public static void main(String[] args) &#123;        Hero garen &#x3D;  new Hero();        garen.name &#x3D; &quot;盖伦&quot;;        &#x2F;&#x2F;直接打印对象，会显示该对象在内存中的虚拟地址        &#x2F;&#x2F;格式：Hero@c17164 c17164即虚拟地址，每次执行，得到的地址不一定一样         System.out.println(&quot;打印对象看到的虚拟地址：&quot;+garen);        &#x2F;&#x2F;调用showAddressInMemory，打印该对象的this，显示相同的虚拟地址-&gt;表示this起始和对象名garen指向的是同一个东西        garen.showAddressInMemory();    &#125;&#125;</code></pre><ul><li>使用this给对象的属性赋值。示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Hero &#123;         String name; &#x2F;&#x2F;姓名         &#x2F;&#x2F;参数名和属性名一样    &#x2F;&#x2F;在方法体中，只能访问到参数name    public void setName1(String name)&#123;        name &#x3D; name;    &#125;         &#x2F;&#x2F;为了避免setName1中的问题，参数名不得不使用其他变量名    public void setName2(String heroName)&#123;        name &#x3D; heroName;    &#125;         &#x2F;&#x2F;通过this访问属性    public void setName3(String name)&#123;        &#x2F;&#x2F;name代表的是参数name        &#x2F;&#x2F;this.name代表的是属性name        this.name &#x3D; name;    &#125;         public static void main(String[] args) &#123;        Hero  h &#x3D;new Hero();                 h.setName1(&quot;teemo&quot;);        System.out.println(h.name); &#x2F;&#x2F;结果为null，即参数的值传不到对象里的属性上                 h.setName2(&quot;garen&quot;);        System.out.println(h.name); &#x2F;&#x2F;结果为garen，成功，即使用this可以访问到当前对象的属性                    h.setName3(&quot;死歌&quot;);        System.out.println(h.name); &#x2F;&#x2F;结果为死歌，成功，即使用非属性名的形参，还可以将值传给属性。        &#125;     &#125;</code></pre><ul><li>this还可以用来在<strong>一个构造器内部调用该类中的另一个构造器</strong>。调用的形式为<code>this(要调用的构造器的参数)</code>。在一个构造器中调用另一个构造器的的语句只能放在该构造器的第一条语句。</li></ul><h2 id="隐式参数与显式参数"><a class="markdownIt-Anchor" href="#隐式参数与显式参数"></a> 隐式参数与显式参数</h2><ul><li>隐式参数是出现在方法之前的实例字段，在方法中被直接调用。而显式参数就是普通的位于方法名后面括号中的参数。</li><li>隐式参数常用this来指示，以便和局部变量区分开来。</li><li>示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Employee &#123;    double salary;    public void raiseSalary (double byPercent) &#123;        double raise &#x3D; salary * byPercent &#x2F; 100;        salary +&#x3D; raise;    &#125;&#125;</code></pre><ul><li>在这个例子中，salary为隐式参数，而byPercent为显式参数。</li><li>可以用this指示隐式参数：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Employee &#123;    double salary;    public void raiseSalary (double byPercent) &#123;        double raise &#x3D; this.salary * byPercent &#x2F; 100;        this.salary +&#x3D; raise;    &#125;&#125;</code></pre><h2 id="参数的传递"><a class="markdownIt-Anchor" href="#参数的传递"></a> 参数的传递</h2><ul><li>参数与变量一样，分为基本类型和类类型。基本类型参数与c语言基本一样，而类类型的参数有一点类似c语言中的指针参数。</li><li>类类型参数可以修改实际的类类型的变量指向的对象，实际类类型变量是对应对象的引用，是对象的一个地址。示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Hero &#123;            String name; &#x2F;&#x2F;姓名            float hp; &#x2F;&#x2F;血量            float armor; &#x2F;&#x2F;护甲            int moveSpeed; &#x2F;&#x2F;移动速度         public Hero()&#123;             &#125;         public Hero(String name,float hp)&#123;        this.name &#x3D; name;        this.hp &#x3D; hp;    &#125;     &#x2F;&#x2F;复活    public void revive(Hero h)&#123; &#x2F;&#x2F;传入的参数是Hero类型的引用        h &#x3D; new Hero(&quot;提莫&quot;,383);    &#125;     public static void main(String[] args) &#123;        Hero teemo &#x3D;  new Hero(&quot;提莫&quot;,383);                 &#x2F;&#x2F;受到400伤害，挂了        teemo.hp &#x3D; teemo.hp - 400;                 teemo.revive(teemo); &#x2F;&#x2F; teemo中hp的值变为了383，即通过类类型传递的是可以在函数内部修改的。                          &#125;      &#125;</code></pre><ul><li>在给参数命名时，可以在名字面前加上前缀a以与实例字段区别。如<code>name = aName</code>.</li></ul><h2 id="包"><a class="markdownIt-Anchor" href="#包"></a> 包</h2><ul><li>包：类和接口的集合，即为类库。</li><li>把具有某种关系的类放在一个包里。包必须在<strong>类最开始的地方声明</strong>。若是缺省该语句，则默认将类指定为无名包下。</li><li>借助包名可以确保类名的唯一性。包名常使用因特网域名的逆序形式，一般都是用小写字母。如域名为<code>horstman.com</code>则将包名设为<code>com.horstman</code>.包名之后还可以追加一个工程名之后再写上类名。如<code>com.horstman.corejava.Employee</code>，这个也被称为该类的<strong>完全限定名</strong>.其中corejava为工程名，Employee为类名。</li><li>示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package charactor; &#x2F;&#x2F;在最开始的地方声明该类所处于的包名public class Hero &#123;            String name; &#x2F;&#x2F;姓名            float hp; &#x2F;&#x2F;血量            float armor; &#x2F;&#x2F;护甲            int moveSpeed; &#x2F;&#x2F;移动速度     &#125;</code></pre><ul><li>包与类的关系示例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/java.jpg" alt="java" /></li></ul><h3 id="类的导入"><a class="markdownIt-Anchor" href="#类的导入"></a> 类的导入</h3><ul><li><strong>一个类可以使用所属包中的所有类</strong>，以及其他包里的公共类。但是<strong>其他包里的公共类必须使用<code>import</code>来导入</strong>。（也可以在使用其他包里的公共类时使用其<strong>完全限定名</strong>）</li><li>使用<code>import 包名.*</code>引入语句，只表示了源程序所需要的类会在包中找到并引入，但是对包中其它的类或它下面的包中的类并不引入。（但是只能使用<code>*</code>导入一个包，不能导入一个包里嵌套的所有包。）</li><li>示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package charactor; &#x2F;&#x2F;Weapon类在其他包里，使用必须进行importimport property.Weapon;&#x2F;&#x2F;格式为 import 类的完全限定名; public class Hero &#123;            String name; &#x2F;&#x2F;姓名            float hp; &#x2F;&#x2F;血量            float armor; &#x2F;&#x2F;护甲            int moveSpeed; &#x2F;&#x2F;移动速度         &#x2F;&#x2F;装备一把武器    public void equip(Weapon w)&#123;             &#125;        &#125;</code></pre><h3 id="静态导入"><a class="markdownIt-Anchor" href="#静态导入"></a> 静态导入</h3><ul><li>在import关键字之后加上static修饰符可以导入某个类中的静态方法和静态字段。如：<code>import static java.lang.System.*</code>可以导入System类中的所有静态方法和静态字段。如果这样导入，<code>System.out.print()</code>就可以用<code>out.print()</code>代替（可以省略类名）。当然，也可以导入特定的方法和字段。如<code>import static java.lang.System.out</code>.</li></ul><h3 id="在包中增加类"><a class="markdownIt-Anchor" href="#在包中增加类"></a> 在包中增加类</h3><ul><li>要将类放入包中需要将包的名字放在该类源文件的开头。如<code>package com.horstman.corejava</code>.如果在源文件开头没有防止package语句，则这个类就默认属于<strong>无名包</strong>（没有名字，但是实际存在的的包）。还要注意<strong>类的源文件必须放到与完整包名匹配的目录中</strong>。</li><li>编译和运行类必须切换到基目录。</li></ul><h3 id="类路径"><a class="markdownIt-Anchor" href="#类路径"></a> 类路径</h3><ul><li>类的路径必须与包名相匹配。</li><li>通过设置<code>classpath</code>来设置类路径，以使多个程序共享类。</li></ul><h3 id="jar文件"><a class="markdownIt-Anchor" href="#jar文件"></a> JAR文件</h3><ul><li><strong>JAR文件</strong>:java的压缩包文件（使用zip格式）。在一个JAR文件中可以包含多个压缩形式的类文件和子目录，也可以包含诸如图像、声音等类型的文件。在程序中使用第三方的库文件时，需要得到相应的JAR文件。</li><li><strong>创建JAR文件</strong>：使用<code>jar</code>工具来制作JAR文件。类似Unix系统中的<code>tar</code>指令。[jar程序选项](<a href="https://www.cnblogs.com/chenjfblog/p/10164967.html">https://www.cnblogs.com/chenjfblog/p/10164967.html</a></li><li><strong>清单文件</strong>：每个JAR文件都包含一个清单文件（manifest），用于描述JAR文件的某些特性。<a href="https://blog.csdn.net/weixin_33801856/article/details/86247641">清单文件具体使用</a>.</li><li><strong>可执行JAR文件</strong>：需要为JAR包装的程序指定入口点，即在需要调用java程序启动器时指定的类。可以使用<code>jar</code>命令的e选项，来指定入口点。</li></ul><h2 id="成员变量的修饰符"><a class="markdownIt-Anchor" href="#成员变量的修饰符"></a> 成员变量的修饰符</h2><h3 id="类之间的关系"><a class="markdownIt-Anchor" href="#类之间的关系"></a> 类之间的关系</h3><ul><li><strong>依赖</strong>：&quot;use-a&quot;关系，即一个类的方法使用或者操纵另一个类的对象，就是一个类依赖于另一个类。</li><li><strong>聚合</strong>：&quot;has-a&quot;关系，即一个类中的对象包含另一个类的一些对象。</li><li><strong>继承</strong>：&quot;is-a&quot;关系，表示一个更特殊的类与更一般的类之间的关系。，这个更特殊的类中不但包含了原来的类中的所有对象和方法，还增加一些额外的功能。</li><li><strong>UML</strong>:unified Modeling Language:统一建模语言，可以用来绘制类图。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200922073144.jpg" alt="" /></li></ul><h3 id="private"><a class="markdownIt-Anchor" href="#private"></a> private</h3><ul><li>使用private修饰的变量，只有<strong>这种类的对象</strong>才可以访问，子类不可以继承，其它的类就更不能访问了。</li></ul><h3 id="缺省"><a class="markdownIt-Anchor" href="#缺省"></a> 缺省</h3><ul><li>没有修饰符的成员变量，自身的对象可以访问，同包的类可以访问，同包子类可以继承，不同包子类也可以继承，但是不同包的类不可以访问。</li></ul><h3 id="proteced"><a class="markdownIt-Anchor" href="#proteced"></a> proteced</h3><ul><li>使用protected修饰的成员字段或者方法，<strong>同包类可以访问和继承</strong>，不同包的类不可以访问和继承。</li></ul><h3 id="public"><a class="markdownIt-Anchor" href="#public"></a> public</h3><ul><li>任何地方，都可以访问和继承。</li><li>在一个源文件中（.java）中只能有<strong>一个public类</strong>（这个类就是文件名），但可以有任意数目的非公共类。</li><li>由一个源文件编译而成的类文件（.class），将包含main方法的类名提供给解释器以启动这个程序。</li></ul><h2 id="类属性static"><a class="markdownIt-Anchor" href="#类属性static"></a> 类属性（static）</h2><ul><li>当类中的属性被static修饰时，这个属性就叫做<strong>类属性</strong>，又叫做<strong>静态属性</strong>或<strong>静态字段</strong>。如果某个属性被声明为类属性，那么该类所有的对象都共享这个值,不管有没有实例化得到的对象，这个属性都存在，不管有多少个对象（甚至从未创建过该类的对象），都共用一个静态字段，静态字段只属于类，不属于任何单个的对象。静态属性中常用的是<strong>静态常量</strong>。类属性事实上提供了<strong>全局变量和全局方法</strong>。</li><li>与类属性相对的（类中没有static修饰的属性）叫做<strong>对象属性</strong>，又叫做<strong>非静态属性</strong>，<strong>实例属性</strong>。示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package charactor; public class Hero &#123;    public String name; &#x2F;&#x2F;实例属性，对象属性，非静态属性    protected float hp;    static String copyright;&#x2F;&#x2F;类属性,静态属性         public static void main(String[] args) &#123;           Hero garen &#x3D;  new Hero();           garen.name &#x3D; &quot;盖伦&quot;;                       Hero.copyright &#x3D; &quot;版权由Riot Games公司所有&quot;; &#x2F;&#x2F;对类属性的赋值                       System.out.println(garen.name);           System.out.println(garen.copyright);                       Hero teemo &#x3D;  new Hero();           teemo.name &#x3D; &quot;提莫&quot;;           System.out.println(teemo.name);               System.out.println(teemo.copyright);             &#125;     &#125;</code></pre><ul><li>对类属性的访问通过<strong>直接使用类名</strong>来完成<code>Hero.copyright = </code>.也可以通过实际的对象来调用，不过一般还是使用类来直接调用，这样更符合类对象的概念。</li></ul><h2 id="类方法静态方法"><a class="markdownIt-Anchor" href="#类方法静态方法"></a> 类方法（静态方法）</h2><ul><li><strong>类方法</strong>，又叫静态方法。同类对象相似，类方法也是通过在方法名前面加上<code>static</code>关键字来实现的。<ul><li>static方法仅能调用其他的static方法；</li><li>static方法只能访问static数据；</li><li>static方法不能以任何方式引用this或者super。</li></ul></li><li>静态方法不使用对象中的实例字段（也可以理解为静态方法中没有this参数，它所需要的所有参数都通过显示参数提供），计算结果与实际对象无关。</li><li>与类方法相对的是<strong>对象方法</strong>，对象方法又叫实例方法，非静态方法。示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package charactor; public class Hero &#123;    public String name;    protected float hp;     &#x2F;&#x2F;实例方法,对象方法，非静态方法    &#x2F;&#x2F;必须有对象才能够调用    public void die()&#123;        hp &#x3D; 0;    &#125;         &#x2F;&#x2F;类方法，静态方法    &#x2F;&#x2F;通过类就可以直接调用    public static void battleWin()&#123;        System.out.println(&quot;battle win&quot;);    &#125;         public static void main(String[] args) &#123;           Hero garen &#x3D;  new Hero();           garen.name &#x3D; &quot;盖伦&quot;;           &#x2F;&#x2F;必须有一个对象才能调用           garen.die();                       Hero teemo &#x3D;  new Hero();           teemo.name &#x3D; &quot;提莫&quot;;                       &#x2F;&#x2F;无需对象，直接通过类调用           Hero.battleWin();             &#125;&#125;</code></pre><ul><li><strong>对象方法必须用实际创建的对象才能调用</strong>，而类方法可以使用类来直接调用，也可以使用对象来调用。（同类对象的情况一致）。</li><li>当某个方法没有涉及到具体对象的属性时，设计为类方法，而当涉及具体对象的属性时，则一般设计为对象方法。示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public String getName()&#123;return name;&#125;public static void printGameDuration()&#123;    System.out.println(&quot;已经玩了10分50秒&quot;);&#125;</code></pre><h3 id="工厂方法"><a class="markdownIt-Anchor" href="#工厂方法"></a> 工厂方法</h3><ul><li>静态方法的另一个用途就是静态工厂方法，工厂方法实际上是构造器方法的延伸。使用工厂方法可以生成不同风格的对象。</li></ul><h3 id="main方法"><a class="markdownIt-Anchor" href="#main方法"></a> main方法</h3><ul><li>main方法启动时还没有任何对象，所以main方法不对任何对象进行操作，main方法<strong>必须声明为static</strong>方法。</li><li>每个类都可以有一个main方法，用于对每个类进行单元测试。</li><li>包含main方法的类<strong>声明为public类</strong>。</li><li>main方法是<strong>程序运行的入口</strong>。</li></ul><h2 id="属性初始化"><a class="markdownIt-Anchor" href="#属性初始化"></a> 属性初始化</h2><ul><li>对象属性初始化。<ol><li>在声明时初始化；</li><li>在块中初始化，初始化块的前面还是可以加上修饰符的；</li><li>在构造方法中初始化。</li><li><strong>初始化的顺序</strong>：如果三种初始化方式同时出现，则不管构造方法中初始化的相对位置在哪里，它的初始化都是最后执行的。</li><li>示例：</li></ol></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Hero &#123;    public String name &#x3D; &quot;some hero&quot;; &#x2F;&#x2F;声明该属性的时候初始化    protected float hp;    float maxHP;         &#123;        maxHP &#x3D; 200; &#x2F;&#x2F;初始化块,单独用花括号给出一个用来初始化属性的块。    &#125;           public Hero()&#123;        hp &#x3D; 100; &#x2F;&#x2F;构造方法中初始化             &#125;     &#125;</code></pre><ul><li>类属性初始化<ol><li>声明时初始化</li><li>静态初始化块:在普通花括号形成的块前面加上关键字<code>static</code>形成静态初始化块。</li><li>示例：</li></ol></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Hero &#123;    public String name;    protected float hp;    float maxHP;         &#x2F;&#x2F;物品栏的容量    public static int itemCapacity &#x3D; 8; &#x2F;&#x2F;声明的时候 初始化         static&#123;        itemCapacity &#x3D; 6;&#x2F;&#x2F;静态初始化块 初始化    &#125;         public Hero()&#123;             &#125;         public static void main(String[] args) &#123;        System.out.println(Hero.itemCapacity);    &#125;     &#125;</code></pre><h2 id="单例模式"><a class="markdownIt-Anchor" href="#单例模式"></a> 单例模式</h2><ul><li><strong>单例模式</strong>又叫<strong>Singleton</strong>模式，表示的是一个类，在一个JVM（Java虚拟机）中只有一个实例存在。</li></ul><h3 id="饿汉式单例模式"><a class="markdownIt-Anchor" href="#饿汉式单例模式"></a> 饿汉式单例模式</h3><ul><li>饿汉式单例模式通过使用private使构造方法无法在外部通过new来创建对象，并创建一个新的方法指定在类中定义的对象，每次使用该方法都只能产生一个唯一的对象从而实现单例模式。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class GiantDragon &#123;     &#x2F;&#x2F;私有化构造方法使得该类无法在外部通过new 进行实例化    private GiantDragon()&#123;             &#125;     &#x2F;&#x2F;准备一个类属性，指向一个实例化对象。 因为是类属性，所以只有一个     private static GiantDragon instance &#x3D; new GiantDragon();         &#x2F;&#x2F;public static 方法，提供给调用者获取前面定义的instance对象    public static GiantDragon getInstance()&#123;        return instance;    &#125;     &#125;</code></pre><h3 id="懒汉式单例模式"><a class="markdownIt-Anchor" href="#懒汉式单例模式"></a> 懒汉式单例模式</h3><ul><li>懒汉式与饿汉式的区别在于懒汉式只有在调用创建对象的方法时才第一次创建对象。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class GiantDragon &#123;      &#x2F;&#x2F;私有化构造方法使得该类无法在外部通过new 进行实例化    private GiantDragon()&#123;           &#125;      &#x2F;&#x2F;准备一个类属性，用于指向一个实例化对象，但是暂时指向null    private static GiantDragon instance;          &#x2F;&#x2F;public static 方法，返回实例对象    public static GiantDragon getInstance()&#123;        &#x2F;&#x2F;第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象        if(null&#x3D;&#x3D;instance)&#123;            instance &#x3D; new GiantDragon();        &#125;        &#x2F;&#x2F;返回 instance指向的对象        return instance;    &#125;      &#125;</code></pre><h2 id="枚举类型"><a class="markdownIt-Anchor" href="#枚举类型"></a> 枚举类型</h2><ul><li>枚举类型包括有限个命名的值。例如：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">enum Size&#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;;&#x2F;&#x2F;定义枚举类型Size。Size s &#x3D; Size.MEDIUM;&#x2F;&#x2F;声明枚举类型的变量s并进行初始化。</code></pre><ul><li>枚举类型的变量中只能存储这个类型的声明中给定的<strong>某个枚举值</strong>，或者null（表示这个变量没有设置任何值）。</li></ul><h1 id="接口与继承"><a class="markdownIt-Anchor" href="#接口与继承"></a> 接口与继承</h1><h2 id="接口interface"><a class="markdownIt-Anchor" href="#接口interface"></a> 接口（Interface）</h2><ul><li>接口不是类，而是对希望符合这个接口的类的一组需求（应该做什么）。接口是抽象的，它的所有成员方法都是抽象方法（abstract）（语句体都是空的。</li><li>接口的所有成员变量都默认是<code>public static final</code>类型，创建成员变量时可以省略这些修饰符。即接口中的所有成员变量都可以直接用接口名来访问。</li><li>但是在接口中声明的成员方法都默认是<code>public abstract</code>方法，也可以省略这两个修饰符。</li><li>接口可以作为一个引用类型来使用：<ul><li>任何实现了该接口的类的实例都可以存储在该接口类型的变量中；</li><li>通过接口类型的变量可以访问类中所实现的该接口的方法。</li></ul></li><li>接口不能包含<strong>实例字段</strong>，但可以包含<strong>常量</strong>。</li><li>接口的创建：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package charactor; public interface AD &#123; &#x2F;&#x2F;接口的创建使用关键字interface。        &#x2F;&#x2F;物理伤害    public void physicAttack(); &#x2F;&#x2F;接口的成员函数都是抽象函数，只有其形，而实际里面什么也没有。&#125;</code></pre><ul><li>接口的使用：（接口在类中具体实现时的public不能省略）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package charactor; public class ADHero extends Hero implements AD&#123; &#x2F;&#x2F;ADHero是从Hero继承而来的的子类，并且使用关键字implements加入了AD接口    @Override    public void physicAttack() &#123; &#x2F;&#x2F;接口在实际使用的时候再定义具体操作的实现。这是方法的重写，需要有Override注解        System.out.println(&quot;进行物理攻击&quot;);    &#125; &#125;</code></pre><ul><li>接口使用关键字<code>implements</code>来加入，并且可以<strong>同时加入多个接口</strong>，如<code>...implements AD,AP</code>.</li></ul><h3 id="接口的属性"><a class="markdownIt-Anchor" href="#接口的属性"></a> 接口的属性</h3><ul><li>接口<strong>不是类</strong>，不能使用new来实例化一个接口。</li><li>可以声明<strong>接口类型的变量</strong>，这个接口类型的变量必须引用实现了这个的类对象。</li><li>可以使用<code>instanceof</code>来判断一个对象是否实现了某个特定的接口。如：<code>if(anObject instanceof Comparable) &#123;...&#125;</code>。</li><li>接口与类一样，也可以进行扩展，形成<strong>接口链</strong>，从通用性较高的接口扩展到专用性较高的接口。对接口进行扩展同样使用<code>extends</code>关键字，基本扩展规则与类的扩展相似。<strong>接口可以实现多重继承，即一个接口同时继承其它多个接口</strong>。</li></ul><h3 id="接口与抽象类"><a class="markdownIt-Anchor" href="#接口与抽象类"></a> 接口与抽象类</h3><ul><li>接口与抽象类的最大区别是：每个类<strong>只能扩展一个类</strong>。但是每个类却可以实现多个接口。</li></ul><h3 id="默认方法"><a class="markdownIt-Anchor" href="#默认方法"></a> 默认方法</h3><ul><li>接口中允许对一些方法进行实现，以使用这个接口的类不用在类中在对该方法进行实现，这种接口中实现了的方法称为<strong>默认方法</strong>。</li><li>默认方法必须再前面加上<code>default</code>关键字。</li></ul><h3 id="标记接口"><a class="markdownIt-Anchor" href="#标记接口"></a> 标记接口</h3><ul><li>普通接口的作用是确保一个类实现一些方法。而标记接口中不包含任何方法，它唯一的作用就是允许在类型查询中使用<code>instanceof</code>。如：Cloneable就是一个标记接口。</li></ul><h3 id="lambda表达式"><a class="markdownIt-Anchor" href="#lambda表达式"></a> lambda表达式</h3><ul><li>lambda表达式是用来实现对一些代码块的复用，避免每次使用一些方法就得构造一个对象。（类似于模拟c语言中普通的函数）。</li><li>Lambda 表达式可以对某些接口进行简单的实现，但并不是所有的接口都可以使用 Lambda 表达式来实现。<strong>Lambda 规定接口中只能有一个需要被实现的方法</strong>，不是规定接口中只能有一个方法。jdk8中有另一个新特性：default， 被 default 修饰的方法会有默认实现，不是必须被实现的方法，所以不影响 Lambda 表达式的使用。</li><li>lambda表达式的形式：(parameters) -&gt; expression或(parameters) -&gt;{ statements; }。<ul><li><code>()</code>:接口中抽象方法的参数列表，没有参数就空着；</li><li><code>-&gt;</code>:传递的意思，把参数传递给方法体。</li><li><code>&#123;&#125;</code>:重写接口的抽象方法的方法体。</li></ul></li><li>lambda表达式的重点是使代码延迟执行。这种延迟执行可以用于：<ol><li>在一个单独的线程中运行代码；</li><li>多次运行代码；</li><li>在算法的适当位置执行代码等。</li></ol></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;多个参数(String first, String second) -&gt; &#123;    if (first.length() &lt; second.length())        return -1;    else if (first.length() &gt; second.length())        return 1;    else         return 0;&#125;&#x2F;&#x2F;没有参数() -&gt; ｛for（intI&#x3D; 100; i &gt;&#x3D; 0; ; i--) System.out.println(); ｝&#x2F;&#x2F;一个参数event -&gt; &#123;    System.out.println(event);&#125;&#x2F;&#x2F;只有一个表达式(String first, String second) -&gt; first.length - second.length();</code></pre><h4 id="函数式接口"><a class="markdownIt-Anchor" href="#函数式接口"></a> 函数式接口</h4><ul><li>对于<strong>只有一个抽象方法的接口</strong>，需要这种接口的对象时，就可以提供一个lambda表达式，这种接口称为<strong>函数式接口</strong>。</li><li>可以将lambda表达式转换为函数式接口。</li></ul><h4 id="lambda的方法引用"><a class="markdownIt-Anchor" href="#lambda的方法引用"></a> lambda的方法引用</h4><ul><li>当lambda表达式只调用一个方法而不做其他操作时，可以把lambda表达式重写为<strong>方法引用</strong>。</li><li>方法引用有三种情况：<ol><li><code>对象 :: 普通方法</code> ：等价于向方法传递参数的lambda表达式，如<code>System.out::println</code>等价于<code>x -&gt; System.out.println(x)</code>.</li><li><code>类 :: 普通方法</code> ：在这种情况下第一个参数会称为方法的隐式参数，如： <code>String::compareToTgnoreCase</code>等价于<code>(x, y) -&gt; x.compareToIgnoreCase(y)</code>.</li><li><code>类 :: 静态方法</code> ：所有参数都传递到静态方法，如<code>Math::pow</code>等价于<code>(x, y) -&gt; Math.pow(x, y)</code>。</li></ol></li><li>还可以在方法引用中使用<code>this</code>和<code>super</code>.如：<code>this::equals</code>等价于<code>x -&gt; this.equals(x)</code>.</li></ul><h4 id="构造器引用"><a class="markdownIt-Anchor" href="#构造器引用"></a> 构造器引用</h4><ul><li>构造器引用与方法引用类似，只不过将方法名统一为new。如<code>int[]::new</code>等价于<code>x -&gt; new int[x]</code>.</li></ul><h3 id="服务加载器"><a class="markdownIt-Anchor" href="#服务加载器"></a> 服务加载器</h3><p>。。。</p><h3 id="代理"><a class="markdownIt-Anchor" href="#代理"></a> 代理</h3><p>。。。</p><h2 id="对象转型"><a class="markdownIt-Anchor" href="#对象转型"></a> 对象转型</h2><h3 id="引用类型和对象类型"><a class="markdownIt-Anchor" href="#引用类型和对象类型"></a> 引用类型和对象类型</h3><ul><li>在<code>Hero a = new Hero()</code>中，a是引用，a的类型即是引用类型（此例中为a前面的Hero类类型），而<code>new Hero()</code>创建的就是对象，对象类型就是Hero类类型。</li></ul><h3 id="子类转父类向上转型"><a class="markdownIt-Anchor" href="#子类转父类向上转型"></a> 子类转父类（向上转型）</h3><ul><li>类型转换发生在引用类型和对象类型不一致的时候。（类似基本类型中<code>=</code>两边的类型不一致时。）类型转换不一定会成功。（就像基本类型转换也会有失败的时候，就像int不能转换为double）。子类是可以转换为父类的（就像基本类型中，长的可以转换为短的，如double可以转换为int）。</li></ul><h3 id="父类转子类向下转型"><a class="markdownIt-Anchor" href="#父类转子类向下转型"></a> 父类转子类（向下转型）</h3><ul><li>父类转子类需要进行强制类型转换，如<code>a  = (ADHero)h</code>.</li></ul><h3 id="没有继承关系的类"><a class="markdownIt-Anchor" href="#没有继承关系的类"></a> 没有继承关系的类</h3><ul><li>没有继承关系的类之间转换一定会失败，即使用强制类型转换也会出现异常报错。</li></ul><h3 id="实现类转换为接口向上转型"><a class="markdownIt-Anchor" href="#实现类转换为接口向上转型"></a> 实现类转换为接口(向上转型)</h3><h3 id="接口转换为实现类向下转型"><a class="markdownIt-Anchor" href="#接口转换为实现类向下转型"></a> 接口转换为实现类（向下转型）</h3><h2 id="instanceof语句"><a class="markdownIt-Anchor" href="#instanceof语句"></a> instanceof语句</h2><ul><li>instanceof语句用来判断一个引用所指向的对象是否是某种类的实例化或者其子类的实例化。使用示例：<code>h instanceof Hero</code>判断引用h指向的对象是否是Hero类或者Hero子类的，如果是则结果为true，否则为false。</li></ul><h2 id="重写"><a class="markdownIt-Anchor" href="#重写"></a> 重写</h2><ul><li>子类可以继承父类的对象方法，如果子类对从父类继承过来的对象方法进行了修改（即在子类中对相同名字的对象方法在写一遍，故称为重写），这就叫做方法的重写。示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package property; &#x2F;&#x2F;父类public class Item &#123;    String name;        public void effect() &#123;        System.out.println(&quot;物品使用后，可以有效果&quot;);    &#125; &#125;&#x2F;&#x2F;从Item中继承的子类public class LifePotion extends Item&#123;          &#x2F;&#x2F;对Item中的effect方法进行了重写    public void effect()&#123;        System.out.println(&quot;血瓶使用后，可以回血&quot;);    &#125;     &#125;</code></pre><h2 id="多态"><a class="markdownIt-Anchor" href="#多态"></a> 多态</h2><h3 id="操作符的多态"><a class="markdownIt-Anchor" href="#操作符的多态"></a> 操作符的多态</h3><ul><li>操作符的多态是指同一个操作符在不同的情景下的作用不同。如<code>+</code>，在算术运算中是加法的作用，而在字符串中是连接字符串的作用。</li></ul><h3 id="类的多态"><a class="markdownIt-Anchor" href="#类的多态"></a> 类的多态</h3><ul><li>同一个类的同一个方法，输出不同的结果是类的一种多态现象。示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package property; public class Item &#123;    String name;    int price;     public void buy()&#123;        System.out.println(&quot;购买&quot;);    &#125;    public void effect() &#123;        System.out.println(&quot;物品使用后，可以有效果 &quot;);    &#125;         public static void main(String[] args) &#123;        Item i1&#x3D; new LifePotion(); &#x2F;&#x2F;LifePotion和MagicPotion是类Item的两个子类。而且这两个子类中都有方法的重写。        Item i2 &#x3D; new MagicPotion(); &#x2F;&#x2F;引用是父类类型的。        System.out.print(&quot;i1  是Item类型，执行effect打印:&quot;); &#x2F;&#x2F;由于两个子类的重写方法不同，导致调用同一个方法会有不同的输出        i1.effect();        System.out.print(&quot;i2也是Item类型，执行effect打印:&quot;);        i2.effect();    &#125; &#125;</code></pre><ul><li>实现类的多态的条件:<ol><li>父类（接口）指向子类的对象；</li><li>调用的方法被重写。</li></ol></li></ul><h3 id="对象变量的多态"><a class="markdownIt-Anchor" href="#对象变量的多态"></a> 对象变量的多态</h3><ul><li>一个对象变量可以指示多种实际类型的现象称为多态。</li><li>这种情况常出现在父类和子类的对象中。如,父类为Father，子类为Kid。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">var people &#x3D; new Father[2];Kid person1 &#x3D; new Kid();Father person2 &#x3D; new Father();for(Father e : people) &#123;    e.age++;&#125;</code></pre><ul><li>在这个例子中，对象变量e既有可能指向Father类型，也有可能指向Kid类型。</li></ul><h2 id="隐藏"><a class="markdownIt-Anchor" href="#隐藏"></a> 隐藏</h2><ul><li>与重写类似。重写是子类对父类的<strong>对象方法</strong>的覆盖，而隐藏是对父类的<strong>类方法的覆盖</strong>。示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package charactor;  public class Hero &#123;    public String name;    protected float hp;      &#x2F;&#x2F;类方法，静态方法    &#x2F;&#x2F;通过类就可以直接调用    public static void battleWin()&#123;        System.out.println(&quot;hero battle win&quot;);    &#125;      &#125;public class ADHero extends Hero &#123;      &#x2F;&#x2F;隐藏父类的battleWin方法    public static void battleWin()&#123;        System.out.println(&quot;ad hero battle win&quot;);    &#125;            public static void main(String[] args) &#123;        Hero.battleWin(); &#x2F;&#x2F;输出的是hero battle win        ADHero.battleWin(); &#x2F;&#x2F;输出的是ad hero battle win    &#125;  &#125;</code></pre><h2 id="super关键字"><a class="markdownIt-Anchor" href="#super关键字"></a> super关键字</h2><ul><li>super是在子类中调用父类被隐藏的属性，方法的关键字。<ol><li>显式调用父类构造方法；如<code>super(参数)</code></li><li>调用父类的属性：如<code>super.name</code></li><li>调用父类的普通方法:如<code>super.useItem()</code>.</li></ol></li><li><code>super()</code><strong>必须是子类构造函数的第一个执行语句</strong>。</li></ul><h2 id="object类"><a class="markdownIt-Anchor" href="#object类"></a> Object类</h2><ul><li>Object默认是<strong>所有类的父类</strong>。（全名：java.lang.Object:java.lang这个包是默认导入到每一个类中的）</li><li>Object类中提供的方法所有类都默认含有。</li><li>Objiect类中有很多方法，如<code>toString(), finalize(),equals()...</code>。</li></ul><h3 id="object类型的变量"><a class="markdownIt-Anchor" href="#object类型的变量"></a> Object类型的变量</h3><ul><li>可以使用Object类型的变量引用所有类型的<strong>对象</strong>。如：<code>Object obj = new Employee();</code>。（注意：除了基本类型（int，char，boolean…)不是对象，其他所有类型都是对象。）</li><li>所有的数组类型，不管是基本类型的数组还是对象数组都是Object类的扩展。如</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">Employee[] staff &#x3D; new Employee[10];obj &#x3D; staff; &#x2F;&#x2F;okobj &#x3D; int[10]; &#x2F;&#x2F;ok</code></pre><h3 id="equals方法"><a class="markdownIt-Anchor" href="#equals方法"></a> equals方法</h3><ul><li>Object中equals的实现：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">   &#x2F;&#x2F;第一种public boolean equals(Object obj) &#123;  return (this &#x3D;&#x3D; obj);  &#x2F;&#x2F;第二种</code></pre><ul><li>Objects类中equals的实现：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">static boolean equals(Object a, Object b) &#123;    ...&#125;</code></pre><ul><li>equals方法是用来检测一个对象是否等于另一个对象的(Object中的equals方法适用于两个参数都不为null的情况，Objects类中的equals方法两个参数都为null时返回true，一个为null是返回false，两个都不为null时<strong>返回a.equals(b)的结果</strong>，即进行正常比较。不过object类中直接判断两个对象的引用是否相等来判断对象是否想等的方法有时会不够，所以equals方法经常会在子类中被<strong>重写</strong>。如：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Employee&#123;    ...    @override &#x2F;&#x2F;用@override标记来表明这是对超类方法的覆盖，以避免出现参数类型不一致等情况（会报错）    public boolean equals(Object otherObject)&#123;&#x2F;&#x2F;参数类型必须为Object才能覆盖Object类中的equals方法        &#x2F;&#x2F;快速检查对象是否相同        if(this&#x3D;&#x3D;otherObject) return true;                &#x2F;&#x2F;如果EcPLID参数为空，则必须返回false        if(otherObject&#x3D;&#x3D;null) return false;                &#x2F;&#x2F;如果类不匹配，它们就不能相等。        if(getClass()!&#x3D;otherObject.getClass())            return false;                &#x2F;&#x2F;现在我们知道另一个对象是非空雇员，将其强制类型转换为对应的类型        Employee other &#x3D;(Employee)otherObject;                &#x2F;&#x2F;测试字段是否具有相同的值        return Object.equals(other.name);        &amp;&amp; salary&#x3D;&#x3D;other.salary        &amp;&amp; hireDay.equals(other.hireDay);    &#125;&#125;</code></pre><ul><li>equals方法的设计一般要遵循<strong>自反性</strong>，<strong>对称性</strong>，<strong>传递性</strong>，<strong>一致性</strong>，<strong>非空性</strong>。</li></ul><h3 id="hashcode方法"><a class="markdownIt-Anchor" href="#hashcode方法"></a> hashCode方法</h3><ul><li>散列码是由对象导出的一个整型值。没有规律，两个不同的对象的散列码基本不会相同。Object类的散列码是由对象的存储地址导出的。</li><li>hashCode方法：<code>int hashCode()</code>。返回对象的散列码。</li></ul><h3 id="tostring方法"><a class="markdownIt-Anchor" href="#tostring方法"></a> toString方法</h3><ul><li>toString方法会返回表示对象值的一个字符串：类名[字段值]。</li><li>Object类中的toString方法会打印对象的类名和散列码。toString 方法经常会在子类中被重写。如：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public String toString() &#123;    return getClass().getName() + &quot;name&#x3D;&quot; + name +&quot;salary&#x3D;&quot; + salary;&#125;</code></pre><ul><li>使用getClass和getName方法确保子类也可以调用该方法。</li><li>只要一个对象与一个字符串通过<code>+</code>相连，java编译器就会自动地调用toString方法来或得这个对象的字符串描述并与另一个字符串相连。</li></ul><h2 id="final修饰词"><a class="markdownIt-Anchor" href="#final修饰词"></a> final修饰词</h2><ul><li>final在修饰类、方法、基本类型变量、引用是分别有不同的意思。</li></ul><h3 id="final修饰类"><a class="markdownIt-Anchor" href="#final修饰类"></a> final修饰类</h3><ul><li>final修饰类时表示该类不能被继承。使用示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package charactor; public final class Hero extends Object &#123;            String name; &#x2F;&#x2F;姓名            float hp; &#x2F;&#x2F;血量        &#125;</code></pre><h3 id="final修饰方法"><a class="markdownIt-Anchor" href="#final修饰方法"></a> final修饰方法</h3><ul><li>如果类中的方法被final修饰，则代表该方法不能在子类中被重写。使用示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Hero &#123;            String name; &#x2F;&#x2F;姓名                    public final void useItem()&#123;        System.out.println(&quot;hero use item&quot;);    &#125;              public static void main(String[] args) &#123;        new Hero();    &#125;      &#125;</code></pre><h3 id="final修饰基本类型变量"><a class="markdownIt-Anchor" href="#final修饰基本类型变量"></a> final修饰基本类型变量</h3><ul><li>final修饰基本类型变量表示该类型只有一次赋值机会（即变量在第一次被手动初始化后便是只读的变量，再不可修改了），如：<code>final int hp = 2;</code></li></ul><h3 id="final修饰引用"><a class="markdownIt-Anchor" href="#final修饰引用"></a> final修饰引用</h3><ul><li>被final修饰的引用代表该引用只有一次被赋予指向对象的机会（类似基本类型变量只有一次赋值机会）。</li></ul><h2 id="抽象类"><a class="markdownIt-Anchor" href="#抽象类"></a> 抽象类</h2><h3 id="抽象方法"><a class="markdownIt-Anchor" href="#抽象方法"></a> 抽象方法</h3><ul><li>没有实现体的方法，是抽象方法。抽象方法使用<code>abstract</code>关键字标识。示例：<code>public abstract void attack();</code></li></ul><h3 id="抽象类-2"><a class="markdownIt-Anchor" href="#抽象类-2"></a> 抽象类</h3><ul><li><strong>包含抽象方法的类必须声明为抽象类</strong>，使用关键字<code>abstract</code>。</li><li>没有包含抽象方法的类也可以声明为抽象类。</li><li>抽象类不可以被直接实例化。即不可以使用<code>new</code>来创建抽象类的对象。但是<strong>抽象类类型的引用变量</strong>却是可以声明的。如果Person是一个抽象类，<code>new Person()</code>是错误的，但是<code>Person p;</code>却是可行的。</li><li><strong>构造方法，类方法（static修饰的方法），私有方法</strong>不可以作为抽象方法定义。</li><li><strong>抽象类与接口区别</strong>：一个子类只可以继承一个抽象类，但是可以实现多个接口。抽象类和接口都是为子类的具体实现提供了一个框架。</li><li>抽象类与接口中都可以包含实体的方法，这些实体方法被叫做<strong>默认方法</strong>。</li><li>示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class Hero &#123; &#x2F;&#x2F;声明为抽象类    String name;                 public static void main(String[] args) &#123;        &#x2F;&#x2F;虽然没有抽象方法，但是一旦被声明为了抽象类，就不能够直接被实例化        Hero h&#x3D; new Hero();    &#125;          &#125;</code></pre><h2 id="内部类"><a class="markdownIt-Anchor" href="#内部类"></a> 内部类</h2><ul><li>在一个类内部声明的类就是<strong>内部类</strong>，相应的外面的类为<strong>外部类</strong>。</li><li>内部类对同一个包中的其他类隐藏；</li><li>内部类方法可以访问定义这个类的类的作用域中的成员变量和成员方法，包括原本的<strong>私有变量和方法</strong>。</li><li>内部类<strong>不可以声明类变量和类方法</strong>（即内部类的成员变量和方法不可以用static来修饰）</li></ul><h3 id="非静态内部类"><a class="markdownIt-Anchor" href="#非静态内部类"></a> 非静态内部类</h3><ul><li>直接在类内部定义(类前面没有任何修饰词），只有在外部类存在的时候才有意义。实例化的语法：<code>new &lt;外部类&gt;().new &lt;内部类&gt;</code>或者<code>&lt;外部类引用&gt;.new &lt;内部类&gt;</code>.示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package charactor; public class Hero &#123;    private String name; &#x2F;&#x2F; 姓名     &#x2F;&#x2F; 非静态内部类，只有一个外部类对象存在的时候，才有意义    &#x2F;&#x2F; 战斗成绩只有在一个英雄对象存在的时候才有意义    class BattleScore &#123; &#x2F;&#x2F;直接在内部定义，前面没有修饰词        int kill;        int die;        int assit;         public void legendary() &#123;            if (kill &gt;&#x3D; 8)                System.out.println(name + &quot;超神！&quot;);            else                System.out.println(name + &quot;尚未超神！&quot;);        &#125;    &#125;     public static void main(String[] args) &#123;        Hero garen &#x3D; new Hero();        garen.name &#x3D; &quot;盖伦&quot;;        &#x2F;&#x2F; 实例化内部类        &#x2F;&#x2F; BattleScore对象只有在一个英雄对象存在的时候才有意义        &#x2F;&#x2F; 所以其实例化必须建立在一个外部类对象的基础之上        BattleScore score &#x3D; garen.new BattleScore();        score.kill &#x3D; 9;        score.legendary();    &#125; &#125;</code></pre><h3 id="静态内部类"><a class="markdownIt-Anchor" href="#静态内部类"></a> 静态内部类</h3><ul><li>静态内部类在外部类里面定义时加上了<code>static</code>修饰，此时的内部类与普通类相比，除了内部类可以访问外部类的私有静态成员外，没有任何区别。</li><li>静态内部类不依赖于外部类的对象，所以可以直接实例化。如<code>h = new Hero.EnemyCrystal()</code>.</li><li>示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package charactor;  public class Hero &#123;    public String name;    protected float hp;      private static void battleWin()&#123;        System.out.println(&quot;battle win&quot;);    &#125;         &#x2F;&#x2F;敌方的水晶    static class EnemyCrystal&#123;        int hp&#x3D;5000;                 &#x2F;&#x2F;如果水晶的血量为0，则宣布胜利        public void checkIfVictory()&#123;            if(hp&#x3D;&#x3D;0)&#123;                Hero.battleWin();                                 &#x2F;&#x2F;静态内部类不能直接访问外部类的对象属性                System.out.println(name + &quot; win this game&quot;);            &#125;        &#125;    &#125;         public static void main(String[] args) &#123;        &#x2F;&#x2F;实例化静态内部类        Hero.EnemyCrystal crystal &#x3D; new Hero.EnemyCrystal();        crystal.checkIfVictory();    &#125;  &#125;</code></pre><h3 id="匿名类"><a class="markdownIt-Anchor" href="#匿名类"></a> 匿名类</h3><ul><li>直接使用一个类的子类的类体创建一个子类对象，该类体被认为是创建该类的类的子类。如：<code>new People() &#123;子类（匿名类）的类体&#125;</code></li><li>也可以直接使用接口名和一个类体创建一个匿名对象，此类体被认为是实现了该接口的类。如：<code>new Computable() &#123;匿名类类体&#125;</code></li><li>对于抽象方法，本来应该在子类中对其实现后，再实例化。但是<strong>匿名类</strong>是在实际使用这个抽象方法的时候直接对其现场实现，省去了在子类中实现的步骤，因而没有子类的名字，叫做匿名。但是，实际上系统是自动为这个你未曾创建的子类分配了一个名字。</li><li>示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package charactor;   public abstract class Hero &#123;    String name; &#x2F;&#x2F;姓名                 public abstract void attack(); &#x2F;&#x2F;抽象方法          public static void main(String[] args) &#123;                  ADHero adh&#x3D;new ADHero();        &#x2F;&#x2F;通过打印adh，可以看到adh这个对象属于ADHero类        adh.attack();        System.out.println(adh);                  Hero h &#x3D; new Hero()&#123; &#x2F;&#x2F;对抽象类在实例化时直接实现抽象类，省去了在子类中实现的步骤，从而没有类名，故为匿名类。            &#x2F;&#x2F;当场实现attack方法            public void attack() &#123;                System.out.println(&quot;新的进攻手段&quot;);            &#125;        &#125;;        h.attack();        &#x2F;&#x2F;通过打印h，可以看到h这个对象属于Hero$1这么一个系统自动分配的类名                  System.out.println(h);    &#125;      &#125;</code></pre><h3 id="本地类"><a class="markdownIt-Anchor" href="#本地类"></a> 本地类</h3><ul><li>本地类可以看做有名字的匿名类，都是在实际使用的代码块里对抽象方法进行实现，只是本地类还顺手创建了子类的名字。示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package charactor;   public abstract class Hero &#123;    String name; &#x2F;&#x2F;姓名          public abstract void attack();          public static void main(String[] args) &#123;                  &#x2F;&#x2F;与匿名类的区别在于，本地类有了自定义的类名        class SomeHero extends Hero&#123; &#x2F;&#x2F;s使用时创建了Hero的子类SomeHero            public void attack() &#123;                System.out.println( name+ &quot; 新的进攻手段&quot;);            &#125;        &#125;                 SomeHero h  &#x3D;new SomeHero();        h.name &#x3D;&quot;地卜师&quot;;        h.attack();    &#125;      &#125;</code></pre><h2 id="默认方法-2"><a class="markdownIt-Anchor" href="#默认方法-2"></a> 默认方法</h2><ul><li>在接口中除了抽象方法，还可以实现具体的方法，这个实现了的方法就是默认方法。默认方法前使用<code>default</code>来修饰。示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package charactor; public interface Mortal &#123;    public void die(); &#x2F;&#x2F;抽象方法     default public void revive() &#123; &#x2F;&#x2F;默认方法        System.out.println(&quot;本英雄复活了&quot;);    &#125;&#125;</code></pre><h1 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h1><ol><li><code>//</code>方式：其注释内容从//开始到本行末尾。</li><li><code>/* */</code>方式：其注释内容从<code>/*</code>开始到<code>*/</code>结束。</li><li>文档注释：从<code>/**</code>开始到<code>*/</code>结束。</li></ol><h2 id="文档注释"><a class="markdownIt-Anchor" href="#文档注释"></a> 文档注释</h2><ul><li>文档注释借助于javadoc工具实现，它可以由源文件生成一个HTML文档。</li><li>在注释中包含<strong>标记</strong>和自由格式的文本(在其中可以使用HTML修饰符)。每个标记以<code>@</code>开始，如<code>@return</code>.</li></ul><h3 id="类注释"><a class="markdownIt-Anchor" href="#类注释"></a> 类注释</h3><ul><li>类注释放在<code>import</code>语句之后，类定义之前。</li></ul><h3 id="方法注释"><a class="markdownIt-Anchor" href="#方法注释"></a> 方法注释</h3><ul><li>方法注释放在所描述的方法之前。通常会使用标记。</li><li><code>@param</code>：用以描述当前方法的参数(parameters),可以占据多行。</li><li><code>@return</code>:用以描述当前方法的返回信息，同样可以占据多行。</li><li><code>@throws</code>：表示这个方法有可能抛出异常。</li></ul><h3 id="字段注释"><a class="markdownIt-Anchor" href="#字段注释"></a> 字段注释</h3><ul><li>对公共字段（通常为静态常量）建立文档。</li></ul><h3 id="通用注释"><a class="markdownIt-Anchor" href="#通用注释"></a> 通用注释</h3><ul><li><code>@since</code>：建立一个描述这个特性的版本的文本。</li><li><code>@author</code>:描述作者，可以有多个这个标记，每个标记对应一个作者。</li><li><code>@version</code>:描述当前版本。</li><li><code>@see</code>和<code>@link</code>：可以在之后放指向其它类或方法，以及URL的超链接。</li></ul><h3 id="包注释"><a class="markdownIt-Anchor" href="#包注释"></a> 包注释</h3><ul><li>在每个包的目录下创建一个名为package-info.java（包含一个Javadoc文档，在文档后面是一个package语句）或者package.html的文件（使用普通的html即可，javadoc会抽取<code>&lt;body&gt;...&lt;/bode&gt;</code>的部分）.</li></ul><h3 id="文档注释的抽取"><a class="markdownIt-Anchor" href="#文档注释的抽取"></a> 文档注释的抽取</h3><ul><li>使用<a href="https://www.cnblogs.com/fjhh/p/5370642.html">javadoc</a>.</li></ul><h1 id="异常-断言和日志"><a class="markdownIt-Anchor" href="#异常-断言和日志"></a> 异常、断言和日志</h1><h2 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h2><ul><li>异常就是程序执行过程中出现的不正常现象，如非预期情况，错误的参数，网络故障等。</li><li>任何一个程序都可能出现异常，java使用<strong>异常对象</strong>表示打开的文件不存在，内存不够，数组访问超界等非预期情况。</li></ul><h3 id="异常概念"><a class="markdownIt-Anchor" href="#异常概念"></a> 异常概念</h3><ul><li><strong>异常处理的任务</strong>：将控制权从产生错误的地方转移到能够处理这种情况的错误处理器。</li><li><strong>程序中可能会出现的错误</strong>：<ul><li>用户输入错误；</li><li>设备错误；</li><li>物理限制（存储空间）；</li><li>代码错误。</li></ul></li><li><strong>异常处理过程</strong>： 如果某个方法不能够正常的完成，可以通过<strong>抛出</strong>一个封装了错误信息的异常对象来退出方法。需要退出的方法并不返回任何值，而是<strong>直接退出</strong>（中断处理），之后异常处理机制开始搜索能够处理这种异常的异常处理器。</li></ul><h3 id="异常分类"><a class="markdownIt-Anchor" href="#异常分类"></a> 异常分类</h3><ul><li><strong>异常对象</strong>：是派生于Throwable类的类实例。</li><li><strong>异常的层次结构</strong>：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201015184846.jpg" alt="" /><ul><li>所有的异常类都是由<strong>Throwable类</strong>继承而来，Throwable类属于java.lang类，不需要import即可使用。</li><li><strong>Error</strong>类层次结构：描述了java运行时的系统内部错误和资源耗尽错误，不能人工处理的，一般也不要求处理。</li><li><strong>Exception</strong>类层次结构：是设计程序时主要关注的异常。</li><li><strong>RuntimeException</strong>:由<strong>编程错误</strong>导致的异常（如果出现RuntimeException异常，一定是程序员的问题），又称运行期异常，一般也不要求处理，只要求提示。具体包含：<ul><li>错误的强制类型转换；</li><li>数组访问越界；</li><li>访问null指针。</li></ul></li><li><strong>IOException</strong>:包含除RuntimeException的其他异常，例如：<ul><li>试图超越文件末尾继续读取数据；</li><li>试图打开一个不存在的文件；</li><li>试图根据给定的字符串查找并不存在的Class对象。</li></ul></li></ul></li><li><strong>非检查型异常与检查型异常</strong>：所有派生于<strong>Error或者RuntimeException类的异常称为非检查型异常</strong>。其余异常为检查型异常。</li></ul><h3 id="异常处理的第一种方式声明检查型异常"><a class="markdownIt-Anchor" href="#异常处理的第一种方式声明检查型异常"></a> 异常处理的第一种方式：声明检查型异常</h3><ul><li>在方法首法使用<code>throws</code>关键字声明该方法可能抛出的<strong>检查型异常</strong>：如： <code>public FileInputStream(String name) throws FileNotFoundException</code>。如果会抛出多个异常，可以在首部声明所有的检查型异常类,用逗号分隔，如：<code>public Image loadImage(String s) throws FileNotFoundException, EoFException</code></li><li>一个方法必须声明所有可能抛出的<strong>检查型异常</strong>。而非检查型异常是我们无法控制的（Error），或者是我们应该极力在编程时避免的（RuntimeException）。</li><li><strong>子类</strong>方法中声明的检查型异常是<strong>父类</strong>方法中的声明的异常相同的，或者是该异常的子类。如果父类没有声明异常，则子类也不可以声明异常。</li><li>如果方法中抛出的多个异常都是一个异常的子类，那么只需要声明这写异常的父类异常即可。</li><li>声明的检查型异常会抛出给方法的调用者处理，最终交给JVM处理。</li><li>调用一个声明了抛出异常的方法，必须处理声明的异常，有以下两种方法：<ol><li>在调用这个方法的方法里继续使用throws声明抛出异常，交给jvm来处理，但是jvm处理异常是通过中断来处理的，在抛出异常对象的语句之后的代码不会再被执行。</li><li>在该方法里使用<code>try...catch</code>语句，自己处理该异常。</li></ol></li></ul><h3 id="抛出异常"><a class="markdownIt-Anchor" href="#抛出异常"></a> 抛出异常</h3><ul><li>抛出指定异常的方法：<ol><li>找到一个合适的异常类；</li><li>创建这个类的<strong>对象</strong>：如：<code>var e = new EOFException</code></li><li>将对象抛出：如<code>throw e</code>。</li></ol></li><li>2、3步可以合并为一步：<code>throw new EOFException</code></li><li>每个异常类都带有一个字符串参数的构造器，可以用来描述异常的具体信息。如：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">String gripe &#x3D; &quot;Content-length: &quot; + len +&quot;, Recived: &quot; + n;throw new EOFException(gripe);</code></pre><ul><li>throws 出来的RuntimeException或者其子类异常，就可以直接抛出交给jvm内置的异常处理器来处理。</li></ul><h3 id="创建异常类"><a class="markdownIt-Anchor" href="#创建异常类"></a> 创建异常类</h3><ul><li>如果标准的异常类不能描述清楚你程序的问题，那么就需要创建自己的异常类。</li><li>命名以Exception结尾。</li><li>自定义的异常类需要派生于Exception类或者Exception的子类（<strong>所有异常类都是Throwable类的子类</strong>）。并且这个类中应该包含两个构造器：一个默认的构造器（无参数），一个包含<strong>描述异常信息的字符串参数的构造器</strong>。示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">class FileFormatException extends IOException &#123;    public FileFormatException() &#123;&#125; &#x2F;&#x2F;默认的构造器    public FileFormatException (String gripe) &#123;        super(gripe);&#x2F;&#x2F;父类构造器中有含这个参数的构造器，直接借用即可    &#125;&#125;</code></pre><h3 id="异常的第二种处理方法捕获异常"><a class="markdownIt-Anchor" href="#异常的第二种处理方法捕获异常"></a> 异常的第二种处理方法：捕获异常</h3><ul><li>抛出异常是将发生的异常交给异常处理器取处理。而与之相对的<strong>捕获异常</strong>就是将异常交给用户指定的异常处理器去处理。</li><li>在调用可能会产生异常的方法时使用<code>try/catch</code>来捕获异常，来替代直接throws声明异常将异常继续抛出交给jvm来处理。</li><li>捕获异常需要使用<code>try/catch</code>语句块，要捕获异常的方法就不再使用<code>throws</code>声明抛出异常。示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void read(String filename) &#123;    try &#123;        &#x2F;&#x2F;放置可能产生异常的代码        var in &#x3D; new FileInputStream(filename);        int b;        while (b &#x3D; in.read() !&#x3D; -1) &#123;            process input        &#125;    &#125;    catch (IOException exception) &#123; &#x2F;&#x2F;异常类名 异常对象名， 发挥了声明异常中throw new 异常的作用        exception.printStackTrace(); &#x2F;&#x2F;调用对应异常的处理器方法    &#125;&#125;</code></pre><ul><li><strong>捕获多个异常</strong>：在一个try语句块中可以捕获多个异常类型，并对不同的异常类型做出不同的处理。例如：  <pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;    &#x2F;&#x2F;code that might throw exceptions&#125;catch (FileNotFoundException e) &#123;    &#x2F;&#x2F;emergency action for missing files&#125; catch (IOException e) &#123; &#x2F;&#x2F;父类异常必须放在子类异常后面，否则子类异常就失去作用了    &#x2F;&#x2F;emergency action for all other I&#x2F;O problems&#125;​&#96;&#96;&#96;java    * 还可以用一个catch语句捕获多个异常类型，前提是这些异常类型彼此之间不存在子类关系。如：​&#96;&#96;&#96;javatry &#123;    &#x2F;&#x2F;code that might throw exceptions&#125;catch (FileNotFoundException e | UnknownHostException e) &#123; &#x2F;&#x2F;同时捕获多个异常    &#x2F;&#x2F;emergency action for missing files or unknown hosts&#125; catch (IOException e) &#123;    &#x2F;&#x2F;emergency action for I&#x2F;O problems&#125;</code></pre></li><li><strong>再次抛出异常</strong>：可以在catch语句中仅记录一个异常（即<em>不对该异常对象做修改</em>），之后再将这个异常重新抛出。此时可以在方法上重新加上<code>throws</code>关键字，指明抛出的异常类型。示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;    &#x2F;&#x2F;access thr database&#125;catch (Exception) &#123;    logger.log(level, message, e);&#x2F;&#x2F;仅仅是记录该异常的信息    throw e;&#125;</code></pre><h3 id="finally子句"><a class="markdownIt-Anchor" href="#finally子句"></a> finally子句</h3><ul><li>代码抛出一个异常时，会停止处理这个方法中的剩余的代码，并退出这个方法。但此时可能会有这个方法以及获得的资源没有清理。而finally子句正是用来清理这这些资源的。</li><li><strong>finally不能单独使用，必须和try一起使用</strong>。</li><li><strong>无论该方法有没有抛出异常，finally子句中的代码都会在前面代码按照普通流程结束后执行</strong>（没有异常则顺序执行到finally子句，捕获了异常则在catch中处理了异常再执行finall子句，抛出了异常则抛出异常后执行finally子句），示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">var in &#x3D; new FileInputStream;try &#123;    &#x2F;&#x2F;code&#125;catch (IOException) &#123;    &#x2F;&#x2F;...&#125;finally &#123;    in.close();&#125;</code></pre><ul><li>还可以将两个try嵌套，内层try确保关闭资源，外层try语句确保报告错误。示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">InputStream in &#x3D; ...;try &#123;    try &#123;        &#x2F;&#x2F;code that might throw exception    &#125;    finally &#123;        in.close();    &#125;&#125;catch (IOException) &#123;    &#x2F;&#x2F;...&#125;</code></pre><h3 id="try-with-resources语句"><a class="markdownIt-Anchor" href="#try-with-resources语句"></a> try-with-Resources语句</h3><ul><li>try-with-Resources语句是和finally子句实现同样功能的。可以在try后面加上执行完代码后需要关闭的资源，这样构成try-with-Resources语句,无论什么时候退出try语块，都会自动将资源关闭。示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">try (var in &#x3D; new Scanner(new FileInputStream(&quot;&#x2F;usr&#x2F;share&#x2F;dict&#x2F;words&quot;), StandardCharests.UTF_8)) &#123;    while (in.hasNext()) &#123;        System.out.println(in.next());    &#125;&#125;</code></pre><ul><li>try-with-Resources语句也可以带上catch子句和finally子句。</li></ul><h3 id="分析堆栈轨迹元素"><a class="markdownIt-Anchor" href="#分析堆栈轨迹元素"></a> 分析堆栈轨迹元素</h3><ul><li>堆栈轨迹（stack trace）是程序执行过程中某个特定点上所有挂起的方法调用的一个列表。</li><li>可以通过Throwable类或者StackWalker类来显示堆栈轨迹。</li></ul><h2 id="断言"><a class="markdownIt-Anchor" href="#断言"></a> 断言</h2><ul><li><strong>断言</strong>：断言机制允许在测试代码时插入一些检查。使用关键字<code>assert</code>来使用断言。一般格式:<ul><li><code>assert condition;</code>:这个语句会计算condition中的条件，如果结果为false，就会抛出一个AssertionError的异常。</li><li><code>assert condition:expression;</code>:在前一个语句的基础上增加了expression异常描述消息字符串，这个语句会将这个expression描述传入AssertionError的对象构造器中。</li></ul></li><li>示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;断言x是一个非负数。assert x &gt;&#x3D; 0;&#x2F;&#x2F;或者assert x &gt;&#x3D; 0 : x;</code></pre><ul><li>断言的使用场景：<ul><li>断言失败应该是失败的、不可恢复的错误；</li><li>断言检查只是用在开发和测试调试阶段，是程序员用来自我检查的工具。</li></ul></li></ul><h2 id="日志"><a class="markdownIt-Anchor" href="#日志"></a> 日志</h2><ul><li>日志用来记录程序中需要记录的问题。可以用java自带的API（如：java.util.logging）实现，也可以用第三方平台的API实现。</li></ul><h1 id="并发"><a class="markdownIt-Anchor" href="#并发"></a> 并发</h1><h2 id="线程与进程"><a class="markdownIt-Anchor" href="#线程与进程"></a> 线程与进程</h2><ul><li>每个进程(processor)都拥有自己的一套变量，而线程(thread)之间共享数据。线程比进程更加的轻量级。</li><li>线程是在进程内部同时做的事情。</li><li>多线程即在同一时间，可以做多件事情。</li><li>线程由3部分组成：<ol><li>虚拟的cpu：封装在Java.lang.Thread类中。</li><li>cpu所执行的代码：传递给Thread类。</li><li>cpu所处理的数据：传递给Thread类。</li></ol></li></ul><h2 id="创建多线程"><a class="markdownIt-Anchor" href="#创建多线程"></a> 创建多线程</h2><h3 id="继承线程类创建多线程"><a class="markdownIt-Anchor" href="#继承线程类创建多线程"></a> 继承线程类创建多线程</h3><ul><li>可以通过继承<code>Thread</code>类来实现创建线程，如：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class KillThread extends Thread&#123; &#x2F;&#x2F;KillThread是继承自Thread的子类         private Hero h1;    private Hero h2;     &#x2F;&#x2F;线程的构造器    public KillThread(Hero h1, Hero h2)&#123;        this.h1 &#x3D; h1;        this.h2 &#x3D; h2;    &#125;     public void run()&#123; &#x2F;&#x2F;覆盖Thread中的run方法（必须），以实现启动线程后的具体操作。        while(!h2.isDead())&#123;            h1.attackHero(h2);        &#125;    &#125;&#125;</code></pre><ul><li>无论使用什么方法实现线程，线程启动都需要使用Thread类中的<strong>start方法</strong>。线程启动示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">KillThread killThread1 &#x3D; new KillThread(gareen,teemo); &#x2F;&#x2F;新建一个线程killThread1.start(); &#x2F;&#x2F;启动一个创建的线程KillThread killThread2 &#x3D; new KillThread(bh,leesin);killThread2.start();</code></pre><h3 id="实现runable接口来创建多线程"><a class="markdownIt-Anchor" href="#实现runable接口来创建多线程"></a> 实现Runable接口来创建多线程</h3><ul><li>Runable接口中有一个run方法，实现这个接口的时候必须实现run方法（run方法中是这个线程需要做的事）。</li><li>实现Runable接口示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Battle implements Runnable&#123; &#x2F;&#x2F;实现Runable接口的类         private Hero h1;    private Hero h2;     public Battle(Hero h1, Hero h2)&#123;        this.h1 &#x3D; h1;        this.h2 &#x3D; h2;    &#125;     public void run()&#123; &#x2F;&#x2F;实现run方法        while(!h2.isDead())&#123;            h1.attackHero(h2);        &#125;    &#125;&#125;</code></pre><ul><li>无论使用什么方法都需要<strong>实现run方法</strong>。</li><li>线程启动示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">Battle battle1 &#x3D; new Battle(gareen,teemo); &#x2F;&#x2F;启动的时候，首先创建一个Battle对象，然后再根据该battle对象创建一个线程对象，并启动 new Thread(battle1).start(); &#x2F;&#x2F;把Battle对象作为Thread对象的构造器的参数来新建一个Thread对象，并直接调用start方法启动这个线程。 Battle battle2 &#x3D; new Battle(bh,leesin);new Thread(battle2).start();</code></pre><h3 id="使用匿名类创建多线程"><a class="markdownIt-Anchor" href="#使用匿名类创建多线程"></a> 使用匿名类创建多线程</h3><p>。。。</p><h2 id="线程的状态"><a class="markdownIt-Anchor" href="#线程的状态"></a> 线程的状态</h2><ul><li>线程有4个状态：<ol><li><strong>新生态</strong>：线程生成后立即进入新生态，此时该线程已被初始化（分配存储空间，初始化数据）。此时的线程可以使用<code>start()</code>方法调度。</li><li><strong>可执行态</strong>：，新生态使用<code>start()</code>方法被调度后，进入可执行态，随时可以被执行，可细分为两种状态：<ol><li>执行状态：已获得cpu，正在执行。</li><li>就绪状态：只等待处理器资源。这两个子状态的过渡由执行调度器来控制。</li></ol></li><li><strong>阻塞态</strong>：由于某种原因引起线程暂停执行的状态。</li><li><strong>停止态</strong>：线程执行完毕或者另一线程调用<code>stop（）</code>使该线程停止，进入停止态，它表示线程已经退出执行状态，并且不再进入可执行状态。</li></ol></li><li>一个线程被创建后就有了生命周期。线程在创建后到销毁前总处于这四种状态中。</li></ul><h2 id="线程优先级"><a class="markdownIt-Anchor" href="#线程优先级"></a> 线程优先级</h2><ul><li><p>优先级是线程获得cpu而执行的优先程度。java把优先级划为10级，用1到10整数表示，数值越大，优先级越高。</p></li><li><p>Tread类中定义了三个优先级常量：<code>MIN_PRIORITY</code>,<code>MAX_PRIORITY</code>, <code>NORM_PRIORITY</code>分别对应1，10，5.默认线程优先级是<code>NORM_PRIORITY</code>。</p></li><li><p>Thread类中的<code>setPriority(int a)</code>方法可以修改线程的优先级。</p></li><li><p>java采用<strong>抢占式调度方式</strong>，高优先级线程具有剥夺低优先级线程执行的权利。正在执行的低优先级线程，遇到高优先级线程只能停止，让高优先级线程立即执行。相同优先级的线程采取先来先执行。</p></li><li><p>调用**<code>sleep()</code>**方法能使线程暂时进入“睡眠状态”，让出cpu，使与其具有相同优先级线程或者低优先级的线程有执行的机会。</p></li><li><p>**<code>yield()</code>**方法能让线程放弃cpu，使与其具有相同优先级的线程具有执行的机会。</p></li></ul><h2 id="线程同步"><a class="markdownIt-Anchor" href="#线程同步"></a> 线程同步</h2><ul><li>多线程同步控制机制：保证同一时刻只有<strong>一个线程访问数据资源</strong>。</li><li>Tread类定义控制线程执行的方法：<ol><li><strong><code>start()</code></strong>:用于调用<code>run()</code>方法使线程开始执行，进入可执行态；</li><li><strong><code>stop()</code></strong>:立即停止线程执行，其内部状态清零，放弃占用资源，进入停止态；</li><li><strong><code>wait()</code></strong>:使线程处于等待状态，进入阻塞态；</li><li><strong><code>notify()</code></strong>:使线程脱离阻塞状态,进入可执行态；</li><li><strong><code>sleep()</code></strong>:调整线程执行时间，参数指定睡眠时间，睡眠时间内，进入阻塞态；</li><li><strong><code>yield</code></strong>:暂停调度线程并将其放在等待队列的末尾，等待下一轮执行。</li></ol></li><li><strong>同步锁</strong>：java使用锁标志（lock flag），对被访问数据进行同步限制（上锁），从而实现对数据的保护。线程必须取得锁标志才能访问被保护（上锁）的资源。</li><li>使用<code>synchronized</code>修饰符来为保护资源上锁。但是<code>synchronzied</code>只能用来说明<strong>方法</strong>和<strong>代码段</strong>，不能用来说明类和成员变量。被<code>synchronized</code>修饰的方法或者代码段同一时刻只能被一个线程执行，其他想用的线程必须等待。</li><li><code>wait()</code>可使一个线程进入阻塞状态，等待其他线程用<code>notify</code>唤醒。<code>notifyAll()</code>可以唤醒其它所有线程。二者配合实现同步机制。</li></ul><h1 id="流"><a class="markdownIt-Anchor" href="#流"></a> 流</h1><ul><li>流(stream)是指在计算机的输入和输出之间运动的数据序列。</li><li>流通过java的输入输出系统与物理设备链接。</li><li><strong>字节流</strong>：java把处理二进制数据的流称为字节流，字节流每次处理一个字节的数据。字节流的命名以<strong>Stream</strong>结尾。</li><li><strong>字符流</strong>：把处理某种格式的特定数据称为字符流，字符流每次处理一个字符的数据。字符流命名以<strong>Reader /Writer</strong>结尾。</li><li><strong>节点流</strong>：node stream是指直接从指定的位置（如磁盘文件或内存区域）读或写。</li><li><strong>过滤器</strong>：非节点流的流称为过滤器（filters）。过滤器输入流往往是将其它输入流作为它的输入流，经过过滤或处理后再以新的输入流的形式提供给用户；过滤输出流也类似。</li></ul><h2 id="javaiofile类"><a class="markdownIt-Anchor" href="#javaiofile类"></a> java.io.File类</h2><ul><li>File类是<strong>文件及文件目录路径名的抽象表示形式</strong>。java可以使用File类对文件和目录进行创建，删除，获取，判断，遍历等操作。</li><li>File类是与系统无关的类，任何操作系统都可以使用这个类中的方法和字段（它会自适应各种操作系统）。</li></ul><h3 id="file类的成员变量"><a class="markdownIt-Anchor" href="#file类的成员变量"></a> File类的成员变量</h3><ul><li>成员变量（都为静态）：<ul><li><code>static String pathSeparator;</code>路径分隔符：Windows中为分号<code>;</code>,linux系统为冒号<code>:</code>.</li><li><code>static String separator</code>:文件名分隔符：Windows中为反斜杠<code>\</code>,linux中为正斜杠<code>/</code>。</li><li><code>static char pathSeparetorChar</code>:内容一样的字符表示形式。</li><li><code>static char separatorChar</code>：内容一样的字符表示形式。</li></ul></li><li>路径：<ul><li>绝对路径：完整路径，以盘符<code>C:\\</code>开始，如<code>C:\02Permanent\Blog\source\_posts</code></li><li>相对路径：相对于当前项目的根目录，可以省略当前项目的根目录。若当前路径<code>C:\02Permanent\Blog\source\_posts\java.md</code>,在当前目录下可以简写为<code>java.md</code>。</li><li>路径不区分大小写；</li><li>Windows的文件名分隔符原本为<code>\</code>,但是反斜杠又有转义的作用，所以需要使用两个反斜杠<code>\\</code>来表示分隔符。</li></ul></li></ul><h3 id="file类的构造方法"><a class="markdownIt-Anchor" href="#file类的构造方法"></a> File类的构造方法</h3><ul><li>构造方法：<ul><li><code>File(String pathname)</code>:通过将给定路径名字符串转换为抽象路径名来创建一个File对象。<ul><li>参数：路径名称的字符串为构造的参数。<ul><li>既可以是文件结尾，也可以是文件名结尾。</li><li>既可以是绝对路径，也可以是相对路径。</li><li>路径可以存在的，也可以是不存在的。</li></ul></li></ul></li><li><code>File(String parent, String child)</code>:根据parent路径名字符串和child路径名字符串创建一个File对象。<ul><li>参数：将路径分为了父路径和子路径两个部分，父路径和子路径都可以单独变化，使用起来很灵活。</li><li>示例：<code>File f = new File(&quot;c:\\&quot;, &quot;java.md&quot;);</code>f的结果为<code>c:\java.md</code>。</li></ul></li><li><code>File(File parent, String chile)</code>:根据parent<strong>抽象</strong>路径名和child路径名字符串创建一个File对象。<ul><li>参数：把路径分为了抽象路径和路径名字符串两部分。可以使用File类的方法对parent路径进行操作，再使用该路径创建File对象。</li><li>示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">File parent &#x3D; new File(&quot;c:\\&quot;);File file &#x3D; new File(parent, &quot;hello.java&quot;);</code></pre></li><li><code>File(URL url)</code>：暂略</li></ul></li></ul><h3 id="file类获取文件信息的方法"><a class="markdownIt-Anchor" href="#file类获取文件信息的方法"></a> File类获取文件信息的方法</h3><ul><li><code>public String getAbsolutePath()</code>：返回此File的<strong>绝对路径</strong>名字符串；（返回构造File时的传入的路径）</li><li><code>public String getPath()</code>:返回此File的路径名字符串（既可以是绝对路径，也可以是相对）</li><li><code>public String getName()</code>:返回此File表示的<strong>文件或者目录的名称</strong>（即构造时传入的路径的结尾部分）</li><li><code>public String getParent()</code>:返回File对象的父目录名称。</li><li><code>public long lenght()</code>:返回此File表示的文件的长度；<ul><li>长度是以字节为单位计算的；</li><li>目录是没有大小的，只能得到具体文件的长度大小。</li></ul></li></ul><h3 id="file类判断属性或状态的方法"><a class="markdownIt-Anchor" href="#file类判断属性或状态的方法"></a> File类判断属性或状态的方法</h3><ul><li><code>public boolean exists();</code>:此File对象表示的文件或者目录是否真实存在。如果路径本身就不存在，则直接返回false</li><li><code>public boolean isDirectory();</code>此File对象表示的是否为目录。如果路径本身就不存在，则直接返回false</li><li><code>public boolean isFile();</code>此File对象表示的是否为文件。如果路径本身就不存在，则直接返回false</li><li>还有<code>canWrite(), canRead(), isAbsoulte()</code>等分别表示是否写保护，是否读保护，是否使用绝对路径。</li></ul><h3 id="file类创建和删除的方法"><a class="markdownIt-Anchor" href="#file类创建和删除的方法"></a> File类创建和删除的方法</h3><ul><li><code>public boolean createNewFile();</code>:当且仅当具有该名称的<strong>文件</strong>尚不存在的时候，创建一个新的空文件。<ul><li>创建文件的路径和名称在构造方法中给出</li><li>文件不存在，创建文件，返回true</li><li>文件存在，返回false</li><li>如果路径不存在，则会抛出<strong>IOException异常</strong>;所以调用这个方法要么throws异常，要么使用try-catch捕获异常。</li><li>只能创建文件，不能创建文件夹（目录）</li></ul></li><li><code>public boolean mkdir();</code>:创建由此File表示的目录（只能创建单级空文件夹）<ul><li>创建文件夹的路径和名称在构造方法中给出</li><li>文件夹不存在，创建文件，返回true</li><li>文件夹存在，返回false</li><li>如果路径不存在，则还是返回false</li><li>只能创建文件夹，不能创建文件。</li></ul></li><li><code>public boolean mkdirs();</code>:创建由此File表示的目录（能够创建多级文件夹，如<code>File//111//222//333</code>）<ul><li>创建文件夹的路径和名称在构造方法中给出</li><li>文件夹不存在，创建文件，返回true</li><li>文件夹存在，返回false</li><li>如果路径不存在，则还是返回false</li><li>只能创建文件夹，不能创建文件。</li></ul></li><li><code>public boolean delete();</code>删除由此File表示的<strong>文件或目录</strong><ul><li>文件或者目录删除成功，返回true</li><li>文件夹中有内容，不会删除返回false；</li><li>构造方法中的路径不存在返回false；</li><li>该方法直接在硬盘删除文件或者文件夹，不走回收站。</li></ul></li></ul><h3 id="file的目录遍历功能"><a class="markdownIt-Anchor" href="#file的目录遍历功能"></a> File的目录遍历功能</h3><ul><li><code>public String[] list();</code>:返回一个String数组，表示该File目录中所有的子文件或目录。遍历构造方法中给出的目录，会获取目录中<strong>所有文件/文件夹的名称</strong>，把获取到的多个名称存储到一个String类型的数组。（打印出来就是文件或者文件夹名）</li><li><code>public File[] listFiles();</code>:返回一个File数组，表示该File目录中所有的子文件或目录。遍历构造方法中的目录，或获取目录中所有的文件或文件夹，把文件或者文件夹封装为File对象，多个File对象，存储到File数组中。（打印出来的是文件名和它的完整存储路径）</li><li>这两种方法遍历的是构造方法中给出的目录，如果给出的目录路径不存在，会抛出空指针异常，如果给出的路径不是一个目录，也会抛出一个空指针异常。</li><li>示例：递归打印多级目录</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.File;public class Recurison &#123;    public static void main(String[] args) &#123;        File file &#x3D; new File(&quot;c:&#x2F;&#x2F;...&quot;);        getAllFile(file);    &#125;    public  static void getAllFile(File dir) &#123;        File[] files &#x3D; dir.listFiles();        System.out.println(dir);        for(File f : files) &#123;            if(f.isDirectory()) &#123;                getAllFile(f);            &#125; else &#123;                System.out.println(f);            &#125;        &#125;    &#125;&#125;</code></pre><ul><li>示例：遍历目录，只需以.java结尾的文件</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.File;public class Recurison &#123;    public static void main(String[] args) &#123;        getAllFile(file);    &#125;    public  static void getAllFile(File dir) &#123;        File[] files &#x3D; dir.listFiles();        System.out.println(dir);        for(File f : files) &#123;            if(f.isDirectory()) &#123;                getAllFile(f);            &#125; else &#123;                &#x2F;*                * 三选一                *&#x2F;                &#x2F;&#x2F;String name &#x3D; f.getName();                &#x2F;&#x2F;String path &#x3D; f.getPath();                String s &#x3D; f.toString();                                &#x2F;&#x2F;把字符串转换为小写                s &#x3D; s.tolowerCase();                boolean b &#x3D; s.endWith(&quot;.java&quot;);                if(b) &#123;                    System.out.println(f);                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="filefilter和filenamefilter过滤器"><a class="markdownIt-Anchor" href="#filefilter和filenamefilter过滤器"></a> FileFilter和FilenameFilter过滤器</h3><ul><li>FileFilter是一个接口，用于抽象路径名（File对象）的过滤；</li><li>FileFilter内有过滤文件的抽象方法：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">boolean accept (File pathname) &#x2F;&#x2F;测试指定抽象路径名是否应该包含在某个路径名列表中</code></pre><pre><code>* File pathname:使用ListFiles方法遍历目录，得到的每一个文件对象；</code></pre><ul><li>FilenameFilter也是一个接口，用于过滤文件名称。</li><li>FileFilter内过滤的抽象方法：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">boolean accept (File dir, String name) </code></pre><pre><code>* File dir:构造方法中传递的被遍历的目录；* String name：使用ListFiles方法遍历目录，获取的每一个文件/目录的名称</code></pre><ul><li>两个过滤器接口是没有实现类的，需要我们自己写实现类，重写过滤器的方法accept，在方法找那个自己定义过滤的规则</li><li>示例：遍历目录，过滤掉不是以.java结尾的文件。使用接口实现类。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.File;public class Recurison &#123;    public static void main(String[] args) &#123;        getAllFile(file);    &#125;    public  static void getAllFile(File dir) &#123;        &#x2F;*        * 1.listFiles方法会对目录中传递的目录进行遍历，获取目录中的每一个文件、文件夹--》封装为File对象        * 2.listFiles方法会调用参数传递的过滤器的accept方法        * 3.listFiles方法会把遍历得到的每一个File对象，传递给accept方法的参数pathname        * 4.accept的返回值为true则将传递进去的File对象存入File数组，为false则不保存。        *&#x2F;        File[] files &#x3D; dir.listFiles(new FileFilterimpl());&#x2F;&#x2F;传递过滤器对象,将过滤的规则传递给listFiles方法，最后返回过滤后的数组        System.out.println(dir);        for(File f : files) &#123;            if(f.isDirectory()) &#123;                getAllFile(f);            &#125; else &#123;                    System.out.println(f);                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class FileFiterImpl implements FileFilter &#123;    @overide    public boolean accept (File pathname) &#123;        if(pathname.isDirectory()) &#123;            return true; &#x2F;&#x2F;如果是文件夹，则仍存在File数组中。        &#125;        return pathname.getName().toLowerCase().endWith(&quot;.java&quot;);    &#125;&#125;</code></pre><ul><li>使用匿名内部类实现过滤器</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.File;public class Recurison &#123;    public static void main(String[] args) &#123;        getAllFile(file);    &#125;    public  static void getAllFile(File dir) &#123;        &#x2F;*        * 1.listFiles方法会对目录中传递的目录进行遍历，获取目录中的每一个文件、文件夹--》封装为File对象        * 2.listFiles方法会调用参数传递的过滤器的accept方法        * 3.listFiles方法会把遍历得到的每一个File对象，传递给accept方法的参数pathname        * 4.accept的返回值为true则将传递进去的File对象存入File数组，为false则不保存。        *&#x2F;        File[] files &#x3D; dir.listFiles(new FileFilterimpl() &#123;            @override            public boolean accept(File pathname) &#123;            return pathname.getName().toLowerCase().endWith(&quot;.java&quot;) || pathname.isDirectory();            &#125;        &#125;);&#x2F;&#x2F;传递过滤器对象,将过滤的规则传递给listFiles方法，最后返回过滤后的数组        System.out.println(dir);        for(File f : files) &#123;            if(f.isDirectory()) &#123;                getAllFile(f);            &#125; else &#123;                    System.out.println(f);                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><ul><li>使用lambda表达式（接口中只有一个方法）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.File;public class Recurison &#123;    public static void main(String[] args) &#123;        getAllFile(file);    &#125;    public  static void getAllFile(File dir) &#123;        &#x2F;*        * 1.listFiles方法会对目录中传递的目录进行遍历，获取目录中的每一个文件、文件夹--》封装为File对象        * 2.listFiles方法会调用参数传递的过滤器的accept方法        * 3.listFiles方法会把遍历得到的每一个File对象，传递给accept方法的参数pathname        * 4.accept的返回值为true则将传递进去的File对象存入File数组，为false则不保存。        *&#x2F;        File[] files &#x3D; dir.listFiles((File pathname) -&gt; &#123;            return pathname.getName().toLowerCase().endWith(&quot;.java&quot;) || pathname.isDirectory();        &#125;) &#x2F;&#x2F;传递过滤器对象,将过滤的规则传递给listFiles方法，最后返回过滤后的数组        System.out.println(dir);        for(File f : files) &#123;            if(f.isDirectory()) &#123;                getAllFile(f);            &#125; else &#123;                    System.out.println(f);                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="io流概述"><a class="markdownIt-Anchor" href="#io流概述"></a> IO流概述</h2><ul><li>I(Input)O(Output),流：数据（字符，字节）1个字符 = 2个字节，1个字节 = 8个二进制位。</li><li>I输入：把硬盘中的数据读取到内存中。O输出：把内存的数据读到硬盘中。</li><li>字节流：以字节为单位，可以输入输出任意文件。</li><li>字符流：以字符为单位。</li><li>输入流：输入数据。</li><li>输出流：输出数据。</li><li><strong>一切皆为字节</strong>：一切文件数据都是以二进制数字的形式保存的，就是以一个一个字节的形式来存储的。</li></ul><h2 id="字节流"><a class="markdownIt-Anchor" href="#字节流"></a> 字节流</h2><ul><li>所有流都是在<code>java.io</code>包中实现的。</li></ul><h3 id="字节输出流"><a class="markdownIt-Anchor" href="#字节输出流"></a> 字节输出流</h3><ul><li>在<code>java.io.OutputStream</code>定义了OutputStream<strong>抽象类</strong>，表示所有输出字节流的超类。</li><li>成员方法：<ul><li><code>void close();</code>:关闭此输出流并释放与此流有关的所有系统资源。</li><li><code>void flush();</code>:刷新此输出流并强制写出所有缓冲的输出字节。</li><li><code>void write(byte[] b);</code>:将b.length个字节从指定的byte数组写入此输入流。每次写入数据都会覆盖文件中的所有的数据。</li><li><code>void write(byte[] b, int off, int len);</code>:将指定byte数组中从偏移量off开始的len个字节写入此输出流。</li><li><code>void write(int b);</code>:将指定的字节写入此输出流。</li></ul></li></ul><h4 id="fileoutstream类"><a class="markdownIt-Anchor" href="#fileoutstream类"></a> FileOutStream类</h4><ul><li>OutStream类的子类，叫做文件字节输出流，把内存中的数据写入到硬盘的文件中。</li><li>构造方法：参数为写入数据的目的地。会有FileNotFoundException异常（是IOException异常的子类）。需要抛出或者捕获。<ul><li><code>FileOutputStream(String name)</code>:创建一个向指定名称的文件中写入数据的输出文件流。</li><li><code>FileOutputStream(File file)</code>:创建一个向指定File对象表示的文件中写入数据的文件输出流。</li><li><code>FileOutputStream(String name, boolean append);</code>：创建一个向具有指定name的文件中写入数据的的输出文件流。<ul><li>String name：写入数据的目的地；</li><li>boolean append：<strong>追加写</strong>的开关。true:追加写，false：关闭追加写。</li></ul></li><li><code>FileOutputStream(File file, boolean append);</code>:</li><li>构造方法的作用：<ul><li>创建一个FileOutputStream对象</li><li>会根据构造方法中传递的文件/文件路径，创建一个新的空文件</li><li>会把FileOutputStream对象指向创建好的文件。</li></ul></li></ul></li><li>字节输出流的使用步骤：<ol><li><strong>创建</strong>一个FileOutputStream对象，构造方法中传递写入数据的目的地；</li><li>调用FilePOutputStream对象中的<strong>write方法</strong>，把数据写入文件中；</li><li>释放资源(调用<strong>close方法</strong>），因为流在使用过程中会占用系统资源。</li></ol></li><li>示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test &#123;    public static void main(String[] args) throws IOException &#123;    &#x2F;&#x2F; **创建**一个FileOutputStream对象，构造方法中传递写入数据的目的地,在路径不对时会抛出IO异常的子异常（FileNotFoundException）。    FileOutputStream fos &#x3D; new FileOutputStream(&quot;路径&quot;);    &#x2F;&#x2F;调用FilePOutputStream对象中的**write方法**，把数据写入文件中；    fos.write(数据);    &#x2F;*    fos.write(&#39;b&#39;);    byte[] b &#x3D; &#123;&#39;1&#39;,&#39;a&#39;,&#39;-&#39;&#125;;    fos.write(b);    fos.write(b, 1,  2);    *&#x2F;    &#x2F;&#x2F;释放资源    fos.close();    &#125;&#125;</code></pre><ul><li>写入字符串：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">byte[] b &#x3D; &quot;hello world&quot;.getBytes();fos.write(b);</code></pre><ul><li>换行<ul><li>不同系统的换行符号；<ul><li>Windows：<code>\r\n</code></li><li>linux:<code>\n</code></li><li>mac:<code>\r</code></li></ul></li><li>示例：</li></ul>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">FileOutputStream fos &#x3D; new FileOutputStream(&quot;a.txt&quot;,true);        byte[] c &#x3D; &quot;hello&quot;.getBytes();        for(int i &#x3D; 0; i &lt; 10; i++) &#123;            fos.write(c);            fos.write(&quot;\r\n&quot;.getBytes());        &#125;        fos.close();</code></pre></li></ul><h3 id="文件存储的原理与文本编辑器"><a class="markdownIt-Anchor" href="#文件存储的原理与文本编辑器"></a> 文件存储的原理与文本编辑器</h3><ul><li>写到硬盘中的文件是以二进制形式保存的，如果直接以int的形式输入数据，则会转换为二进制形式。如：<code>fos.write(97)</code>,实际写数据的时候会将97转化为二进制数1100001。</li><li>任意的文本编辑器（如记事本）在打开文件的时候都会查询编码表，把字节转换为字符表示，如果就是以字节形式输入<code>'a','1'</code>则会按照原样输出。<ul><li>0~127之间的数查询ASCII表；</li><li>其他值：查询系统默认码表（如中文系统的GBK编码）。</li></ul></li><li>示例：<code>fos.write(97);</code>将97写入a.txt文件中，最终用记事本打开看见的结果为字符<code>a</code></li></ul><h3 id="字节输出流-2"><a class="markdownIt-Anchor" href="#字节输出流-2"></a> 字节输出流</h3><ul><li><code>java.io.InputStream</code>是字节输入流所有类的超类，是抽象类，定义了所有子类共性的方法</li><li><code>int read();</code>：从输入流中读取数据的下一个字节，返回值会转换为int类型。读到<strong>文件末尾会返回-1</strong>（因为系统会在每个文件末尾设置一个看不见的结束标记）.如果路径不存在，会有IOExcption异常。每次读取完之后，会自动“指向”后面紧接着的未被读的数据。</li><li><code>int read(byte[] b);</code>: 从输入流中读取一定数量的字节，并将其存储在缓冲区数组b中。数组b的长度是每次从文件中读取字节的数目。返回值是从文件中成功读取的字节数,如果一个数据都没有读到，则返回-1.</li><li><code>void close();</code>:关闭此输入流并释放与该流关联的所有系统资源。</li></ul><h4 id="fileinputstream类"><a class="markdownIt-Anchor" href="#fileinputstream类"></a> FileInputStream类</h4><ul><li>继承了<code>InputStream</code>类。将硬盘文件中的数据，读取到内存中使用。</li><li>构造方法：会有FileNotFoundException异常（是IOException异常的子类）。需要抛出或者捕获。<ul><li><code>FileInputStream(String name)</code>:String name是要读取的文件的路径。</li><li><code>FileInputStream(File, file)</code>：File file是要读取的文件。</li><li>作用：创建一个FileInputStream对象，并将此对象指定构造方法中要读取的文件。</li></ul></li><li>输入字节流的使用步骤：<ol><li>创建一个FileInputStream对象，构造方法中绑定要读取的数据源。</li><li>使用FileInputStream对象中的方法read，读取文件。、</li><li>释放资源（close方法）</li></ol></li><li>一次读取一个字节的示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.FileInputStream;import java.io.IOException;public class InputStreamTest &#123;    public static void main(String[] args) throws IOException &#123; &#x2F;&#x2F;抛出IOException异常可以同时解决FileNotFound和IoException两个异常        FileInputStream fis &#x3D; new FileInputStream(&quot;a.txt&quot;);        int len &#x3D; 0;        while((len &#x3D; fis.read() )!&#x3D; -1) &#123;            System.out.print((char)len); &#x2F;&#x2F;要想显示字符信息，需要强制转换为char类型        &#125;    &#125;&#125;</code></pre><ul><li>一次读取多个字节的示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class InputStreamTest &#123;    public static void main(String[] args) throws IOException &#123;        FileInputStream fis &#x3D; new FileInputStream(&quot;a.txt&quot;);        byte[] b &#x3D; new byte[1000];        int len &#x3D; fis.read(b);        System.out.println(len);        System.out.println(new String(b));&#x2F;&#x2F;利用byte数组作为参数构造String对象可以按照文件中原有的格式输出数据。        fis.close();        &#125;    &#125;</code></pre><ul><li>文件复制基本操作：<ol><li>创建一个字节输入流对象绑定源数据地址；创建一个字节输出流对象绑定目的数据地址。</li><li>read读入字节，使用write写入目的地址。</li><li>关闭字节输出流对象，关闭字节输入流对象。</li></ol></li></ul><h2 id="字符流"><a class="markdownIt-Anchor" href="#字符流"></a> 字符流</h2><ul><li>一个中文在GBK中占用2个字节，在utf-8占用3个字节。所以一个字节一个字节的读入文件不能得到正确的中文字符。使用字符流可以一次读取一个字符（中文，英文，符号等），解决了这个问题。</li></ul><h3 id="javaioreader类"><a class="markdownIt-Anchor" href="#javaioreader类"></a> java.io.Reader类</h3><ul><li>字符输入流：是<strong>字符输入最顶层的父类</strong>，定义了一些共性的成员方法，是一个抽象类。</li><li>成员方法：<ul><li><code>int read();</code>:读取单个字符并返回；</li><li><code>int read(char[] cbuf)</code>:一次读取多个字符，将字符读入数组；</li><li><code>void close();</code>关闭该字符流并释放与之相关的所有资源。</li></ul></li></ul><h4 id="javaiofilereader类"><a class="markdownIt-Anchor" href="#javaiofilereader类"></a> java.io.FileReader类</h4><ul><li>继承了<code>InputStreamReader</code>和<code>Reader</code>类。</li><li>作用：把硬盘文件中的数据以字符的方式读取到内存中。</li><li>构造方法：会有FileNotFoundException异常（是IOException异常的子类）。需要抛出或者捕获。<ul><li><code>FileReader(String fileName)</code></li><li><code>FileReader(File file)</code></li><li>参数：<ul><li>String fileName:文件的<strong>路径</strong>；</li><li>File file：一个文件。</li></ul></li><li>作用：<ul><li>创建一个FileReader对象；</li><li>会把FileReader对象指向我们要读取的文件。</li></ul></li></ul></li><li>字符输入流的使用步骤：<ol><li>创建FileReader对象，构造方法中绑定要读取的数据源；</li><li>使用FileReader对象中的read()方法读取文件；</li><li>释放资源（close）。</li></ol></li><li>示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;一个字符读入import java.io.FileReader;import java.io.IOException;public class ReaderTest &#123;    public static void main(String[] args) throws IOException &#123;        &#x2F;&#x2F;创建对象        FileReader fr &#x3D; new FileReader(&quot;a.txt&quot;);        &#x2F;&#x2F;使用read读取文件        int len &#x3D; 0;        while ((len &#x3D; fr.read()) !&#x3D; -1) &#123;            System.out.print((char)len);        &#125;        &#x2F;&#x2F;释放资源        fr.close();    &#125;&#125;&#x2F;&#x2F;使用字符数组，一次读入多个字符进入数组import java.io.FileReader;import java.io.IOException;public class ReaderTest &#123;    public static void main(String[] args) throws IOException &#123;        &#x2F;&#x2F;创建对象        FileReader fr &#x3D; new FileReader(&quot;a.txt&quot;);        char[] cs &#x3D; new char[1024];        int len &#x3D; 0; &#x2F;&#x2F;记录每次读取的有效字符个数        while ((len &#x3D; fr.read(cs)) !&#x3D; -1) &#123;            System.out.println(new String(cs, 0,len));&#x2F;&#x2F;把字符数组的一部分转换为字符串        &#125;    &#125;&#125;</code></pre><h3 id="javaiowriter类"><a class="markdownIt-Anchor" href="#javaiowriter类"></a> java.io.Writer类</h3><ul><li>字符输出流：所有字符输出流最顶层的父类，是一个抽象类；</li><li>部分成员方法：<ul><li><code>void write(int c);</code>写入单个字符；</li><li><code>void write(char[] cbuf);</code>写入字符数组；</li><li><code>void write(String str);</code>：写入字符串；</li><li><code>void flush()</code>：刷新该流的缓冲；</li><li><code>void close()</code>:关闭此流，但要先刷新它。</li></ul></li></ul><h3 id="javaiofilewriter类"><a class="markdownIt-Anchor" href="#javaiofilewriter类"></a> java.io.FileWriter类</h3><ul><li>继承了OutputStream和Writer类，把内存中的字符数据写入文件中。</li><li>构造方法：会有FileNotFoundException异常（是IOException异常的子类）。需要抛出或者捕获。<ul><li><code>FileWriter(File file);</code>:根据指定的File对象构造一个FileWriter对象。</li><li><code>FileWriter(String filename);</code>:根据指定的文件名构造一个FileWriter对象。</li><li>参数：写入数据的目的地<ul><li>String filename：文件的路径</li><li>File file：文件</li></ul></li><li>作用：<ol><li>创建一个FileWriter对象</li><li>根据构造方法中传递的文件/文件的路径创建文件（该文件不存在的情况下）</li><li>会把FileWriter对象指向创建好的文件。</li></ol></li></ul></li><li>字符输出流的使用步骤：<ol><li>创建FileWriter对象，构造方法中绑定要写入数据的目的地；</li><li>使用FileWriter对象中的write()方法，把数据写到<strong>内存数据缓冲区</strong>（字符转换为字节）</li><li>使用FileWriter对象中的<strong>flush方法</strong>，把内存中的数据，刷新到文件中。</li><li>释放资源（close():会先把内存缓冲区的文件刷新到文件中，再释放资源）</li></ol></li><li>示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.FileWriter;import java.io.IOException;public class WriterTest &#123;    public static void main(String[] args) throws IOException &#123;        FileWriter fileWriter &#x3D; new FileWriter(&quot;a.txt&quot;);        fileWriter.write(&quot;你好!&quot;);        fileWriter.flush();        fileWriter.close()    &#125;&#125;</code></pre><ul><li>续写：使用append开关：<ul><li><code>FileWriter(String fileName, boolean append);</code></li><li><code>FileWriter(File file, boolean append);</code></li><li>append是续写的开关，为true则<strong>不会创建新的文件覆盖源文件</strong>，为false则创建新的文件覆盖源文件。</li></ul></li><li>换行：使用换行符号<ul><li>windows：<code>\r\n</code></li><li>linux:<code>/n</code></li><li>mac:<code>/r</code></li></ul></li><li>续写和换行示例：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.FileWriter;import java.io.IOException;public class WriterTest &#123;    public static void main(String[] args) throws IOException &#123;        FileWriter fileWriter &#x3D; new FileWriter(&quot;a.txt&quot;,true);        fileWriter.write(&quot;你好&quot;+ &quot;\r\n&quot;);        fileWriter.write(&quot;你好&quot;+ &quot;\r\n&quot;);        fileWriter.flush();        fileWriter.close();    &#125;&#125;</code></pre><h2 id="流中的异常处理"><a class="markdownIt-Anchor" href="#流中的异常处理"></a> 流中的异常处理</h2><h1 id="网络编程"><a class="markdownIt-Anchor" href="#网络编程"></a> 网络编程</h1><ul><li>java具有支持Internet和WWW的完整软件包。java.net包支持Internet。</li></ul><h2 id="网络通信协议"><a class="markdownIt-Anchor" href="#网络通信协议"></a> 网络通信协议</h2><ul><li>同一个网络中的计算机在进行连接和通信时需要遵守一定的<strong>规则</strong>，这些规则被称为网络通信协议，它对数据的传输格式，速率，步骤等做了统一规定。</li><li>TCP/IP协议：传输控制协议/因特网互联协议（Transmission Control Protocol/Internet Protocol）是Internet最基本和广泛的协议，它定义了计算机如何炼乳因特网以及数据在它们之间传输的标准。它包含了一系列协议，并且采用了<strong>4层分层模型</strong>，每一层都呼叫它的下一层所提供的协议来完成自己的需求。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/20180930155137505.jpeg" alt="20180930155137505" /><ul><li>链路层：用于定义物理传输通道，通常是对某些网络连接设备的驱动协议。</li><li>网络层：网络层是协议的核心，它主要用于将传输的数据进行分组并将分组后的数据放松到目标计算机或者网络。</li><li>运输层：主要用于网络程序之间的通信（可以用TCP协议，也可以使用UDP协议）。</li><li>应用层：主要负责应用程序的协议，如HTTP协议，FTP协议。</li></ul></li><li><strong>UDP协议</strong>：用户数据报协议（User Datagram Protocol）。<ul><li>UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。</li><li>不能保证数据的完整性.会有丢包现象出现。</li><li>消耗资源少，通信效率高，通常用于音频，视频和普通数据等的传输。</li><li>数据限制在64kb之类，超出这个范围就不能传输了。</li><li><strong>数据报（Datagram）</strong>：网络传输的基本单位。</li></ul></li><li><strong>TCP协议</strong>：传输控制协议（Transmission control Protocol）。<ul><li>TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接受端建立逻辑连接，然后再传输数据。</li><li>TCP协议提供了两台计算机之间<strong>可靠无差错</strong>的数据传输。</li><li>TCP连接必须明确客户端和服务器端，<strong>由客户端像服务器端发送请求</strong>，每次连接的创建都需要经过<strong>三次握手</strong>：</li><li>三次握手：在发送数据的准备阶段，客户端和服务器端之间的三次交互，以保证连接的可靠：<ul><li>第一次握手：客户端向服务器端发出连接<strong>请求</strong>，等待服务器的确认；</li><li>第二次握手：服务器端向客户端回送一个<strong>响应</strong>，通知客户端收到了连接请求。</li><li>第三次握手：客户端再次向服务器端发送确认信息，确认连接。</li></ul></li><li>传输安全，应用广泛，例如下载文件，浏览网页等。</li></ul></li></ul><h2 id="ip地址"><a class="markdownIt-Anchor" href="#ip地址"></a> IP地址</h2><ul><li><strong>IP地址</strong>：互联网协议地址（Internet Protocol Address），IP地址用来给一个网络中的计算机设备做唯一的编号。</li><li>IP地址分类：<ul><li>IPV4:32位的二进制数，通常被分为4个字节（每个自己的表示范围位0～255的十进制整数），表示成<code>a.b.c.d</code>格式，如：<code>192.168.65.100</code>.</li><li>IPV6:为了扩大地址空间，通过IPV6来重新定义地址空间，采用128位，每16个字节一组，分为8组16进制数，表示成<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>/</li></ul></li><li>查看本机的IP地址，在控制台输入：<code>ipconfig</code></li><li>检查网络是否连通,在控制台输入<code>ping IP地址</code></li></ul><h2 id="端口号"><a class="markdownIt-Anchor" href="#端口号"></a> 端口号</h2><ul><li>IP地址唯一标示网络中的设备，端口号唯一标识设备中的进程（应用程序）。</li><li>打开网络软件时，操作系统会为该网络软件分配端口号。</li><li>端口号：用两个字节表示的整数，范围（0～65535）。<ul><li>1024之前的端口号，已经被系统分配给了已知的网络软件，不能再使用（一台计算机上的端口号是不能够重复的）。</li><li>常用端口号：<ul><li>80端口：网络端口。如<code>www.baidu.com:80</code></li><li>Mysql默认端口号：3306</li><li>Tomcat默认端口号：8080</li></ul></li></ul></li><li>利用<code>协议+IP地址+端口号</code>可以标识网络中的进程。</li></ul><h2 id="套接字socket"><a class="markdownIt-Anchor" href="#套接字socket"></a> 套接字（socket）</h2><ul><li>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。</li><li>Socket的英文原义是（电力系统的）“插座”，在网络中用于描述IP地址和端口。在Internet上的主机一般同时提供几种服务，每种服务都绑定到一个端口上。客户软件将插头插到不同编号的插座（ip和端口），就可以得到不同的服务。</li><li>如果一个进程要通过网络向另一个进程发送数据，只需简单地写入与socket相关联的输出流。一个进程通过从与socket相关联的输入流读来读取另一个进程所写的数据。</li></ul><h2 id="客户端服务器模型"><a class="markdownIt-Anchor" href="#客户端服务器模型"></a> 客户端/服务器模型</h2><ul><li>即Client/Server(客户机/服务器)结构，通过任务合理分配到Client端和Server端，降低了系统通讯开销，可充分利用两端硬件环境优势。</li><li>C/S的优点是能充分发挥客户端ＰＣ的处理能力，很多工作可以在客户端处理后再提交给服务器。</li></ul><h2 id="tcp通信编程"><a class="markdownIt-Anchor" href="#tcp通信编程"></a> TCP通信编程</h2><h3 id="javanetsocket类客户端"><a class="markdownIt-Anchor" href="#javanetsocket类客户端"></a> java.net.Socket类：客户端</h3><ul><li>Socket类实现<strong>客户端</strong>的套接字，套接字是两台计算机之间通信的端点。<ul><li>客户端和网络端进行交互必须使用Socket中提供的网络流，不能使用自己创建的流对象。</li><li>当我们创建客户端对象Socket的时候，就会去请求服务器，和服务器经过3次握手建立连接通信。</li></ul></li><li>构造方法：<code>Socket(String host, int port)</code>,创建一个流套接字并将其连接到指定主机的指定端口号；<ul><li>String host：服务器的主机地址/服务器的IP地址</li><li>int port：服务器的端口号；</li></ul></li><li><code>OutputStream getOutputStream()</code>:返回此套接字的输出流</li><li><code>InputStream getInputStream()</code>:返回此套接字的输入流</li><li><code>void close()</code>：关闭此套接字；</li></ul><h3 id="javanetserversocket类服务器端"><a class="markdownIt-Anchor" href="#javanetserversocket类服务器端"></a> java.net.ServerSocket类：服务器端</h3><ul><li>ServerSocket类表示服务器端的套接字。</li><li>构造方法；<code>ServerSocket(int port)</code>:创建指定端口号的ServerSocket对象；</li><li><code>Socket accept()</code>；侦听并接受请求此ServerSocket对象的Socket对象。</li><li><code>void close()</code>：关闭此套接字。</li></ul><h3 id="internet寻址inetaddress类和url类"><a class="markdownIt-Anchor" href="#internet寻址inetaddress类和url类"></a> Internet寻址(InetAddress类和URL类)</h3><ul><li>InetAddress类提供有关从域名地址查询IP地址的方法，类中没有构造器。TCP/IP面向连接服务类(Socket类和ServerSocket类)。</li><li>getAddress() ：返回4个字节的IP地址，是4个整数，有可能是负数，需要进行转换处理，才能正确显示。</li><li>getHostName()：返回被查询<strong>主机域名地址</strong>，即生成InetAddress对象时使用的字符串参数。</li></ul><h2 id="tcp通信程序"><a class="markdownIt-Anchor" href="#tcp通信程序"></a> TCP通信程序</h2><h3 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h3><ul><li>TCP通信能够实现两台计算机之间的数据交互，通信的两端要严格区分为<strong>客户端（client）与服务器端（server）</strong>。</li><li>TCP通信步骤：<ol><li>服务器端先启动：不会主动请求客户端；</li><li>客户端请求服务器端，建立逻辑连接；</li></ol></li><li>客户端和服务器端的逻辑连接中包含一个IO对象（字节流类型对象），客户端和服务器端使用IO对象进行通信。</li><li><strong>多个客户端</strong>可以同时与<strong>一个服务器</strong>进行交互。在服务器端通过<strong>accept方法</strong>来获取发送请求的客户端对象。<strong>服务器端没有IO流</strong>，服务器获取客户端Socket对象，使用每个客户端Socket对象中提供的IO流和客户端进行交互。即服务器端不会新建IO流，而是直接借用客户端的IO流来与客户端交互。</li><li>服务器端与客户端交互模型：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/uPic/IMG_2180.JPG" alt="IMG_2180" /></li></ul><h3 id="tcp通信程序实现"><a class="markdownIt-Anchor" href="#tcp通信程序实现"></a> TCP通信程序实现</h3><h1 id="集合"><a class="markdownIt-Anchor" href="#集合"></a> 集合</h1><h2 id="集合概述"><a class="markdownIt-Anchor" href="#集合概述"></a> 集合概述</h2><ul><li>集合是java提供的一种容器，可以用来存储多个数据。</li><li>集合与数组的区别：<ul><li>集合的长度是可变的；</li><li>集合存储的都是<strong>对象</strong>，而且对象的类型可以不一致。</li></ul></li></ul><h2 id="单列集合的框架"><a class="markdownIt-Anchor" href="#单列集合的框架"></a> 单列集合的框架</h2><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201204142553.png" alt="" /></p><ul><li>List集合:有存储顺序，可以存储重复元素，有索引；<ul><li>ArrayList：底层是<strong>数组</strong>实现的，查询快，增删慢；</li><li>LinkedList:底层是<strong>链表</strong>实现的，查询慢，增删快。</li></ul></li><li>Set集合：无索引，不可存储重复元素，存取无序。<ul><li>HashSet:底层是<strong>哈希表+红黑树</strong>实现的，无索引，不可以存储重复元素，存取无序。</li><li>LinkedList：底层是<strong>哈希表+链表</strong>实现的，无索引，不可以存储重复元素，但可以包装存储<strong>顺序</strong>。</li><li>TreeSet:底层是<strong>二叉树</strong>实现，一般用于<strong>排序</strong>。</li></ul></li></ul><h2 id="collection接口"><a class="markdownIt-Anchor" href="#collection接口"></a> Collection接口</h2><ul><li>全称：<code>java.util.Collection</code>,是所有单列集合最顶层的接口，定义了所有单列集合共性的方法。</li><li>常利用<strong>多态</strong>创建Collection对象,如：<code>Collection&lt;String&gt; coll = new ArrayList&lt;&gt;();</code>,即上层接口对象指向下层实现类。</li><li>直接打印Collection对象，会打印出集合中所有的元素。如：<code>System.out.println(coll);</code>空集会打印一个<code>[]</code>,一般会打印<code>[张三, 李四]</code></li><li><code>public boolean add(E e);</code>：把给定的对象添加到当前集合中去,添加成功返回true。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">coll.add(&quot;张三&quot;);</code></pre><ul><li><code>public boolean remove(E e);</code>:把给定的对象在当前集合中删除，如果要删除的元素存在则返回true。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">coll.remove(&quot;张三&quot;);</code></pre><ul><li><code>public boolean contains(E e);</code>:判断当前集合中是否包含指定的对象，包含则返回true。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">coll.contains(&quot;张三&quot;);</code></pre><ul><li><code>public boolean isEmpty();</code>:判断当前集合是否为空，为空则返回true。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">coll.isEmpty();</code></pre><ul><li><code>public int size();</code>:返回集合中的元素个数</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">int size &#x3D; coll.size();</code></pre><ul><li><code>public Object[] toArray();</code>:把集合中的元素存储到<strong>数组</strong>中。注意返回值是<strong>Object</strong>类型的数组。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">Object[] arr &#x3D; coll.toArray();for(Object i : arr) &#123;    System.out.println(i);&#125;</code></pre><ul><li><code>public void clear();</code>:清空集合中所有的元素，此时集合变回和刚创建时一样。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">coll.clear();</code></pre><h2 id="iterator接口"><a class="markdownIt-Anchor" href="#iterator接口"></a> Iterator接口</h2><ul><li>迭代：获取Collection集合中元素的通用方法。</li><li>全称:<code>java.util.Iterator</code>接口，即实现迭代的迭代器。</li><li><code>boolean hasNext()</code>:判断集合中还有没有下一个元素，有则返回true。</li><li><code>E next()</code>；取出集合中的下一个元素。</li><li>获取Iterator接口的实现类对象方法：<ul><li>实现Collection接口的实现类对象调用<code>iterator()</code>方法，这个方法返回值就是Iterator接口的实现类对象。</li><li><code>Iterator&lt;E&gt; iterator();</code>：迭代器的泛型跟随Collection对象的泛型。</li></ul></li><li>迭代器的使用步骤：<ol><li>使用集合中的iterator方法获取迭代器的实现类对象，使用Iterator接口对象来接收（同Collection对象一样利用多态）；</li><li>使用Iterator中的hasNext方法来判断是否还有下一个元素</li><li>使用Iterator中的next方法取出集合中的下一个元素。</li></ol></li><li>迭代器理解：<ul><li>可以将集合想象为一个表，迭代器中有一个游标指向当前行，开始时这个游标是指向表头的。每取一次下一个元素，这个游标都会移向下一行（即取出了元素这一行）。</li><li>如果试图取出没有元素的行的值，会出现NoSuchElementException异常。</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">Collection&lt;String&gt; coll &#x3D; new ArrayList&lt;&gt;();coll.add(&quot;张三&quot;);coll.add(&quot;李四&quot;);Iterator&lt;String&gt; it &#x3D; coll.iterator(); &#x2F;&#x2F;多态的使用while(it.hasNext()) &#123;    System.out.println(it.next());&#125;</code></pre><ul><li>增强for循环：又称for-each循环，是jdk1.5以后，java提供的利用迭代器原理的新特性。用来遍历数组或者集合。(只可以用来遍历，不能用来修改集合或者数组)。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">for(Object i : coll) &#123;    System.out.println(i);&#125;</code></pre><h1 id="java的api"><a class="markdownIt-Anchor" href="#java的api"></a> Java的API</h1><hr /><p>实在是太多了，可以在需要时查看API的<a href="https://docs.oracle.com/en/java/javase/15/docs/api/index.html">官方文档</a>或者<a href="https://tool.oschina.net/apidocs/apidoc?api=jdk-zh">在线中文文档</a></p><h2 id="javalangobject"><a class="markdownIt-Anchor" href="#javalangobject"></a> java.lang.Object</h2><ul><li><code>Class getClass()</code>:返回包含对象信息的类对象。</li><li><code>boolean equals(Object otherObject)</code>:比较两个对象是否相等。</li><li><code>String toString()</code>:返回表示该对象值的字符串。</li></ul><h2 id="javalangclass"><a class="markdownIt-Anchor" href="#javalangclass"></a> java.lang.Class</h2><ul><li><code>String getName()</code>:返回这个类的名字；</li><li><code>Class getSuperclass()</code>:以Class对象的的形式返回这个类的超类。</li><li><code>public static Class&lt;T&gt; forName(String className) throws ClassNotFoundException</code>:返回与带有给定字符串名的类或接口相关联的 Class 对象。调用此方法等效于：<code>Class.forName(className, true, currentLoader)</code>其中 currentLoader 表示当前类的定义类加载器。<ul><li>例如，以下代码片段返回命名为 java.lang.Thread 的类的运行时 Class 描述符。<code>Class t = Class.forName(&quot;java.lang.Thread&quot;)</code>。参数：className - 所需类的完全限定名。返回：具有指定名的类的 Class 对象。抛出：LinkageError - 如果链接失败;ExceptionInInitializerError - 如果此方法所激发的初始化失败;ClassNotFoundException - 如果无法定位该类。</li></ul></li><li><code>public String toString()</code>:将对象转换为字符串。字符串的表示形式为字符串 “class” 或 “interface” 后面紧跟一个空格，然后是该类的完全限定名，它具有 getName 返回的那种格式。如果此 Class 对象表示一个基本类型，则此方法返回该基本类型的名称。如果该 Class 对象表示 void，则此方法返回 “void”。覆盖：类 Object 中的 toString;返回：表示此 class 对象的字符串。</li></ul><h2 id="javautilobjects"><a class="markdownIt-Anchor" href="#javautilobjects"></a> java.util.Objects</h2><ul><li>可以看做是Object类针对多个对象进行处理的类似的类。</li><li>判断两对象是否相等的方法：<code>static boolean equals(Object a, Object b)</code>。</li><li>提供散列码的方法（hashcode）:<ul><li><code>static int hash(Object...objects)</code>，返回一个散列码，由提供的所有对象的散列码组合得到。</li><li><code>static int hashCOde(Object a)</code>如果a为null返回0，否则返回a.hashCode()的结果（即Object类中的hashCode方法增加了对null的处理）</li></ul></li><li>判断对象是否为空并抛出异常的方法：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static &lt;T&gt; T requireNonNull(T obj,String message) &#123;    if (obj &#x3D;&#x3D; null) &#123;        throw new NullPointerException(message);    &#125;    return obj;&#125;</code></pre><h2 id="javautillist"><a class="markdownIt-Anchor" href="#javautillist"></a> java.util.List</h2><h2 id="math"><a class="markdownIt-Anchor" href="#math"></a> Math</h2><h2 id="javatimelocaldate"><a class="markdownIt-Anchor" href="#javatimelocaldate"></a> java.time.LocalDate</h2><h2 id="javautilrandom"><a class="markdownIt-Anchor" href="#javautilrandom"></a> java.util.Random</h2><ul><li><code>Random()</code>返回一个随机数生成器（对应的类的对象）</li><li><code>int nextInt(int n)</code>，返回一个0~n-1之间的随机数的方法。</li></ul><h2 id="javautilarrayliste-泛型数组列表"><a class="markdownIt-Anchor" href="#javautilarrayliste-泛型数组列表"></a> java.util.ArrayList<E> （泛型数组列表）</h2><ul><li>ArrayList类类似于数组，但是它能在添加或者删除元素时，<strong>自动调整数组的容量</strong>。</li><li>ArrayList是有<strong>类型参数</strong>的<strong>泛型类</strong>（所以又被称为<strong>泛型数组列表</strong>），泛型类是可以在使用时再声明具体类型的。使用时为了指明数组保存的元素的类型，可以使用一对尖括号<code>&lt;&gt;</code>来将具体的类名追加到ArrayList后面。如<code>Array&lt;Employee&gt; staff = new ArrayList&lt;Employee&gt;();</code>.在这种方式中可以去掉后一个尖括号中的类型<code>Array&lt;Employee&gt; staff = new ArrayList&lt;&gt;(可以在这里填数组列表的容量,也可以不写。即使写了容量，这个容量仍是可以在使用时动态改变的);</code>,这种使用空的尖括号的方式又被称为<strong>菱形语法</strong>。</li><li>使用<code>boolean add(E obj)</code>方法可以将元素<strong>加到数组列表</strong>中，如<code>staff.add(i)</code>.<code>void add(int index, E obj)</code>。可以在数组内部指定位置插入元素，并使后面的元素后移，同时数组长度加一。</li><li><code>int size()</code>方法返回数组列表中现在的元素个数。如<code>length = staff.size()</code>.</li><li>不能使用普通的<code>[下标]</code>来访问数组列表中的元素。使用<code>get()</code>方法来访问数组列表中第i个元素，如<code>value = staff.get(i)</code>。使用<code>set()</code>方法来对第i个元素进行赋值。如<code>staff.set(i, value)</code>.</li><li><code>remove()</code>方法删除指定位置的元素，并将之后的所有元素前移，返回所删除的元素。如<code>staff.remove(i)</code>.</li><li><code>void ensureCapacity(int capacity)</code>方法可以给数组分配一个有具体数量的数组空间如：<code>staff.ensure(100)</code>。与直接在创建数组列表时声明大小的效果一样。</li><li>遍历：泛型数组列表同样可以用<code>for each</code>循环来遍历每个元素。</li></ul><h2 id="javautilstacke"><a class="markdownIt-Anchor" href="#javautilstacke"></a> java.util.Stack<E></h2><ul><li>这是java用于实现栈功能的类。</li><li>初始化一个空栈：<code>Stack&lt;Interger&gt; stack1 = new Stack&lt;Interger&gt;();</code>,因为栈也是使用泛型的，所以初始化的时候需要<strong>指定类型</strong>。</li><li>判断栈是否为空:<code>stack1.empty()</code>,方法<code>boolean empty()</code></li><li>查看栈顶部的元素但不取出：<code>stack1.peek()</code>,方法<code>Object peek()</code>，Object是指返回值的类型是由初始化的时候指定的，具体为哪种并不确定。</li><li>进栈：<code>stack1.push(Object element);</code>，方法<code>Object push(Object element)</code></li><li>出栈：<code>stack1.pop();</code>,方法<code>Object pop()</code>.</li><li>返回某个值在堆栈中的位置从，位置是从1开始的：方法<code>int search(Object element)</code>.</li></ul><h2 id="javautilarrays"><a class="markdownIt-Anchor" href="#javautilarrays"></a> java.util.Arrays</h2><ul><li>这是一个主要用来对数组进行处理的类。</li><li>判断两个数组是否相等的静态方法：<code>static boolean equals(xxx[] a, xxx[] b)</code>.如果两个数组长度相同且对应位置的元素相等，则返回true，否则返回false。</li><li>打印数组:<code>Arrays.toString(数组名)</code>。结果是一个形如&quot;[1, 2, 3, 4]&quot;的字符串。打印多维数组需要调用<code>Arrays.deepToString(数组名)</code>。</li><li>拷贝数组<code>数组名1.toArray(数组名2)</code>。将数组1的数组元素拷贝到数组2中去。</li><li><code>static void sort(Object[] a)</code>:对数组a中的元素进行排序，要求数组中的元素必须实现了Comparable接口的类，并且元素之间必须是可以比较的。</li></ul><h2 id="javalanginteger"><a class="markdownIt-Anchor" href="#javalanginteger"></a> java.lang.Integer</h2><ul><li><code>int intValue()</code>:将该Integer的对象的值作为一个int返回。</li><li><code>static String toString(int i)</code>:返回一个String对象，表示指定数值的十进制表示。</li><li><code>static String toString(int i, int radix)</code>：返回数值i基于radix参数指定进制的表示。</li><li><code>static int parseInt(String s)</code>：将字符串转换为十进制整型返回。</li><li>`static int pardeInt(String s, int radix)：将字符串转换为radix进制整型返回。</li><li><code>static Integer valueOf(String s)</code>:返回一个Integer对象，用s表示的十进制整数初始化。</li><li><code>static Integer valueOf(String s, int radix)</code>：返回一个Integer对象，用s表示的radix进制数初始化。</li><li><code>static int compare(int x, int y)</code>:对两个整数进行比较，如果x &lt; y,返回负整数，如果x=y返回0， x &gt; y返回一个正整数。</li></ul><h2 id="javalangenume"><a class="markdownIt-Anchor" href="#javalangenume"></a> java.lang.Enum<E></h2><ul><li><code>static Enum valueOf(Class enumClass, String name)</code>：返回给定类中指定名字的枚举常量。</li><li><code>String toString()</code>:返回枚举常量名。如<code>Size.SMALL.toString()</code>返回字符串&quot;SMALL&quot;.</li><li><code>int ordinal()</code>：返回枚举常量在enum中声明的位置，位置从0开始计数。</li><li><code>int compareTO(E other)</code>:如果枚举常量出现在other之前，返回一个负整数；如果this==other，返回0； 其他情况返回一个正整数。</li></ul><h2 id="javalangcomparablet"><a class="markdownIt-Anchor" href="#javalangcomparablet"></a> java.lang.Comparable<T></h2><ul><li>这是一个接口。其中要求了<code>int comparable(T other)</code>方法。这个方法要求对象小于other返回一个负整数，相等返回0，大于返回正整数。</li></ul><h2 id="javalangthrowable异常"><a class="markdownIt-Anchor" href="#javalangthrowable异常"></a> java.lang.Throwable(异常)</h2><ul><li><code>Thorwable()</code>:构造一个Throwable对象但是没有详细的描述信息</li><li><code>Throwable(String message)</code>: 构造一个Throwable对象，带有指定的详细描述信息。</li><li><code>String getMessage()</code>:获得Throwable对象的简短描述信息。</li><li><code>vois PrintStackTrace()</code>:jvm打印堆栈轨迹（异常的信息），是最全面的异常信息（包括类名，方法名及所在程序的行数等）。</li><li><code>String toString();</code>返回此异常的描述消息字符串。</li></ul><h2 id="javauitlproperties配置文件"><a class="markdownIt-Anchor" href="#javauitlproperties配置文件"></a> java.uitl.Properties(配置文件)</h2><ul><li>Properties类继承自Hashtable类并且实现了Map接口。该类主要用于<strong>读取Java</strong>的配置文件，不同的编程语言有自己所支持的配置文件，配置文件中很多变量是经常改变的，为了方便用户的配置，能让用户够脱离程序本身去修改相关的变量设置。就像在Java中，其配置文件常为<code>.properties</code>文件，是以键值对的形式进行参数配置的。</li><li>层次关系：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201206084813.jpg" alt="" /></li><li>字段：<code>protected Properties defaults</code>,一个属性列表，包含属性列表中所有<strong>未找到值</strong>的键的默认值。</li><li>构造方法：<ul><li><code>public Properties()</code>:创建一个无默认值的空属性列表。</li><li><code>public Properties(Properties defaults)</code>:创建一个带有指定默认值的空属性列表。参数：defaults - 默认值。</li></ul></li><li>方法：<ul><li><code>public String getProperty(String key)</code>:用指定的键在此属性列表中搜索属性。如果在此属性列表中未找到该键，则接着递归检查默认属性列表及其默认值。如果未找到属性，则此方法返回 null。参数：key - 属性键。</li><li><code>public String getProperty(String key,String defaultValue)</code>:用指定的键在属性列表中搜索属性。如果在属性列表中未找到该键，则接着递归检查默认属性列表及其默认值。如果未找到属性，则此方法返回<strong>默认值变量</strong>。参数：key - 哈希表defaultValue - 默认值。返回：属性列表中具有指定键值的值。</li><li><code>public void load(Reader reader)throws IOException</code>:按简单的面向行的格式从输入字符流中读取属性列表（键和元素对）此方法返回后，指定的<strong>流仍保持打开状态</strong>。参数：reader - 输入字符流(Reader是FileReader的上两级父类）。抛出：IOException - 如果从输入流读取时发生错误。IllegalArgumentException - 如果输入中出现了错误的 Unicode 转义。。</li></ul></li></ul><h2 id="javaneturl"><a class="markdownIt-Anchor" href="#javaneturl"></a> java.net.URL</h2><ul><li>类 URL 代表一个统一资源定位符，它是指向互联网“资源”的指针。资源可以是简单的文件或目录，也可以是对更为复杂的对象的引用，例如对数据库或搜索引擎的查询。<br />*<code> http://www.socs.uts.edu.au:80/MosaicDocs-old/url-primer.html</code></li><li>通常，URL 可分成几个部分。上面的 URL 示例指示使用的<strong>协议</strong>为 http （超文本传输协议）并且该信息驻留在一台名为 <a href="http://www.socs.uts.edu.au">www.socs.uts.edu.au</a> 的<strong>主机</strong>上。主机上的信息名称为 /MosaicDocs-old/url-primer.html。主机上此名称的准确含义取决于协议和主机。该信息一般存储在文件中，但可以随时生成。该 URL 的这一部分称为<strong>路径</strong>部分。URL 可选择指定一个“<strong>端口</strong>”，它是用于建立到远程主机 TCP 连接的端口号。如果未指定该端口号，则使用协议默认的端口。</li><li><code>public String getPath()</code>:获取此 URL 的路径部分。返回：此 URL 的路径部分，如果没有路径，则返回一个空字符串</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/Python/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Python/Python/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="python概述"><a class="markdownIt-Anchor" href="#python概述"></a> python概述</h1><ol><li>Python是一门解释性语言，无需编译和链接。</li><li>Python解释器是可以交互的，因此Python甚至可以用作桌面计算器。</li><li>Python是可扩展的，可以为Python的解释器添加内置函数和模块。</li><li>本文学习的是Python3.</li></ol><h2 id="解释器"><a class="markdownIt-Anchor" href="#解释器"></a> 解释器</h2><ul><li>trackback:程序无法成功地运行时，解释器会提供一个traceback。traceback是一条记录，指出了解释器尝试运行代码时， 在什么地方陷入了困境。</li></ul><h2 id="python编写规范"><a class="markdownIt-Anchor" href="#python编写规范"></a> Python编写规范</h2><p><a href="https://python.freelycode.com/contribution/detail/47">PEP8编写规范</a></p><ul><li><strong>python之禅</strong>：Python社区的理念都包含在TimPeters撰写的“Python之禅”中。要获悉这些有关编写优秀Python代码的指导原则，只需在解释器中执行命令<code>import this</code>。</li><li><strong>Python改进提案（Python Enhancement Proposal，PEP）</strong>。PEP 8是最古老的PEP之一，它向Python程序员提供了代码格式设置指南。PEP 8的篇幅很长，但大都与复杂的编码结构相关。</li><li><strong>缩进</strong>：每级缩进都使用四个空格;<ul><li>如果你混合使用了制表符和空格，可将文件中所有的<strong>制表符转换为空格</strong></li></ul></li><li><strong>空格</strong>：<ul><li>在诸如== 、&gt;= 和&lt;= 等<strong>比较运算符</strong>两边各添加一个空格，例如，<code>if age &lt; 4:</code> 要比<code>if age&lt;4:</code>好。</li></ul></li></ul><h2 id="python的注释"><a class="markdownIt-Anchor" href="#python的注释"></a> python的注释</h2><ul><li>Python中使用<code>#</code>做注释符，即使是在解释器的交互编程中也可以使用<code>#</code>注释符。</li></ul><h1 id="变量和数据类型结构"><a class="markdownIt-Anchor" href="#变量和数据类型结构"></a> 变量和数据类型(结构)</h1><h2 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h2><ul><li>变量名只能包含<strong>字母、数字和下划线</strong>。变量名可以以字母或下划线打头，但不能以数字打头，例如，可将变量命名为message_1，但不能将其命名为1_message。</li><li>变量名不能包含空格，但可使用下划线来分隔其中的单词。例如，变量名greeting_message可行，但变量名greeting message会引发错误。</li><li>不要将Python关键字和函数名用作变量名，即不要使用Python保留用于特殊用途的单词，如print。</li><li>变量名应既简短又具有描述性。例如，name比n好，student_name比s_n好，name_length比length_of_persons_name好。 慎用小写字母l和大写字母O，因为它们可能被人错看成数字1和0。</li><li>就目前而言，应使用小写的Python变量名。在变量名中使用大写字母虽然不会导致错误，但避免使用大写字母是个不错的主意。</li></ul><h2 id="一数字"><a class="markdownIt-Anchor" href="#一数字"></a> 一：数字</h2><ul><li>常用的数据类型有int、float，但是Python还有其它很多数据类型。例如复数类型（complex）,这种类型中使用j或者J代表复数部分，如<code>5+2j</code>.</li><li>基本运算<ul><li>Python支持基本的<code>+</code>,<code>-</code>,<code>*</code>以及<code>/</code>，<code>%</code>（求模/余）的运算，但是和c语言不同的是，<code>/</code>默认的结果是浮点型。使用<code>//</code>可以做返回值为int型的除法运算（类似c语言的普通除法运算）.</li><li>Python还支持<strong>幂方运算</strong><code>**</code>,<code>5**2</code>表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>5</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">5^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">5</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>；</li><li>python仍旧使用<code>=</code>为变量赋值，同c语言一样，Python中的变量在使用前必须先进行赋值。（但是在交互式编程中，Python内置了一个变量<code>_</code>,存储最近一个表达式的运算结果，这个变量无需赋值，便可直接使用，事实上，<code>_</code>是一个只读变量，对它赋值是没有意义的。）</li><li>python的赋值可以进行多重赋值，例如：<code>a, b = 0, 1</code>相当于<code>a = 0, b = 1</code></li><li>在字符串中使用<strong>数值类型时</strong>，需要显式地指出你希望Python将这个整数用作字符串。为此，可调用函数<code>str()</code> ， 它让Python将非字符串值表示为字符串,如：<code>print(&quot;age:&quot;+str(19))</code></li></ul></li></ul><h2 id="二字符串"><a class="markdownIt-Anchor" href="#二字符串"></a> 二：字符串</h2><ul><li>字符串可以用单引号<code>''</code>或者双引号<code>&quot;&quot;</code>表示;<ul><li>灵活地使用单引号和双引号来使字符串中可以<strong>嵌套引号和撇号</strong>，如：<ul><li><code>'I told my friend, &quot;Python is my favorite language!&quot;'</code></li><li><code>&quot;The language 'Python' is named after Monty Python, not the snake.&quot; </code></li><li><code>&quot;One of Python's strengths is its diverse and supportive community.&quot;</code></li></ul></li></ul></li><li>引号可以用<code>\</code>来转义。</li><li>字符串可以用<code>+</code>连接，如<code>'zhang'+'jie'</code>合为<code>'zhangjie'</code>.</li><li>字符串可以用<code>*</code>重复输出。<code>'zj'*3</code>即为<code>'zjzjzj'</code>。</li><li>字符串可以被索引，进行类似c语言的取出字符串的中字母的操作。如：<code>word = 'python</code>, <code>word[0] == 'p'</code>;<ul><li><strong>索引可以为负数</strong>，这会从右边开始索引。如：<code>word = 'python'</code>,<code>word[-1] = 'n'</code>(负索引是从-1开始，而不是0)。</li></ul></li><li>字符串可以被切片。如<code>word = 'python'</code>,则<code>word[0:2] = 'py'</code>,包含起始的字符，不包含末尾的字符。切片可以省略，省略左边，默认为从0开始，省略右边，则默认到末尾。如<code>word[:3] = 'pyt'</code>,<code>word[1:] = 'ython'</code>。</li><li>字符串<strong>是不可变的</strong>，不可以被修改。如果需要修改，只能创建一个新的字符串，并在创建的过程中，将修改加进去。</li><li>制表符<code>\t</code>:添加四个空格，如：<code>print(&quot;\tPython&quot;)</code></li><li>换行符<code>\n</code>:换到下一行。</li></ul><h3 id="字符串对象方法"><a class="markdownIt-Anchor" href="#字符串对象方法"></a> 字符串对象方法</h3><ul><li><code>title()</code>:以首字母大写的方式显示每个单词，即将每个单词的首字母都改为大写。其中以空格区分单词。</li><li><code>upper()</code>:将字符串改为全部大写</li><li><code>lower()</code>:将字符串改为全部小写,存储数据时，方法lower() 很有用。很多时候，你无法依靠用户来提供正确的大小写，因此需要将字符串先转换为小写，再存储它们。以后需要显示这些信息时，再将其转换为 最合适的大小写方式。</li><li>删除空白的方法：<ul><li><code>rstrip()</code>:删除字符串末尾的空白,只是输出的结果中没有了空白，要想将字符串变量中的空白永久删除，需要将结果重新赋值给字符串变量。</li><li><code>lstrip()</code>:删除字符串开头的空白。</li><li><code>strip()</code>:同时删除字符串两端的空白。</li></ul></li><li></li></ul><h2 id="三列表"><a class="markdownIt-Anchor" href="#三列表"></a> 三：列表</h2><h3 id="列表的基本性质"><a class="markdownIt-Anchor" href="#列表的基本性质"></a> 列表的基本性质</h3><ul><li>列表由一系列按<strong>特定顺序排列的元素组成</strong>。你可以创建包含字母表中所有字母、数字0~9或所有家庭成员姓名的列表；也可以将任何东西加入列表中，其中的元素之间可以没有任何关系。鉴于列表通常包含多个元素，给列表指定一个表示复数的名称（如letters 、digits 或names ）是个不错的主意。</li><li>用方括号<code>[]</code>来表示列表，并用逗号来分隔其中的元素。</li><li>列表类似c语言的数组。但是列表中的元素不需要是同一类型。</li><li>列表的赋值：如<code>list1 = [1, 2, 3, 4, 5]</code>， <code>list2 = [1, 'a', 2, 'b', 3,[1, 2,&quot;zhangjie&quot;]]</code>,<code>list3 = []</code>。</li><li>访问列表元素：类似数组，通过<strong>索引</strong>来访问列表中的元素。如：<code>list1[0]</code>访问的元素是1。<ul><li>最后一个列表元素可以通过索引-1来访问，如：<code>list1[-1]</code>访问的是5。</li><li>用负数索引，是从-1开始从右往左依次索引。</li></ul></li><li>同字符串一样，列表也可以被切片和索引。<ul><li>可以<strong>通过切片来复制一个列表</strong>，如：<code>list2 = list1[:]</code>,如果直接赋值，引用还是同一个列表：<code>list2 = list1</code>，两个列表名其实是一个列表的两个不同名字。</li></ul></li><li>同字符串一样，列表也支持使用<code>+</code>进行连接,使用<code>*</code>进行重复。但是连接和重复的对象都必须是列表，返回的结果也是列表。</li><li>与字符串不同的是，列表中的元素是<strong>可以修改</strong>的。可以利用赋值操作对列表中某个元素进行修改。</li><li>可以使用append（）方法，在列表后面加元素。(括号中放需要加的元素。)</li><li>列表中可以嵌套列表。</li><li>使用函数<code>len()</code>，可以得到列表或者字符串的长度。如；<code>len(list1)</code>的结果为5.</li><li>可以使用函数<code>enumerate(序列)</code>来同时得到元素的值和索引值。</li></ul><h3 id="列表中常用的方法"><a class="markdownIt-Anchor" href="#列表中常用的方法"></a> 列表中常用的方法</h3><ul><li><code>list.append（x）</code>在列表的后面加上一个元素x。</li><li><code>list.extend(L)</code>将一个给定列表（L）中的元素全部都加到另一个列表里（list）.</li><li><code>list.insert(i, x)</code>在列表的指定元素之前插入元素。其中第一个参数是指定列表中元素的索引，第二个参数是要插入的值。如，<code>list.insert(0, 5)</code>是在整个列表前插入一个5.</li><li><code>list.remove(x)</code>删除列表中值为x的第一个元素，如果没有这样的元素，则会返回错误。</li><li><code>list.pop([i])</code>类似栈里面的弹出，会删除列表里指定元素并返回它的值。如果<strong>没有指定参数</strong>则默认对列表的最后一个元素进行操作。（另外，参数用方括号[]括起来是表示，这个参数是可以有也可以没有的）。结合<code>append</code>方法和<code>pop</code>方法可以将列表当做一个栈使用。</li><li><code>list.clear()</code>删除列表中的所有元素，此时打印列表只剩下一对空的方括号。</li><li><code>list.index(x)</code>返回列表中第一个值为x的元素的索引，如果不存在这样的元素，则返回一个错误。</li><li><code>list.count(x)</code>返回值x在列表中出现的次数。</li><li><code>list.sort()</code>会对列表中的元素进行永久性正向排序（即按字母顺序从小到大）;<ul><li>传递参数<code>reverse=True</code>可以对元素进行永久性反向排序（按字母顺序从大到小），如：<code>list.sort(reverse=True)</code></li></ul></li><li><code>sorted(list)</code>对列表中的元素进行临时正向排序，排序规则与sort方法相同，如：<code>print(sorted(list))</code></li><li><code>list.reverse()</code>会对列表中的元素进行逆序排列，不是指按与字母顺序相反的顺序排列列表元素，而只是反转列表元素的排列顺序。</li><li><code>list.copy()</code>会返回一个列表的拷贝。</li></ul><h3 id="列表的应用"><a class="markdownIt-Anchor" href="#列表的应用"></a> 列表的应用</h3><ul><li>当作栈使用。</li><li>当作队列使用。需要引入collections.deque方法。</li></ul><h3 id="列表解析"><a class="markdownIt-Anchor" href="#列表解析"></a> 列表解析</h3><ul><li>列表可以由公式推出其中的元素。列表推导式由包含一个表达式的方括号组成，<strong>表达式用于存储要存入列表的结果</strong>，表达式后面跟随一个 for 子句，之后可以有零或多个 for 或 if 子句。结果是一个列表，由表达式依据其后面的 for 和 if 子句上下文计算而来的结果构成。</li><li>例如： <code>[(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]</code>,它的结果为<code>[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]</code>。</li></ul><h3 id="del语句"><a class="markdownIt-Anchor" href="#del语句"></a> del语句</h3><ul><li>del语句可以<strong>根据索引删除列表中的元素。del语句也可以删除列表中的切片</strong>。例如：<code>del list[1]</code>以及<code>del list[2:4]</code>,<code>del list[:]</code>。</li><li>del语句还可以删除整个变量，<code>del list</code>.在del删除整个变量后，再次调用该变量会报错，除非再次这个变量赋值。</li></ul><h3 id="range函数"><a class="markdownIt-Anchor" href="#range函数"></a> range()函数</h3><ul><li>range()会生成一个指定长度的链表，例如：`range(10),会生成一个<strong>从0到9</strong>的序列，即参数10是指定生成的链表的长度，默认情况下，这个等差链表是从0开始的。</li><li>可以指定range生成的链表的起始和结束，例如：<code>range(5, 10)</code>会生成一个从5到9的链表。</li><li>可以指定链表的步长（即公差，可以为负数）。例如：<code>range(0, 10, 3)中的第一个参数是起始的数，结束的数为10（永远不会包含指定的结束数），3为步长</code>,结果为0， 3， 6， 9。可以把步长设置为负数，形成从大到小的链表。例如<code>range(-10, -100, -30)</code>,结果-10，-40，-70。</li></ul><h2 id="四元组"><a class="markdownIt-Anchor" href="#四元组"></a> 四：元组</h2><ul><li>元组与列表有很多地方类似的，但是元组是用<strong>圆括号来定义</strong>的。</li><li>元组和字符串一样是<strong>不可变</strong>的，一般是通过索引来访问其中的元素值。<ul><li>虽然不能修改元组的元素，但可以给存储元组的变量赋值。如：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">dimensions&#x3D;(1,2)dimensions&#x3D;(3,4)</code></pre></li><li>元组中的元素可以是<strong>不同类型</strong>的，但是列表中的元素必须是<strong>同一类型</strong>的。</li><li>元组的定义可以省掉括号，但最好带上。</li><li>元组的常见形式， <code>t = 12345, 'hello'</code>，<code>t = (1, 3 ,&quot;zhangjie&quot;)</code></li></ul><h2 id="五集合set"><a class="markdownIt-Anchor" href="#五集合set"></a> 五：集合（set）</h2><ul><li>集合同数学中的定义一样，是一个无序不重复的集。集合中的元素可以是不同的类型的。如果在给集合定义或者复制时，有重复的元素，并不会报错，但是Python会自动删除集合中重复的元素，最终只留下一个元素。</li><li>可以使用花括号<code>&#123;&#125;</code>或者<code>set()</code>函数来创建集合。例如：<code>a = &#123;1, 'hello'&#125;</code>或者<code>a = set('abcdefg')</code>。使用set必须有单引号<code>''</code>或者双引号<code>&quot;&quot;</code>，并且set会把被引号包围的任何东西拆分，并按照随机顺序存入集合中。（定义空集合只能使用set(),而不能使用花括号｛｝）</li><li>集合也可类似列表使用推导式来定义其内的元素。</li><li>集合中可以使用<code>&amp;并，^交，-, |</code>等数学集合运算。</li></ul><h2 id="六字典"><a class="markdownIt-Anchor" href="#六字典"></a> 六：字典</h2><ul><li>字典与列表不同，它是根据事先存好的的关键字来索引具体元素的。就像真实的字典一样,在Python中，字典是一系列<strong>键—值对</strong> 。每个键都与一个值相关联,形如<code>key:value</code>，你可以使用键来访问与之相关联的值。与键相关联的值可以是数字、字符串、列表乃至字典。事实上，可将任何Python对象用作字典中的值。</li><li>使用<strong>花括号</strong>来创建字典。例如；<code>dict = &#123;'key1':1, 'key2': 2&#125;</code>。一对空的花括号可以创建一个空的字典。</li><li>可以直接给字典<strong>增加关键字和对应的值</strong>:<code>dict['key3'] = 3</code>.要<strong>修改字典中的值</strong>，可依次指定字典名、用方括号括起的键以及与该键相关联的新值。</li><li>键—值对是两个相关联的值。指定键时，Python将返回与之相关联的值。键和值之间用<strong>冒号</strong>分隔，而键—值对之间用<strong>逗号</strong>分隔。在字典中，你想存储多少个键—值对都可以。</li><li>要获取与键相关联的值，可依次指定字典名和放在方括号内的键,如：<code>print(dict['key1'])</code>。</li><li>注意，键—值对的<strong>排列顺序与添加顺序不同</strong>。Python不关心键—值对的添加顺序，而只关心键和值之间的关联关系。</li><li>对于字典中不再需要的信息，可使用<strong>del 语句将相应的键—值对彻底删除</strong>。使用del 语句时，必须指定字典名和要删除的键。如：<code>del dict['key1']</code>.</li><li>使用关键字<code>in</code>可以确认某个关键字是否在字典中。例如；<code>'key1' in dict</code>,如果’key1’存在的话返回True，否则返回False。（类似的还有<code>'key1' not in dict</code>的写法）、</li><li>可以使用方法<code>字典名.items()</code><strong>同时读出字典中的关键字和值</strong>（常用在循环中遍历字典）。</li><li>使用方法 <code>字典名.keys()</code>可以返回一个字典中的<strong>全部关键字</strong>。</li><li>可使用方法<code>values() </code>，它<strong>返回一个值列表，而不包含任何键</strong>。</li><li>遍历循环示例：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 遍历键值对for key, value in dict.items():    print(&quot;key &#x3D; &quot; + key)    print(&quot;value &#x3D; &quot; + value)# 只遍历键for key in dict.keys():    print(&quot;key &#x3D; &quot;  + key)</code></pre><ul><li>可使用函数<code>sorted()</code>来获得按特定顺序排列(特定顺序是指按字母的大小写顺序等默认的顺序)的键列表的副本,如：<code>for name in sorted(dict.keys()):</code></li><li>dic()函数可以从值对列表中创建字典。</li><li>通过对包含重复元素的列表调用<code>set()</code>方法 ，可让Python找出列表中<strong>独一无二的元素，并使用这些元素来创建一个集合</strong>。如：<code>for value in set(dict.values()):</code></li><li>字典推导式也是同样可以使用的。</li><li>我们将较大的字典放在多行中:</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">favorite_languages &#x3D; &#123;    &#39;jen&#39;: &#39;python&#39;,    &#39;sarah&#39;: &#39;c&#39;,    &#39;edward&#39;: &#39;ruby&#39;,    &#39;phil&#39;: &#39;python&#39;,    &#125;</code></pre><ul><li>字典和列表等可以相互嵌套，如：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 列表中嵌套字典alien_0 &#x3D; &#123;&#39;color&#39;: &#39;green&#39;, &#39;points&#39;: 5&#125;alien_1 &#x3D; &#123;&#39;color&#39;: &#39;yellow&#39;, &#39;points&#39;: 10&#125;alien_2 &#x3D; &#123;&#39;color&#39;: &#39;red&#39;, &#39;points&#39;: 15&#125;aliens &#x3D; [alien_0, alien_1, alien_2]# 在字典中嵌套列表pizza &#x3D; &#123;&#39;crust&#39;: &#39;thick&#39;,&#39;toppings&#39;: [&#39;mushrooms&#39;, &#39;extra cheese&#39;],&#125;# 在字典中嵌套字典users &#x3D; &#123;&#39;aeinstein&#39;: &#123;&#39;first&#39;: &#39;albert&#39;,&#39;last&#39;: &#39;einstein&#39;,&#39;location&#39;: &#39;princeton&#39;,&#125;,&#39;mcurie&#39;: &#123;&#39;first&#39;: &#39;marie&#39;,&#39;last&#39;: &#39;curie&#39;,&#39;location&#39;: &#39;paris&#39;,&#125;,&#125;</code></pre><h1 id="python的流程控制"><a class="markdownIt-Anchor" href="#python的流程控制"></a> python的流程控制</h1><h2 id="if语句"><a class="markdownIt-Anchor" href="#if语句"></a> if语句</h2><ul><li>类似c语言中的if语句，但是python<strong>省去了条件外面的括号</strong>，而是<strong>用冒号<code>:</code>来表示</strong>（就像c语言不能忘记括号一样，python也不能忘记冒号），<strong>并将<code>else if</code>合成了一个<code>elif</code>关键字</strong>（但是还是有单独的<code>else</code>)。如：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; (int)(input()) #input读取键盘的输入，但是默认读入的类型是字符串型，需要强制转换为数字整型if x &lt; 0:        x &#x3D; 0        print(x)elif x &#x3D;&#x3D; 0:        x &#x3D; -1        print(x)else:        x &#x3D; 1       print(x)</code></pre><ul><li>python条件语句内部的语句不是用花括号<code>&#123;&#125;</code>来括起来，而是直接<strong>用缩进来表示包含关系</strong>。所以这种带有控制语句的代码最好不直接在解释器中写。</li><li><strong>条件测试（布尔表达式）</strong>：每条if 语句的核心都是一个值为True 或False 的表达式，这种表达式被称为条件测试。<ul><li>条件表达式(布尔表达式)的结果要么为True ，要么为False 。</li></ul></li><li>if语句判断列表是否为空：<code>if list:</code>,如果列表是空的，相当于条件为false，如果为非空，则相当于条件为true。</li></ul><h2 id="for语句"><a class="markdownIt-Anchor" href="#for语句"></a> for语句</h2><ul><li>与c语言的for循环不同的是，python的for循环没有控制条件，它自动停止的。例如</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">words &#x3D; [&#39;zhang&#39;, &#39;jie&#39;]for word in words:  print(word)</code></pre><ul><li>for循环常用来遍历列表或者字符串等序列，循环会在序列尾部自动结束。而在示例程序中的<code>word</code>变量是定义的列表序列中的单个元素。注意<code>for...in...</code>的格式。</li><li>for语句的末尾有一个<strong>冒号</strong>。</li><li>循环中的语句依靠<strong>缩进</strong>来识别。</li></ul><h2 id="while循环"><a class="markdownIt-Anchor" href="#while循环"></a> while循环</h2><ul><li>for 循环用于针对<strong>集合中的每个元素</strong>，而while 循环不断地运行，直到<strong>指定的条件不满足</strong>为止。示例：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">current_number &#x3D; 1while current_number &lt;&#x3D; 5:    print(current_number)    current_number +&#x3D; 1</code></pre><h2 id="break和continue语句"><a class="markdownIt-Anchor" href="#break和continue语句"></a> break和continue语句</h2><ul><li>break 语句用于控制程序流程，可使用它来控制哪些代码行将执行，哪些代码行不执行，从而让程序按你的要求执行你要执行的代码。</li><li>示例：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; for n in range(2, 10):...     for x in range(2, n):#第一次循环，range（2,2)是没有值的,解释器不会输出任何内容...         if n % x &#x3D;&#x3D; 0:...             print(n, &#39;equals&#39;, x, &#39;*&#39;, n&#x2F;&#x2F;x)...             break...     else:...         # loop fell through without finding a factor...         print(n, &#39;is a prime number&#39;)...2 is a prime number3 is a prime number4 equals 2 * 25 is a prime number6 equals 2 * 37 is a prime number8 equals 2 * 49 equals 3 * 3</code></pre><ul><li>要<strong>返回到循环开头</strong>，并根据条件测试结果决定是否继续执行循环，可使用continue 语句，它不像break 语句那样不再执行余下的代码并退出整个循环。continue语句与c语言中基本一样，它表示跳过continue语句中后面所有的当前循环的语句（到循环尾），从而直接进入下一次迭代。示例：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; for num in range(2, 10):...     if num % 2 &#x3D;&#x3D; 0:...         print(&quot;Found an even number&quot;, num)...         continue...     print(&quot;Found a number&quot;, num)Found an even number 2Found a number 3Found an even number 4Found a number 5Found an even number 6Found a number 7Found an even number 8Found a number 9</code></pre><h2 id="pass语句"><a class="markdownIt-Anchor" href="#pass语句"></a> pass语句</h2><ul><li>pass语句就像它的名字一样，读到它时，什么也不做，直接过去就行。</li></ul><h2 id="条件控制"><a class="markdownIt-Anchor" href="#条件控制"></a> 条件控制</h2><h3 id="in-和-not-in"><a class="markdownIt-Anchor" href="#in-和-not-in"></a> in 和 not in</h3><ul><li>in和not in用来判断某个值是否在某个区间内（如列表）。</li><li><strong>检查特定值是否在列表中</strong>:要判断特定的值是否已包含在列表中，可使用<strong>关键字in</strong>,如：<code>if user in users:</code>,也可以判断特定值不再列表中，如：<code>if user not in users:</code></li></ul><h3 id="is-和-not-is"><a class="markdownIt-Anchor" href="#is-和-not-is"></a> is 和 not is</h3><ul><li>is和not is用来判断两个比较对象是否相同。</li></ul><h3 id="大于等于以及判等"><a class="markdownIt-Anchor" href="#大于等于以及判等"></a> 大于等于以及判等</h3><ul><li>python中支持连续比较，即像普通比较一样可以连续的比较多个值的关系。例如：<code>a &lt; b == c</code>可以判断b是否大于a的同时等于c。</li></ul><h3 id="逻辑操作符"><a class="markdownIt-Anchor" href="#逻辑操作符"></a> 逻辑操作符</h3><ul><li>python中的逻辑操作符包括<code>and, not, or</code>。</li><li><strong>or</strong>的示例：<code>x or y</code>,如果x为真则返回x，否则返回y。</li><li><strong>and</strong>的示例：<code>x and y</code>,如果x的值为假，则不再看y的值，返回（false），如果x的值为真，则返回y的值。（and和or都是从左向右解析，and返回值的条件是遇见假的变量或或者到末尾， 而or返回的条件是遇见真或者到末尾。</li><li><strong>not</strong>的示例：<code>not x</code>,not只有True和False两种返回值。如果x为真，则not使其取反，结果为False，反之亦然。</li></ul><h3 id="序列的比较"><a class="markdownIt-Anchor" href="#序列的比较"></a> 序列的比较</h3><ul><li>条件比较<code>&gt;, &lt; ,==</code>可以用于比较序列（如列表，字符串，字典）。</li><li>比较规则：首先比较前两个元素，如果不同，就决定了比较的结果；如果相同，就比较后两个元素，依此类推，直到所有序列都完成比较。如果两个元素本身就是同样类 型的序列，就递归字典序比较。如果两个序列的所有子项都相等，就认为序列相等。如果一个序列是另一个序列的初始子序列，较短的一个序列就小于另一个。字符 串的字典序按照单字符的 ASCII 顺序。</li></ul><h1 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h1><ul><li>函数是带名字的代码块，用于完成具体的工作。</li><li>重构：将代码划分为一系列完成具体工作的函数。这样的过程被称为<strong>重构</strong>。重构让代码更清晰、更易于理解、更容易扩展。</li><li>函数编写规范：<ul><li>应给函数指定描述性名称，且只在其中使用<strong>小写字母和下划线</strong>;</li><li>每个函数都应包含简要地阐述其功能的注释，该注释应紧跟在函数定义后面，并采用文档字符串格式；</li><li>给形参指定默认值时以及函数调用中的关键字实参，<strong>等号两边不要有空格</strong>；</li><li>如果程序或模块包含多个函数，可使用<strong>两个空行将相邻的函数分开</strong>，这样将更容易知道前一个函数在什么地方结束，下一个函数从什么地方开始。</li><li>所有的<strong>import 语句都应放在文件开头</strong>，唯一例外的情形是，在文件开头使用了注释来描述整个程序。</li><li>如果形参很多，导致函数定义的长度超过了79字符，可在函数定义中输入左括号后按回车键，并在下一行按两次Tab键，从而将形参列表和只缩进一层的函数体区分开来。如：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">def function_name(      parameter_0, parameter_1, parameter_2,      parameter_3, parameter_4, parameter_5):  function body...</code></pre></li></ul><h2 id="函数定义"><a class="markdownIt-Anchor" href="#函数定义"></a> 函数定义</h2><ul><li>使用<code>def</code>定义函数，<code>def</code>后接函数的名字，以及她的形参列表，最后就像大多数功能语句一样，以<code>:</code>开启函数体。</li><li>函数体的书写必须必须<strong>全部相对定义缩进</strong>。示例：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; def fib(n):    # write Fibonacci series up to n...     &quot;&quot;&quot;Print a Fibonacci series up to n.&quot;&quot;&quot;...     a, b &#x3D; 0, 1...     while a &lt; n:...         print(a, end&#x3D;&#39; &#39;)...         a, b &#x3D; b, a+b...     print()...&gt;&gt;&gt; # Now call the function we just defined:... fib(2000)0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597</code></pre><ul><li>函数第一行处的文本是被称为<strong>文档字符串 （docstring）<strong>的注释，描述了函数是做什么的。文档字符串用</strong>三引号</strong>括<br />起，Python使用它们来生成有关程序中函数的文档。。</li></ul><h2 id="函数调用"><a class="markdownIt-Anchor" href="#函数调用"></a> 函数调用</h2><ul><li>直接输入函数的名字并给他传递实参即可，例如<code>fib(10)</code>,即是对前文函数的调用。</li><li>函数名可以直接赋值给其它变量。如</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">f &#x3D; fibf(10)</code></pre><p>与直接<code>fib(10)</code>效果一样。</p><h2 id="函数的参数"><a class="markdownIt-Anchor" href="#函数的参数"></a> 函数的参数</h2><ul><li>鉴于函数定义中可能包含<strong>多个形参</strong>，因此函数调用中也可能包含多个实参。向函数传递实参的方式很多，可使用<strong>位置实参</strong> ，这要求实参的顺序与形参的顺序相同；也可使用<strong>关键字实参</strong> ，其中每个实参都由变量名和值组成；还可使用列表和字典。</li><li><strong>位置实参</strong>：要求实参的顺序与形参的顺序相同，如：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">def describe_pet(animal_type, pet_name):    &quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot;    print(&quot;\nI have a &quot; + animal_type + &quot;.&quot;)    print(&quot;My &quot; + animal_type + &quot;&#39;s name is &quot; + pet_name.title() + &quot;.&quot;)describe_pet(&#39;hamster&#39;, &#39;harry&#39;)describe_pet(&#39;dog&#39;, &#39;willie&#39;)</code></pre><ul><li><strong>关键字实参</strong>：每个实参都由变量名和值组成；还可使用列表和字典，如：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">def describe_pet(animal_type, pet_name):    &quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot;    print(&quot;\nI have a &quot; + animal_type + &quot;.&quot;)    print(&quot;My &quot; + animal_type + &quot;&#39;s name is &quot; + pet_name.title() + &quot;.&quot;)describe_pet(animal_type&#x3D;&#39;hamster&#39;, pet_name&#x3D;&#39;harry&#39;)</code></pre><ul><li><strong>形参的默认值</strong>：编写函数时，可给每个形参指定默认值 。在调用函数中给形参提供了实参时，Python将使用指定的实参值；否则，将使用形参的默认值。因此，给形参指定默认值后，可在函数调用中省略相应的实参。使用默认值可简化函数调用，还可清楚地指出函数的典型用法。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">def describe_pet(pet_name, animal_type&#x3D;&#39;dog&#39;):    &quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot;    print(&quot;\nI have a &quot; + animal_type + &quot;.&quot;)    print(&quot;My &quot; + animal_type + &quot;&#39;s name is &quot; + pet_name.title() + &quot;.&quot;)</code></pre><ul><li>如果传递的参数是列表等复杂类型，<strong>函数中对列表等的修改是永久生效的</strong>（类似传递给该函数的是对该列表的引用）<ul><li>若想要仅仅<strong>传一个副本给函数</strong>，可使用切片的方法。如：<code>function_name(list_name[:])</code>。</li></ul></li><li>传递<strong>任意数量的实参</strong>：在形参的前面加上<code>*</code>可以生成一个元组，将所有接收到的元组都封装到这个元组中，使用参数时便在这个元组中去取。示例：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">def make_pizza(*toppings):    &quot;&quot;&quot;概述要制作的比萨&quot;&quot;&quot;    print(&quot;\nMaking a pizza with the following toppings:&quot;)    for topping in toppings:      print(&quot;- &quot; + topping)make_pizza(&#39;pepperoni&#39;)make_pizza(&#39;mushrooms&#39;, &#39;green peppers&#39;, &#39;extra cheese&#39;)</code></pre><ul><li>结合使用<strong>位置形参和任意数量的实参</strong>：如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。Python<strong>先匹配位置实参和关键字实参</strong>，再将余下的实参都收集到最后一个形参中。</li><li><strong>任意数量的关键字实参</strong>：有时候，需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。在这种情况下，可将函数编写成能够接受任意数量的<strong>键—值对</strong>——调用语句提供了多少就接受多少。<ul><li>使用<code>**</code>能够将接收到的关键字实参封装为一个字典。示例：</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">def build_profile(first, last, **user_info):    &quot;&quot;&quot;创建一个字典，其中包含我们知道的有关用户的一切&quot;&quot;&quot;    profile &#x3D; &#123;&#125;    profile[&#39;first_name&#39;] &#x3D; first    profile[&#39;last_name&#39;] &#x3D; last    for key, value in user_info.items():      profile[key] &#x3D; value    return profileuser_profile &#x3D; build_profile(&#39;albert&#39;, &#39;einstein&#39;,                              location&#x3D;&#39;princeton&#39;,                              field&#x3D;&#39;physics&#39;)print(user_profile) </code></pre><h2 id="函数的返回值"><a class="markdownIt-Anchor" href="#函数的返回值"></a> 函数的返回值</h2><ul><li><p>在函数中，可使用return 语句将值返回到调用函数的代码行。</p></li><li><p>函数可返回任何类型的值，包括列表和字典等较复杂的数据结构。</p></li><li><p><code> -&gt;</code>常常出现在python函数定义的函数名后面，为函数添加<code>元数据</code>,描述函数的返回类型，从而方便开发人员使用。如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Class ListNode:    def _init_(self, x):        self.val &#x3D; x        self.next &#x3D; NoneClass Solution:    def reverseList(self, head: ListNode) -&gt; ListNode:# 表示该函数的返回值类型为ListNode</code></pre></li></ul><h2 id="模块"><a class="markdownIt-Anchor" href="#模块"></a> 模块</h2><h3 id="模块的概念"><a class="markdownIt-Anchor" href="#模块的概念"></a> 模块的概念</h3><ul><li>模块是一个在其中<strong>封装了函数的Python程序</strong>。模块可以比作一整盒拼装玩具，而函数就是其中的一块块积木。</li><li>模块是包含了函数的定义的Python文件。<a href="http://xn--ciq4sf6ja323bty0ax7a40rl63althx06d.py">这个文件的名称是模块名.py</a>。</li><li>模块中也可以导入其它模块。</li></ul><h3 id="模块的导入与调用"><a class="markdownIt-Anchor" href="#模块的导入与调用"></a> 模块的导入与调用</h3><ul><li><code>import 模块名</code>导入模块名。这种方法导入的模块名，使用名模块内的函数时，必须再加上模块名。即类似<code>模块名.函数名</code>的调用方法。示例：<br />模块(<a href="http://fibo.py">fibo.py</a>)内容：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">def fib(n):    # write Fibonacci series up to n    a, b &#x3D; 0, 1    while b &lt; n:        print(b, end&#x3D;&#39; &#39;)        a, b &#x3D; b, a+b    print()def fib2(n): # return Fibonacci series up to n    result &#x3D; []    a, b &#x3D; 0, 1    while b &lt; n:        result.append(b)        a, b &#x3D; b, a+b    return result</code></pre><p>模块调用：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; import fibo&gt;&gt;&gt; fibo.fib(1000)1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987&gt;&gt;&gt; fibo.fib2(100)[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]&gt;&gt;&gt; fib &#x3D; fibo.fib #还可以将调用的函数赋给本地定义的变量，以方便频繁调用。&gt;&gt;&gt; fib(500)1 1 2 3 5 8 13 21 34 55 89 144 233 377</code></pre><ul><li><code>from 模块名 import 函数名</code>导入函数,这样不会导入模块名，但是导入的函数可以不依赖模块而直接调用。<ul><li>通过用逗号分隔函数名，可根据需要从模块中导入任意数量的函数：<code>from module_name import function_0, function_1, function_2</code></li></ul></li><li>还可以使用<code>from 模块名 import *</code>来导入模块中所有除了以下划线<code>_</code>开头的定义。示例：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; from fibo import fib, fib2 #导入&gt;&gt;&gt; fib(500) #直接调用函数1 1 2 3 5 8 13 21 34 55 89 144 233 377&gt;&gt;&gt; from fibo import * #导入模块中所有的定义&gt;&gt;&gt; fib(500)1 1 2 3 5 8 13 21 34 55 89 144 233 377</code></pre><ul><li>使用<code>as</code><strong>给导入的函数指定别名</strong>：如果要导入的函数的名称可能与程序中现有的名称冲突，或者函数的名称太长，可指定简短而独一无二的别名 ——函数的另一个名称，类似于外号。如：<code>from module_name import function_name as fn</code>.</li><li>使用<code>as</code>给<strong>模块指定别名</strong>：通过给模块指定简短的别名（如给模块pizza 指定别名p ），让你能够更轻松地调用模块中的函数。如：<code>import module_name as mn</code></li><li>最佳的做法是，要么只导入你需要使用的函数，要么导入整个模块并使用句点表示法。这能让代码更清晰，更容易阅读和理解。</li></ul><h3 id="模块的搜索路径"><a class="markdownIt-Anchor" href="#模块的搜索路径"></a> 模块的搜索路径</h3><ul><li>在导入一个模块时，解释器会从<strong>当前目录</strong>， <strong>环境变量PYTHONPATH</strong>指定的目录列表以及<strong>Python的默认安装路径中</strong>搜索模块。</li><li>解释器的实际搜索路径是由变量<code>sys.path</code>指定的。</li></ul><h3 id="标准模块"><a class="markdownIt-Anchor" href="#标准模块"></a> 标准模块</h3><ul><li>Python默认内置了很多标准模块，可以直接调用和配置。</li></ul><h3 id="dir函数"><a class="markdownIt-Anchor" href="#dir函数"></a> dir（）函数</h3><ul><li>dir（）函数用来按模块名搜索模块的定义。</li></ul><h3 id="包模块集"><a class="markdownIt-Anchor" href="#包模块集"></a> 包（模块集）</h3><ul><li>包是模块的上层，调用包中的模块与调用模块中的函数大体是相同的。可以直接<code>import 包名.模块名.函数名</code>,也可以用<code>from 包名 import 模块名/函数、变量名</code>或者<code>from 包名.模块名 import 子模块名/函数、变量名</code>。当然，类似模块的导入，包也同样有<code>from 包名 import *</code>的导入方式。</li><li>同样的，包内也可以引用其他包。</li><li>包文件的创建；包文件中必须包含<code>_init_.py</code>文件，这个文件可以让Python把该文件识别为包。它可以为空，也可以包含初始化的一些配置。示例：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">sound&#x2F;                          Top-level package      __init__.py               Initialize the sound package      formats&#x2F;                  Subpackage for file format conversions              __init__.py              wavread.py              wavwrite.py              aiffread.py              aiffwrite.py              auread.py              auwrite.py              ...      effects&#x2F;                  Subpackage for sound effects              __init__.py              echo.py              surround.py              reverse.py              ...      filters&#x2F;                  Subpackage for filters              __init__.py              equalizer.py              vocoder.py              karaoke.py              ...</code></pre><h1 id="输入和输出"><a class="markdownIt-Anchor" href="#输入和输出"></a> 输入和输出</h1><h2 id="格式化输出-print"><a class="markdownIt-Anchor" href="#格式化输出-print"></a> 格式化输出-print()</h2><ul><li>使用<code>print()</code>函数。print()中有类似c语言的用%以及相应参数限制输出格式的方法。<ul><li>Python 3中的print 是一个函数，因此<strong>括号必不可少</strong>。</li><li>每一个<code>print()</code>语句结束后，对内容会自动进行换行。</li><li>下面示例演示了如何将较长的print 语句分成多行。单词print 比大多数字典名都短，因此让输出的第一部分紧跟在左括号后面是合理的（见❶）。请选择在合适的地方拆分要打印的内容，并在第一行末尾（见❷）加上一个拼接运算符（+ ）。按回车键进入print 语句的后续各行，并使用Tab键将它们对齐并缩进一级。指定要打印的所有内容后，在print 语句的最后一行末尾加上右括号（见❸）。</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">❶ print(&quot;Sarah&#39;s favorite language is &quot; +❷     favorite_languages[&#39;sarah&#39;].title() +❸     &quot;.&quot;)</code></pre><ul><li>使用标准string模块，对字符串进行格式操作；例如<code>字符串.format()</code>方法。</li><li>使用Template方法；</li><li>使用str（）和repr（）函数。str（）将值转化为适合人阅读的形式，repr将值转化为适合解释器读取的形式。示例：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; s &#x3D; &#39;Hello, world.&#39;&gt;&gt;&gt; str(s)&#39;Hello, world.&#39;&gt;&gt;&gt; repr(s)&quot;&#39;Hello, world.&#39;&quot;</code></pre><h2 id="格式化输入"><a class="markdownIt-Anchor" href="#格式化输入"></a> 格式化输入</h2><h3 id="字符串输入-input"><a class="markdownIt-Anchor" href="#字符串输入-input"></a> 字符串输入-input()</h3><ul><li>函数input() 让程序暂停运行，等待用户输入一些文本。获取用户输入后，Python将其存储在一个变量中，以方便你使用。</li><li>函数input() 接受一个参数：即要向用户显示的提示 或说明，让用户知道该如何做。示例：</li><li>使用函数input() 时，Python将用户输入解读为<strong>字符串</strong>。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">name &#x3D; input(&quot;Please enter your name: &quot;)print(&quot;Hello, &quot; + name + &quot;!&quot;)</code></pre><h3 id="将字符串转换为数字"><a class="markdownIt-Anchor" href="#将字符串转换为数字"></a> 将字符串转换为数字</h3><ul><li>因为input()函数只能读取进来字符串，所以在需要读取数值的时候，需要对字符串类型进行转换。</li><li><code>int()</code>函数可以将符合整数的规定的<strong>字符串转换成int型的</strong></li><li><code>float(str)</code>函数将符合浮点型的规定的<strong>字符串转换成float型的</strong></li><li><code>str(num)</code>将<strong>整数、浮点型转换成字符串型的</strong></li></ul><h2 id="文件读写"><a class="markdownIt-Anchor" href="#文件读写"></a> 文件读写</h2><h3 id="文件的打开与关闭"><a class="markdownIt-Anchor" href="#文件的打开与关闭"></a> 文件的打开与关闭</h3><ul><li>要以任何方式使用文件——哪怕仅仅是打印其内容，都得先<strong>打开文件</strong>，这样才能访问它。<ul><li>**函数<code>open()</code>**接受一个参数：要打开的文件的名称。Python在当前执行的文件所在的目录中查找指定的文件。</li><li>使用函数<code>open()</code>会<strong>返回文件对象</strong>。open常用的模式是<code>open('filename', 'mode')</code>.<ul><li>第一个参数是一个含有要打开的文件的文件名（或文件路径）的字符串。<ul><li><strong>文件路径</strong>：你将类似pi_digits.txt这样的简单文件名传递给函数open() 时，Python将在<strong>当前执行的文件（即.py程序文件）所在的目录</strong>中查找文件,但仅向open()传递位于当前目录下的文件夹下的文件的名称也不可行。要让Python打开不与程序文件位于同一个目录中的文件，需要提供<strong>文件路径</strong> ，它让Python到系统的特定位置去查找。</li><li><strong>相对路径</strong>：如：Linux/OS:<code>with open('text_files/filename.txt') as file_object:</code>,在Windows系统中，在文件路径中使用<strong>反斜杠（<code>\ </code>）而不是斜杠（<code>/ </code>）</strong>：</li><li><strong>绝对路径</strong>：绝对路径通常比相对路径更长，因此将其存储在一个变量中，再将该变量传递给open() 会有所帮助。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"># Linux&#x2F;OSfile_path &#x3D; &#39;&#x2F;home&#x2F;ehmatthes&#x2F;other_files&#x2F;text_files&#x2F;filename.txt&#39; with open(file_path) as file_object:# Windowsfile_path &#x3D; &#39;C:\Users\ehmatthes\other_files\text_files\filename.txt&#39; with open(file_path) as file_object:</code></pre></li><li>第二个参数也是一个字符串，含有描述如何使用该文件的几个字符。<ul><li>mode 为 ‘r’ 时表示只是读取文件；‘w’ 表示只是写入文件（已经存在的同名文件将被删掉）；‘a’ 表示打开文件进行追加，写入到文件中的任何数据将自动添加到末尾。 ‘r+’ 表示打开文件进行读取和写入。</li><li>mode 参数是可选的，默认为 ‘r’。示例：<code>f = open('workfile', 'w')</code>。</li><li>只用写入的模式(w,a)，如果输入的文件不存在，会在当前目录下<strong>创建该文件</strong>。</li></ul></li></ul></li></ul></li><li>文件打开之后需要正常的<strong>关闭</strong>：<ul><li>未妥善地关闭文件可能会导致数据丢失或受损；</li><li>可以<code>close()</code>语句来关闭文件。</li><li>也可以是用关键字<code>with</code>来关闭文件：关键字with 在不再需要访问文件后将其关闭。如：<code>with open('pi_digits.txt') as file_object:</code></li></ul></li></ul><h3 id="读取文件内容"><a class="markdownIt-Anchor" href="#读取文件内容"></a> 读取文件内容</h3><ul><li><code>文件对象.read(size)</code>方法：该方法读取若干数量的数据并以字符串形式返回其内容，size 是可选的数值，指定字符串长度。如果没有指定 size 或者指定为负数，就会<strong>读取并返回整个文件</strong>。如果到了文件末尾，f.read() 会返回一个空字符串（‘’）</li><li><strong>逐行读取文件</strong>：要以每次一行的方式检查文件，可对文件对象使用<strong>for 循环</strong>(注意：每行的末尾都有一个看不见的换行符,可以使用<code>rstrip()</code>方法去掉)：<pre class="line-numbers language-python" data-language="python"><code class="language-python">filename &#x3D; &#39;pi_digits.txt&#39; with open(filename) as file_object:    # 每一次在循环中只读取文件中的一行  for line in file_object:     print(line.rstrip())</code></pre></li><li><code>文件对象.readline()</code>从文件中读取单独一行，字符串结尾会自动加上一个换行符（ \n ）。如果 f.readline() 返回一个空字符串，那就表示到达了文件末尾。</li></ul><h3 id="写入文件"><a class="markdownIt-Anchor" href="#写入文件"></a> 写入文件</h3><ul><li>要将文本写入文件，你在调用open() 时需要提供<strong>另一个实参</strong>（因为默认是r模式），告诉Python你要写入打开的文件。</li><li>使用文件对象的方法<code>write()</code><strong>将一个字符串写入文件</strong>;<ul><li>函数write() <strong>不会在你写入的文本末尾添加换行符</strong>，因此如果你写入多行时没有指定换行符，文件看起来可能不是你希望的那样：</li><li>要让每个字符串都单独占一行，需要在write() 语句中<strong>包含换行符</strong>,如：<code>file_object.write(&quot;I love programming.\n&quot;)</code></li><li>像显示到终端的输出一样，还可以<strong>使用空格、制表符和空行来设置这些输出的格式</strong>。</li></ul></li><li>Python<strong>只能将字符串写入文本文件</strong>。要将数值数据存储到文本文件中，必须先使用函数<code>str()</code> 将其转换为字符串格式。</li></ul><h1 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h1><ul><li>Python使用<strong>被称为异常的特殊对象来管理程序执行期间发生的错误</strong>。<ul><li>语法正确的情况下发生的错误为异常错误。</li><li>错误信息的最后一行指出发生了什么异常类型。异常也有不同的类型，异常类型做为错误信息的一部分显示出来：如零除错误（ ZeroDivisionError ） ，命名错误（ NameError） 和 类型错误（ TypeError ）等。</li></ul></li><li>每当发生让Python不知所措的错误时，它都会创建一个异常对象。如果你编写了处理该异常的代码，程序将继 续运行；如果你未对异常进行处理，程序将停止，并显示一个traceback(在异常没有被处理的情况下才会有traceback)，其中包含有关异常的报告。</li><li>异常是使用<strong>try-except 代码块处理</strong>的。try-except 代码块让Python执行指定的操作，同时告诉Python发生异常时怎么办。使用了try-except 代码块时，<strong>即便出现异常， 程序也将继续运行：显示你编写的友好的错误消息，而不是令用户迷惑的traceback并让程序终止</strong>。</li></ul><h2 id="语法错误syntaxerror"><a class="markdownIt-Anchor" href="#语法错误syntaxerror"></a> 语法错误（SyntaxError）</h2><ul><li>语法分析器指出错误行，并且在检测到错误的位置前面显示一个小“箭头”。 错误是由箭头 前面 的标记引起的（或者至少是这么检测的）。</li><li>错误会输出文件名和行号，所以如果是从脚本输入的你就知道去哪里检查错误了。</li></ul><h2 id="异常的处理"><a class="markdownIt-Anchor" href="#异常的处理"></a> 异常的处理</h2><ul><li>使用<code>try...except</code>语句来处理异常。<ul><li>如果try 代码块中的代码运行起来没有问题，Python将跳过except 代码块；如果try 代码块中的代码导致了 错误，Python将查找这样的except 代码块，并运行其中的代码，即其中指定的错误与引发的错误相同。 可以在except代码块中放入<strong>pass语句，告诉程序捕获到异常后什么都不需要做</strong>。</li><li>在出现异常的情况下，如果<strong>try-except 代码块后面还有其他代码，程序将接着运行</strong>，因为已经告诉了Python如何处理这种错误。</li><li>如：</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">try:  print(5&#x2F;0) except ZeroDivisionError:   print(&quot;You can&#39;t divide by zero!&quot;)</code></pre><ul><li><code>try...except...else</code>代码块：依赖于try 代码块成功执行的代码都应放到else 代码块中：<ul><li>try-except-else 代码块的工作原理大致如下：Python尝试执行try 代码块中的代码；只有可能引发异常的代码才需要放在try 语句中。有时候，<strong>有一些仅在try 代码块成功 执行时才需要运行的代码；这些代码应放在else 代码块中</strong>。except 代码块告诉Python，如果它尝试运行try 代码块中的代码时引发了指定的异常，该怎么办。</li><li>示例：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">try:  answer &#x3D; int(first_number) &#x2F; int(second_number) except ZeroDivisionError:   print(&quot;You can&#39;t divide by 0!&quot;) else:  print(answer)</code></pre></li><li>（<code>try...finall</code>）可以用来定义清理行为。</li></ul><h2 id="异常的抛出"><a class="markdownIt-Anchor" href="#异常的抛出"></a> 异常的抛出</h2><ul><li>使用<code>raise</code>语句可以抛出异常。</li></ul><h2 id="自定义异常"><a class="markdownIt-Anchor" href="#自定义异常"></a> 自定义异常</h2><ul><li>用户可以自定义异常类型来创建自己的异常名。</li></ul><h2 id="预定义清理行为"><a class="markdownIt-Anchor" href="#预定义清理行为"></a> 预定义清理行为、</h2><ul><li><code>with</code>语句打开文件，使用完毕之后会自动关闭文件。这可以称作一种预定义的清理行为。示例；</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">with open(&quot;myfile.txt&quot;) as f:    for line in f:        print(line)</code></pre><h1 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h1><h2 id="类的定义"><a class="markdownIt-Anchor" href="#类的定义"></a> 类的定义</h2><ul><li>类与函数一样，在使用前需要先定义。类的定义示例如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">class ClassName():    &lt;statement-1&gt;    .    .    .    &lt;statement-N&gt;</code></pre><ul><li><strong>方法</strong>：类中的函数叫做方法。</li><li><strong>属性</strong>：可通过实例访问的变量称为属性 。</li><li>可将类视为有关如何创建实例的说明。</li></ul><h2 id="_init_-类构造方法"><a class="markdownIt-Anchor" href="#_init_-类构造方法"></a> <code>_init_()</code>-类构造方法</h2><ul><li><code>__init__()</code>是一个特殊的方法，每当你根据类创建新实例时，<strong>Python都会自动运行它</strong>。在这个方法的名称中，<strong>开头和末尾各有两个下划线</strong>，这是一种约定，旨在避免Python默认方法与普通方法发生名称冲突。</li><li>在<code>_init_()</code>这个方法的定义中，<strong>形参self 必不可少，还必须位于其他形参的前面</strong>。<ul><li>Python调用这个<code>__init__() </code>方法来创建实例时，将<strong>自动传入实参self</strong> 。每个**与类相关联的方法调用都自动传递实参self ，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。**每当我们根据类创建实例时，都只需给除开self的形参提供值。</li><li>以self 为前缀的变量都可供类中的所有方法使用，我们还可以通过类的任何实例来访问这些变量。如：<code>self.name = name</code> 获取存储在形参name 中的值，并将其存储到变量name 中，然后<strong>该变量被关联到当前创建的实例</strong>。</li></ul></li><li>类的属性不用单独定义，**在<code>_init()</code>中通过self定义并初始化。</li><li>示例：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Dog():    &quot;&quot;&quot;一次模拟小狗的简单尝试&quot;&quot;&quot;    def __init__(self, name, age):      &quot;&quot;&quot;初始化属性name和age&quot;&quot;&quot;      self.name &#x3D; name      self.age &#x3D; age    def sit(self):      &quot;&quot;&quot;模拟小狗被命令时蹲下&quot;&quot;&quot;     print(self.name.title() + &quot; is now sitting.&quot;)    def roll_over(self):      &quot;&quot;&quot;模拟小狗被命令时打滚&quot;&quot;&quot;      print(self.name.title() + &quot; rolled over!&quot;)</code></pre><h2 id="类的实例化"><a class="markdownIt-Anchor" href="#类的实例化"></a> 类的实例化</h2><ul><li>类的实例化就就是<strong>将类看做一个函数进行调用</strong>。例如：<code>x = Myclass()</code>。</li><li>我们通常可以认为首字母大写的名称（如Dog）指的是类，而小写的名称（如my_dog ）指的是根据类创建的实例。</li><li>属性与方法的调用：使用句点表示法获取实例的属性和调用其方法。如：<code>my_dog.name</code>,<code>my_dog.roll_over()</code><ul><li><code>__doc__</code> 也是一个有效的属性，返回类的文档字符串</li></ul></li></ul><h2 id="类的编码风格"><a class="markdownIt-Anchor" href="#类的编码风格"></a> 类的编码风格</h2><ul><li>类名应采用<strong>驼峰命名法</strong>，即将<strong>类名中的每个单词的首字母都大写</strong>，而不使用下划线。实例名和模块名都采用<strong>小写格式，并在单词之间加上下划线</strong>。</li><li>对于每个类，都应紧跟在类定义后面包含一个<strong>文档字符串</strong>。这种文档字符串简要地描述类的功能，并遵循编写函数的文档字符串时采用的格式约定。每个模块也都应包含一个文 档字符串，对其中的类可用于做什么进行描述。</li><li>可使用空行来组织代码，但不要滥用。在类中，可使用<strong>一个空行来分隔方法</strong>；而在模块中，可使用<strong>两个空行来分隔类</strong></li><li>需要同时导入标准库中的模块和你编写的模块时，<strong>先编写导入标准库模块的import 语句，再添加一个空行</strong>，然后编写导入你自己编写的模块的import 语句。</li></ul><h2 id="类的继承"><a class="markdownIt-Anchor" href="#类的继承"></a> 类的继承</h2><ul><li>编写类时，并非总是要从空白开始。如果你要编写的类是另一个现成类的特殊版本，可使用继承 。一个类继承另一个类时，它将自动获得另一个类的所有属性和方法；原有的类称为父类 ，而新类称为子类 。<strong>子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法</strong>。</li><li>创建子类时，<strong>父类必须包含在当前文件中，且位于子类前面</strong>。</li><li>定义子类时，必须<strong>在括号内指定父类的名称</strong>。</li><li>子类的方法<code>__init__()</code><ul><li>创建子类的实例时，Python首先需要完成的任务是给父类的所有属性赋值。为此，<strong>子类的方法__init__() 需要父类施以援手</strong>。</li><li><code>super()</code> 是一个特殊函数，帮助Python将父类和子类关联起来。使用这个函数让Python调用父类的方法<code>__init__()</code> ，让该子类包含父类的所有属性。</li></ul></li><li>让一个类继承另一个类后，可<strong>添加区分子类和父类所需的新属性和方法</strong>,属性在调用<code>super()</code>函数后之后添加，方法可以在类中任意定义。</li><li><strong>重写父类的方法</strong>：<ul><li>对于<strong>父类的方法</strong>，只要它不符合子类模拟的实物的行为，都可对其进行重写。</li><li>重写父类的方法只需要在<strong>子类中定义一个同名的方法</strong>，就会自动覆盖掉父类的该方法。</li></ul></li><li><strong>将实例用作属性</strong>：类中属性可以是<strong>引用类型</strong>。如：<code>self.battery = Battery()</code>,其中<code>Battery()</code>是Battery类的构造方法。</li><li>示例：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 父类class Car():   &quot;&quot;&quot;一次模拟汽车的简单尝试&quot;&quot;&quot;    def __init__(self, make, model, year):      self.make &#x3D; make      self.model &#x3D; model      self.year &#x3D; year      self.odometer_reading &#x3D; 0    def get_descriptive_name(self):      long_name &#x3D; str(self.year) + &#39; &#39; + self.make + &#39; &#39; + self.model     return long_name.title()    def read_odometer(self):      print(&quot;This car has &quot; + str(self.odometer_reading) + &quot; miles on it.&quot;)    def update_odometer(self, mileage):      if mileage &gt;&#x3D; self.odometer_reading:        self.odometer_reading &#x3D; mileage else:print(&quot;You can&#39;t roll back an odometer!&quot;)           def increment_odometer(self, miles):      self.odometer_reading +&#x3D; miles         def gas_gank():     print(&quot;油箱信息&quot;)# 子类     class ElectricCar(Car):   &quot;&quot;&quot;电动汽车的独特之处&quot;&quot;&quot;    def __init__(self, make, model, year):      &quot;&quot;&quot;初始化父类的属性&quot;&quot;&quot;       super().__init__(make, model, year)       self.battery_size &#x3D; 70          def describe_battery(self):      &quot;&quot;&quot;打印一条描述电瓶容量的消息&quot;&quot;&quot;      print(&quot;This car has a &quot; + str(self.battery_size) + &quot;-kWh battery.&quot;)      # 重写父类方法   def gas_gank():    print(&quot;电动车没有油箱&quot;)</code></pre><h2 id="导入类"><a class="markdownIt-Anchor" href="#导入类"></a> 导入类</h2><ul><li>类和函数一样都可以<strong>封装在模块中</strong>，进行导入。</li><li>在模块文件的首部写<strong>个模块级文档字符串，对该模块的内容做简要的描述</strong>。</li><li>从模块中导入类的语法和导入函数一致。</li><li>一个模块中可以存储一个或者多个类。</li><li>模块示例：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;一组可用于表示电动汽车的类&quot;&quot;&quot;  from car import Carclass Battery():     ...... class ElectricCar(Car):     .......</code></pre><h2 id="python标准库"><a class="markdownIt-Anchor" href="#python标准库"></a> Python标准库</h2><ul><li>Python标准库是一组模块，安装的Python都包含它。</li><li>可使用标准库中的任何函数和类，为此，只需在程序开头包含一条简单的import 语句。</li><li>注：你还可以从其他地方下载外部模块。</li></ul><h1 id="json存储数据"><a class="markdownIt-Anchor" href="#json存储数据"></a> JSON存储数据</h1><ul><li>**JSON（JavaScript Object Notation）**格式最初是为JavaScript开发的，但随后成了一种常见格式，被包括Python在内的众多语言采用。</li><li>模块json 让你能够将简单的Python<strong>数据结构转储到文件</strong>中，并在程序再次运行时加载该文件中的数据。</li><li>可以使用json在Python程序之间分享数据。</li><li>JSON数据格式并非Python专用的，这让你能够将以<strong>JSON格式存储的数据与使用其他编程语言</strong>的人分享。</li><li>JSON在Python中是一个<strong>模块</strong>，使用JSON格式时需要先导入json模块。</li><li><code>json.dump()</code>:这个函数能够将数据结构转存到文件中。</li><li><code>json.load()</code>:将以json方式存储到文件的数据结构读取到内存中去。</li><li>示例：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">import json # 如果以前存储了用户名，就加载它 # 否则，就提示用户输入用户名并存储它 filename &#x3D; &#39;username.json&#39; try:    with open(filename) as f_obj:      username &#x3D; json.load(f_obj)   except FileNotFoundError:      username &#x3D; input(&quot;What is your name? &quot;)       with open(filename, &#39;w&#39;) as f_obj:        json.dump(username, f_obj)        print(&quot;We&#39;ll remember you when you come back, &quot; + username + &quot;!&quot;)   else:    print(&quot;Welcome back, &quot; + username + &quot;!&quot;)</code></pre><h1 id="python测试"><a class="markdownIt-Anchor" href="#python测试"></a> Python测试</h1><ul><li>Python标准库中的<strong>模块unittest</strong>提供了代码测试工具。</li><li><strong>单元测试</strong>用于核实函数的某个方面没有问题。</li><li><strong>测试用例</strong>是一组单元测试，这些单元测试一起核实函数在各种情形下的行为都符合要求。</li><li><strong>全覆盖测试用例</strong>包含一整套单元测试，涵盖了各种可能的函数使用方式。</li><li>示例：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">import unittest from name_function import get_formatted_name class NamesTestCase(unittest.TestCase):   &quot;&quot;&quot;测试name_function.py &quot;&quot;&quot;   def test_first_last_name(self):     &quot;&quot;&quot;能够正确地处理像Janis Joplin这样的姓名吗？&quot;&quot;&quot;     formatted_name &#x3D; get_formatted_name(&#39;janis&#39;, &#39;joplin&#39;)     self.assertEqual(formatted_name, &#39;Janis Joplin&#39;)   def test_first_last_middle_name(self):     &quot;&quot;&quot;能够正确地处理像Wolfgang Amadeus Mozart这样的姓名吗？&quot;&quot;&quot;      formatted_name &#x3D; get_formatted_name( &#39;wolfgang&#39;, &#39;mozart&#39;, &#39;amadeus&#39;)      self.assertEqual(formatted_name, &#39;Wolfgang Amadeus Mozart&#39;)      unittest.main()</code></pre><ul><li><p>可先导入<strong>模块unittest</strong>以及要<strong>测试的函数</strong>;</p></li><li><p>再创建一个<strong>继承unittest.TestCase 的类</strong>，在这个类中编写一系列<strong>方法</strong>对函数行为的不同方面进行测试。</p><ul><li>你可随便给这个类命名，但最好让它看起来与要测试的函数相关，并包含字样Test。</li></ul></li><li><p>在类中用于测试函数不同方面的方法名称<strong>必须以test打头，我们运行该测试程序的时候，所有以test打头的方法都将自动运行</strong>。</p></li><li><p>最后需要<strong>调用<code>unittest.main()</code>方法，用于运行测试程序</strong>。</p></li><li><p><strong>断言</strong>：断言方法用来核实得到的<strong>结果是否与期望的结果一致</strong>。</p><ul><li>在python中断言的一种实现方式是使用通过<code>unint.TestCase</code>类中的<code>assertEqual()</code>方法,如：<code>self.assertEqual(formatted_name, 'Wolfgang Amadeus Mozart') </code>,前面的参数是测试的结果，后面的参数是预期的结果。</li><li><code>assertEqual(a, b)</code>: 核实a == b</li><li><code>assertNotEqual(a, b)</code>: 核实a != b</li><li><code>assertTrue(x)</code>: 核实x 为True</li><li><code>assertFalse(x)</code>: 核实x 为False</li><li><code>assertIn(item , list )</code> 核实 item 在 list 中</li><li><code>assertNotIn(item , list )</code>: 核实 item 不在 list 中</li></ul></li><li><p>和函数的测试相似的，也可以对类进行测试：</p><ul><li>类的测试就是将原来测试函数中调用函数的地方，修改为调用类中的方法。</li><li><strong>使用<code>setUp()</code>方法</strong>将测试类初始化：<ul><li><code>unittest.TestCase</code>类包含方法<code>setUp()</code> ，让我们<strong>只需创建这些对象一次，并在每个测试方法中使用它们</strong>。如果你在TestCase 类中包含了方法<code>setUp()</code> ，<strong>Python将先运行它，再运行各个以test_打头的方法</strong>。这样，在你编写的每个测试方法中都可使用在方法<code>setUp()</code> 中创建的对象了。</li></ul></li><li>类测试示例：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">import unittest from survey import AnonymousSurvey class TestAnonymousSurvey(unittest.TestCase):   &quot;&quot;&quot;针对AnonymousSurvey类的测试&quot;&quot;&quot;   def setUp(self):     &quot;&quot;&quot; 创建一个调查对象和一组答案，供使用的测试方法使用 &quot;&quot;&quot;     question &#x3D; &quot;What language did you first learn to speak?&quot;     self.my_survey &#x3D; AnonymousSurvey(question)     self.responses &#x3D; [&#39;English&#39;, &#39;Spanish&#39;, &#39;Mandarin&#39;]       def test_store_single_response(self):     &quot;&quot;&quot;测试单个答案会被妥善地存储&quot;&quot;&quot;     self.my_survey.store_response(self.responses[0])     self.assertIn(self.responses[0], self.my_survey.responses)       def test_store_three_responses(self):     &quot;&quot;&quot;测试三个答案会被妥善地存储&quot;&quot;&quot;     for response in self.responses:       self.my_survey.store_response(response)     for response in self.responses:       self.assertIn(response, self.my_survey.responses) unittest.main()</code></pre></li></ul><pre class="line-numbers language-none"><code class="language-none"></code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/GDB/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/GDB/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="gdb的安装"><a class="markdownIt-Anchor" href="#gdb的安装"></a> GDB的安装</h1><h2 id="快速安装"><a class="markdownIt-Anchor" href="#快速安装"></a> 快速安装</h2><ul><li>快速安装一般不是最新版本；</li><li>直接使用命令：<code>sudo apt-get install gdb</code></li></ul><h2 id="源码编译安装"><a class="markdownIt-Anchor" href="#源码编译安装"></a> 源码编译安装</h2><ul><li>安装速度较慢，但可以使用最新版本的gdb。</li><li>源码安装的步骤：<ol><li>从<a href="http://ftp.gnu.org/gnu/gdb/">官网</a>下载<code>.tar.gz</code>格式的源码压缩包。</li><li>之后编译安装。</li></ol></li></ul><h1 id="gdb的基本使用"><a class="markdownIt-Anchor" href="#gdb的基本使用"></a> GDB的基本使用</h1><h2 id="编译为可使用gdb的可执行文件"><a class="markdownIt-Anchor" href="#编译为可使用gdb的可执行文件"></a> 编译为可使用GDB的可执行文件</h2><ul><li>使用gcc编译源文件时，加上<code>-g</code>选项，可以生成可使用GDB进行调试的可执行文件。</li></ul><h2 id="gdb的调用"><a class="markdownIt-Anchor" href="#gdb的调用"></a> GDB的调用</h2><ul><li>GDB调用的基本格式为：<code>gdb &lt;可执行文件名&gt;</code></li><li>GDB常用的调试指令</li></ul><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>b &lt;行号&gt;</td><td>在源代码指定的某一行设置断点</td></tr><tr><td>r</td><td>执行被调试的程序，其会在第一个断点处停止执行</td></tr><tr><td>c</td><td>当程序在某一断点处停止执行后，使用该指令可使程序继续执行，直到遇到下一个断点或者程序结束</td></tr><tr><td>n</td><td>令程序一行代码一行代码地执行</td></tr><tr><td>p &lt;变量名&gt;</td><td>打印指定变量在程序断点处的值（在程序停下来时使用）</td></tr><tr><td>l</td><td>显示程序的源代码，并显示行号</td></tr><tr><td>q</td><td>终止调试，退出程序</td></tr></tbody></table><hr /><p><a href="http://c.biancheng.net/gdb/">参考资料</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 杂技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> GDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机基本快捷键</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%BF%AB%E6%8D%B7%E9%94%AE/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%BF%AB%E6%8D%B7%E9%94%AE/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="windows系统快捷键"><a class="markdownIt-Anchor" href="#windows系统快捷键"></a> Windows系统快捷键</h1><ul><li>带Windows键</li></ul><table><thead><tr><th>快捷键</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>win</td><td>开始菜单</td><td>按Esc或者再按下win可以退出开始菜单</td></tr><tr><td>win + S</td><td>调出搜索</td><td></td></tr><tr><td>win + E</td><td>调出文件资源管理器</td><td>可反复使用打开多个文件资源管理器窗口</td></tr><tr><td>win + R</td><td>调出运行命令</td><td>常用来打开注册表</td></tr><tr><td>win +T</td><td>调出底部任务栏，并在其中切换</td><td>多次按下win + T可在底部任务栏中顺序切换，按下Esc可以退出选择</td></tr><tr><td>win +数字</td><td>可在底部任务栏中快速切换，排在第几，就对应第几个数字</td><td>再次按下可以最小化窗口</td></tr><tr><td>win + U</td><td>可以直接打开Windows的系统设置窗口</td><td></td></tr><tr><td>win + A</td><td>打开通知中心</td><td>按Esc可以退出</td></tr><tr><td>win + D</td><td>最小化所有窗口</td><td>再次按下可以恢复</td></tr><tr><td>win + G</td><td>启动Xbox屏幕录制</td><td>不会直接录制，而是先进入Xbox的操作界面</td></tr><tr><td>win + Alt + R</td><td>等待一下下后直接开始屏幕录制</td><td>再次按下，则停止录制并保存到C:\Users\12246\Videos\Captures，可选择录制声音</td></tr><tr><td>win + K</td><td>打开无线连接设备</td><td>如蓝牙</td></tr><tr><td>win + L</td><td>锁定计算机</td><td>进入需要密码进入的状态</td></tr><tr><td>win + x</td><td>调出系统快捷菜单</td><td></td></tr><tr><td>win + 空格</td><td>在输入法之间切换</td><td></td></tr><tr><td>win + 上方向键</td><td>总体上可使当前窗口向上移动分屏，连按几次后进入最大化窗口</td><td></td></tr><tr><td>win + 下方向键</td><td>总体上可使当前窗口向下移动分屏，连按几次后进入最小化窗口</td><td></td></tr><tr><td>win + 左/右方向键</td><td>使当前窗口左右分屏或者移动</td><td>到达边界后弹向相反的另一方</td></tr><tr><td>win + Tab</td><td>进入时间轴任务窗口模式</td><td>再按一次或者Esc可以回到正常窗口</td></tr><tr><td>win + Alt + D</td><td>打开日历</td><td></td></tr></tbody></table><ul><li>其它</li></ul><table><thead><tr><th>快捷键</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>Ctrl键按住</td><td>与鼠标左键配合可以选择不连续的多个文件</td><td></td></tr><tr><td>shift键按住</td><td>与鼠标左键配合可以选择连续的多个文件</td><td></td></tr><tr><td>Ctrl + A</td><td>全选</td><td></td></tr><tr><td>Ctrl + C</td><td>复制选择的项目</td><td></td></tr><tr><td>Ctrl + X</td><td>剪切选择的项目</td><td></td></tr><tr><td>Ctrl + V</td><td>粘贴被复制或者剪切的项目</td><td></td></tr><tr><td>Ctrl + Z</td><td>撤销刚才的操作</td><td></td></tr><tr><td>ctrl + Y</td><td>重新执行刚才的操作</td><td>差不多是反撤销，可以理解为撤销被撤销的操作</td></tr><tr><td>Ctrl + F</td><td>查找当前页面的指定字符</td><td></td></tr><tr><td>Alt + tab</td><td>显示当前所有窗口</td><td>按住Alt再按tab可以顺序选中不同的窗口,松手后进入选中的页面</td></tr><tr><td>F11</td><td>进入全屏</td><td>比普通方法进入全屏更强，可以连上边栏的显示也直接关掉，再次按下可关闭全屏</td></tr></tbody></table><h1 id="vscode快捷键"><a class="markdownIt-Anchor" href="#vscode快捷键"></a> vscode快捷键</h1><ul><li>总控制</li></ul><table><thead><tr><th>快捷键</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>CTRL + Shift + P、F1</td><td>打开顶部命令控制</td><td>ctrl + shift + P 会有失灵的时候</td></tr><tr><td>Ctrl + P</td><td>打开快捷控制窗口</td><td>这个窗口可以快速查找一些当前文件夹下的文件</td></tr><tr><td>Ctrl + shift + N</td><td>创建一个全新的vscode窗口</td><td></td></tr><tr><td>Ctrl + shift + W</td><td>关闭当前窗口</td><td></td></tr><tr><td>Ctrl + ,</td><td>打开设置（settings）窗口</td><td></td></tr><tr><td>Ctrl + K + Ctrl + S</td><td>打开设置快捷键的窗口</td><td></td></tr></tbody></table><ul><li>文本编辑</li></ul><table><thead><tr><th>快捷键</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>Ctrl + X</td><td>剪切选中部分</td><td>与vim插件有冲突，不能使用</td></tr><tr><td>Ctrl + C</td><td>复制选中的部分</td><td>与vim插件冲突，不能使用</td></tr><tr><td>Alt + 上下方向键</td><td>向上或者向下一行一行的移动当前行</td><td></td></tr><tr><td>shift + Alt + 上下方向键</td><td>向上或者向下复制当前行的内容</td><td></td></tr><tr><td>ctrl + shift + K</td><td>删除当前行</td><td></td></tr><tr><td>Ctrl + enter</td><td>在当前行下面插入一行</td><td></td></tr><tr><td>Ctrl + shift +enter</td><td>在当前行上面插入一行</td><td></td></tr><tr><td>Ctrl + 上下方向键</td><td>向上下移动页面一行行地移动页面</td><td></td></tr></tbody></table><ul><li>界面控制</li></ul><table><thead><tr><th>快捷键</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>Ctrl + F4，Ctrl + W</td><td>关闭当前编辑页</td><td>Ctrl + w不知为何用不了</td></tr><tr><td>ctrl +|拆分当前编辑页面（向右）</td><td></td><td></td></tr><tr><td>ctrl + 数字</td><td>进入第几个拆分页面</td><td></td></tr><tr><td>ctrl + K +方向键</td><td>调整拆分页面的排列方式</td><td></td></tr><tr><td>Ctrl + shift + `</td><td>打开内置的终端</td><td></td></tr></tbody></table><ul><li>文件控制</li></ul><table><thead><tr><th>快捷键</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>Ctrl + N</td><td>创建新的编辑文档</td><td>要在特定的位置按下才有用</td></tr><tr><td>Ctrl + O</td><td>需要在文件选项下按才会有打开文件资源管理器的效果</td><td></td></tr><tr><td>Ctrl + F4</td><td>关闭当前的标签页</td><td></td></tr><tr><td>Ctrl + tab</td><td>在标签页之间切换</td><td></td></tr><tr><td>ctrl + +/-</td><td>控制窗口和字体的大小</td><td></td></tr><tr><td>Ctrl + B</td><td>打开侧栏</td><td></td></tr><tr><td>Ctrl +shift+ E</td><td>打开侧边栏文件管理</td><td></td></tr><tr><td>Ctrl + shift + F</td><td>打开侧边栏查找</td><td></td></tr><tr><td>Ctrl + shift + G</td><td>打开侧边栏版本管理</td><td></td></tr><tr><td>Ctrl + shift + D</td><td>打开侧边栏debug</td><td></td></tr><tr><td>Ctrl + shift + X</td><td>打开侧边栏扩展</td><td></td></tr><tr><td>Ctrl + shift + V</td><td>打开Markdown预览</td><td></td></tr></tbody></table><ul><li>调试</li></ul><table><thead><tr><th>快捷键</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>F9</td><td>设置断点</td><td></td></tr><tr><td>F5</td><td>开始调试</td><td></td></tr><tr><td>Shift +F5</td><td>停止调试</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 杂技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/Git/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/Git/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="git"><a class="markdownIt-Anchor" href="#git"></a> Git</h1><p><a href="https://git-scm.com/book/en/v2/Getting-Started-First-Time-Git-Setup">官方文档</a></p><h2 id="git简介"><a class="markdownIt-Anchor" href="#git简介"></a> Git简介</h2><ul><li>Git是一个开源的分布式版本控制系统;</li><li>所谓分布式，是指每个人的电脑上都有一个版本库（仓库），而每当要与别人合作的时候便把自己的版本库推送到模拟的“中央服务器”上，别人再从这个“中央服务器”中获得该版本库。</li></ul><h2 id="git安装及配置"><a class="markdownIt-Anchor" href="#git安装及配置"></a> Git安装及配置</h2><ul><li>在linux上可以通过<code>sudo apt-get git</code>来直接安装;在Windows上需要到<a href="https://git-scm.com/downloads">Git的官网下载</a>;而在Mac上的安装可以在命令行通过<a href="https://brew.sh/">homebrew</a>安装，但实际上Mac的Xcode上集成了Git，安装Xcode的时候就已经安装好了Git。</li><li><strong>配置用户名和用户邮箱</strong>：  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot;</code></pre><ul><li><code>--config</code>这个参数，代表你这台机器上的所有仓库都使用这个用户名和邮箱。</li></ul></li></ul><h2 id="创建版本库仓库"><a class="markdownIt-Anchor" href="#创建版本库仓库"></a> 创建版本库(仓库)</h2><ul><li>版本库又名仓库，英文名repository，你可以简单理解成一个目录(文件夹），这个目录(目录的路径设置成英文避免出现问题）里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</li><li>仓库的初始化：进入当前目录下，打开“Git bash”,在终端输入<code>git init</code>,之后会在当前目录下生成一个<code>.git</code>文件目录，这是Git用来跟踪这个目录的文件，不能随意改动。</li><li>在当前目录下创建一个文件之后，需要将这个文件加入Git的暂存区中，此时使用<code>git add &lt;filename&gt; </code>（<code>git add .</code>可以将当前目录下的所有文件加入暂存区）（当修改的文件不在当前目录下，而在更深的文件夹中，则需要使用该文件的相对路径作为<code>git add</code>后面的参数。）</li><li>暂存区的文件需要加入Git的版本分支中，才算完成了整个文件的Git版本管理，此时使用<code>git commit -m &quot;本次提交说明&quot;</code></li></ul><h2 id="时间轴上版本查看"><a class="markdownIt-Anchor" href="#时间轴上版本查看"></a> 时间轴上版本查看</h2><h3 id="分支状态查看"><a class="markdownIt-Anchor" href="#分支状态查看"></a> 分支状态查看</h3><ul><li>使用<code>git stastus</code>查看<strong>当前分支</strong>(如果有除了master分支的其他分支的信息，除非当前在那条分支上，否则是不会显示那条分支的信息的）的状态，例如主分支下有多少分分支，以及暂存区多少文件待提交。</li><li>使用<code>git status</code>查看当前分支的状态，例如主分支下有多少分分支，以及暂存区多少文件待提交。</li></ul><h3 id="查看具体修改内容"><a class="markdownIt-Anchor" href="#查看具体修改内容"></a> 查看具体修改内容</h3><ul><li>使用<code>git diff  &lt;filename&gt;</code>可以查看具体的修改内容。</li></ul><h3 id="查看commit的历史记录"><a class="markdownIt-Anchor" href="#查看commit的历史记录"></a> 查看commit的历史记录</h3><ul><li>使用<code>git log</code>可以看到从最近到最远的所有commit记录，每个记录都会有commit的版本号id（一串乱七八糟的数字）,时间，作者以及commit时的描述。（此处就显得commit时一个合适的描述是多么的重要。）</li></ul><h3 id="版本回退回退commit"><a class="markdownIt-Anchor" href="#版本回退回退commit"></a> 版本回退（回退commit）</h3><ul><li>Git中用HEAD来表示当前版本，HEAD<sup>来表示上一个版本，HEAD</sup>^来表示上上个版本，而至于像100次提交前的版本，则用HEAD~100来表示。</li><li>要回到某一个版本可以使用<code>git reset --hard HEAD^</code>或者<code>git reset --hard &lt;版本号&gt;</code>(版本号不用输完，指数前几位即可，Git会自动去寻找符号这部分版本号的commit)。</li></ul><h3 id="查看历史命令"><a class="markdownIt-Anchor" href="#查看历史命令"></a> 查看历史命令</h3><ul><li>使用<code>git reflog</code>可以查看历史命令。</li></ul><h3 id="撤销工作区的修改"><a class="markdownIt-Anchor" href="#撤销工作区的修改"></a> 撤销工作区的修改</h3><ul><li><p>使用<code>git checkout -- &lt;filename&gt;</code>可以将工作区的某文件恢复至上一次<code>git add</code>或者<code>git commit</code>时的状态。（注意，<code>--</code>和`<filename>之间有一个空格）。</p></li><li><p>总结： <code>git reset</code>是撤销版本库的修改（即.git文件中的版本信息）,<code>git checkout</code>是撤销对工作区文件的修改（即当前电脑上真实的文件，实际原理是从.git文件中的暂存区或者版本库中把以前的版本还原到工作区中。）</p></li><li><p>删除文件</p></li><li><p>工作区文件被删除后，会导致版本库和工作区中的文件不一致。为了使工作区与版本库一致，可以使用<code>gir rm &lt;filename&gt;</code>删除，在<code>git conmmit -m &quot;删除描述&quot;</code>将版本库中的文件也删除。当然，我们也可以用<code>git checkout --&lt;filename&gt;</code>恢复工作区中被误删的文件。</p></li></ul><h2 id="远程仓库"><a class="markdownIt-Anchor" href="#远程仓库"></a> 远程仓库</h2><h3 id="使用ssh与远程主机github关联"><a class="markdownIt-Anchor" href="#使用ssh与远程主机github关联"></a> 使用SSH与远程主机（GitHub）关联</h3><ul><li>前面说到使用Git与多人合作，需要使用一个类似“中央服务器”的东西，我们可以自己创建一个Git服务器来充当这个中央服务器，也可以直接使用GitHub来充当这个东西。</li><li>首先得使用SSH将本地机与GitHub关联起来，是两者之间能够安全的传输数据。</li></ul><h4 id="创建本机的ssh秘钥"><a class="markdownIt-Anchor" href="#创建本机的ssh秘钥"></a> 创建本机的SSH秘钥</h4><ul><li>首先查看自己用户主目录中有没有一个<code>.ssh</code>的文件（我的电脑是在<code>C:\Users\12246\.ssh</code>）。如果没有则使用<code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code>创建。</li><li>在<code>.ssh</code>文件中会有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，其中<code>id_rsa</code>是私钥，<code>id_rsa.pub</code>是公钥。</li></ul><h4 id="将ssh公钥放入github账号中"><a class="markdownIt-Anchor" href="#将ssh公钥放入github账号中"></a> 将SSH公钥放入GitHub账号中</h4><ul><li>然后登录GitHub，在设置中找到设置SSH的地方，将本机上的公钥粘贴上去（粘贴的时候可能会出现格式错误，比如我用vim打开id_rsa.pub复制的就不行，而用cat查看复制就可以。）。这样就建立了本地机与GitHub的关联。只有将公钥放在GitHub上的电脑，才可以将文件上传到GitHub上。</li></ul><h3 id="创建远程仓库"><a class="markdownIt-Anchor" href="#创建远程仓库"></a> 创建远程仓库</h3><ul><li>首先在GitHub账号中创建一个仓库</li><li>之后将本地仓库与GitHub中的远程仓库关联起来。在本地仓库目录下打开Gitbash输入如下指令<code>$ git remote add origin git@github.com:&lt;GitHub上的username》/&lt;GitHub上的远程仓库名&gt;.git</code>,便将当前目录下的本地仓库与远程的仓库关联起来了。在本地机上远程库的名字叫orgin，这是远程仓库的默认叫法，当然也可以叫其它名字，只需再关联远程仓库时将orgin改成其它名字即可。</li></ul><h3 id="推送到远程仓库"><a class="markdownIt-Anchor" href="#推送到远程仓库"></a> 推送到远程仓库</h3><ul><li>使用<code>git push -u orgin master</code>，将当前库中的当前分支推送到远程库的master中。（在这个命令中，参数 -u只有在第一次推送这个分支时才需要使用，若不是第一次，只需<code>git push orgin master</code>即可；其中，origin是远程仓库在本地的名字，而master是远程仓库的分支名。）</li></ul><h3 id="从远程库克隆"><a class="markdownIt-Anchor" href="#从远程库克隆"></a> 从远程库克隆</h3><ul><li>使用<code>git clone  git@github.com:&lt;GitHub上的username》/&lt;GitHub上的远程仓库名&gt;.git</code>可以将远程的仓库克隆到本地（在哪个目录下打开gitbash使用的克隆，最后克隆下来的仓库就在哪个目录）(使用一<code>git clone</code>与使用<code>git pull</code>以及<code>git fetch</code>等一样，当执行命令后叫确认的时候不要直接回车，而应按照它所说的输入yes或者no。)</li><li>除了使用<code>git@....</code>格式的地址外，还可以使用普通的http地址，只是传输速度相对较慢。</li></ul><h2 id="分支管理"><a class="markdownIt-Anchor" href="#分支管理"></a> 分支管理</h2><h3 id="创建分支"><a class="markdownIt-Anchor" href="#创建分支"></a> 创建分支</h3><ul><li>使用<code>git branch &lt;分支名字&gt;</code>可以创建一个分支。</li><li>使用<code>git checkout &lt;分支名字&gt;</code>或者<code>git switch &lt;分支名字&gt;</code>可以切换到分支。</li><li>使用<code>git checkour -b &lt;分支名字&gt;</code>或者<code>git switch -c &lt;分支名字&gt;</code>可以创建一个分支并切换至那个分支。</li></ul><h3 id="查看分支"><a class="markdownIt-Anchor" href="#查看分支"></a> 查看分支</h3><ul><li>使用<code>git branch</code>可以查看所有分支，当前分支前面会有一个<code>*</code>标识。</li><li>切换至分支上后，我们所有的提交都是在分支上延伸出去。分支的开始位置是在主分支上申请分支的结点。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200901175215.jpg" alt="" /></li></ul><h3 id="合并分支"><a class="markdownIt-Anchor" href="#合并分支"></a> 合并分支</h3><ul><li>假如要把其他分支合并到master分支，首先需要切换回master分支；</li><li>使用<code>git merge &lt;需要被合并的分支名字&gt;</code>可以把指定的分支合并到<strong>当前分支</strong>。</li></ul><h4 id="快速合并"><a class="markdownIt-Anchor" href="#快速合并"></a> 快速合并</h4><ul><li>当master在创建分支后完全没有修改过，而其他分支内容有所修改，此时的合并直接就是把master指向其他分支的当前提交，过程十分的快速。</li></ul><h4 id="修改合并"><a class="markdownIt-Anchor" href="#修改合并"></a> 修改合并</h4><ul><li>当master分支和其他分支都各自有不同的修改时，合并分支操作会把他们各自的修改合并在一起成为新的master分支。</li></ul><h4 id="解决冲突合并"><a class="markdownIt-Anchor" href="#解决冲突合并"></a> 解决冲突合并</h4><ul><li>当master分支和其它分支都有修改并且有对同一个地方的不同的修改，此时就需要我们手动解决冲突。当使用<code>git merge &lt;分支名&gt;</code>后，会提示分支无法自动合并，需要我们手动解决。<code>git status </code>可以告诉我们有冲突的文件，此时我们打开有冲突的文件，会发现有<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD</code>以及<code>==========</code>和<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;分支名</code>的标识，我们只需要在有标识的地方把文件改成自己想要的样子，之后再正常add和commit即可。</li></ul><h3 id="查看分支合并的状况"><a class="markdownIt-Anchor" href="#查看分支合并的状况"></a> 查看分支合并的状况</h3><ul><li>使用带参数的log可以查看分支合并的情况。<code>git log --graph --pretty=oneline --abbrev-commit</code>.或者直接<code>git log --graph</code>查看分支合并图。</li></ul><h3 id="删除分支"><a class="markdownIt-Anchor" href="#删除分支"></a> 删除分支</h3><ul><li>删除分支常在分支被合并到主分支之后；</li><li>使用<code>git branch -d &lt;分支名字&gt;</code>来删除指定的分支。</li></ul><h3 id="隐藏工作区"><a class="markdownIt-Anchor" href="#隐藏工作区"></a> 隐藏工作区</h3><ul><li>使用<code>git stash</code></li></ul><h2 id="本地管理远程库"><a class="markdownIt-Anchor" href="#本地管理远程库"></a> 本地管理远程库</h2><h3 id="查看远程库的信息"><a class="markdownIt-Anchor" href="#查看远程库的信息"></a> 查看远程库的信息</h3><ul><li>使用<code>git remote</code>或者<code>git remote -v</code>查看远程库的信息。</li></ul><h3 id="推送分支"><a class="markdownIt-Anchor" href="#推送分支"></a> 推送分支</h3><ul><li>使用<code>git push &lt;远程分支在本地的名字&gt; &lt;本地分支名&gt;</code>,可以将本地的指定分支推送到远程分支上。</li></ul><h3 id="抓取分支"><a class="markdownIt-Anchor" href="#抓取分支"></a> 抓取分支</h3><ul><li>使用<code>git pull</code>抓取关联的远程分支</li></ul><h3 id="整理分支线"><a class="markdownIt-Anchor" href="#整理分支线"></a> 整理分支线</h3><ul><li>使用命令<code>git rebase</code></li></ul><h2 id="标签管理"><a class="markdownIt-Anchor" href="#标签管理"></a> 标签管理</h2><h3 id="创建标签"><a class="markdownIt-Anchor" href="#创建标签"></a> 创建标签</h3><ul><li>使用<code>git tag &lt;标签名&gt;</code>可以给当前分支的最近提交打上一个标签。</li><li>使用<code>git tag</code>查看所有标签；</li><li>使用<code>git tag &lt;标签名&gt; &lt;commit id&gt;</code>给具体某个commit打上标签。</li><li>使用<code>git show &lt;标签名&gt;</code>查看某个标签的具体信息。</li></ul><h3 id="远程标签"><a class="markdownIt-Anchor" href="#远程标签"></a> 远程标签</h3><ul><li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签。</li><li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li><li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li><li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 杂技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七章 图</title>
      <link href="//post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%9B%BE/index.html"/>
      <url>//post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%9B%BE/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="图"><a class="markdownIt-Anchor" href="#图"></a> 图</h1><p>由于考试压力。。。还有待完善。。。</p><h2 id="图的定义"><a class="markdownIt-Anchor" href="#图的定义"></a> 图的定义</h2><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815081734.jpg" alt="" /></p><ul><li>图由顶点集合和边集合产生</li></ul><h3 id="有向图和无向图"><a class="markdownIt-Anchor" href="#有向图和无向图"></a> 有向图和无向图</h3><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815081931.jpg" alt="" /></p><ul><li>有向图的边带有箭头，而无向图的边没有箭头。</li><li>无向边用<code>()</code>表示，而有向边用<code>&lt;&gt;</code>表示。</li></ul><h3 id="图的基本术语"><a class="markdownIt-Anchor" href="#图的基本术语"></a> 图的基本术语</h3><ul><li><strong>端点和邻接点</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815082218.jpg" alt="" /><ul><li>一条边的两头的顶点为端点，这两个端点互为邻接点。</li></ul></li><li><strong>顶点的度、入度和出度</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815082421.jpg" alt="" /><ul><li>有向图的度又分为出度和入度。</li><li>度、顶点数和边数的关系<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815082652.jpg" alt="" /><ul><li>每个顶点的度都代表了一条边，但是又因为每个边两头会有两个顶点，所以把所有顶点的度相加再除以2便是边的数目。</li></ul></li></ul></li><li><strong>完全图</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815083033.jpg" alt="" /><ul><li>完全无向图：每个顶点都与剩下的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个顶点直接有边相连，总共有n个结点，但是这样算，每条边都被算了两次，所以总边数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n(n-1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>。</li><li>完全有向图：因为每两个顶点之间都有两条方向不同的边，所以总边数直接就为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>,无需再除以2。</li></ul></li><li><strong>稠密图和稀疏图</strong><ul><li>稠密图：接近完全图的图；</li><li>稀疏图：含有边数较少的图（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>&lt;</mo><mo>&lt;</mo><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e&lt;&lt;n(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>）。</li></ul></li><li><strong>子图</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815084016.jpg" alt="" /><ul><li>类似集合中子集的关系。</li></ul></li><li><strong>路径和路径长度</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815084731.jpg" alt="" /><ul><li>路径上无重复结点的路径为简单路径（开始和结尾可以重复）。</li></ul></li><li><strong>回路和环</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815084909.jpg" alt="" /><ul><li>开始与结尾相同的简单路径为简单回路或简单环。</li></ul></li><li><strong>连通、连通图和连通分量</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815085209.jpg" alt="" /><ul><li>连通图的连通分量为自身；而非连通图的连通分量可能有多个；</li><li>非连通图的连通分量是原来图中不相连的几个部分；如果原来连通的部分再被拆开，则不是连通分量。例如：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815085655.jpg" alt="" /><ul><li>图2和图3是图1的连通分量，而图4不是。</li></ul></li></ul></li><li><strong>强连通图和强连通分量</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815103923.jpg" alt="" /><ul><li>强连通图是针对有向图而言的，任意两个结点之间连通的前提下，还要这两个结点间可以互通。</li><li>在非强连通图中找强连通分量的方法：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815104350.jpg" alt="" /><ul><li>先找出一个有向环，在这个环内各个顶点之间是互通的，然后再去增加环外与环上任一顶点互通的顶点，从而这个顶点肯定与环内其余顶点互通，从而构建出了强连通分量。</li></ul></li></ul></li><li><strong>权和网</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815105816.jpg" alt="" /><ul><li>给边加上权，带权图即为网。</li></ul></li></ul><h2 id="图的存储结构"><a class="markdownIt-Anchor" href="#图的存储结构"></a> 图的存储结构</h2><p>1.邻接矩阵：</p><ul><li>特别适合于稠密图的存储。</li><li>一个图的邻接矩阵的表示是唯一的。</li><li>无向图与有向图均可存储。<br />2.邻接表：</li><li>特别适合稀疏图的存储；</li><li>一个图的邻接表表示不唯一。</li><li>普通邻接表不能表现边的方向性，所以存储有向图需要使用<strong>逆邻接表</strong>。<br />3.十字链表<ul><li>储存有向图<br />4.邻接多重表</li></ul></li><li>存储无向图</li></ul><h3 id="邻接矩阵"><a class="markdownIt-Anchor" href="#邻接矩阵"></a> 邻接矩阵</h3><ul><li><strong>邻接矩阵定义</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815105755.jpg" alt="" /><ul><li>通过数组下标与顶点的编号之间的对应关系，来表示两个顶点之间的边。因为矩阵的大小是根据顶点数固定了的，所以当图很稀疏时，即图中的边数较少时，会有很多空间的浪费。</li><li>由此可知，无向图的邻接矩阵一定是一个主对角线上的元素全为0的对称矩阵。</li><li>示例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815105816.jpg" alt="" /></li></ul></li><li><strong>邻接矩阵存储类型定义</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815110730.jpg" alt="" /><ul><li>需要设立一个二维数组（邻接矩阵）来存储边的信息，一个一维数组来存储顶点的信息；</li><li>顶点的信息中包括顶点的编号和它的数据信息。</li><li>实质是一种顺序存储结构。</li></ul></li></ul><h3 id="邻接表"><a class="markdownIt-Anchor" href="#邻接表"></a> 邻接表</h3><ul><li><strong>邻接表的定义</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815111128.jpg" alt="" /><ul><li>通过链表来表示顶点之间边的关系；因为链表的长度是动态的，所以当图较稀疏时，也不会有太多存储空间浪费。</li><li>用一个数组来记录每个顶点的信息。</li><li>每个顶点对应的单链表只是表示它们是顶点的邻接点，而单链表结点之间并无关系。</li><li>示例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815111437.jpg" alt="" /></li></ul></li><li><strong>邻接表存储类型定义</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815111929.jpg" alt="" /><ul><li>边结点类型即单链表结点的类型；</li><li>头结点类型即存储在数组中的顶点类型；</li><li>通过在数组中检索到顶点，再由顶点通过顶点类型中定义的指向对应单链表的指针来找到该顶点的边信息。</li></ul></li><li><strong>逆邻接表</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815112323.jpg" alt="" /><ul><li>用于存储有向图；</li><li>对于每个顶点的单链表中，存储的是有边指向该顶点的顶点。</li></ul></li></ul><h3 id="十字链表"><a class="markdownIt-Anchor" href="#十字链表"></a> 十字链表</h3><ul><li><strong>十字链表的基本概念</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815124639.jpg" alt="" /><ul><li>在邻接表的基础上，每个顶点结点增加一个指向边结点的指针。即每个顶点结点中既记录了出边的信息，又记录了入边的信息；</li><li>每个边结点增加相对的起点和终点信息（起点即指向它的顶点，终点即它指向的顶点）,另外使用指向下一个相同终点或起点的指针（即指向对同一个顶点的入边或者出边）,来为某一个顶点的入边或者出边形成一个相对的单链表。</li></ul></li><li><strong>十字链表的实现模型</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815125018.jpg" alt="" /><ul><li>例如：0顶点的两条入边，2和3在第一列被链起来了；而3的三条出边2，0，1在最后一行被链起来了。</li></ul></li></ul><h3 id="邻接多重表"><a class="markdownIt-Anchor" href="#邻接多重表"></a> 邻接多重表</h3><ul><li><strong>邻接多重表的基本概念</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815131029.jpg" alt="" /><ul><li>与十字链表类似，只不过去掉了方向性（即起点与终点之分）</li></ul></li><li><strong>邻接多重表的实现模型</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815131254.jpg" alt="" /><ul><li>例如：0的两条边，3和1在第一行通过靠0来识别的指针链起来了；1的三条边，0、2和4通过以1为标识来识别的指针在第一列链起来了。</li></ul></li></ul><h2 id="图的基本运算邻接表"><a class="markdownIt-Anchor" href="#图的基本运算邻接表"></a> 图的基本运算（邻接表）</h2><h3 id="图的创建"><a class="markdownIt-Anchor" href="#图的创建"></a> 图的创建</h3><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815175445.jpg" alt="" /></p><ul><li>先给邻接表分配空间（AdjGraph）;</li><li>再让所有头结点（即储存图顶点的数组adjlist）指向第一条边结点的指针域为空；</li><li>遍历邻接矩阵中的所有元素，将存在的边，存入边结点类型中（Arcnode）,之后再将边结点以头插法的方式插入到头结点后面。</li><li>有两重循环，时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul><h3 id="图的输出"><a class="markdownIt-Anchor" href="#图的输出"></a> 图的输出</h3><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815180314.jpg" alt="" /></p><ul><li>把邻接表的头结点的编号，相邻结点，边的权重，依次打印即可。</li></ul><h3 id="图的销毁"><a class="markdownIt-Anchor" href="#图的销毁"></a> 图的销毁</h3><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815180909.jpg" alt="" /></p><ul><li>依次遍历所有头结点；</li><li>在遍历每个头结点时，遍历它身后的边结点链，并逐个释放。</li></ul><h3 id="邻接表转换为邻接矩阵"><a class="markdownIt-Anchor" href="#邻接表转换为邻接矩阵"></a> 邻接表转换为邻接矩阵</h3><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815181559.jpg" alt="" /></p><ul><li>进入头结点后的边结点链表，然后将当前扫描的边结点编号作为邻接矩阵的列标（头结点编号作为行标）,并修改当前行标列标下的邻接矩阵元素的权重值。</li><li>虽有两重循环，但实际只对所有头结点和边结点访问了一次，所以算法的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span>,n为头结点数，e为边结点数。而把邻接矩阵转化为邻接表的的算法，却对许多没有存在的边也要访问一次，所以时间复杂度要高一些。</li></ul><h2 id="图的遍历"><a class="markdownIt-Anchor" href="#图的遍历"></a> 图的遍历</h2><ul><li>图的遍历：从给定的图中的任意一个顶点开始，按照某种方法，沿着图的边访问图中所有的顶点，且每个顶点仅被访问一次。</li><li>图的遍历序列：通过图的遍历得到的顶点序列称为图的遍历序列。</li><li>图的遍历方法：<ol><li>深度优先遍历（DFS：depth-first search）</li><li>广度优先遍历(BFS: breadth-first search)</li></ol></li></ul><h3 id="深度优先遍历对无向连通图"><a class="markdownIt-Anchor" href="#深度优先遍历对无向连通图"></a> 深度优先遍历（对无向连通图）</h3><ul><li><p><strong>基本原理</strong><br />1.首先访问出发点v，并将其标记为已访问过；<br />2.然后依次从v出发搜索v的每个邻接点w。若w未曾访问过，则以w为新的出发点继续进行深度优先遍历，直至图中所有和<strong>源点v有路径相通的顶点</strong>均已被访问为止。<br />3.若此时图中仍有未访问的顶点，则另选一个尚未访问的顶点为新的源点重复上述过程，直至图中所有的顶点均已被访问为止。<br />4.注意：<strong>深度优先遍历尽可能优先往深层次进行搜索。</strong><br />5.<strong>使用一次深度优先遍历只能访问到初始点所在连通分量中的所有顶点，不可能访问到其它连通分量中的顶点</strong></p></li><li><p><strong>实现过程</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815184154.jpg" alt="" /></p><ul><li>按照访问一个顶点之后便找它的邻接点来访问的递归思路，可以一直穷尽一条通路；</li><li>一条路走完之后，便重新找一个没有被访问过的顶点，继续重复这样的访问；</li><li>直到最后所有顶点都已被访问过，便停止访问。</li></ul></li><li><p><strong>算法实现</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815183638.jpg" alt="" /></p><ul><li>设计一个<strong>全局数组</strong>，用它的下标代表顶点的编号，每次一个顶点被访问过之后，就将该数组对应的元素置为1，表示该顶点已经被访问过了；</li><li>最后退出递归时，是因为到了通路的最后一个顶点，这个顶点唯一的邻接点已经被访问过了，然后终止循环退出；但是，一旦退出递归，若这条通路上的所有顶点，都不与某个顶点向连通，那个顶点便永远无法访问到,这也是这种算法只能遍历无向连通图的原因。</li></ul></li></ul><h3 id="广度优先遍历对无向连通图"><a class="markdownIt-Anchor" href="#广度优先遍历对无向连通图"></a> 广度优先遍历（对无向连通图）</h3><ul><li><p><strong>基本原理</strong><br />1.首先访问出发点v<br />2.接着依次访问v的所有邻接点w1、w2…wt<br />3.然后依次访问w1、w2…wt邻接的所有未曾访问过的顶点。<br />4.以此类推，直至图中所有和源点v有路径相通的顶点都已访问到为止。此时从v开始的搜索过程结束。<br />5.注意：广度优先遍历按层次优先搜索最近的结点，一层一层往外搜索。深度优先是不断深挖每一个被访问了的顶点的邻接点，广度优先是先将当前顶点的所有邻接点访问完。<br />6. <strong>同深度优先遍历一样，由于每次访问的都是与当前顶点有一定关系的顶点，所以只能适用于遍历无向连通图</strong></p></li><li><p><strong>实现过程</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815191255.jpg" alt="" /></p><ul><li>先访问完当前顶点的所有未被访问过的邻接点；</li><li>到最后一个邻接点时，转向其它顶点。</li><li>直到所有顶点均已被访问，便停止访问。</li></ul></li><li><p><strong>算法实现</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815192349.jpg" alt="" /></p><ul><li>使用队列来实现广度优先遍历，并未像深度优先算法一样才用递归的方法;</li><li>设置一个标记数组（无需全局数组，因为广度优先算法直接使用队列，借用一个循环便可完成，不须递归使用函数）,来确定某个顶点是否已经被访问过了。</li><li>将第一个要访问的顶点访问后进队；</li><li>之后设置循环将队列元素出队并访问它的未被访问过的邻接点，然后将每个被访问的邻接点被访问后都进队，直到当前出队的元素的所有邻接点均已被访问完，之后再出队一个元素，重复此过程，直到队列为空。由于访问的元素与初始元素都有关系，所以这种算法只能用来遍历无向连通图。</li></ul></li></ul><h3 id="非连通图的遍历"><a class="markdownIt-Anchor" href="#非连通图的遍历"></a> 非连通图的遍历</h3><ul><li>可以通过多次调用DFS或者BFS算法，来访问多个连通分量。</li></ul><h4 id="深度优先遍历"><a class="markdownIt-Anchor" href="#深度优先遍历"></a> 深度优先遍历</h4><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815194234.jpg" alt="" /></p><ul><li>其中<code>DFS</code>算法是前面遍历无向连通图的深度优先算法；</li></ul><h4 id="广度优先遍历"><a class="markdownIt-Anchor" href="#广度优先遍历"></a> 广度优先遍历</h4><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815194402.jpg" alt="" /></p><ul><li>其中<code>BFS</code>算法是前面遍历无向连通图的广度优先算法。</li><li>此处的标记数组visted是全局数组。</li></ul><h4 id="利用遍历来判断无向图是否连通"><a class="markdownIt-Anchor" href="#利用遍历来判断无向图是否连通"></a> 利用遍历来判断无向图是否连通</h4><ul><li><strong>基本思路</strong><ul><li>使用某种遍历算法遍历该邻接表；</li><li>若一次遍历后，标记数组visited的所有元素均为1，即所有元素都已被遍历过了，则该图是连通图，反之，则不是。</li></ul></li><li><strong>算法实现</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815194938.jpg" alt="" /><ul><li>在调用依次遍历算法后，在遍历标记数组，看是否有元素为0.</li></ul></li></ul><h3 id="深度优先遍历的应用"><a class="markdownIt-Anchor" href="#深度优先遍历的应用"></a> 深度优先遍历的应用</h3><h4 id="判断某两个顶点之间是否存在简单路径深度优先"><a class="markdownIt-Anchor" href="#判断某两个顶点之间是否存在简单路径深度优先"></a> 判断某两个顶点之间是否存在简单路径（深度优先）</h4><ul><li><p><strong>基本思路</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815213644.jpg" alt="" /></p></li><li><p><strong>算法实现</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815214032.jpg" alt="" /></p></li></ul><h4 id="输出某两个顶点之间的一条简单路径深度优先"><a class="markdownIt-Anchor" href="#输出某两个顶点之间的一条简单路径深度优先"></a> 输出某两个顶点之间的一条简单路径(深度优先)</h4><ul><li><p><strong>基本思路</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815214256.jpg" alt="" /></p></li><li><p><strong>算法实现</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815214557.jpg" alt="" /></p></li></ul><h4 id="输出某两个顶点之间的全部简单路径深度优先"><a class="markdownIt-Anchor" href="#输出某两个顶点之间的全部简单路径深度优先"></a> ？？输出某两个顶点之间的全部简单路径（深度优先）</h4><ul><li><p><strong>基本思路</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815214910.jpg" alt="" /></p></li><li><p><strong>算法实现</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815215424.jpg" alt="" /></p></li></ul><h4 id="输出某个顶点的全部回路"><a class="markdownIt-Anchor" href="#输出某个顶点的全部回路"></a> ??输出某个顶点的全部回路</h4><ul><li><p><strong>基本思路</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815215915.jpg" alt="" /></p></li><li><p><strong>具体算法</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815220035.jpg" alt="" /></p></li></ul><h3 id="广度优先遍历的应用"><a class="markdownIt-Anchor" href="#广度优先遍历的应用"></a> 广度优先遍历的应用</h3><h4 id="求不带权无向连通图某两顶点之间的一条最短路径"><a class="markdownIt-Anchor" href="#求不带权无向连通图某两顶点之间的一条最短路径"></a> 求不带权无向连通图某两顶点之间的一条最短路径</h4><ul><li><strong>算法实现</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815221045.jpg" alt="" /><ul><li>为什么这样找就是最短的？</li></ul></li></ul><h2 id="生成树和最小生成树"><a class="markdownIt-Anchor" href="#生成树和最小生成树"></a> 生成树和最小生成树</h2><h3 id="生成树的定义"><a class="markdownIt-Anchor" href="#生成树的定义"></a> 生成树的定义</h3><ul><li><strong>连通图的生成树</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200816082837.jpg" alt="" /><ul><li>连通图的最小生成树含有全部n个顶点，和对应的n-1条边。</li></ul></li><li><strong>带权连通图的最小生成树</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200816083255.jpg" alt="" /><ul><li>最小生成树是针对于带权连通图而言的；</li><li>所有边权值之和最小的生成树称为该带权连通图的最小生成树。</li></ul></li><li><strong>遍历方法产生生成树</strong><ul><li>深度优先生成树：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200816083559.jpg" alt="" /></li><li>广度优先生成树：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200816083708.jpg" alt="" /></li><li><strong>一个连通图的生成树不一定是唯一的</strong></li></ul></li><li><strong>非连通图的生成森林</strong><ul><li>多次调用遍历过程。每个连通分量中的顶点集和走过的边一起构成一棵生成树。</li><li>所有连通分量的生成树组成非连通图的<strong>生成森林</strong>。</li></ul></li></ul><h3 id="最小生成树的构造算法邻接矩阵存储"><a class="markdownIt-Anchor" href="#最小生成树的构造算法邻接矩阵存储"></a> 最小生成树的构造算法（邻接矩阵存储）</h3><h4 id="普里姆prim算法"><a class="markdownIt-Anchor" href="#普里姆prim算法"></a> 普里姆（Prim）算法</h4><ul><li><strong>基本思想</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200816084857.jpg" alt="" /><ul><li>在一个集合中存储已经被访问过的顶点，然后每次在与这些被访问过的顶点相连的边中选一条权值最小的边，然后将该边的另一个未被访问的顶点加入集合中，重复这个步骤，直到所有的顶点都被加入了这个集合。</li></ul></li><li><strong>过程示例</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200816085251.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200816085325.jpg" alt="" /></li><li><strong>具体算法</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200816085705.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200816095434.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200816095547.jpg" alt="" /><ul><li>INF 即无穷大的意思，它经常取32767或者65535这样不可能会取到的值，权重为INF表示，这两个顶点不直接相连。</li><li>设置两个数组，lowcost存储与已访问过的顶点相连的边的权重,比如lowcost[j]表示j到已访问结点的边的权重。而closest存储已访问过的顶点的下标。</li><li>第一步，给两个数组赋初值，lowcost的初值就是与初始顶点与剩余顶点的所有边的权重（到自己的权重为0，到邻接的顶点的权重为实际权重，到不相邻的顶点的权重为INF）,closest的初值便为便为初始顶点。</li><li>之后，比较lowcost中元素的大小，找到最小的权重对应的顶点，记录它的编号到k中，**将lowcost[k]设为0，表示编号为k的顶点已经访问过了。</li><li>找到k顶点后，将与k元素相连的边的权重与lowcost中储存的边的权重比较，若较小，则存入lowcost中，同时将对应位置的closest设置为k;例如：若lowcost[j]&lt;g.edges[k][j],则将closest[j]设为k,因为closest与lowcost是一一对应的，lowcost和closest的下标都对应未被访问过的顶点（已经被访问过的顶点会由于lowcost[j]而被跳过）,而lowcost的值对应的是与已访问顶点之间权重较小的边的权重，closest的值对应的就是这条边另一头已经被访问过的顶点。</li><li>找k的循环循环n-1次，则将整个图的所有元素都被访问了。</li><li>每次找到一个k顶点，则将对应的边和顶点输出。（边就是closest[k]到k,顶点就是closest[k]和k)。</li></ul></li><li><strong>时间复杂度</strong><ul><li>该算法中有两重循环，外重循环n-1次，内重n+n次。所以算法的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</li></ul></li><li><strong>Prim算法的特点</strong><ul><li>适合于稠密图求最小生成树，因为每两个顶点间，不管是否存在边，都会被检查，所以如果图很稀疏，那么无用的检查就会很多。</li></ul></li></ul><h4 id="克鲁斯卡尔kruskal算法"><a class="markdownIt-Anchor" href="#克鲁斯卡尔kruskal算法"></a> 克鲁斯卡尔（Kruskal）算法</h4><ul><li><strong>基本思想</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200816103616.jpg" alt="" /><ul><li>Prim算法是以顶点为中心，依次寻找相邻的权值最小的边；而Kruskal算法是一边为中心，逐次选取权值较小的边，最后包含n-1条边便组成了最小生成树。</li><li>不过需要注意的是，一旦选取的边生成的回路，便要舍弃这条边。</li></ul></li><li><strong>算法实现</strong><ul><li>存放边的结构：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200816113957.jpg" alt="" /></li><li>具体算法：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200816114726.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200816114934.jpg" alt="" /><br />* 设置一个标识数组vset来确定一条边的两个顶点是否已经被连接为一个连通分量（一个集合中）,来防止选取的边是生成树形成回路。<br />* 用一个边数组存储所有的边，并将数组中的边按照权值递增排序。<br />* 依次选取边数组中的边（因为事先已经排好序了）,利用标识数组vest确定这条边的两个顶点不在一个连通分量中，则输出该边，并将该边的两个顶点对应的表示数组值，改为相同（都为边的起始顶点值），之后选取下一条边；否则，跳过该边，选取下一条边；<br />* 当选取成功了n-1条边时，终止程序。</li></ul></li><li><strong>Krustal算法的特点</strong><ul><li>因为是根据边来选择，所以适合于边稀疏图</li></ul></li><li><strong>Krustal算法的时间复杂度</strong><ul><li>该算法的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>e</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(elog_2e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span>,其中e为边数。</li></ul></li></ul><h2 id="最短路径"><a class="markdownIt-Anchor" href="#最短路径"></a> 最短路径</h2><h3 id="最短路径定义"><a class="markdownIt-Anchor" href="#最短路径定义"></a> 最短路径定义</h3><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200817233805.jpg" alt="" /></p><ul><li>对带权有向图而言，路径为从此顶点到目的顶点，而路径长度则为这条路径上所有边的权值之和。</li></ul><h3 id="单源最短路径问题-狄克斯特拉dijkstra算法"><a class="markdownIt-Anchor" href="#单源最短路径问题-狄克斯特拉dijkstra算法"></a> 单源最短路径问题-狄克斯特拉（Dijkstra）算法</h3><ul><li><p><strong>问题描述</strong></p><ul><li>给定一个<strong>带权有向图</strong>G与源点v，求从v到G中其他顶点的最短路径（限定各边上的<strong>权值大于或者等于0</strong>）。</li></ul></li><li><p><strong>基本原理</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200818212756.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819192549.jpg" alt="" /></p><ul><li>一步步求出每个顶点与源点的最短距离，每次求最短路径都是基于已经求出最短路径的顶点而求更远顶点的最短路径。</li></ul></li><li><p><strong>基本过程</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200818214447.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200818214607.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200818214753.jpg" alt="" /></p><ul><li>将顶点分为两个集合，一个是已经计算过最短路径的，一个没有；</li><li>每次从未被计算过的集合中寻找距离已被计算过的集合最短的顶点，加入该集合中。</li><li>最后直到所有顶点都已被计算过最短路径。</li></ul></li><li><p><strong>具体算法</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200818220136.jpg" alt="" /></p></li></ul><h3 id="多源最短路径问题-floyed算法"><a class="markdownIt-Anchor" href="#多源最短路径问题-floyed算法"></a> 多源最短路径问题-Floyed算法</h3><ul><li><strong>问题描述</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819192155.jpg" alt="" /></li><li><strong>基本原理</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819192337.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819192801.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819192903.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819193108.jpg" alt="" /></li><li><strong>基本过程</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819194244.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819194303.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819194415.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819194512.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819194656.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819194743.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819194928.jpg" alt="" /></li><li><strong>具体算法</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819195159.jpg" alt="" /></li></ul><h2 id="拓扑排序有向图"><a class="markdownIt-Anchor" href="#拓扑排序有向图"></a> 拓扑排序（有向图）</h2><h3 id="拓扑排序概念"><a class="markdownIt-Anchor" href="#拓扑排序概念"></a> 拓扑排序概念</h3><p>I</p><ul><li><strong>拓扑序列与拓扑排序</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819200318.jpg" alt="" /></li></ul><h3 id="拓扑排序操作"><a class="markdownIt-Anchor" href="#拓扑排序操作"></a> 拓扑排序操作</h3><ul><li><strong>基本过程</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819200530.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819200744.jpg" alt="" /></li><li><strong>具体算法</strong><ul><li><strong>顶点类型</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819200922.jpg" alt="" /></li><li><strong>算法</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200819211309.jpg" alt="" /></li></ul></li></ul><h2 id="aoe网与关键路径"><a class="markdownIt-Anchor" href="#aoe网与关键路径"></a> AOE网与关键路径</h2><h3 id="aoe网"><a class="markdownIt-Anchor" href="#aoe网"></a> AOE网</h3><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200820225224.jpg" alt="" /></p><h3 id="关键路径"><a class="markdownIt-Anchor" href="#关键路径"></a> 关键路径</h3><h4 id="关键路径定义"><a class="markdownIt-Anchor" href="#关键路径定义"></a> 关键路径定义</h4><pre><code>![](https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200820225342.jpg)</code></pre><h4 id="求解关键路径"><a class="markdownIt-Anchor" href="#求解关键路径"></a> 求解关键路径</h4><ul><li><strong>事件的最早开始时间和最迟开始时间</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200820225920.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200820230947.jpg" alt="" /></li><li><strong>活动的最早开始时间和最迟开始时间</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200820231244.jpg" alt="" /></li><li><strong>求关键活动</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200820231404.jpg" alt="" /></li><li><strong>示例</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200820231640.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200820231813.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200820231922.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200820232022.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200820232312.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200820232421.jpg" alt="" /></li></ul>]]></content>
      
      
      <categories>
          
          <category> 专业基础 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章 树和二叉树</title>
      <link href="//post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/index.html"/>
      <url>//post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="树和二叉树"><a class="markdownIt-Anchor" href="#树和二叉树"></a> 树和二叉树</h1><h2 id="树"><a class="markdownIt-Anchor" href="#树"></a> 树</h2><h3 id="树的定义"><a class="markdownIt-Anchor" href="#树的定义"></a> 树的定义</h3><ul><li>形式化定义：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810104420.jpg" alt="" /></li><li>递归定义：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810104558.jpg" alt="" /></li></ul><h4 id="树的逻辑表示"><a class="markdownIt-Anchor" href="#树的逻辑表示"></a> 树的逻辑表示</h4><ul><li>树形表示法：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810104658.jpg" alt="" /></li><li>文氏图表示法：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810104800.jpg" alt="" /></li><li>凹入表示法：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810104848.jpg" alt="" /></li><li>括号表示法：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810104956.jpg" alt="" /></li></ul><h4 id="树的基本术语"><a class="markdownIt-Anchor" href="#树的基本术语"></a> 树的基本术语</h4><ul><li><strong>结点的度与树的度</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810105105.jpg" alt="" /><ul><li>结点的度指的是子树的个数；</li><li>树的度是<strong>各结点度的最大值</strong></li><li><strong>m次数或者m叉树</strong>，其中的m均指的是树的度。（<strong>二叉树是被重新定义过的，它的度小于或者等于2</strong>）</li></ul></li><li><strong>分支结点与叶结点</strong>：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810105401.jpg" alt="" /></li><li><strong>路径与路径长度</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810105502.jpg" alt="" /><ul><li>路径是指<strong>两结点间的结点（包含自身）</strong>;</li><li>路径长度是指<strong>两结点路径上的分支数目，不是结点的个数</strong>。</li></ul></li><li><strong>孩子结点、双亲结点和兄弟结点</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810105732.jpg" alt="" /></li><li><strong>子孙结点和祖先结点</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810105902.jpg" alt="" /><ul><li>子孙结点与孩子结点的区别：子孙结点可以跨很多辈，而孩子结点只是比双亲低一辈；</li><li>祖先结点与双亲结点的区别：祖先结点可以跨很多辈。</li></ul></li><li><strong>结点的层次与树的高度（深度）：</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810110201.jpg" alt="" /><ul><li>与结点的度和树的度的关系类似，最大的结点的度为树的度；最大的结点的层次为树的高度（深度）。</li></ul></li><li><strong>有序树与无序树</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810110434.jpg" alt="" /></li><li><strong>森林：</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810110535.jpg" alt="" /><ul><li>森林相当于树的上级；</li><li>一棵树也同时也是森林。</li></ul></li></ul><h3 id="树的性质"><a class="markdownIt-Anchor" href="#树的性质"></a> 树的性质</h3><ol><li><strong>树中的总结点数等于所有结点的度数之和加1</strong>。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810110918.jpg" alt="" /><ul><li>每个结点的度都表示它的子结点的个数，所以每个结点的度加起来可以表示结点的个数；</li><li>但是根结点没有双亲结点，所以没有将根节点加进去，所以得在所有度之和的基础上加一表示根结点。</li></ul></li><li><strong>每层的最大结点数</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810111645.jpg" alt="" /><ul><li>相当于是从根结点递归推下来的：第1层只有一个，第二层最多有m个，第三层最多有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>∗</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">m * m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>个，第四层最多有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>m</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">m^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>个…</li></ul></li><li><strong>一棵树最多的结点数</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810112031.jpg" alt="" /><ul><li>在每层最多结点数的条件下累加起来（等比数列求和）</li></ul></li><li><strong>一颗树的最小高度</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810112321.jpg" alt="" /><ul><li>在一棵树结点数最多的情况下反解出最下高度。</li></ul></li></ol><h3 id="树的基本运算"><a class="markdownIt-Anchor" href="#树的基本运算"></a> 树的基本运算</h3><h4 id="树的基本操作"><a class="markdownIt-Anchor" href="#树的基本操作"></a> 树的基本操作</h4><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810121713.jpg" alt="" /></p><h4 id="树的基本运算-2"><a class="markdownIt-Anchor" href="#树的基本运算-2"></a> 树的基本运算</h4><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810121819.jpg" alt="" /></p><h5 id="树的遍历"><a class="markdownIt-Anchor" href="#树的遍历"></a> 树的遍历</h5><ol><li>先根遍历：若树不空，先访问根结点，然后依次先跟遍历各颗子树（递归描述）</li><li>后根遍历：若树不空，先依次后根遍历各颗子树，然后访问根结点；</li><li>层次遍历：若树不空，则自上而下，自左至右访问树中的每个结点。</li></ol><h6 id="树的先根遍历"><a class="markdownIt-Anchor" href="#树的先根遍历"></a> 树的先根遍历</h6><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810122430.jpg" alt="" /></p><ul><li>根与结点始终是相对的。最开始先到A,此时B,C,D看做三颗子树，A过后到B,此时B又做根，E,F做子树，E,F依次访问完了，才又回到A的角度，遍历A的第二颗子树C，依次递归下去。</li></ul><h6 id="树的后根遍历"><a class="markdownIt-Anchor" href="#树的后根遍历"></a> 树的后根遍历</h6><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810122913.jpg" alt="" /></p><ul><li>先找到第一个叶子结点，先从左往右访问它的兄弟结点，这个子树的兄弟结点都访问完了再回到双亲，双亲又访问它的兄弟结点，若它的兄弟结点下面还有结点，则将该结点以及它以下的结点看做一颗子树的整体，进入这颗子树后，又是从第一个叶子结点开始，层层回溯。直到最后回到根结点。</li></ul><h6 id="树的层次遍历"><a class="markdownIt-Anchor" href="#树的层次遍历"></a> 树的层次遍历</h6><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810123313.jpg" alt="" /></p><ul><li>遵从从上至下，从左至右的顺序依次遍历即可。</li></ul><h2 id="二叉树"><a class="markdownIt-Anchor" href="#二叉树"></a> 二叉树</h2><h3 id="二叉树的定义"><a class="markdownIt-Anchor" href="#二叉树的定义"></a> 二叉树的定义</h3><ul><li><p><strong>递归定义</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810123739.jpg" alt="" /></p></li><li><p><strong>二叉树的五种基本形态</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810124011.jpg" alt="" /></p><ul><li>空树和单独一个根结点都可以看做二叉树；</li><li>二叉树不须每个结点的度都为2，甚至是只要结点最大的度不超过2即可。这是二叉树与二次树的区别，二次树必须至少有一个度为2的结点（即二次树的度为2，二叉树的度小于或者等于2）</li></ul></li><li><p><strong>特殊的二叉树</strong></p><ol><li><strong>满二叉树</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810124630.jpg" alt="" /></li></ol><ul><li>性质：高度为h的满二叉树恰有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^h - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个结点（由树最多结点数的性质推导）</li></ul><ol start="2"><li><strong>完全二叉树</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810125026.jpg" alt="" /><ul><li>完全二叉树包含了满二叉树。</li><li>完全二叉树最下层的叶子结点一定先集中在左边。</li></ul></li></ol></li></ul><h3 id="二叉树的性质"><a class="markdownIt-Anchor" href="#二叉树的性质"></a> 二叉树的性质</h3><ol><li><strong>非空二叉树的叶结点数</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810154759.jpg" alt="" /><ul><li>利用度的总数与结点总数的关系推得。</li></ul></li><li><strong>非空二叉树每一层上最多的结点数</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810155328.jpg" alt="" /></li><li><strong>非空二叉树最多的结点数</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810155418.jpg" alt="" /></li><li><strong>完全二叉树的性质</strong><ol><li>度数为0的结点数为0或1：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810155628.jpg" alt="" /><ul><li>最后一行如果没有满，就必须从左至右排列叶子结点，上一层同时有两个结点都只有一个分支的情况是不可能发生的。</li></ul></li><li>根据编号判断分支结点和叶子结点<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810160129.jpg" alt="" /></li><li><strong>双亲的编号与孩子的编号之间的关系</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810160345.jpg" alt="" /></li></ol></li></ol><h3 id="二叉树的存储结构"><a class="markdownIt-Anchor" href="#二叉树的存储结构"></a> 二叉树的存储结构</h3><ol><li>顺序存储结构</li><li>链式存储结构</li></ol><h4 id="二叉树的顺序存储结构"><a class="markdownIt-Anchor" href="#二叉树的顺序存储结构"></a> 二叉树的顺序存储结构</h4><ul><li><strong>完全二叉树的顺序存储结构</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810160851.jpg" alt="" /><ul><li>利用双亲与孩子结点编号之间的关系，确定每个结点在数组中的下标，并且根据这种关系来用数组恢复二叉树的逻辑关系。</li></ul></li><li><strong>非完全二叉树的顺序存储结构</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810161304.jpg" alt="" /><ul><li>用空结点将非完全二叉树补全为完全二叉树，之后再依次标号，好使用完全二叉树双亲与孩子结点编号直接的关系表达二叉树的逻辑结构。</li></ul></li><li>**二叉树顺序存储结构的特点：<ol><li>十分适合用来存储完全二叉树；</li><li>对于一般的二叉树，特别是单分支结点较多的二叉树来说，可能会使很多空结点未被利用，造成存储空间的大量浪费。</li><li>二叉树的顺序存储结构中，找一个结点的双亲和孩子结点十分容易，只需根据下标换算即可。</li></ol></li></ul><h4 id="二叉树的链式存储结构"><a class="markdownIt-Anchor" href="#二叉树的链式存储结构"></a> 二叉树的链式存储结构</h4><ul><li><strong>结点的类型定义：</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810162118.jpg" alt="" /><ul><li>链式存储是利用递归思想来表现二叉树的逻辑结构。</li></ul></li><li><strong>链式存储结构的表现：</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810162232.jpg" alt="" /></li><li><strong>链式存储结构的空指针域</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810162232.jpg" alt="" /><ul><li>总指针域数（结点数的两倍）减去分支数（结点度数之和）</li></ul></li><li><strong>二叉树链式存储结构的特点</strong><ol><li>除了会有一些空指针域的浪费，二叉链较顺序存储结构更为节省空间；</li><li>在二叉链中，找一个结点的孩子容易（根据自己的指针域找即可）,但是找双亲就很麻烦。（可以设计指回去的指针噻。）</li></ol></li></ul><h3 id="二叉树链式的基本运算"><a class="markdownIt-Anchor" href="#二叉树链式的基本运算"></a> 二叉树（链式）的基本运算</h3><h4 id="二叉树的基本操作"><a class="markdownIt-Anchor" href="#二叉树的基本操作"></a> 二叉树的基本操作</h4><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810163035.jpg" alt="" /></p><h4 id="二叉树的遍历运算"><a class="markdownIt-Anchor" href="#二叉树的遍历运算"></a> 二叉树的遍历运算</h4><ul><li>遍历只允许每个结点仅被访问一次。</li><li>不管采用哪种方法遍历，在有选择的地方都是从左至右的。</li></ul><h5 id="先序遍历"><a class="markdownIt-Anchor" href="#先序遍历"></a> 先序遍历</h5><ul><li><p><strong>基本原理</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810172342.jpg" alt="" /></p><ul><li>每到一个结点都看作是最简单的三个结点的二叉树，贯彻递归的思想。</li></ul></li><li><p><strong>先序遍历的递归算法</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810172658.jpg" alt="" /></p><ul><li>所有遍历的前提都是树不空，所以遍历之前要判断树是否为空，这也是递归结束的条件。</li></ul></li><li><p><strong>先序遍历的非递归算法1</strong></p><ul><li>基本原理：出栈访问法<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810173151.jpg" alt="" /><ul><li>利用栈的特性。从根结点进栈后，将其出栈，出栈接受访问的同时将它的右左孩子进栈，之后再依序将左孩子出栈，并将其的右左孩子进栈，一层嵌一层，从而实现了类似递归的效应。</li></ul></li><li>具体算法：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810173631.jpg" alt="" /><br />* 注意，一切操作之前还是要先判断二叉树是否为空。<br />* 进栈的顺序是先右孩子，后左孩子，出栈时才能实现先左后右。<br />* 遍历结束的条件是栈为空。</li></ul></li><li><p><strong>先序遍历的非递归算法2</strong></p><ul><li>基本原理：进栈访问法<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810174539.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810174652.jpg" alt="" /><ul><li>注意：算法有瑕疵，在进栈的循环完之后在进入出栈的步骤前，应该增加一步取栈顶元素指针的步骤，每次出栈的是栈顶元素，不应都用一个指针来混淆。</li><li>进栈时访问了根结点，将根结点进栈，然后转向左子树，将左子树进栈访问，然后再将当前结点视为相对根结点转向其左子树依次进行下去，直到左子树被穷尽，之后出栈栈顶元素（最后进来的左结点）,转向其右子树。</li></ul></li><li>具体算法：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810180154.jpg" alt="" /><ul><li>虽说遍历的结束条件是栈为空或者p为NULL,但是实际上遍历结束时，定是栈既为空p也为NULL,但是未遍历结束到达循环底部，单独栈为空时p必不为NULL,p为NULL时栈必不为空；之所以将条件设置为或者是因为刚要进入遍历循环前，栈为空，但是p不为NULL,这样设置既能保证进入循环又能保证控制循环的结束。（改为do while循环便可减少条件但仍能进入循环）</li></ul></li></ul></li></ul><h5 id="中序遍历"><a class="markdownIt-Anchor" href="#中序遍历"></a> 中序遍历</h5><ul><li><p><strong>基本原理</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810194032.jpg" alt="" /></p><ul><li>左中右的顺序。先找到最左边的元素，访问它的左结点，此时定为空，然后访问自身，再转向右结点，之后回到这颗左子树对应的根结点，递归下去。</li></ul></li><li><p><strong>中序遍历的递归算法</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810194514.jpg" alt="" /></p></li><li><p><strong>中序遍历的非递归算法</strong></p><ul><li>基本原理：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810194847.jpg" alt="" /><ul><li>源自先序遍历的进栈访问法，只是将访问的时间改变成了出栈时。</li></ul></li><li>具体算法：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810195228.jpg" alt="" /></li></ul></li></ul><h5 id="后序遍历"><a class="markdownIt-Anchor" href="#后序遍历"></a> 后序遍历</h5><ul><li><p><strong>基本原理</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810195426.jpg" alt="" /></p><ul><li>左右后的顺序。先序，中序和后序的区别在于根结点在何时被访问，二先左后右的顺序是始终没有改变过的。</li><li>同中序遍历类似，先找到最左边的元素，访问它的左结点，此时定为空，然后转向右结点并访问，之后回到该左边的元素，访问它，然后回到这颗左子树对应的根结点，依次递归下去。</li></ul></li><li><p><strong>后序遍历的递归算法</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810195907.jpg" alt="" /></p></li><li><p><strong>后序遍历的非递归算法</strong></p><ul><li>基本原理<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810200500.jpg" alt="" /><ul><li>源自中序遍历的非递归算）,但是由于根结点必须最后访问，但是从左结点到右结点必须经过根结点，但第一次经过根结点时又不能访问它，所以需要设计一个标识来判读此时的指针指向的结点能不能被访问。</li></ul></li><li>具体算法：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810201255.jpg" alt="" /><ul><li>由于第一次经过根结点时不能直接访问，但根据中序遍历的算法每次都是进入访问栈顶元素的循环中，直接访问栈顶元素，所以使用一个r指针和flag标识，当此时根结点有右孩子时，跳过访问它的步骤，而转向它的右孩子，并将flag标识设为false表明此时已经不是在处理栈顶元素了，需要退出处理栈顶元素的循环。</li><li>在退出处理栈顶元素的循环后，将此时指针指向的右孩子结点进栈，变为新的栈顶元素，再进入处理栈顶元素的循环中，将其出栈访问，并且将r标识指向它，表明它已经被处理过了，之后继续在处理栈顶元素的循环中运行，此时根节点由于有了r指针说明它的右孩子已经被处理过了，所以能够顺利地出栈访问。</li><li>依次递归进行下去，层层出栈逐渐处理回上层结点。</li><li>这个两个标识设计得确实秒啊！！！</li><li>怪不得老师在先序遍历的第二种非递归算法和中序遍历的非递归算法中要单独注释处理栈顶元素的循环，原来是为这里做准备！</li></ul></li></ul></li></ul><h5 id="层次遍历"><a class="markdownIt-Anchor" href="#层次遍历"></a> 层次遍历</h5><ul><li><p>层次遍历：对于一颗二叉树，从根结点开始，按从上到下，从左至右的顺序访问每一个结点。</p></li><li><p><strong>基本原理：</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810222139.jpg" alt="" /></p><ul><li>利用队列先进先出的特性遍历二叉树。根结点进队，然后出队，出队时依次将它的左右孩子进队，然后左右孩子出队，同时又将它们的孩子进队，依次递归下去。</li></ul></li><li><p><strong>算法实现</strong></p><ul><li>结点定义：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810222604.jpg" alt="" /><ul><li>采用环形队列</li></ul></li><li>具体算法：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810222604.jpg" alt="" /><ul><li>队空时说明二叉树已经遍历完了。因为此时遍历倒数第二层结点时储存在队列中的的叶子结点已经全部出队了。</li></ul></li></ul></li></ul><h3 id="线索二叉树"><a class="markdownIt-Anchor" href="#线索二叉树"></a> 线索二叉树</h3><h4 id="线索二叉树的定义"><a class="markdownIt-Anchor" href="#线索二叉树的定义"></a> 线索二叉树的定义</h4><ul><li>在二叉树的链式存储结构的基础上，修改空链域为指向结点的前驱和后继结点的地址。这样指向该二叉树中的前驱和后继的指针，称为<strong>线索</strong>。（这里的前驱和后继是相对于遍历的先后顺序来说的）</li><li>创建线索的过程称为<strong>线索化</strong></li><li>生成的线索二叉树与采用的<strong>遍历方法</strong>有关，据此，线索二叉树分为三种：1. 先序线索二叉树；2.中序线索二叉树；3.后序线索二叉树。</li></ul><h5 id="线索二叉树的基本原理"><a class="markdownIt-Anchor" href="#线索二叉树的基本原理"></a> 线索二叉树的基本原理</h5><ul><li><strong>结点的设计</strong><ul><li>设计原理：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200811000127.jpg" alt="" /><ul><li>每个结点都只有两个指针域，这两个指针域是指向自己的孩子结点还是指向自己的前驱和后继结点，则需要设置标志来判断。</li></ul></li><li>结点类型定义：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200811000415.jpg" alt="" /></li></ul></li><li>线索二叉树的基本模型<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200811000712.jpg" alt="" /><ul><li>先要根据具体的遍历方法，找到每个结点的前驱和后继；</li><li>左指针域指向左孩子结点或者前驱结点，此处根据中序遍历规则，最左边最下面的结点没有前驱结点，最右边最下面的结点没有后继结点，所以设置了一个额外的头结点来做这种没有前驱或者后继的结点的“前驱和后继”。</li></ul></li></ul><h5 id="线索化二叉树"><a class="markdownIt-Anchor" href="#线索化二叉树"></a> 线索化二叉树</h5><ul><li><p><strong>线索化的过程</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200811001337.jpg" alt="" /></p><ul><li>依照某种遍历方法遍历该二叉树，在遍历的过程中，检查每个结点的指针域是否为空，并根据具体的情况，将这些空指针域指向各自的前驱或者后继结点。</li></ul></li><li><p><strong>建立中序线索二叉树的算法</strong></p><ul><li>基本原理<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200811001810.jpg" alt="" /><ul><li>在中序遍历该二叉树的同时设立两个指针，分别指向互为前驱和后继的两个结点，其中有一个一直指向当前结点，另一个指向它的前驱结点。</li></ul></li><li>具体算法：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200811003232.jpg" alt="" /><ul><li>线索化二叉树的函数有两个，一个负责修改二叉树中各个结点的指针域（Thread）,一个负责创建头结点等开始启动工作和修改最后一个结点的指针域等收尾工作。</li><li>先将头结点创建好，并将其后继结点设为头结点并修改标识符（如果这是一个空树，则将头结点的左孩子指针域指向头结点，示意这是空树）</li><li>头结点的左孩子结点设为二叉树的根结点，pre指针指向头结点，将二叉树的根结点指针传入Thread函数；</li><li>在Thread函数中，应用中序遍历的递归算法，只不过把中间访问根结点的步骤改为检查当前结点的指针域并修改的步骤；</li><li>结束Thread函数后，该二叉树除了最后一个结点的后继线索未设置好之外，其余结点的线索均已设置好；</li><li>最后结束Thread函数，再次进入CreateThread函数中时，只需再将最后一个结点的线索修改好即可。</li></ul></li></ul></li></ul><h5 id="遍历线索化二叉树"><a class="markdownIt-Anchor" href="#遍历线索化二叉树"></a> 遍历线索化二叉树</h5><ul><li><p>基本原理<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814105518.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814105614.jpg" alt="" /></p><ul><li>找到开始结点（采用不同的线索化方式而有不同，开始结点不是头结点，而是整个遍历过程中要第一个访问的结点）。</li><li>在遍历过程中要由线索指向的结点才接受访问。</li><li>最后遍历的指针指向了头结点时，则说明整颗树已经遍历完成了。</li></ul></li><li><p>具体算法：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814110007.jpg" alt="" /></p><ul><li>如果是线索就直接访问它，如果不是线索就转向它而不访问。</li></ul></li></ul><h3 id="二叉树的构造"><a class="markdownIt-Anchor" href="#二叉树的构造"></a> 二叉树的构造</h3><ul><li><p><strong>二叉树序列性质：</strong></p><ul><li>同一颗二叉树，具有唯一的先序序列，中序序列和后序序列。但不同二叉树可能具有相同的先序序列、中序序列和后序序列。<ul><li>示例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814160437.jpg" alt="" /></li></ul></li><li>通过一颗二叉树的先序、中序和后序序列可以<strong>唯一</strong>确定该二叉树。（同时有三种序列）</li><li>仅有先序、中序和后序中的<strong>一种</strong>，无法唯一构造该二叉树。</li><li><strong>任何n个不同结点的二叉树，都可有它的中序序列和先序序列唯一地确定。（或者中序序列和后序序列）。即必须有中序序列。</strong></li></ul></li><li><p><strong>由先序序列和中序序列构造二叉树</strong></p><ul><li>基本原理：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814161524.jpg" alt="" /><ul><li>通过递归的思想理解，把两种序列都看作根结点、左子树和右子树三个部分。然后同一个结点对应在两个序列的相同部分（比如说都是在根结点部分）的不同位置。</li></ul></li><li>示例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814161924.jpg" alt="" /></li><li>具体算法：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814163249.jpg" alt="" /><ul><li>先确定是否为空树（**这是确定最后递归结束的重要条件），再确定在这两种序列中的左子树，右子树和根结点的三个部分。</li><li>采用分而治之的递归思想，在每一个左右子树部分执行同样的的操作，递归下去，直到序列走尽。</li></ul></li></ul></li><li><p><strong>由后序和中序序列构造二叉树</strong></p><ul><li>基本原理：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814163402.jpg" alt="" /><ul><li>通过根结点确定序列左子树、右子树和根结点的三个部分是关键。（<strong>之所以只用先序和后序序列不能构造二叉树，就是因为这两个的根结点都位于开头或者结尾，无法通过根结点划分序列为三个部分，而单独中序序列由无法确定根结点的位置</strong>）</li></ul></li><li>示例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814163844.jpg" alt="" /><ul><li>每次放入二叉树的结点的都是相对的根结点。</li></ul></li><li>具体算法：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814164152.jpg" alt="" /><ul><li>整体是先构造根结点再构造左子树和右子树，是<strong>先序遍历</strong>的思路。</li></ul></li></ul></li></ul><h3 id="树-森林和二叉树的关系"><a class="markdownIt-Anchor" href="#树-森林和二叉树的关系"></a> 树、森林和二叉树的关系</h3><h4 id="树的存储结构"><a class="markdownIt-Anchor" href="#树的存储结构"></a> 树的存储结构</h4><h5 id="树的双亲存储结构"><a class="markdownIt-Anchor" href="#树的双亲存储结构"></a> 树的双亲存储结构</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814164629.jpg" alt="" /></p><ul><li>使用顺序存储结构来存储树的结点。</li><li>在每一个结点的数据元素之外，再加上一个记录它的双亲元素的位置的元素。（即新增一个元素存储该结点双亲的下标）。</li></ul><h5 id="树的孩子链存储结构"><a class="markdownIt-Anchor" href="#树的孩子链存储结构"></a> 树的孩子链存储结构</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814165603.jpg" alt="" /></p><ul><li>每个结点都用一个指针指向，让后每一个结点内不仅包含自身的数据，还要再设置一个指针类型的数组来记录它的孩子结点的指针。</li><li>空指针域会很多。</li></ul><h5 id="树的孩子兄弟链存储结构"><a class="markdownIt-Anchor" href="#树的孩子兄弟链存储结构"></a> 树的孩子兄弟链存储结构</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814170017.jpg" alt="" /></p><ul><li>每个结点只设置两个指针域，一个指向孩子结点（或者孩子结点构成的链）,一个指向兄弟结点。</li><li>结束的结点应该两个指针域均为空。</li></ul><h4 id="二叉树与树-森林之间的转换"><a class="markdownIt-Anchor" href="#二叉树与树-森林之间的转换"></a> 二叉树与树、森林之间的转换</h4><h5 id="树-森林转化为二叉树"><a class="markdownIt-Anchor" href="#树-森林转化为二叉树"></a> 树、森林转化为二叉树</h5><ul><li>一棵树转化为二叉树<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814170017.jpg" alt="" /><ul><li>实现步骤：<ol><li>将树的根节点直接作为二叉树的根节点</li><li>将树的根节点的<strong>第一个子节点作为根节点的左儿子，若该子节点存在兄弟节点，则将该子节点的第一个兄弟节点（方向从左往右）作为该子节点的右儿子</strong></li><li>将树中的剩余节点按照上一步的方式，依序添加到二叉树中，直到树中所有的节点都在二叉树中.</li></ol></li><li>总的来说：每个点的左儿子是它的第一个儿子，右儿子是它从左往右数的第一个兄弟。</li></ul></li><li>多棵树（森林）转化为二叉树<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814171103.jpg" alt="" /><ul><li>法一：<ol><li>把森林的每一棵树转成二叉树<ol><li>以某一棵树作为起始树，下一棵树的根结点作为右孩子连接到上一颗树的根结点。直到处理完最后一棵树。</li></ol></li></ol></li><li>法二：<ol><li>新增一个结点，把这个结点作为总的根结点，然后将所有树组成一个新的树；</li><li>按照处理一颗树的方式，把这棵树转化为二叉树；</li><li>最后删除新增的结点。</li></ol></li></ul></li></ul><h5 id="二叉树还原为森林-树"><a class="markdownIt-Anchor" href="#二叉树还原为森林-树"></a> 二叉树还原为森林、树</h5><ul><li>将一棵二叉树还原为一棵树<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814172402.jpg" alt="" /><ul><li>实现步骤：<ol><li>加线。如果某个结点存在左孩子，则将左孩子的右结点，其右结点的右孩子…也就是一直深入到没有右孩子，将这些结点与父结点连线。</li><li>去线。删除所有结点与其右孩子的连线。</li><li>调整结构，让原本某结点的右孩子与该结点处于一个水平线，则他们成为了兄弟。</li></ol></li></ul></li><li>将一棵二叉树还原为多棵树（森林）<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814172632.jpg" alt="" /><ul><li>实现步骤：<ol><li>将所有结点的右孩子与其的连线切断，从而还原出很多二叉树；</li><li>将还原出的二叉树再进一步还原为普通树。</li></ol></li></ul></li></ul><h3 id="哈夫曼树"><a class="markdownIt-Anchor" href="#哈夫曼树"></a> 哈夫曼树</h3><h4 id="哈夫曼树的定义"><a class="markdownIt-Anchor" href="#哈夫曼树的定义"></a> 哈夫曼树的定义</h4><ul><li><strong>带权路径长度</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814230259.jpg" alt="" /><ul><li>根结点到各个<strong>叶结点</strong>的路径长度与权值的乘积之和。</li></ul></li><li><strong>哈夫曼树</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814230625.jpg" alt="" /><ul><li>哈夫曼树是在叶结点权值相同情况下构造出的带权路径长度最小的二叉树。</li><li>哈夫曼树首先是二叉树；</li><li>哈夫曼树又称为最优树。</li></ul></li><li><strong>哈夫曼树的特点</strong><ol><li>没有度为1的结点.</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub><mo>+</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><msub><mi>n</mi><mn>2</mn></msub><mo>=</mo><mn>2</mn><msub><mi>n</mi><mn>0</mn></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n=n_0+n_1+n_2=2n_0-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li></ol></li></ul><h4 id="构造哈夫曼树-"><a class="markdownIt-Anchor" href="#构造哈夫曼树-"></a> 构造哈夫曼树-&gt;???</h4><ul><li><strong>基本原理</strong><ul><li>权值越大的叶结点越靠近根结点，反之，权值越小的叶结点越远离根结点。</li></ul></li><li><strong>构造哈夫曼树的过程</strong><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814232041.jpg" alt="" /></li><li><strong>构造哈夫曼树的算法</strong><ul><li>结点结构<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814232545.jpg" alt="" /></li><li>具体算法：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814233947.jpg" alt="" /><ul><li>关键在于每次剔除已经有了双亲结点的结点。</li></ul></li></ul></li></ul><h4 id="哈夫曼编码"><a class="markdownIt-Anchor" href="#哈夫曼编码"></a> 哈夫曼编码 =》？？？</h4><ul><li><p>定义<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200814235953.jpg" alt="" /></p><ul><li>哈夫曼编码是二进制的01代码</li><li>特点：权值越大的字符编码越短，反之越长。</li><li>哈夫曼编码是针对叶结点而言的。=》在一组字符中，不可能出现一个字符的哈夫曼编码是另一个字符哈夫曼编码的前缀。</li><li>哈夫曼编码又称前缀编码。</li></ul></li><li><p>哈夫曼编码的生成算法</p><ul><li>哈夫曼编码的存储结构<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815004956.jpg" alt="" /></li><li>具体算法：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200815005526.jpg" alt="" /></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 专业基础 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章 数组与广义表</title>
      <link href="//post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/index.html"/>
      <url>//post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="数组与广义表"><a class="markdownIt-Anchor" href="#数组与广义表"></a> 数组与广义表</h1><h2 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h2><h3 id="数组的定义"><a class="markdownIt-Anchor" href="#数组的定义"></a> 数组的定义</h3><ul><li><p>数组的逻辑结构</p><ul><li>一维数组：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809155005.jpg" alt="" /></li><li>多维数组：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809155216.jpg" alt="" /></li></ul></li><li><p>数组的抽象数据类型：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809155800.jpg" alt="" /></p></li><li><p>数组的基本操作：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809155900.jpg" alt="" /></p><ul><li>数组运算的关键在于找到对应元素的下标。</li></ul></li></ul><h3 id="数组的存储结构"><a class="markdownIt-Anchor" href="#数组的存储结构"></a> 数组的存储结构</h3><ul><li>顺序存储结构：数组中的所有元素存储在一块地址连续的内存单元中,使用的是顺序存储结构。（不要把数组与顺序存储结构搞混，顺序存储结构是单指与链式存储结构相对的地址连续的内存单元存储法，只是在c语言中，顺序存储结构由数组来表现）</li><li>数组类型的性质<ul><li>数据元素的数目固定；</li><li>所有数据元素具有相同的数据类型；</li><li>每个数据元素都有一个（组）唯一的下标；</li><li>数组是一种<strong>随机存储结构</strong>，数组中的元素可以随机存取。（随机存取即直接用下标存取矩阵中的元素）</li></ul></li></ul><h4 id="一维数组"><a class="markdownIt-Anchor" href="#一维数组"></a> 一维数组：</h4><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809160821.jpg" alt="" /></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mtext>与</mtext><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_i与a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">与</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之间有i-1个元素，占领了（i-1）*k个存储单元。</li></ul><h4 id="多维数组"><a class="markdownIt-Anchor" href="#多维数组"></a> 多维数组</h4><ul><li>行优先存储：以行序为主序的存储</li><li>列优先存储：以列序为主序的存储</li><li>分为这两种存储方式的原因是：虽然在我们的理解中多维数组就像矩阵一样，但实际在计算机中它是连续存储（就像一排排完的）,所以区分行列的优先度就显得很重要。</li></ul><h5 id="行优先存储"><a class="markdownIt-Anchor" href="#行优先存储"></a> 行优先存储</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809161853.jpg" alt="" /></p><ul><li>计算每一个元素前面的元素个数时，先计算前面有多少行，再计算本行前面有多少个元素。</li></ul><h6 id="三维数组的行优先存储"><a class="markdownIt-Anchor" href="#三维数组的行优先存储"></a> 三维数组的行优先存储</h6><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809163051.jpg" alt="" /></p><ul><li>三个下标之间的关系可以类比二维数组行优先存储理解：二维数组的a[i][j]中，i是行数，j是列数，在计算机中存储时，相当与每一行看做一个整体（一维数组）然后依标号的顺序存储，一行中包含很多列。三维数组的a[i][j][k]中，i是页数，j是行数，k是列数，在计算机存储中，相当于将一页看做一个整体（二维数组），然后根据标号的顺序存储，一页中包含很多行和列，单独看一页中的存储顺序便相当于又是按照二维数组的存储方式来存储的。</li><li>计算公式的理解：先计算前面有多少页<code>i -1</code>,每一页的总元素个数为行列最大数相乘；再计算本页前面有多少行<code>j -1</code>每行的元素个数即为最大的列数，最后计算本行前面有多少列<code>k - 1</code>。</li></ul><h6 id="n维数组的行优先存储"><a class="markdownIt-Anchor" href="#n维数组的行优先存储"></a> n维数组的行优先存储</h6><ul><li>第一个元素为a[1][1][1]算：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809164751.jpg" alt="" /></li><li>第一个元素不为a[1][1][1]算：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809165211.jpg" alt="" /></li></ul><h5 id="列优先存储"><a class="markdownIt-Anchor" href="#列优先存储"></a> 列优先存储</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809165539.jpg" alt="" /></p><ul><li>所有计算公式都与行优先存储的公式结构相同，顺序相反。即行优先存储从第一个下标<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">i_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>算到第n个下标<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">i_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,而列优先存储的公式都是从第n个下标算到第1个下标。</li></ul><h3 id="特殊矩阵的压缩存储"><a class="markdownIt-Anchor" href="#特殊矩阵的压缩存储"></a> 特殊矩阵的压缩存储</h3><ul><li>特殊矩阵的主要形式<ol><li>对称矩阵</li><li>上三角矩阵/下三角矩阵</li><li>对角矩阵（带状矩阵）</li></ol></li><li>特殊矩阵的共性：都是方阵，行数和列数相同。</li><li>特殊矩阵压缩存储后，由于它矩阵元素分布的规律，仍然<strong>具有随机存取</strong>的特性。</li></ul><h4 id="对称矩阵的压缩存储"><a class="markdownIt-Anchor" href="#对称矩阵的压缩存储"></a> 对称矩阵的压缩存储</h4><ul><li><p>对称矩阵定义<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809170742.jpg" alt="" /></p><ul><li>a[i][j] == a[j][i]</li></ul></li><li><p>对称矩阵的压缩存储</p><ul><li>基本思想：<ul><li>利用其关于主对角线对称的特性，只存储下三角和主对角线上的元素，以节省空间。</li><li>下三角和主对角线上的元素的特征是，行标大于或等于列标（i &gt;= j）。</li><li>用一维数组存储对称矩阵。</li></ul></li><li>压缩前后的对应关系<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809172226.jpg" alt="" /><ul><li>原矩阵有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>个元素，而压缩后储存在一维数组中的只有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n(n+1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>个元素。但是原矩阵中的所有元素都可以在这个一维数组中找到。</li><li>原矩阵第i行储存了i个元素在一维数组中，所以第i行第j列元素前有（1 + 2 + 3 + …+i-1）+ j-1个元素。这个个数，也对应着在一维数组中该元素的下标（若非c语言，要在个数后加1）。</li><li>若要找到上三角的元素，则根据对称性，只需要将行列的下标对换，代入一维数组的下标计算公式即可。</li><li>存储位置计算公式：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809173413.jpg" alt="" /></li></ul></li></ul></li></ul><h4 id="三角矩阵的压缩存储"><a class="markdownIt-Anchor" href="#三角矩阵的压缩存储"></a> 三角矩阵的压缩存储</h4><ul><li>上三角矩阵<ul><li>基本思想<ul><li>与对称矩阵类似，只是未存储的部分全部为0，需要一维数组在最后留一个位置来储存这个常数。</li></ul></li><li>压缩前后的对应关系：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809173945.jpg" alt="" /><ul><li>原矩阵第i行存入一维数组的元素个数为n-i+1个元素。</li></ul></li></ul></li><li>下三角矩阵：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809174220.jpg" alt="" /></li><li>按列优先存储压缩三角矩阵：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809174446.jpg" alt="" /><ul><li>将计算公式的行列对换即可；</li><li>注意：一维数组的<strong>初始下标是从0还是1</strong>开始。</li></ul></li></ul><h4 id="对角矩阵的压缩存储"><a class="markdownIt-Anchor" href="#对角矩阵的压缩存储"></a> 对角矩阵的压缩存储：</h4><ul><li>三对角矩阵的定义：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809174817.jpg" alt="" /></li><li>压缩的基本思想：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809180021.jpg" alt="" /><ul><li>每个元素前有多少个元素是按照每行三个元素计算：3（i-1），之后再减去第一行少的一个元素，加上本行前有多少个:j-i+1</li></ul></li><li>压缩前后的对应关系<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809175328.jpg" alt="" /><ul><li>每个元素前有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2(i-1)+j-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个元素。</li></ul></li></ul><h3 id="稀疏矩阵"><a class="markdownIt-Anchor" href="#稀疏矩阵"></a> 稀疏矩阵</h3><ul><li>稀疏矩阵的定义：一个阶数较大的矩阵中的非零元素个数相对于总元素个数十分小时，称该矩阵为稀疏矩阵。</li><li>稀疏矩阵的压缩存储：<ol><li>三元组表示法：仍然使用线性表，即顺序存储结构存储；</li><li>十字链表表示法：使用链表表示。</li></ol></li><li>稀疏矩阵与特殊矩阵不同，它的非零元素分布并没有规律，所以稀疏矩阵压缩后就<strong>丧失了随机存取</strong>的特性。</li></ul><h4 id="稀疏矩阵的三元组表示"><a class="markdownIt-Anchor" href="#稀疏矩阵的三元组表示"></a> 稀疏矩阵的三元组表示</h4><h5 id="三元组定义"><a class="markdownIt-Anchor" href="#三元组定义"></a> 三元组定义</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809181332.jpg" alt="" /></p><ul><li>其中i，j存储的是该元素在稀疏矩阵中的行标和下标（与普通矩阵不同的是，它的行标和下标是从0开始算的）,而a[i][j]存储的是该元素具体的值。</li></ul><h4 id="三元组线性表的顺序结构存储及算法"><a class="markdownIt-Anchor" href="#三元组线性表的顺序结构存储及算法"></a> 三元组线性表的顺序结构存储及算法</h4><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809181930.jpg" alt="" /></p><h5 id="创建三元组"><a class="markdownIt-Anchor" href="#创建三元组"></a> 创建三元组</h5><ul><li>基本原理<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809182315.jpg" alt="" /></li><li>算法实现：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809182537.jpg" alt="" /><ul><li>将非零元素按行序扫描到的顺序存储进顺序表中，即可实现三元组中的元素是按行序为主序排列。</li></ul></li></ul><h5 id="三元组的元素赋值"><a class="markdownIt-Anchor" href="#三元组的元素赋值"></a> 三元组的元素赋值</h5><ul><li>分为两种情况：<ul><li>只是修改非零元素的值</li><li>增加一个非零元素，即将原来矩阵中的0元素改为非零元素。</li></ul></li><li>算法实现:<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809183912.jpg" alt="" />  <pre class="line-numbers language-c" data-language="c"><code class="language-c">bool Value(TSMatrix *t, ElemType  e, int i, int j) &#x2F;&#x2F;三元组的赋值&#123;int k &#x3D; 0;if(i &gt; t.Rows || j &gt; t.Cols)    return false; &#x2F;&#x2F;坐标不合理  while(k &lt; t.Terms &amp;&amp; i &gt; t.elem[k].row)  &#x2F;&#x2F;先查找行    k++;while(k &lt; t.Terms &amp;&amp; i &#x3D;&#x3D; t.elem[k].row &amp;&amp; j &gt; t.elem[k].col) &#x2F;&#x2F;查列    k++;    if(i &#x3D;&#x3D; t.elem[k].row &amp;&amp; j &#x3D;&#x3D; t.elem[k].col) &#x2F;&#x2F;判断条件，如果存在这样的一个元素        t.elem[k].val&#x3D;e; &#x2F;&#x2F;那么把这个元素赋值给它    else &#x2F;&#x2F;如果不存在的话,此时的k在列标比预期列标大得最少的元素位置上    &#123;    for(int k1 &#x3D; t.Terms-1; k &lt; k1; k1--) &#x2F;&#x2F;先进行移位操作    &#123;        t.elem[k1+1].row&#x3D;t.elem[k1].row; &#x2F;&#x2F;行        t.elem[k1+1].col&#x3D;t.elem[k1].col; &#x2F;&#x2F;列        t.elem[k1+1].val&#x3D;t.elem[k1].val; &#x2F;&#x2F;值    &#125;        t.elem[k].row&#x3D;i; &#x2F;&#x2F;行        t.elem[k].col&#x3D;j; &#x2F;&#x2F;列        t.elem[k].val&#x3D;e; &#x2F;&#x2F;值        t.Terms++; &#x2F;&#x2F;个数加1    &#125;    return true;&#125;</code></pre><ul><li>前面的算法有严重错误，后面的算法来做参考</li><li>若能找到对应的非零元素，则直接修改；</li><li>若不能找到对应的非零元素，则将k此时位置及以后的元素后移一位，将新元素值赋给k此时所在的位置。</li></ul></li></ul><h5 id="取出指定位置元素的值"><a class="markdownIt-Anchor" href="#取出指定位置元素的值"></a> 取出指定位置元素的值</h5><ul><li>基本原理:在三元组中查找该位置，若能查到，则将该位置的元素值取出，若不能查到，则该位置的元素值应为0。不能直接根据位置取出元素（随机存取），还需经过查找的过程。（类比数组与链表的区别，数组可以直接拿出某一位置的元素值，而链表必须逐次查找）</li><li>算法实现：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809190222.jpg" alt="" /><ul><li>注意：算法有误，查找时的条件应为<code>i &gt; t.data[k].row ;j &gt; t.data[k].col</code></li><li>没有找到该位置只是对应着该位置元素为0，不是出错了。</li></ul></li></ul><h5 id="输出三元组"><a class="markdownIt-Anchor" href="#输出三元组"></a> 输出三元组</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809190609.jpg" alt="" /></p><ul><li>只是输出三元组，不是输出一个矩阵，不用管零元素。</li></ul><h5 id="矩阵转置"><a class="markdownIt-Anchor" href="#矩阵转置"></a> 矩阵转置</h5><ul><li><p>矩阵转置的定义<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809190842.jpg" alt="" /></p></li><li><p>直接转置的非高效算法<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809191544.jpg" alt="" /></p><ul><li>按照列从1到n依次查找，每一个列数都需要将整个三元组扫描一遍，设列数为n,非零元素个数为t,时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nt)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></li></ul></li><li><p>更加高效的算法：</p><ul><li>基本原理：<ul><li>通过记录每个列标号的个数，来确定在新三元组中该列标号的元素出现的位置，然后直接将元素值填入该位置即可。</li><li>设置两个数组，分别记录某列标号出现的次数，以及该列标号在新三元组中第一次出现的位置。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809200538.jpg" alt="" /><ul><li>此处列标号是从0开始算起。在第二个公式中，1 &lt;= col &lt;= t.n</li><li>position的计算就是将上一个列标号第一次出现的位置加上该列标号的数目。</li></ul></li></ul></li><li>算法实现：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809201328.jpg" alt="" /><ul><li>第一步先将矩阵的总行数与列数逆置；</li><li>之后通过遍历原三元组，确定每列的非零元的个数，通过<code>++bum[t.data[k].col]</code>来实现对每一列非零元个数的计数，着实秒啊！</li><li>第三步，利用num数组，计算出position数组的值；</li><li>最后遍历原三元数组，通过每个元素的列标号col来确认它在新三元组中的位置；</li><li>值得点赞的是，在每个列标号col对应的元素存入新三元组之后,通过<code>++position[col]</code>的操作，来确定下一个第col列非零元素的位置。</li></ul></li></ul></li></ul><h4 id="稀疏矩阵的十字链表表示"><a class="markdownIt-Anchor" href="#稀疏矩阵的十字链表表示"></a> 稀疏矩阵的十字链表表示</h4><ul><li><p>基本原理：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200810091754.jpg" alt="" /></p><ul><li>每个非零元素对应一个结点，该结点中储存该元素的行标和列标以及元素值，另外还设有两个分别向右和向下的指针域。</li><li>每行的所有结点链起来，再设置一个头结点，构成一个带头结点的单链表；</li><li>每列的所有结点链起来，在设置一个列结点，构成一个带头结点的单链表；</li><li>将所有行的头结点用一个数组储存起来，将所有列的头结点用一个数组储存起来；</li></ul></li><li><p>结点的定义</p>  <pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct OLNode&#123;int i,j;&#x2F;&#x2F;元素的行标和列标int data;&#x2F;&#x2F;元素的值struct OLNode * right,*down;&#x2F;&#x2F;两个指针域&#125;OLNode, *Olink;</code></pre></li><li><p>十字链表的定义</p>  <pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct&#123;OLink *rhead, *chead; &#x2F;&#x2F;存储行和列链表头指针的两个数组int mu, nu, tu;  &#x2F;&#x2F;矩阵的行数,列数和非零元的个数&#125;CrossList;</code></pre></li><li><p>十字链表的初始化</p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">CrossList CreateMatrix_OL(CrossList M)&#123;    int m, n, t; &#x2F;&#x2F;储存矩阵的行数和列数，以及非零元素个数    int i, j, e;    OLNode *p, *q;    printf(&quot;输入矩阵的行数、列数和非0元素个数：&quot;);    scanf(&quot;%d%d%d&quot;, &amp;m, &amp;n, &amp;t);    M.mu &#x3D; m;    M.nu &#x3D; n;    M.tu &#x3D; t;    if (!(M.rhead &#x3D; (OLink*)malloc((m + 1) * sizeof(OLink))) || !(M.chead &#x3D; (OLink*)malloc((n + 1) * sizeof(OLink)))) &#x2F;&#x2F;为头结点分配两个顺序储存空间（数组）    &#123;        printf(&quot;初始化矩阵失败&quot;);        exit(0);    &#125;    for (i &#x3D; 1; i &lt;&#x3D; m; i++)    &#123;        M.rhead[i] &#x3D; NULL;    &#125; &#x2F;&#x2F;初始化所有行的头结点    for (j &#x3D; 1; j &lt;&#x3D; n; j++)    &#123;        M.chead[j] &#x3D; NULL;    &#125; &#x2F;&#x2F;初始化所有列的头结点    for (scanf(&quot;%d%d%d&quot;, &amp;i, &amp;j, &amp;e); 0 !&#x3D; i; scanf(&quot;%d%d%d&quot;, &amp;i, &amp;j, &amp;e)) &#123;        if (!(p &#x3D; (OLNode*)malloc(sizeof(OLNode))))        &#123;            printf(&quot;初始化结点失败&quot;);            exit(0);        &#125;        p-&gt;i &#x3D; i;        p-&gt;j &#x3D; j;        p-&gt;e &#x3D; e;        &#x2F;&#x2F;链接到行的指定位置        if (NULL &#x3D;&#x3D; M.rhead[i] || M.rhead[i]-&gt;j &gt; j)        &#123;            p-&gt;right &#x3D; M.rhead[i];            M.rhead[i] &#x3D; p;        &#125; &#x2F;&#x2F;若原来那一行里第一个数据结点的列标就比新结点大或者没有数据结点，则头插法插入        else        &#123;            for (q &#x3D; M.rhead[i]; (q-&gt;right) &amp;&amp; q-&gt;right-&gt;j &lt; j; q &#x3D; q-&gt;right);            p-&gt;right &#x3D; q-&gt;right;            q-&gt;right &#x3D; p;        &#125; &#x2F;&#x2F;若第一个数据结点比新结点的列标小，则向后找比新结点列标大的，若没有就到最后一个结点，然后插入该结点后面        &#x2F;&#x2F;链接到列的指定位置        if (NULL &#x3D;&#x3D; M.chead[j] || M.chead[j]-&gt;i &gt; i)        &#123;            p-&gt;down &#x3D; M.chead[j];            M.chead[j] &#x3D; p;        &#125;        else        &#123;            for (q &#x3D; M.chead[j]; (q-&gt;down) &amp;&amp; q-&gt;down-&gt;i &lt; i; q &#x3D; q-&gt;down);            p-&gt;down &#x3D; q-&gt;down;            q-&gt;down &#x3D; p;        &#125;    &#125;    return M;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 专业基础 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章 串</title>
      <link href="//post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%B2/index.html"/>
      <url>//post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%B2/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="第四章-串"><a class="markdownIt-Anchor" href="#第四章-串"></a> 第四章 串</h1><h2 id="串的定义"><a class="markdownIt-Anchor" href="#串的定义"></a> 串的定义</h2><ul><li><p>串：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200803105608.jpg" alt="" /></p><ul><li>串也是一种线性表</li></ul></li><li><p>串相等：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200803105722.jpg" alt="" /></p><ul><li>长度相等且对应位置相等。</li><li>所有的空串相等。</li></ul></li><li><p>子串：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200803105846.jpg" alt="" /></p><ul><li>类似子集的定义。</li></ul></li><li><p>基本运算：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200803110231.jpg" alt="" /></p></li></ul><h2 id="串的存储结构"><a class="markdownIt-Anchor" href="#串的存储结构"></a> 串的存储结构</h2><ol><li>顺序串：用顺序存储结构（数组）存储，且为存储结构为定长。</li><li>堆串：用顺序存储结构存储，但存储结构的长度是根据串的长度来动态分配的。</li><li>块链串：用链式存储结构来存储。</li></ol><h3 id="串的顺序存储结构顺序串"><a class="markdownIt-Anchor" href="#串的顺序存储结构顺序串"></a> 串的顺序存储结构（顺序串）</h3><h4 id="串的顺序存储结构的定义"><a class="markdownIt-Anchor" href="#串的顺序存储结构的定义"></a> 串的顺序存储结构的定义</h4><ul><li>两种类型：<ul><li>紧缩格式</li><li>非紧缩格式<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200803110825.jpg" alt="" /></li></ul></li><li>结点定义（下面讨论的都是非紧缩）<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200803111043.jpg" alt="" /></li></ul><h4 id="串的顺序存储结构的基本运算"><a class="markdownIt-Anchor" href="#串的顺序存储结构的基本运算"></a> 串的顺序存储结构的基本运算</h4><h5 id="顺序串的插入"><a class="markdownIt-Anchor" href="#顺序串的插入"></a> 顺序串的插入</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200803112812.jpg" alt="" /></p><ul><li>先判断插入位置是否合理</li><li>之后判断能否完全插入一个串<ol><li>若两个串合起来的长度<code>s-&gt;len +t.len</code>也小于s的最大长度，则可以完全插入</li></ol><ul><li>第一步先将原串pos位置及以后的字符向后平移(即复制到后面的位置上去）；</li><li>然后将要插入的串依次赋值到pos位置及它之后空出来的位置上；</li><li>最后修改整个串的长度，即两串的长度相加。</li></ul><ol start="2"><li>若插入后只能保存t串的字符(二串相加的总长度大于最大长度，但pos位置后留的位置比t串的长度长)</li></ol><ul><li>第一步还是先将s串自pos位开始的字符向后平移，但要给t串留出足够空间，即s串能移多少算多少；</li><li>第二步将t串复制进来；</li><li>最后串的长度就是s的最大长度。</li></ul><ol start="3"><li>若插入之后只能保存t串的部分字符（即pos后的位置在不移s串元素过去的情况下，仍然比t串短）<ul><li>直接将t串复制到pos位置及以后，到最大长度为止，能复制多少算多少。</li><li>最后串的长度就是最大长度。</li></ul></li></ol></li></ul><h5 id="顺序串的删除"><a class="markdownIt-Anchor" href="#顺序串的删除"></a> 顺序串的删除</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200803112812.jpg" alt="" /></p><ul><li>先判断删除位置和个数是否合理：pos位置既不能超出边界，在加上要删除的位数之后也不能超出边界<code>pos &gt; (s-&gt;len - k)</code></li><li>先找到待删除区域外的第一个元素，然后依次向前复制，直达到达串的边界。</li><li>最后修改串的长度。</li></ul><h5 id="顺序串的比较"><a class="markdownIt-Anchor" href="#顺序串的比较"></a> 顺序串的比较</h5><ul><li>比较规则：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200804175856.jpg" alt="" /><ul><li>先不管长短，先比较共同区域内元素的大小；</li><li>若共同区域内的元素全都相同，再比较串的长短。（即可能会出现较短的串是较大串的情况）</li></ul></li><li>具体算法：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200804180356.jpg" alt="" /><ul><li>先找出共同长度（即较短串的长度）;</li><li>之后在共同长度内比较；</li><li>若共同长度内字符全部一致，则再比较长度。</li></ul></li></ul><h3 id="堆串"><a class="markdownIt-Anchor" href="#堆串"></a> 堆串</h3><h4 id="堆串的定义"><a class="markdownIt-Anchor" href="#堆串的定义"></a> 堆串的定义</h4><ul><li>为每个串动态分配空间（这个存储空间的实质是一个数组）储存该字符串的信息，然后设置一个指向该串的指针作为串名。每次对字符串进行增删操作就直接分配新的存储空间，释放原来的空间，修改空间的长度。看<a href="#%E5%A0%86%E4%B8%B2%E7%9A%84%E6%8F%92%E5%85%A5">堆串的插入</a>能够更好理解堆串的本质。</li><li>与普通的顺序串相比，堆串每次存储字符串的空间是定量(根据字符串实际的长度）再分配的,而不是直接提前规定好存储字符串的空间的长度（即数组的MaxSize）。</li><li>堆的定义<pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct&#123;  char* ch; &#x2F;&#x2F;指示串的起始地址，即为串分配一个空间，指向这个空间的指针为ch  int len; &#x2F;&#x2F;指示串的长度&#125;HString;</code></pre><ul><li>一个堆即一个堆串的一个基本单元</li></ul></li></ul><h4 id="堆串的基本操作"><a class="markdownIt-Anchor" href="#堆串的基本操作"></a> 堆串的基本操作</h4><h5 id="堆串赋值"><a class="markdownIt-Anchor" href="#堆串赋值"></a> 堆串赋值</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200808224454.jpg" alt="" /></p><ul><li>先要判断串是否<strong>不为空</strong>，如果是的话，就释放原来的空间，等待重新分配。</li><li>之后将要赋值进来的字符数组的长度计数出来，以便可以分配对应长度的空间。</li><li>分配一个长度相同的空间，然后用<code>ch</code>指针指向它;</li><li>如果要赋值进来的的字符数组是空的，则将<code>ch</code>指针置为NULL。</li></ul><h5 id="堆串的插入"><a class="markdownIt-Anchor" href="#堆串的插入"></a> 堆串的插入</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200808231126.jpg" alt="" /></p><ul><li>先分配一个长度为二串相加的存储空间；</li><li>插入操作：<ol><li>将原串pos位置之前的字符复制到新的存储空间里;</li><li>在新存储空间的pos位置开始（包含pos位置）,将带插入的串复制进去；</li><li>在之后将原串的剩余部分复制进去。</li></ol><ul><li>注意：临界点的判断条件，例如复制待插入的串是从pos位置开始的，即原来的pos位置被新的字符占领了，原来处于pos位置的字符相对的向后移。</li></ul></li><li>最后修改表示长度的len变量；释放原串的存储空间，将指示串位置的ch指针指向新分配的空间。</li><li>该基本思想还可以用来实现两串的连接。</li></ul><h5 id="堆串的复制"><a class="markdownIt-Anchor" href="#堆串的复制"></a> 堆串的复制</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200808232839.jpg" alt="" /></p><ul><li>分配新空间，顺序复制字符，修改长度变量即可。</li></ul><h5 id="堆串的判空"><a class="markdownIt-Anchor" href="#堆串的判空"></a> 堆串的判空</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200808233020.jpg" alt="" /></p><ul><li>判断长度是否为0来判读堆串是否为空；</li></ul><h5 id="堆串的比较"><a class="markdownIt-Anchor" href="#堆串的比较"></a> 堆串的比较</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200808233855.jpg" alt="" /></p><ul><li>先逐字符比较，若仍未出结果再比较长度。</li></ul><h5 id="堆串的清空"><a class="markdownIt-Anchor" href="#堆串的清空"></a> 堆串的清空</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200808234131.jpg" alt="" /></p><ul><li>先释放堆串的空间，再将指针置为NULL，长度设为0；</li></ul><h5 id="求堆串的子串"><a class="markdownIt-Anchor" href="#求堆串的子串"></a> 求堆串的子串</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200808234936.jpg" alt="" /></p><ul><li>先要判断求的子串的长度和位置是否合理；</li><li>之后再将子串复制进一个新的堆串中。</li></ul><h5 id="堆串的子串定位"><a class="markdownIt-Anchor" href="#堆串的子串定位"></a> 堆串的子串定位</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809000140.jpg" alt="" /></p><ul><li>先从两个字符串的第一个字符开始比较，若字符相等，则依次比较二者的下一个字符；</li><li>若字符不相等，则将原串的下标<strong>回溯</strong>到第一个字符的下一位，子串的下标归为0继续在比较。即相当于对应原串的每一个字符都可以生成一个子串，每个字符对应的子串都要与目标子串比较，直到找到目标子串。</li><li>比较结束的条件是目标子串已遍历完,最后返回子串第一个字符的位置（即当前下标位置i减去子串的长度j或者t.len）。</li></ul><h3 id="块链串"><a class="markdownIt-Anchor" href="#块链串"></a> 块链串</h3><ul><li>块链串即使用链表储存字符串，每一个结点存储一部分字符(类似一句话是整个字符串，而一个结点相当于一个单词)。然后使用next指针连接结点，串成一个大的字符串。</li><li>块链串结点定义：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809001808.jpg" alt="" /><ul><li>一个结点中包含一个数据域（char类型的数组）和一个指针域（指向下一结点）。</li><li>设置一个储存块链串信息的结构，其中包含该串头结点，尾结点，和长度的信息。</li><li>块链串没有设置空的头结点。</li></ul></li></ul><h2 id="串的模式匹配"><a class="markdownIt-Anchor" href="#串的模式匹配"></a> 串的模式匹配</h2><ul><li>在一个串中找到它的子串的位置称为串的模式匹配</li></ul><h3 id="brute-force蛮牛匹配算法"><a class="markdownIt-Anchor" href="#brute-force蛮牛匹配算法"></a> Brute-Force(蛮牛)匹配算法</h3><ul><li><p>简称为BF算法，又名简单匹配算法。</p></li><li><p>基本思想：穷举<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809003107.jpg" alt="" /></p></li><li><p>算法实现：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809003450.jpg" alt="" /></p><ul><li>先从两个字符串的第一个字符(若pos不为0,则原串从pos位置开始比较）开始比较，若字符相等，则依次比较二者的下一个字符；</li><li>若字符不相等，则将原串的下标<strong>回溯</strong><code>i = i - j + 1</code>到第一个字符的下一位，子串的下标归为0继续在比较。即相当于对应原串的每一个字符都可以生成一个子串，每个字符对应的子串都要与目标子串比较，直到找到目标子串。</li><li>比较结束的条件是目标子串已遍历完,最后返回子串第一个字符的位置（即当前下标位置i减去子串的长度j或者t.len）。</li></ul></li><li><p>算法分析：</p><ul><li>最好情况下的时间复杂度（即原串的第一个字符就可以找到子串）😮(m),其中m为子串的问题规模。</li><li>最坏情况下的时间复杂度：O(n x m) ,其中n为原串的问题规模。</li><li>平均的时间复杂度：O(n x m)。</li></ul></li></ul><h3 id="kmp匹配算法"><a class="markdownIt-Anchor" href="#kmp匹配算法"></a> KMP匹配算法</h3><ul><li><p>KMP是三个提出该算法的人的名字的首字母缩写。KMP算法相对于BF算法，主要消除了原串指针的回溯。</p></li><li><p>算法的思想：（i,j均采用数组的下标表示法）</p><ol><li>若子串没有重复的字符，则当扫描到j位因为字符不相等而退出一轮扫描的时候，说明原串第i位(扫描结束时，j == i)之前的字符与子串第j位之前的字符相等，又因为子串中没有相同的字符，所以子串的的首位字符与原串的前i位字符不相等，所以直接省去子串首字符与原串前i位字符相比较的步骤，跳到与原串第i位开始的字符相比较。这个过程中，<strong>j又回溯</strong>到了子串首字符，而<strong>i没有回溯</strong>直接继续向前推进。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809094650.jpg" alt="" /></li><li>若子串中有重复的字符，则若继续按照没有重复字符的方法，在原串第i位前可能与子串首字符相等的字符就会直接失去比较机会，而实际上它们是有可能与子串匹配的。故此我们先记录下子串中不同字符位置前的字符相等情况（通过创建next数组）,将每一次比较终止第j位前的字符分为三种类型：<ol><li>若j位前的字符无重复情况，则j回溯为到首字符,跳到与原串第i位后的字符继续比较（同整个子串无重复字符的情况类似）;</li><li>若第j位前的字符前缀与后缀相同（即像：abcab,或者aa,或者aba等）,则j回溯到前缀后的第一位字符，该字符与原串的第i位字符继续比较。因为前缀等于后缀，而原串与子串的这一部分字符相等，所以前缀与原串第i位前的相同长度的部分字符相等，所以可以直接跳过前缀与其的比较，直接进行前缀后的第一个字符与原串的第i个字符的比较。</li><li>若第j位前的字符中有相等的情况，但是没有出现前后缀相等的情况（即像：abcdae）,此时j回溯到子串的首字符，然后继续与原串第i位字符开始比较。因为既然子串第j位前字符没有前缀与后缀相等的情况，又有原串的第i位字符前的的字符与子串相同长的字符相等，故与字符开头的部分字符不相等，所以可以直接跳过。例如：子串为abcdaef,原串为abcdaegabcdaef,第一次比较在子串的f位置，原串的g位置停下，若担心漏掉第二次a出现的情况，子串的首字符a与原串的第二个字符a开始比较，肯定是不能匹配成功的。</li></ol></li></ol></li><li><p>next值的求法：</p><ul><li><p>思想：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809102612.jpg" alt="" /></p><ul><li>next取值的三种情况，其中其它情况对应着字符无重复，和字符没有形成相等的前后缀的情况。</li><li>next[j] = -1说明，子串的第j位之前没有任何用于加速匹配的信息（因为此时才开始扫描子串的首字符）,下一趟应从子串的开头j++ =&gt; j=0开始匹配。</li><li>next[j]的值取决于前缀的长度，因为在有前缀的情况下，next[j]代表前缀后第一个字符的下标。</li><li>示例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809111243.jpg" alt="" /></li></ul></li><li><p>求next的算法：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809104129.jpg" alt="" /></p><ul><li>j的值一直在增加（中间会有停顿，但不会回缩），而k的值则再-1，0,和其它数之间循环；</li><li>每遇到一个没有与前面的字符重复的字符，k都会回退到-1。</li><li>要想理解这个算法只有用一个字符串来走来试试（如aabaacd）,词穷了，实在难以用语言描述。。。</li></ul></li></ul></li><li><p>KMP算法实现：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809111243.jpg" alt="" /></p><ul><li>先挨个字符比较，直到遇到不同的字符终止。之后j根据next修改，i不变，再继续比较。</li><li>最后返回匹配到的子串的首字符的下标<code>i - t.len</code>,因为最后一次比较后i还再加了一次，所以直接减去子串的长度即为首字符的下标。</li></ul></li><li><p>KMP算法分析：</p><ul><li>平均时间复杂度：求next数组的时间复杂度为O(m),后面的匹配中时间复杂度为O(n)，所以总的平均时间复杂度O(n+m)。</li></ul></li><li><p>KMP算法的改进</p><ul><li>在计算出next值得同时，如果该位字符与它的next值指向的另一位字符相等，则该位的字符的nextval就指向另一位字符的nextval，如果不等，则该位字符的nextval值就是原来的next值。</li><li>解决的问题：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809113921.jpg" alt="" /></li><li>求nextval的算法<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809114109.jpg" alt="" /><ul><li>在原来的基础上增加了将nextval的值修改为与其next指向的相等的字符的nextval值。</li></ul></li><li>KMP算法的改进实现：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200809114507.jpg" alt="" /><ul><li>除了将next改为了nextval没有任何区别。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 专业基础 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Make及Makefile</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Linux/Make%E5%8F%8AMakefile/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Linux/Make%E5%8F%8AMakefile/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="make及makefile"><a class="markdownIt-Anchor" href="#make及makefile"></a> Make及Makefile</h1><h2 id="make"><a class="markdownIt-Anchor" href="#make"></a> Make</h2><ul><li>代码变成可执行文件，叫做编译（compile）；先编译这个，还是先编译那个（即编译的安排），叫做构建（build）。</li><li>Make是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上 ，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。</li><li>Make这个词，英语的意思是&quot;制作&quot;。Make命令直接用了这个意思，就是要做出某个文件。make是一个根据指定的Shell命令进行构建的工具。</li><li>make命令执行的规则，都写在一个叫做Makefile的文件中，Make命令依赖这个文件进行构建。Makefile文件也可以写为makefile， 或者用命令行参数(<code>make -f &lt;指定的文件名&gt;</code>或者<code> make --file=&lt;指定的文件名&gt;</code>)指定为其他文件名。</li></ul><h2 id="makefile"><a class="markdownIt-Anchor" href="#makefile"></a> Makefile</h2><h3 id="makefile的基本概念"><a class="markdownIt-Anchor" href="#makefile的基本概念"></a> Makefile的基本概念</h3><h4 id="makefile是什么"><a class="markdownIt-Anchor" href="#makefile是什么"></a> Makefile是什么？</h4><ul><li>Makefile 可以简单的认为是一个工程文件的<strong>编译规则</strong>，描述了整个工程的编译和链接等规则。其中包含了那些文件需要编译，那些文件不需要编译，那些文件需要先编译，那些文件需要后编译，那些文件需要重建等等。编译整个工程需要涉及到的，在 Makefile 中都可以进行描述。换句话说，Makefile 可以使得我们的项目工程的<strong>编译变得自动化</strong>，不需要每次都手动输入一堆源文件和参数。</li><li>编写Makefile的作用：<ol><li>简化输入的编译命令：在 Makefile 中，制定相应的规则和对应的链接顺序。这样只需要执行 make 命令，工程就会自动编译。每次想要编译工程的时候就执行 make ，省略掉手动编译中的参数选项和命令。</li><li>节省编译大工程的时间：Makefile 支持多线程并发操作(就像我们使用的<code>make -j8</code>)，会极大的缩短我们的编译时间，并且当我们修改了源文件之后，编译整个工程的时候，make 命令只会编译我们修改过的文件，没有修改的文件不用重新编译，也极大的解决了我们耗费时间的问题。</li></ol></li></ul><h4 id="makefile中的基本规则"><a class="markdownIt-Anchor" href="#makefile中的基本规则"></a> Makefile中的基本规则</h4><ul><li><p>Makefile 描述的是文件编译的相关规则，它的规则主要是两个部分组成，分别是<strong>依赖的关系</strong>和<strong>执行的命令</strong></p></li><li><p>Makefile文件由一系列规则（rules）构成。每条规则的形式如下:</p>  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&lt;target&gt; : &lt;prerequisites&gt; [tab]  &lt;commands&gt;</code></pre><ol><li>targets：规则的目标，可以是 Object File（一般称它为中间文件），也可以是可执行文件，还可以是一个标签</li><li>prerequisites：规则的条件，是我们的依赖文件，要生成 targets 需要的文件或者是目标。可以是多个，也可以是没有；</li><li>command：make 需要执行的命令（任意的 shell 命令）。可以有多条命令，每一条命令占一行。</li><li>注意：<strong>我们的目标和依赖文件之间要使用<em>冒号</em>分隔开，命令的开始一定要使用<em>Tab</em>键</strong></li></ol></li><li><p>Makefile文件规则概要：</p><ol><li>显式规则：<br />显式规则说明了，如何生成一个或多的的<strong>目标文件</strong>。这是由 Makefile 的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。</li><li>隐晦规则<br />由于我们的 make 命名有<strong>自动推导</strong>的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写 Makefile，这是由 make 命令所支持的。</li><li>变量的定义<br />在 Makefile 中我们要定义一系列的变量，变量一般都是字符串，这个有点像C语言中的<strong>宏</strong>，当 Makefile 被执行时，其中的变量都会被扩展到相应的引用位置上。</li><li>文件指示<br />其包括了三个部分，一个是在一个 Makefile 中<strong>引用</strong>另一个 Makefile，就像C语言中的 include 一样；另一个是指根据某些情况指定 Makefile 中的<strong>有效部分</strong>，就像C语言中的预编译 #if 一样；还有就是定义一个多行的命令。</li><li>注释<br />Makefile 中<strong>只有行注释</strong>，和 UNIX 的 Shell 脚本一样，其注释是<strong>用“#”字符</strong>，这个就像 C/C++ 中的“//”一样。如果你要在你的 Makefile 中使用“#”字符，可以用反斜框进行转义，如：<code>\#</code>。</li></ol></li></ul><h4 id="makefile的基本工作流程"><a class="markdownIt-Anchor" href="#makefile的基本工作流程"></a> Makefile的基本工作流程</h4><ul><li>当我们在执行 make 条命令的时候，make 就会去<strong>当前文件</strong>下找要执行的编译规则，也就是 Makefile 文件。我们编写 Makefile 的时可以使用的文件的名称&quot;GNUmakefile&quot; 、“makefile” 、“Makefile” ，make 执行时回去寻找 Makefile 文件，找文件的顺序也是这样的。我们推荐使用<strong>Makefile</strong>（一般在工程中都这么写，大写的会比较的规范）。如果文件不存在，make 就会给我们报错，提示：<br /><code>make：*** 没有明确目标并且找不到 makefile。停止</code></li><li>工作流程简介：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">main:main.o test1.o test2.o  gcc main.o test1.o test2.o -o mainmain.o:main.c test.h  gcc -c main.c -o main.otest1.o:test1.c test.h  gcc -c test1.c -o test1.otest2.o:test2.c test.h  gcc -c test2.c -o test2.o</code></pre><ul><li><strong>工作流程</strong>：当在 shell 提示符下输入 make 命令以后。 make 读取当前目录下的 Makefile 文件，并将 Makefile 文件中的<strong>第一个目标作为其执行的“终极目标”</strong>，开始处理第一个规则（终极目标所在的规则）。在我们的例子中，第一个规则就是目标 “main” 所在的规则。规则描述了 “main” 的<strong>依赖关系</strong>，并定义了<strong>链接 “.o” 文件生成目标 “main” 的命令</strong>；make 在执行这个规则所定义的命令之前，<strong>首先处理目标 “main” 的所有的依赖文件</strong>（例子中的那些 “.o” 文件）的更新规则（以这些 “.o” 文件为目标的规则）。</li><li>对这些 “.o” 文件为目标的<strong>规则处理</strong>有下列三种情况：<ul><li>目标 “.o” 文件<strong>不存在</strong>，使用其描述规则创建它；</li><li>目标 “.o” 文件存在，目标 “.o” 文件所<strong>依赖</strong>的 “.c” 源文件 “.h” 文件中的任何一个比目标 “.o” 文件“更新”（在上一次 make 之后被修改）。则根据规则重新编译生成它；</li><li>目标 “.o” 文件存在，目标 “.o” 文件比它的任何一个依赖文件（“.c” 源文件、“.h” 文件）“更新”（它的依赖文件在上一次 make 之后<strong>没有被修改</strong>），则什么也不做。</li></ul></li><li>我们执行 make 命令时，<strong>只有修改过的源文件或者是不存在的目标文件</strong>会进行重建，而那些没有改变的文件不用重新编译，这样在很大程度上节省时间，提高编程效率。</li><li>具体命令解析<ol><li><code>main: main.o test1.o test2.o</code>:表示最终目标文件是生成main,而main的生成依赖于main.o test1.o test2.o 这三个汇编文件。</li><li><code>gcc mian.o test1.o test2.o -o main</code>:指定了生成main所需要执行的shell命令，即将三个依赖的汇编文件链接输出为main。</li><li><code>main.o: main.c test.h</code>:表示main.o文件依赖于main.c和test.h文件，为了生成最终文件main，make会先执行能生成main的依赖文件的命令。</li><li><code>gcc -c main.c -o main.o</code>:指定了如何通过依赖文件生成main.o的shell命令，即将main.c文件编译汇编为main.o文件（注意：因为gcc会自动找到头文件及所需的链接库，所以汇编时不用加上头文件test.h，但是在<strong>描述依赖关系时还是要将test.h描述进去</strong>）</li></ol></li><li><strong>清除工作过程中的过程文件</strong>:我们在使用的时候会产生中间文件会让整个文件看起来很乱，所以在编写 Makefile 文件的时候会在末尾加上这样的规则语句：</li></ul>  <pre class="line-numbers language-none"><code class="language-none">.PHONY:cleanclean:rm -rf *.o </code></pre><p>其中 “*.o” 是执行过程中产生的中间文件，“test” 是最终生成的执行文件。(具体要删除什么文件，可以自行指定);可以在命令行中指定Makefile中的一个文件作为目标，那么这条make命令就只更新这个指定的目标(如：<code>make clean</code>，如果没有指定目标则make默认更新Makefile中的第一条规则的目标。</p><h3 id="makefile中的通配符"><a class="markdownIt-Anchor" href="#makefile中的通配符"></a> Makefile中的通配符</h3><ul><li>由于Makefile是使用shell命令的，所以shell命令中的通配符在Makefile中也是适用的。</li></ul><table><thead><tr><th>通配符</th><th>作用</th></tr></thead><tbody><tr><td><code>*</code></td><td>匹配任意个字符,如<code>*.o</code>代表在当前文件夹下所有以<code>.o</code>结尾的文件</td></tr><tr><td><code>?</code></td><td>匹配一个字符</td></tr><tr><td><code>[]</code></td><td>匹配指定的字符，指定的字符放在<code>[]</code>中，如<code>[zhangjie].o</code></td></tr><tr><td><code>~</code></td><td>类似于shell中打开目录时的<code>~</code>，后面为空或者接分隔符<code>/</code>或者接路径名或者文件名的时候，代表根目录。如<code>~/bin</code>代表<code>/home/usrname/bin</code>,<code>~zhangjie/bin</code>代表<code>/home/zhangjie/bin</code></td></tr></tbody></table><h3 id="makefile变量的定义和使用"><a class="markdownIt-Anchor" href="#makefile变量的定义和使用"></a> Makefile变量的定义和使用</h3><h4 id="变量的定义"><a class="markdownIt-Anchor" href="#变量的定义"></a> 变量的定义</h4><ul><li>变量的定义：<ul><li>变量是用来存储一个值或者使用来进行运算操作，可以用来表示多处出现而内容又可能发生变化的内容。</li><li>Makefile中的变量不像c语言中一样,没有数据类型。</li><li>变量的名称可以由字母，阿拉伯数字和下划线组成。</li><li>变量的定义语句：<code>变量 = 值列表</code>(其中值列表既可以是零项，又可以是一项或者多项),例如：<code>value = 1 2 3</code>,一个变量的定义从<code>=</code>后面的第一个非空白字符开始，包括后面所有的字符，直到注释或者换行之前结束。</li></ul></li><li>变量的调用：<ul><li>调用变量可以使用<code>$(value)</code>,<code>$&#123;value&#125;</code>.</li><li>示例：  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">OBJ &#x3D; mian.o test.o test: $(OBJ)  gcc $&#123;OBJ&#125; -o test</code></pre></li></ul></li></ul><h4 id="变量的定义方法"><a class="markdownIt-Anchor" href="#变量的定义方法"></a> 变量的定义方法</h4><ul><li>简单赋值：<code>:=</code>,编程中常见的变量赋值，只对当前语句有赋值效果,即遇到这种赋值就立即展开。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">x :&#x3D; fooy :&#x3D; $(x)bx :&#x3D; newtest:  @echo &quot;y &#x3D;&gt; $(y)&quot;  @echo &quot;x &#x3D;&gt; $(x)&quot;</code></pre><p>结果：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200829225226.jpg" alt="" /></p><ul><li>递归赋值：<code>=</code>,又叫做迟滞展开，每次使用的变量都是用的最新的定义，所以这种方式甚至能做到等式右边的式子中的变量在之后才被定义,即遇到递归赋值，会在使用整个变量时才将它展开。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">x :&#x3D; fooy &#x3D; $(x)bx :&#x3D; newtest:  @echo &quot;y &#x3D;&gt; $(y)&quot;  @echo &quot;x &#x3D;&gt; $(x)&quot;</code></pre><p>结果：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200829230330.jpg" alt="" /></p><ul><li><p>与简单赋值不同的是，递归赋值y中的x使用的是在最后赋给x的new,而不是开始就赋给x的foo(实际上递归赋值相当于最后在使用y变量的时候，才将y的赋值式代入，此时它前面已经又有了对x的新的赋值，所以最后呈现出来的是x最后的赋值,也因此把对x的第二个赋值语句改为简单赋值也是同样的输出)。</p></li><li><p>条件赋值：<code>?=</code>如果当前变量从未被赋值过，则相当于<code>=</code>;但如果当前变量已将被赋值过，则什么也不做，不会再重新赋值。</p></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">x :&#x3D; fooy :&#x3D; $(x)bx ?&#x3D; newtest:  @echo &quot;y &#x3D;&gt; $(y)&quot;  @echo &quot;x &#x3D;&gt; $(x)&quot;</code></pre><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200830190810.jpg" alt="" /></p><ul><li><p>最后给x的条件赋值实际没有任何效果。</p></li><li><p>追加赋值：<code>+=</code>,追加赋值类似于c语言中的<code>+=</code>,可理解为变量本身再在后面加上<code>+=</code>后面的值，但是不同定义得到的变量它的<code>+=</code>的理解会有不同。比如说，如果变量object使用<code>:=</code>定义的，那么<code>object += foo</code>,与<code>object := $(object) foo</code>,注意最后合成的object的两部分的变量间会自动生成一个空格。</p></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">x :&#x3D; fooy :&#x3D; $(x)bx +&#x3D; $(y)test:  @echo &quot;y &#x3D;&gt; $(y)&quot;  @echo &quot;x &#x3D;&gt; $(x)&quot;</code></pre><p>结果：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200830192748.jpg" alt="" /></p><h4 id="自动化变量"><a class="markdownIt-Anchor" href="#自动化变量"></a> 自动化变量</h4><ul><li><code>$@</code>:表示规则中的目标</li><li><code>$&lt;</code>:表示规则中的第一个条件（即第一个依赖文件）</li><li><code>$?</code>:表示规则中所有比目标新的条件，组成一个列表，以空格分隔</li><li><code>$^</code>:表示规则中的所有条件(即所有依赖文件)</li></ul><h3 id="makefile的隐含规则"><a class="markdownIt-Anchor" href="#makefile的隐含规则"></a> Makefile的隐含规则</h3><ul><li>在Makefile中有内置的隐含规则可以使我们省略对一些规则的命令的编写。</li></ul><h3 id="makefile的条件判断"><a class="markdownIt-Anchor" href="#makefile的条件判断"></a> Makefile的条件判断</h3><ul><li>在Makefile编译文件时可能会遇到需要分条件使用不同命令的情况，这时可以使用Makefile的条件编译语句。</li><li>常用条件判断的关键字：</li></ul><table><thead><tr><th>关键字</th><th>作用</th></tr></thead><tbody><tr><td>ifeq</td><td>判断参数是否相等，相等为true，不相等为false</td></tr><tr><td>ifneq</td><td>判断参数是否不相等，不相等为true，相等为false</td></tr><tr><td>ifef</td><td>判断是否有值，有值为true，无值为false</td></tr><tr><td>ifnef</td><td>判断是否无值，无值为true，有值为false</td></tr></tbody></table><h3 id="makefile的伪目标"><a class="markdownIt-Anchor" href="#makefile的伪目标"></a> Makefile的伪目标</h3><ul><li>伪目标：这个目标没有任何依赖文件，但是有命令，它最终的结果并不会生成任何目标文件，而只是执行该规则下的命令。</li><li>伪目标的创建：<code>.PHONY:变量名</code></li><li>伪目标的应用：<ul><li>执行一些没有文件产生的命令，如删除</li></ul></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.PHONY:cleanclean:  rm -rf *.o </code></pre><ul><li>一个make命令产生多可执行文件，提升make的效率。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.PHONY:allall:test1, test2, test3test1: test1.o  gcc $^ -o $@test2: test2.o  gcc $^ -o $@test3: test3.o  gcc $^ -o $@</code></pre><p>*如果只想生成一个test1文件，可以用<code>make test1</code>。</p><h3 id="makefile的基础语法"><a class="markdownIt-Anchor" href="#makefile的基础语法"></a> Makefile的基础语法</h3><h4 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h4><ul><li>Makefile类似Python，在每一行后以<code>#</code>来开始注释。</li></ul><h4 id="回声"><a class="markdownIt-Anchor" href="#回声"></a> 回声</h4><ul><li>默认情况下，make会打印它执行的命令行，这叫做“回声”。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200830213731.jpg" alt="" /></li><li>在每行命令前加上<code>@</code>符号就可以关闭回声，例如经常使用的<code>@echo</code></li></ul><h4 id="makefile中的函数"><a class="markdownIt-Anchor" href="#makefile中的函数"></a> Makefile中的函数</h4><p>Makefile中有许多<a href="https://www.gnu.org/software/make/manual/html_node/Functions.html">内置函数</a>可以调用。</p><hr /><p>参考资料：<br /><a href="http://www.ruanyifeng.com/blog/2015/02/make.html">阮一峰的博客</a><br /><a href="http://c.biancheng.net/makefile/">C语言中文网</a><br /><a href="https://www.gnu.org/software/make/">GNU make</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> C </tag>
            
            <tag> MakeFile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章 栈与队列</title>
      <link href="//post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/index.html"/>
      <url>//post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-限定性线性表-栈与队列"><a class="markdownIt-Anchor" href="#第三章-限定性线性表-栈与队列"></a> 第三章 限定性线性表-栈与队列</h1><h2 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h2><h3 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h3><ul><li>栈与队列都是特殊的线性表，是操作受限的线性表，称为限定性线性表。</li><li>特点：先进后出（FILO:first in last out）或后进先出（LIFO:last in first out）<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731163004.jpg" alt="" /><ul><li>线性表可以在任意位置插入、删除，而栈只允许在栈顶进行插入或者删除操作，故称为操作受限。</li></ul></li><li>典例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731163554.jpg" alt="" /></li><li>栈的几种基本运算<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731211109.jpg" alt="" /></li></ul><h3 id="栈的两种存储结构"><a class="markdownIt-Anchor" href="#栈的两种存储结构"></a> 栈的两种存储结构</h3><ol><li>顺序存储结构：<ol><li>优势：存取时定位很方便</li><li>劣势：顺序栈需要一个事先固定的长度，可能会存在空间浪费和不足(栈满）的情况</li></ol></li><li>链式存取结构：<ol><li>优势：栈的长度无限制</li><li>劣势：存取定位不方便，且需要每个元素都有一个指针域，增加了内存开销。</li></ol></li><li>总结：当栈的使用过程中元素数量变化范围不可定，有时很大，有时很小，那么使用链栈；反之，如果变化范围在可控范围内，则使用顺序栈。</li></ol><h3 id="栈的顺序存储结构"><a class="markdownIt-Anchor" href="#栈的顺序存储结构"></a> 栈的顺序存储结构</h3><h4 id="栈的顺序存储结构的定义"><a class="markdownIt-Anchor" href="#栈的顺序存储结构的定义"></a> 栈的顺序存储结构的定义</h4><ul><li><p>结点类型：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731211413.jpg" alt="" /></p><ul><li>用数组存储结点数据；</li><li>需要设置一个栈顶指针,但其实top的实际值不是指针，而只是栈顶元素的数组下标，初始值为-1，表示栈空。</li></ul></li><li><p>基本原理示意：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731211703.jpg" alt="" /></p><ul><li>top指针始终指向栈顶元素，且初始值为-1。</li></ul></li><li><p>顺序栈四要素：</p><ul><li>栈空条件：<code>top == -1</code></li><li>栈满条件： <code>top == StackSize - 1</code></li><li>进栈操作: <code>top++</code>,然后将元素赋给对应数组元素：<code>data[top] = e</code></li><li>退栈操作：<code>top--</code>,然后返回对应元素值。</li></ul></li></ul><h4 id="栈在顺序栈中实现的基本运算"><a class="markdownIt-Anchor" href="#栈在顺序栈中实现的基本运算"></a> 栈在顺序栈中实现的基本运算</h4><h5 id="初始化栈创建"><a class="markdownIt-Anchor" href="#初始化栈创建"></a> 初始化栈（创建）</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731212626.jpg" alt="" /></p><ul><li><code>top = -1</code>即可创建空栈；</li><li>注意栈指针与栈顶“指针”的区别。</li></ul><h5 id="判断栈是否为空"><a class="markdownIt-Anchor" href="#判断栈是否为空"></a> 判断栈是否为空</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731212955.jpg" alt="" /></p><ul><li>判空条件<code> top == -1</code></li><li>直接返回判等式的真假值即可作为栈是否为空的真假值。</li></ul><h5 id="进栈"><a class="markdownIt-Anchor" href="#进栈"></a> 进栈</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731213335.jpg" alt="" /></p><ul><li>先要判断<strong>栈是否已满</strong>;</li><li>栈顶指针<code>top++</code>,再放对应元素即可。</li></ul><h5 id="出栈"><a class="markdownIt-Anchor" href="#出栈"></a> 出栈</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731213626.jpg" alt="" /></p><ul><li>先要判断<strong>栈是否为空</strong>；</li><li>栈顶指针<code>top--</code>即可。</li><li>若单纯取栈顶元素，去掉<code>top--</code>即可，但仍要判断栈是否为空。</li><li>利用进栈顺序与出栈顺序刚好相反可以用来判断一个字符串是否是对称串。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801110904.jpg" alt="" /></li></ul><h5 id="两栈共享技术"><a class="markdownIt-Anchor" href="#两栈共享技术"></a> 两栈共享技术</h5><ul><li>适用于两个相同类型的栈。</li><li>目的是节约存储空间，特别是解决一个栈已满，而另一个栈剩余空间还很多的情况。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801111631.jpg" alt="" /><ul><li>用一个数组来储存两个栈，数组的头尾两端分别对应两个栈的栈底，增加元素则是两个top指针在向中间靠拢。</li><li>用一个小数组来存储两个栈的栈顶指针。</li></ul></li></ul><h6 id="两栈共享的初始化"><a class="markdownIt-Anchor" href="#两栈共享的初始化"></a> 两栈共享的初始化</h6><pre class="line-numbers language-c" data-language="c"><code class="language-c">void InitStack（DqStack *S）&#123;  S-&gt;top[0] &#x3D; -1;  S-&gt;top[1] &#x3D; M;&#x2F;&#x2F;数组末端再外面一格，表示该栈为空&#125;</code></pre><ul><li>注意靠近末端栈的栈顶指针是反着的。</li></ul><h6 id="两栈共享的进栈"><a class="markdownIt-Anchor" href="#两栈共享的进栈"></a> 两栈共享的进栈</h6><pre class="line-numbers language-c" data-language="c"><code class="language-c">int Push(DqStack *S, StackEkementType x, int i)&#123;  if(S-&gt;top[0] + 1 &#x3D;&#x3D; S-&gt;top[1])    return (FALSE);    switch(i)  &#123;    case 0:             S-&gt;top[0]++;            S-&gt;Stack[S-&gt;top[0]] &#x3D; x;             break;    case 1:             S-&gt;top[1]--;            S-&gt;Stack[S-&gt;top[1]] &#x3D; x;            break;    default:            return (FALSE);  &#125;  return (TRUE)&#125;</code></pre><ul><li>先要判断栈是否已满：<code>S-&gt;top[0] + 1 == S-&gt;top[1]</code>,即两个栈顶指针是否已经抵到一起，即它们之间只相差1。</li><li>还需要判断新元素是进入哪个栈；</li><li>注意两个栈的栈顶指针向前移动的方式是相反的，一个是加，一个是减。</li></ul><h6 id="两栈共享的出栈"><a class="markdownIt-Anchor" href="#两栈共享的出栈"></a> 两栈共享的出栈</h6><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801113613.jpg" alt="" /></p><ul><li>在判断好是哪个栈要出栈的基础上，还要判断该栈是否为空。</li><li>出栈只需对应栈顶指针向对应的栈底方向减一位即可。</li></ul><h3 id="栈的链式存储结构"><a class="markdownIt-Anchor" href="#栈的链式存储结构"></a> 栈的链式存储结构</h3><ul><li>使用链表存储的栈称为链栈。</li><li>基本原理：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801151614.jpg" alt="" /><ul><li>带头结点s.</li><li>栈顶为头结点后，栈底为链表链尾。</li></ul></li><li>结点定义：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801151614.jpg" alt="" /></li><li>链表4要素：<ul><li>栈空条件：<code>s-&gt;next == NULL</code></li><li>栈满条件：链栈是无限的，不会满溢。</li><li>进栈操作：头插法。</li><li>退栈操作：取出头结点后第一个结点，并释放其空间，并将头结点与下一个结点连接好。</li></ul></li></ul><h4 id="链栈的基本运算算法"><a class="markdownIt-Anchor" href="#链栈的基本运算算法"></a> 链栈的基本运算算法</h4><h5 id="初始化栈"><a class="markdownIt-Anchor" href="#初始化栈"></a> 初始化栈</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801152247.jpg" alt="" /></p><ul><li>创建头结点（为其分配空间）,并将其指针域置为NULL。</li></ul><h5 id="销毁栈"><a class="markdownIt-Anchor" href="#销毁栈"></a> 销毁栈</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801152548.jpg" alt="" /></p><ul><li>设立两个移动的指针，一个指向当前被释放的结点，一个指向其下一个结点，不断扫描下去。</li><li>最后p指针会指向栈底结点，不要忘了将其释放。</li></ul><h5 id="判断链栈是否为空"><a class="markdownIt-Anchor" href="#判断链栈是否为空"></a> 判断链栈是否为空</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801152848.jpg" alt="" /></p><ul><li>链栈为空的条件是头结点的指针域为空，即<code>s-&gt;next == NULL</code></li></ul><h5 id="进栈-2"><a class="markdownIt-Anchor" href="#进栈-2"></a> 进栈</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801153104.jpg" alt="" /></p><ul><li>每次为新结点分配空间都要判断分配是否成功。</li><li>头插法进栈</li></ul><h5 id="出栈-2"><a class="markdownIt-Anchor" href="#出栈-2"></a> 出栈</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801153346.jpg" alt="" /></p><ul><li>先要判断栈是否为空<code>p == NULL</code></li><li>然后将头结点的指针域设为当前结点的下一个结点即可</li><li>若是单纯取出元素，则仅仅去掉改指针，释放空间的一步即可。</li></ul><h3 id="栈的经典题目"><a class="markdownIt-Anchor" href="#栈的经典题目"></a> 栈的经典题目</h3><h4 id="1一种括号配对"><a class="markdownIt-Anchor" href="#1一种括号配对"></a> 1.一种括号配对</h4><ul><li>基本思路：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801163648.jpg" alt="" /><ul><li>只将左括号进栈，遇到一个右括号则出栈一个左括号与其相匹配；</li><li>成功匹配的条件是，栈为空，且所有括号已扫描完。</li></ul></li><li>算法实现：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801164213.jpg" alt="" /><ul><li>先要创建一个空链栈；</li><li>最后若一直匹配完了，还要判断栈是否为空来确定是否匹配成功。</li></ul></li></ul><h2 id="队列"><a class="markdownIt-Anchor" href="#队列"></a> 队列</h2><h3 id="定义-2"><a class="markdownIt-Anchor" href="#定义-2"></a> 定义</h3><ul><li>队列简称队，是一种运算受限的线性表；</li><li>队列只允许在一端进行插入操作，而在另一端进行删除操作。允许插入的一端称为队尾，允许删除的一端称为队头。</li><li>特点：先进先出（FIFO：first in first out）,与栈刚好想反。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801164935.jpg" alt="" /></li><li>队列的基本运算<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801165142.jpg" alt="" /></li></ul><h3 id="队列的存储结构"><a class="markdownIt-Anchor" href="#队列的存储结构"></a> 队列的存储结构</h3><ol><li>链式存储结构</li><li>不带头结点但头结点后面设置一个空结点的链队</li><li>不带头结点且头结点后直接就是第一个数据结点的链队</li><li>顺序存储结构<ol><li>单向顺序队列</li><li>环形顺序队列</li></ol></li></ol><h3 id="队列的链式存储结构"><a class="markdownIt-Anchor" href="#队列的链式存储结构"></a> 队列的链式存储结构</h3><ul><li><p>带头结点没有空结点的链队<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801223459.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801223632.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801223852.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801224539.jpg" alt="" /></p><ul><li>设置队头和队尾指针，队头指针始终指向第一个数据结点，队尾指针始终指向最后一个数据结点，队列遵循尾进头出的规则。</li><li>设置一个小数组（或者结构）来储存两个指针，其实相当于原来的头结点的升级版。</li><li>链队4要素：<ol><li>空队的条件：<code>front == rear &amp;&amp; front == NULL</code></li><li>链队是不会出现队满的情况的。</li><li>进队操作：将新结点尾插法插入队尾后</li><li>出队操作:删除第一个数据结点。</li></ol></li></ul></li><li><p>带头结点有空结点的链队<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200801224937.jpg" alt="" /></p><ul><li>链队4要素<ol><li>队空条件：<code>front == rear</code>,两个指针开始时都指向设置的第一个空结点；</li><li>不会出现队满的情况；</li><li>进队操作：尾插法；</li><li>出队操作：删除第一个非空的数据结点</li></ol></li><li>所以呢？空结点设来有啥用？<ul><li>front指针域永远不用变动，每次不管什么操作，最多改变rear指针，而front指针是永远指向那个空结点的。</li></ul></li></ul></li><li><p>不带头结点只有尾指针的循环链表队列<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802103925.jpg" alt="" /></p><ul><li>链队4要素<ol><li>队空条件：<code>rear == NULL</code></li><li>队满条件：无限。</li><li>进队操作：将新结点插入队尾；</li><li>出队操作：删除单链表首结点。</li></ol></li><li>初始化：<code>rear = NULL</code></li><li>判空：<code>rear == NULL</code></li><li>进队：(新结点为p)<ul><li>原队列为空：<code>p-&gt;next = p; rear = p</code></li><li>原队列不为空：<code> p-&gt;next = rear-&gt;next; rear-&gt;next =p; rear = p</code></li></ul></li><li>出队：<ul><li>原队中只有一个结点：<code>free(rear); rear = NULL</code></li><li>原队中有两个及以上结点：<code> q = rear-&gt;next; rear-&gt;next = q-&gt;next; free(q)</code></li></ul></li></ul></li></ul><h4 id="带头结点设空结点链队的基本运算"><a class="markdownIt-Anchor" href="#带头结点设空结点链队的基本运算"></a> 带头结点设空结点链队的基本运算</h4><h5 id="初始化队列"><a class="markdownIt-Anchor" href="#初始化队列"></a> 初始化队列</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802100748.jpg" alt="" /></p><ul><li>传进来的参数是指向新版头结点的指针；</li><li>分配一个空的数据结点的空间，让front 和rear指针都指向它，而把它的next域置为NULL。</li></ul><h5 id="清空队列"><a class="markdownIt-Anchor" href="#清空队列"></a> 清空队列</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802101350.jpg" alt="" /></p><ul><li>设置两个移动指针，一个指向当前第一个非空数据结点，另一个指向其下一结点；</li><li>每次释放掉第一个非空数据结点，然后顺序移动指针,扫描队列；</li><li>结束的条件是当前的第一个非空结点的next域为空，即<code>r != NULL</code>或<code>p-&gt;next != NULL</code></li><li>最后释放掉最后一个结点，记得将rear指针域指向空结点。</li></ul><h5 id="判断队列是否为空"><a class="markdownIt-Anchor" href="#判断队列是否为空"></a> 判断队列是否为空</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802102138.jpg" alt="" /></p><ul><li>只需判断front 和rear指针是否相等即可，因为front指针永远指向那个空结点。</li></ul><h5 id="进队"><a class="markdownIt-Anchor" href="#进队"></a> 进队</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802102621.jpg" alt="" /></p><ul><li>为新结点分配一个空间（记得看分配是否成功;</li><li>将新结点接到尾结点后，并移动rear指针。</li></ul><h5 id="出队"><a class="markdownIt-Anchor" href="#出队"></a> 出队</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802102943.jpg" alt="" /></p><ul><li>先要判断队列是否为空；</li><li>然后设置一个指针指向队头元素，以便读出队头元素的数据，以及将空结点的指针域移到队头元素的下一个结点(若没有下一结点，则自然设为了NULL)</li><li>还要注意队头元素是否同时是队尾元素，若是，则需要先将rear指针改为指向空结点,再释放该结点。</li></ul><h3 id="队列的顺序表存储结构"><a class="markdownIt-Anchor" href="#队列的顺序表存储结构"></a> 队列的顺序表存储结构</h3><ul><li>顺序队列的两种存储方式<ol><li><p>顺序队列（普通的单向队列）:</p><ol><li>劣势：假溢出问题：当我们认为队列已满不能进队时，其实数组里还有多余的空位置。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802181417.jpg" alt="" /></li></ol></li><li><p>循环队列</p></li></ol></li></ul><h4 id="1单向顺序队"><a class="markdownIt-Anchor" href="#1单向顺序队"></a> 1.单向顺序队</h4><h5 id="定义-3"><a class="markdownIt-Anchor" href="#定义-3"></a> 定义</h5><ul><li><p>结点定义<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802163228.jpg" alt="" /></p><ul><li>用数组存储；</li><li>设置指向队头和队尾的“模拟指针”,标明数组的头尾下标，以达到类似指针的指向队头和队尾的效果；</li></ul></li><li><p>基本原理：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802163647.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802163835.jpg" alt="" /></p><ul><li>rear指针始终指向队尾元素，且每次增加一个元素，rear指针加一，数组新的位置用以放新元素；</li><li>front指针始终指向队头，且front指向下是始终没有数据元素的；每当元素出队，front则加一前移一位，所以队列与栈不同，用数组表示队列，经常会出现元素在整个数组的中间的情况，前不搭头，后不着尾。</li></ul></li><li><p>单向顺序队4要素：</p><ol><li>队空条件：<code>front == rear</code></li><li>队满条件：<code>rear == StackSize - 1</code></li><li>进队操作：<code>rear++; data[rear] = e //e 为新加数据元素</code></li><li>出队操作：<code>front++;</code></li></ol></li></ul><h5 id="单向顺序队的基本运算"><a class="markdownIt-Anchor" href="#单向顺序队的基本运算"></a> 单向顺序队的基本运算</h5><h6 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h6><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802164742.jpg" alt="" /></p><ul><li>整个顺序队其实是一个结构体，这个结构体中含有一个数组和两个充当“指针”的整数（实际是记录下标）</li><li>为结构体分配好空间后，再将front和rear都置为-1，表示指向整个队列之前，此时队列为空。</li></ul><h6 id="销毁队列"><a class="markdownIt-Anchor" href="#销毁队列"></a> 销毁队列</h6><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802165107.jpg" alt="" /></p><ul><li>不用像链队一样需要将每一个结点空间释放（因为本来就只有一个结点，实际用来储存的是数组）；</li><li>只需要将front和rear都置为-1,形式上表示此队列为空即可，数组中实际留有的数据，在下一次使用队列便覆盖了，没有影响。</li></ul><h6 id="判断栈是否为空-2"><a class="markdownIt-Anchor" href="#判断栈是否为空-2"></a> 判断栈是否为空</h6><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802165537.jpg" alt="" /></p><ul><li>只需判断front和rear是否相等即可。</li></ul><h6 id="进队-2"><a class="markdownIt-Anchor" href="#进队-2"></a> 进队</h6><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802165801.jpg" alt="" /></p><ul><li>注意：先要判断队满与否；</li><li>然后rear进一位，将数据赋入对应位置即可。</li></ul><h6 id="出队-2"><a class="markdownIt-Anchor" href="#出队-2"></a> 出队</h6><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802170017.jpg" alt="" /></p><ul><li>先要判断队是否为空：<code>q-&gt;front == q-&gt;rear</code></li><li>然后将front前移一位（+1）即可。</li></ul><h4 id="2-环形队列"><a class="markdownIt-Anchor" href="#2-环形队列"></a> 2. 环形队列</h4><h5 id="定义-4"><a class="markdownIt-Anchor" href="#定义-4"></a> 定义</h5><ul><li>基本原理<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802181708.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802182023.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802182141.jpg" alt="" /><ul><li>逻辑上看成一个环形的队列，但实际用来存储的还是一个普通的数组。</li><li>利用取余计算结果的循环往复性，在逻辑上实现一个环形；</li><li>约定当rear==front的时候队列为空，可以理解为由于不断有元素出队，front不断前移，当front最终于rear相等的时候说明两者之间的元素已经全部出队列了，此时队列为空。</li><li>如果不对队满的条件加以限制，则当队列真正满的时候，rear 还是与front相等。所以约定<code>(rear + 1) % StackSize == front</code>时为队满条件，即rear还需再加一位才与front相等，也可以理解为此时由于不断有元素进队，rear在一直向前加，马上就要与front相“撞”,我们牺牲一个位置（即rear在即将与front相撞前指向的位置）来保证与队空条件的区分。</li></ul></li><li>环形队列的4要素；<ol><li>队空条件：<code>front == rear</code></li><li>队满条件：<code>(rear + 1) % StackSize == front</code></li><li>进队操作：<code>rear = (rear + 1) % StackSize</code>,若不好理解，就直接理解rear最开始小于StackSize的时候，此时取余元素没有效果，就相当于简单的加1。因为取余运算的效果就是不管rear执行过多少次加法来移动，始终都被局限于StackSize的范围内重复“绕圈”。</li><li>出队操作：<code>front = (front + 1) % StackSize </code></li></ol></li></ul><h5 id="环形队列的基本运算"><a class="markdownIt-Anchor" href="#环形队列的基本运算"></a> 环形队列的基本运算</h5><h6 id="初始化-2"><a class="markdownIt-Anchor" href="#初始化-2"></a> 初始化</h6><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802223719.jpg" alt="" /></p><ul><li>实际只要保证front与rear相等即可，为不为0并不重要。</li></ul><h6 id="入队"><a class="markdownIt-Anchor" href="#入队"></a> 入队</h6><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802223914.jpg" alt="" /></p><ul><li>先要判断队列是否已满；</li><li>之后再将rear指针前移一位。</li></ul><h6 id="出队-3"><a class="markdownIt-Anchor" href="#出队-3"></a> 出队</h6><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802224044.jpg" alt="" /></p><ul><li>先要判断队列是否为空；</li><li>之后只要将front指针向前移一位即可。</li></ul><h5 id="环形队列的简化"><a class="markdownIt-Anchor" href="#环形队列的简化"></a> 环形队列的简化</h5><ul><li><p>根据头指针和队列中的元素个数可以计算出队尾指针，因此可以将队尾指针rear去掉。</p></li><li><p>计算队列中的元素个数和指针的公式：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802224814.jpg" alt="" /></p><ul><li>公式中的取余运算时咋推出来的？</li></ul></li><li><p>结点定义：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200802225447.jpg" alt="" /></p><ul><li>去掉尾指针rear增加元素数量count</li></ul></li><li><p>无尾指针环形队列的4要素</p><ol><li>队空条件：count == 0；</li><li>队满条件：count == StackSize;</li><li>进队操作：先由count和front求出rear指针，再进行与普通环形队列同样的操作；</li><li>出队操作：同普通环形队列。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 专业基础 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCC基础</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/GCC%E5%9F%BA%E7%A1%80/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/GCC%E5%9F%BA%E7%A1%80/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="gcc基础"><a class="markdownIt-Anchor" href="#gcc基础"></a> GCC基础</h1><h2 id="gcc简介"><a class="markdownIt-Anchor" href="#gcc简介"></a> GCC简介</h2><ul><li>早期 GCC 的全拼为 GNU C Compiler，即 GUN 计划诞生的 C 语言编译器，显然最初 GCC 的定位确实只用于编译 C 语言。但经过这些年不断的迭代，GCC 的功能得到了很大的扩展，它不仅可以用来编译 C 语言程序，还可以处理 C++、Go、Objective -C 等多种编译语言编写的程序。与此同时，由于之前的 GNU C Compiler 已经无法完美诠释 GCC 的含义，所以其英文全称被重新定义为  GNU Compiler Collection，即 GNU 编译器套件。</li></ul><h2 id="gcc在linux的安装"><a class="markdownIt-Anchor" href="#gcc在linux的安装"></a> GCC在Linux的安装</h2><h3 id="查看当前gcc的版本"><a class="markdownIt-Anchor" href="#查看当前gcc的版本"></a> 查看当前GCC的版本</h3><ul><li>命令：<code>gcc --version</code>或者<code>gcc -v</code><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200728181043.jpg" alt="" /></li></ul><h3 id="快速安装gcc"><a class="markdownIt-Anchor" href="#快速安装gcc"></a> 快速安装GCC</h3><ul><li>此处以ubuntu系统的为例</li><li>命令:<code>sudo apt-get install gcc</code><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200728181521.jpg" alt="" /><ul><li>因为已经安装了所以没有安装的过程</li></ul></li><li>注：采用此方式安装的 GCC 编译器，版本通常较低。</li></ul><h3 id="编译安装gcc"><a class="markdownIt-Anchor" href="#编译安装gcc"></a> 编译安装GCC</h3><ul><li>此方式需要耗费的时间较长（几个小时），但支持安装指定版本的 GCC 编译器，并适用于大多数 Linux 发行版；同时，如果想对已安装的 GCC 编译器进行版本升级，也可以使用此方式。</li><li>编译安装 GCC 编译器需要提前到 GCC 官网下载指定版本的 GCC 源码安装包，读者可直接点击<a href="http://mirror.hust.edu.cn/gnu/gcc/">GCC源码包</a>进行下载。</li><li>安装步骤：<ol><li>找到下载好的 gcc-10.2.0.tar.gz 安装包(2020年7月23日更新），将其解压至 /usr/local/ 目录下，命令为：<code>sudo tar -xf gcc-10.1.0.tar.gz -C /usr/local</code><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200728183112.jpg" alt="" /></li><li>紧接着执行如下指令，下载安装 GCC 所需要的依赖包（如 gmp、mpfr、mpc 等）:进入/usr/local/gcc-10.2.0目录下 <code>cd /usr/local/gcc-10.2.0</code>，之后执行安装依赖包的命令 <code>  ./contrib/download_prerequisites</code><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200728183918.jpg" alt="" /></li><li>在/usr/local目录下手动创建一个目录，用于存放编译 GCC 源码包生成的文件。执行如下命令：创建目录<code>sudo mkdir gcc-build-10.2.0</code> 之后进入gcc-10.2.0目录下<code> cd gcc-10.2.0</code></li><li>通过执行如下指令，可以配置 GCC 支持编译 C 和 C++ 语言:<code> ../gcc-10.2.0/configure --enable-checking=release --enable-languages=c,c++ --disable-multilib</code><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200728184348.jpg" alt="" /></li><li>在第 4 步创建好 makefile 文件之后，接下来就可以使用 make 命令来编译 GCC 源程序:<code>sudo make </code>(此过程十分耗时，本机使用vmware虚拟机，运行内存4GB，用了8个线程<code>make -j8</code>花了35分钟)</li><li>最后在漫长的等待后不要忘了执行如下命令安装 gcc：<code>sudo make install</code>(如果此时直接执行 gcc --version，则 GCC 版本仍会显示之前安装的版本。操作系统重启之后，GCC 版本就会自行更正过来。)</li><li>注意：因为/usr/local所在目录本身需要sudo权限才能访问，所以最好在每个命令前加上sudo;如果某个命令执行不成功也可加上sudo再试一下。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200728192642.jpg" alt="" /></li></ol></li></ul><h2 id="gcc和g命令的区别"><a class="markdownIt-Anchor" href="#gcc和g命令的区别"></a> gcc和g++命令的区别</h2><ul><li>实际使用中我们更习惯使用 gcc 指令编译 C 语言程序，用 g++ 指令编译 C++ 代码。需要强调的一点是，这并不是 gcc 和 g++ 的区别，gcc 指令也可以用来编译 C++ 程序，同样 g++ 指令也可以用于编译 C 语言程序。</li><li>只要是 GCC 支持编译的程序代码，都可以使用 gcc 命令完成编译。可以这样理解，gcc 是 GCC 编译器的<strong>通用</strong>编译指令，因为根据程序文件的后缀名，gcc 指令可以自行判断出当前程序所用编程语言的类别。（gcc 指令也为用户提供了“<strong>手动指定</strong>代表编译方式”的接口，即使用 -x 选项。例如，gcc -xc xxx 表示以编译 C 语言代码的方式编译 xxx 文件；而 gcc -xc++ xxx 则表示以编译 C++ 代码的方式编译 xxx 文件。）</li><li>使用 g++ 指令，则无论目标文件的后缀名是什么，该指令都**一律按照编译 C++**代码的方式编译该文件。</li><li>如果想使用 gcc 指令来编译执行 C++ 程序，需要在使用 gcc 指令时，手动为其添加<code>-lstdc++ -shared-libgcc</code>选项，表示 gcc 在编译 C++ 程序时可以链接必要的 C++ 标准库。即g++ 指令就等同于<code>gcc -xc++ -lstdc++ -shared-libgcc</code>指令</li></ul><h2 id="指定编译标准"><a class="markdownIt-Anchor" href="#指定编译标准"></a> 指定编译标准</h2><ul><li>命令：<code>gcc/g++ -std=标准 ...</code></li><li>GCC支持的标准一览：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200729173010.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200729173106.jpg" alt="" /></li></ul><h2 id="gcc一步编译cc程序"><a class="markdownIt-Anchor" href="#gcc一步编译cc程序"></a> GCC一步编译c/c++程序</h2><ul><li>编译命令：<code>gcc xx.c  -o &lt;指定生成的文件名&gt;</code><ul><li>若编译c++ 程序换为g++即可</li><li>-o 选项后面接上想要GCC在当前目录下生成的可执行文件的文件名，若去掉-o选项则默认在当前目录下生成一个名为a.out的可执行文件</li></ul></li><li>执行命令：在当前目录下<code>./a.out(文件名)</code>，即只要在终端输入可执行的文件的全路径（绝对或相对均可）就可运行相应可执行文件。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200729180045.jpg" alt="" /></li></ul><h2 id="gcc分布编译cc程序"><a class="markdownIt-Anchor" href="#gcc分布编译cc程序"></a> GCC分布编译c/c++程序</h2><ul><li>无论是 C 还是 C++ 程序，其从源代码转变为可执行代码的过程，具体可分为 4 个过程，分别为预处理（Preprocessing）、编译（Compilation）、汇编（Assembly）和链接（Linking）。默认情况下，gcc 指令会一气呵成，直接将源代码历经这 4 个过程转变为可执行代码，且不会保留各个阶段产生的中间文件。</li><li>如果想查看这 4 个阶段各自产生的中间文件，最简单直接的方式就是对源代码进行“分步编译”，即控制 GCC 编译器逐步对源代码进行预处理、编译、汇编以及链接操作。</li></ul><h3 id="预处理"><a class="markdownIt-Anchor" href="#预处理"></a> 预处理</h3><ul><li><p>所谓预处理操作，主要是处理那些源文件和头文件中以 # 开头的命令（比如 #include、#define、#ifdef 等），并删除程序中所有的注释 // 和 /* … */。</p></li><li><p>为 gcc 指令添加 -E 选项，即可控制 GCC 编译器仅对源代码做预处理操作。</p><ul><li>默认情况下 gcc -E 指令只会将预处理操作的结果输出到屏幕上，并不会自动保存到某个文件。因此该指令往往会和 -o 选项连用，将结果导入到指令的文件中。</li><li>Linux 系统中通常用 “.i” 作为 C 语言程序预处理后所得文件的后缀名。</li><li>为 gcc 指令再添加一个 -C （大写的C）选项，阻止 GCC 删除源文件和头文件中的注释。</li></ul></li><li><p>gcc -E 常用选项</p></li></ul><table><thead><tr><th>选 项</th><th>功 能</th></tr></thead><tbody><tr><td>-D name[=definition]</td><td>在处理源文件之前，先定义宏 name。宏 name 必须是在源文件和头文件中都没有被定义过的。将该选项搭配源代码中的#ifdef name命令使用，可以实现条件式编译。如果没有指定一个替换的值（即省略 =definition），该宏被定义为值 1。</td></tr><tr><td>-U name</td><td>如果在命令行或 GCC 默认设置中定义过宏 name，则“取消”name 的定义。-D 和 -U 选项会依据在命令行中出现的先后顺序进行处理。</td></tr><tr><td>-include file</td><td>如同在源代码中添加 #include “file” 一样。</td></tr><tr><td>-iquote directory</td><td>对于以引号（#include “”）导入的头文件中，-iquote 指令可以指定该<strong>头文件的搜索路径</strong>。当 GCC 在源程序所在目录下找不到此头文件时，就会去 -iquote 指令指定的目录中查找。</td></tr><tr><td><code>-isystem dir</code> <code>-idirafter dir</code></td><td>都用于指定搜索头文件的目录，适用于以引号 “” 和 &lt;&gt; 导入的头文件。</td></tr></tbody></table><ul><li>注意：其中，对于指定 #include 搜索路径的几个选项，作用的先后顺序如下：<ul><li>对于用 #include “” 引号形式引入的头文件，首先搜索当前程序文件所在的目录，其次再前往 -iquote 选项指定的目录中查找；</li><li>前往 -I 选项指定的目录中搜索；</li><li>前往 -isystem 选项指定的目录中搜索；</li><li>前往默认的系统路径下搜索；</li><li>前往 -idirafter 选项指定的目录中搜索。</li></ul></li></ul><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200730100839.jpg" alt="" /></p><h3 id="编译"><a class="markdownIt-Anchor" href="#编译"></a> 编译</h3><ul><li>编译是整个程序构建的核心部分，也是最复杂的部分之一。所谓编译，简单理解就是将预处理得到的程序代码，经过一系列的词法分析、语法分析、语义分析以及优化，加工为当前机器支持的汇编代码。</li><li>通过给 gcc 指令添加 -S（注意是大写）选项，即可令 GCC 编译器仅将指定文件加工至编译阶段，并生成对应的汇编代码文件。</li><li>编译操作会<strong>自行新建一个文件名和指定文件相同、后缀名为 .s 的文件</strong>，并将编译的结果保存在该文件中。</li><li>如果需要的话，我们还可以为 gcc -S 指令添加 -o 选项，令 GCC 编译器将编译结果保存在我们指定的文件中。</li><li>gcc -S 指令操作的文件并非必须是经过预处理后得到的 .i 文件，-S 选项的功能是令 GCC 编译器将指定文件处理至编译阶段结束。这也就意味着，gcc -S 指令可以操作预处理后的 .i 文件，也可以操作源代码文件：<ul><li>如果操作对象为 .i 文件，则 GCC 编译器只需编译此文件；</li><li>如果操作对象为 .c 或者 .cpp 源代码文件，则 GCC 编译器会对其进行<strong>预处理和编译</strong>这 2 步操作。</li></ul></li></ul><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200730142545.jpg" alt="" /></p><h3 id="汇编"><a class="markdownIt-Anchor" href="#汇编"></a> 汇编</h3><ul><li>汇编其实就是将汇编代码转换成可以执行的机器指令。大部分汇编语句对应一条机器指令，有的汇编语句对应多条机器指令。相对于编译操作，汇编过程会简单很多，它并没有复杂的语法，也没有语义，也不需要做指令优化，只需要根据汇编语句和机器指令的对照表一一翻译即可。</li><li>通过为 gcc 指令添加 -c 选项（注意是小写字母 c），即可让 GCC 编译器将指定文件加工至汇编阶段，并生成相应的目标文件（文件名与指定的文件相同，只是改成了.o后缀）。</li><li>和 gcc -S 类似，gcc -c 选项并非只能用于加工 .s 文件。事实上，-c 选项只是令 GCC 编译器<strong>将指定文件加工至汇编阶段，但不执行链接操作</strong>。这也就意味着：<ul><li>如果指定文件为<strong>源程序文件</strong>（例如 demo.c），则 gcc -c 指令会对 demo.c 文件执行预处理、编译以及汇编这 3 步操作；</li><li>如果指定文件为刚刚经过<strong>预处理后的文件</strong>（例如 demo.i），则 gcc -c 指令对 demo.i 文件执行编译和汇编这 2 步操作；</li><li>如果指定文件为刚刚经过<strong>编译后的文件</strong>（例如 demo.s），则 gcc -c 指令只对 demo.s 文件执行汇编这 1 步操作。</li><li>如果文件已经是.o文件,则gcc -c指令不做任何操作。</li></ul></li></ul><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200730143825.jpg" alt="" /></p><h3 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h3><h4 id="执行默认链接操作"><a class="markdownIt-Anchor" href="#执行默认链接操作"></a> 执行默认链接操作</h4><ul><li>gcc 会根据所给文件的后缀名 .o，自行判断出此类文件为目标文件，仅需要进行链接操作。</li><li>命令：<code>gcc xx.o -o xx</code>,若不指定文件名，则默认输出为a.out<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731090856.jpg" alt="" /></li></ul><h4 id="手动添加链接库"><a class="markdownIt-Anchor" href="#手动添加链接库"></a> 手动添加链接库</h4><h5 id="添加标准链接库目录中的库"><a class="markdownIt-Anchor" href="#添加标准链接库目录中的库"></a> 添加标准链接库目录中的库</h5><ul><li>链接器把多个二进制的目标文件（object file）链接成一个单独的可执行文件。在链接过程中，它必须把符号（变量名、函数名等一系列标识符）用对应的数据的内存地址（变量地址、函数地址等）替代，以完成程序中多个模块的外部引用。而且，链接器也必须将程序中所用到的所有C标准库函数加入其中。对于链接器而言，链接库不过是一个具有许多目标文件的集合，它们在一个文件中以方便处理。</li><li>标准库的大部分函数通常放在文件 libc.a 中（文件名后缀.a代表“achieve”，译为“获取”），或者放在用于共享的动态链接文件 <a href="http://libc.so">libc.so</a> 中（文件名后缀.so代表“share object”，译为“共享对象”）。这些链接库一般位于 /lib/ 或 /usr/lib/。当使用 GCC 编译和链接程序时，GCC 默认会链接 libc.a 或者 <a href="http://libc.so">libc.so</a>，但是对于其他的库（例如非标准库、第三方库等），就需要手动添加。</li><li>GCC 的-l选项（小写的 L）可以让我们手动添加链接库。基本命令格式：<code>gcc xx.c -lxx</code>,前缀lib和后缀.a是标准的，xx是基本名称，GCC 会在-l选项后<strong>紧跟着</strong>的基本名称的基础上自动添加这些前缀、后缀。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731105555.jpg" alt="" /><ul><li>标准头文件 &lt;math.h&gt; 对应的数学库默认也不会被链接，如果没有手动将它添加进来，就会发生函数未定义错误。</li><li>数学库的文件名是 libm.a。前缀lib和后缀.a是标准的，m是基本名称，GCC 会在-l选项后紧跟着的基本名称的基础上自动添加这些前缀、后缀，本例中，基本名称为 m。math.c代码如下：</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;      &#x2F;* printf *&#x2F;#include &lt;math.h&gt;       &#x2F;* cos *&#x2F;#define PI 3.14159265int main ()&#123;  double param, result;  param &#x3D; 60.0;  result &#x3D; cos ( param * PI &#x2F; 180.0 );  printf (&quot;The cosine of %f degrees is %f.\n&quot;, param, result );  return 0;&#125;</code></pre><ul><li>又例如Linux的多线程程序：因为pthread的库不是linux系统的库，所以在进行编译的时候要加上-lpthread，否则编译不过。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200714212245.jpg" alt="" /></li></ul></li></ul><h5 id="添加其它目录中的库"><a class="markdownIt-Anchor" href="#添加其它目录中的库"></a> 添加其它目录中的库</h5><ul><li>通常，GCC 会自动在标准库目录中搜索文件，例如 /usr/lib，如果想链接其它目录中的库，就得特别指明。</li></ul><ol><li>法一：把链接库作为一般的目标文件，为 GCC 指定该链接库的完整路径与文件名。<ul><li>例如，如果链接库名为 libm.a，并且位于 /usr/lib 目录，那么下面的命令会让 GCC 编译 main.c，然后将 libm.a 链接到 main.o：<code>gcc main.c -o main.out /usr/lib/libm.a</code></li></ul></li><li>法二：使用-L选项，为 GCC 增加另一个搜索链接库的目录<ul><li><code> gcc main.c -o main.out -L/usr/lib -lm</code> -L后接目录，但还是要有-l选项。另外：可以使用多个-L选项，或者在一个-L选项内使用冒号分割的路径列表。</li></ul></li><li>法三：把包括所需链接库的目录加到环境变量 LIBRARYPATH 中。</li></ol><h4 id="gcc使用静态链接库和动态链接库"><a class="markdownIt-Anchor" href="#gcc使用静态链接库和动态链接库"></a> GCC使用静态链接库和动态链接库</h4><ul><li>库文件只是一个统称，代指的是一类压缩包，它们都包含有功能实用的目标文件。虽然库文件用于程序的链接阶段，但编译器提供有 2 种实现链接的方式，分别称为静态链接方式和动态链接方式，其中采用静态链接方式实现链接操作的库文件，称为静态链接库；采用动态链接方式实现链接操作的库文件，称为动态链接库。</li><li>GCC 编译器生成可执行文件时，默认情况下会<strong>优先使用动态链接库</strong>实现链接操作，除非当前系统环境中没有程序文件所需要的动态链接库，GCC 编译器才会选择相应的静态链接库。如果两种都没有（或者 GCC 编译器未找到），则链接失败。</li><li>在 Linux 发行版中，静态链接库和动态链接库通常存放在 /usr/bin 或者 /bin 目录下。</li></ul><h5 id="静态链接库"><a class="markdownIt-Anchor" href="#静态链接库"></a> 静态链接库</h5><ul><li>静态链接库实现链接操作的方式很简单，即程序文件中哪里用到了库文件中的功能模块，GCC 编译器就会将该模板代码<strong>直接复制</strong>到程序文件的适当位置，最终生成可执行文件。</li><li>静态链接库的优劣：<ul><li>优势是，生成的可执行文件不再需要任何静态库文件的支持就可以独立运行（可移植性强）。</li><li>劣势是，如果程序文件中多次调用库中的同一功能模块，则该模块代码势必就会被复制多次，生成的可执行文件中会包含多段完全相同的代码，造成<strong>代码的冗余</strong>。和使用动态链接库生成的可执行文件相比，静态链接库生成的可执行文件的体积更大。</li></ul></li><li>静态链接库的后缀名：在 Linux 发行版系统中，静态链接库文件的后缀名通常用 .a 表示；在 Windows 系统中，静态链接库文件的后缀名为 .lib。</li></ul><h5 id="动态链接库"><a class="markdownIt-Anchor" href="#动态链接库"></a> 动态链接库</h5><ul><li>动态链接库，又称为共享链接库。和静态链接库不同，采用动态链接库实现链接操作时，程序文件中哪里需要库文件的功能模块，GCC 编译器不会直接将该功能模块的代码拷贝到文件中，而是将功能模块的<strong>位置信息</strong>记录到文件中，直接生成可执行文件。显然，这样生成的可执行文件是<strong>无法独立运行</strong>的。采用动态链接库生成的可执行文件运行时，GCC 编译器会将对应的动态链接库一同加载在内存中，由于可执行文件中事先记录了所需功能模块的位置信息，所以<strong>在现有动态链接库的支持下</strong>，也可以成功运行。</li><li>动态链接库的优劣：<ul><li>优势是，由于可执行文件中记录的是功能模块的地址，真正的实现代码会在程序运行时被载入内存，这意味着，即便功能模块被<strong>调用多次</strong>，使用的都是同一份实现代码（这也是将动态链接库称为共享链接库的原因）。和使用静态链接库生成的可执行文件相比，动态链接库生成的可执行文件的体积更小，因为其内部不会被复制一堆冗余的代码。</li><li>劣势是，此方式生成的可执行文件无法独立运行，必须借助相应的库文件（可移植性差）。</li></ul></li><li>动态链接库的后缀名:在 Linux 发行版系统中，动态链接库的后缀名通常用 .so 表示；在 Windows 系统中，动态链接库的后缀名为 .dll(经常看见.dll文件，搞了半天原来是你）。</li></ul><h4 id="gcc创建链接库"><a class="markdownIt-Anchor" href="#gcc创建链接库"></a> GCC创建链接库</h4><ul><li>仅希望别人使用我们实现的功能，但又不想它看到具体实现的源码，就可以使用创建链接库的办法。</li></ul><h5 id="gcc创建静态链接库"><a class="markdownIt-Anchor" href="#gcc创建静态链接库"></a> GCC创建静态链接库</h5><ul><li>并非任何一个源文件都可以被加工成静态链接库，其至少需要满足以下 2 个条件：<ul><li>源文件中只提供可以重复使用的代码，例如函数、设计好的类等，<strong>不能包含 main 主函数</strong>；</li><li>源文件在实现具备模块功能的同时，还要提供访问它的接口，也就是包含各个功能模块声明部分的<strong>头文件</strong>。</li></ul></li><li>将源文件打包为静态链接库的过程很简单，只需经历以下 2 个步骤:<ol><li>将所有指定的源文件，都编译成相应的目标文件;</li><li>然后使用 ar 压缩指令，将生成的目标文件打包成静态链接库，其基本格式如下：<br /><code>ar rcs 静态链接库名称 目标文件1 目标文件2 ... </code></li></ol></li><li>静态链接库命名规则：<code>libxxx.a</code><ul><li>Linux 系统下，静态链接库的后缀名为 .a；Windows 系统下，静态链接库的后缀名为 .lib。</li><li>其中，xxx 代指我们为该库起的名字，比如 Linux 系统自带的一些静态链接库名称为 libc.a、libgcc.a、libm.a，它们的名称分别为 c、gcc 和 m。</li></ul></li><li>静态链接库的使用很简单，就是在程序的链接阶段，将静态链接库和其他目标文件一起执行链接操作，从而生成可执行文件。<code>gcc -static 目标文件 链接库名</code>,其中，-static 选项强制 GCC 编译器使用静态链接库。</li></ul><h5 id="gcc创建动态链接库"><a class="markdownIt-Anchor" href="#gcc创建动态链接库"></a> GCC创建动态链接库</h5><ul><li><p>法一：</p><ul><li>直接使用源文件创建动态链接库，采用 gcc 命令实现的基本格式如下：<code>gcc -fpic -shared 源文件名... -o 动态链接库名</code>,其中，-shared 选项用于生成动态链接库；-fpic（还可写成 -fPIC）选项的功能是，令 GCC 编译器生成动态链接库（多个目标文件的压缩包）时，表示各目标文件中函数、类等功能模块的地址使用相对地址，而非绝对地址。这样，无论将来链接库被加载到内存的什么位置，都可以正常使用。</li></ul></li><li><p>法二：</p><ul><li>先使用 gcc -c 指令将指定源文件编译为目标文件。</li><li>注意，为了后续生成动态链接库并能正常使用，将源文件编译为目标文件时，也需要使用 -fpic 选项。</li><li>在此基础上，接下来利用上一步生成的目标文件，生成动态链接库：<code>gcc -shared 目标文件名1 目标文件名2 ... 动态链接库名</code></li></ul></li><li><p>动态链接库的使用场景就是和项目中其它源文件或目标文件一起参与链接。</p><ul><li>命令：<code>gcc 源文件名 动态链接库名</code></li><li>运行由动态链接库生成的可执行文件时，必须确保程序在运行时可以找到这个动态链接库。常用的解决方案有如下几种：</li><li>将链接库文件移动到标准库目录下（例如 /usr/lib、/usr/lib64、/lib、/lib64）；</li><li>在终端输入<code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:xxx</code>，其中 xxx 为动态链接库文件的绝对存储路径（此方式仅在当前终端有效，关闭终端后无效）；</li><li>修改~/.bashrc 或~/.bash_profile 文件，即在文件最后一行添加<code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:xxx</code>（xxx 为动态库文件的绝对存储路径）。保存之后，执行source .bashrc指令（此方式仅对当前登陆用户有效）。</li></ul></li></ul><h2 id="gcc指令一次处理多个文件"><a class="markdownIt-Anchor" href="#gcc指令一次处理多个文件"></a> gcc指令一次处理多个文件</h2><ul><li><p>以下这些操作都可以共用一条 gcc 指令：</p><ul><li>将多个 C（C++）源文件加工为汇编文件或者目标文件；</li><li>将多个 C（C++）源文件或者预处理文件加工为汇编文件或者目标文件；</li><li>将多个 C（C++）源文件、预处理文件或者汇编文件加工为目标文件；</li><li>同一项目中，不同的源文件、预处理文件、汇编文件以及目标文件，可以使用一条 gcc 指令，最终生成一个可执行文件。</li></ul></li><li><p>处理多个文件的三种方法：</p><ul><li>法一：先单独编译各个源文件，再将它们链接起来。</li><li>法二：同时编译多个源文件，再将它们链接起来；</li><li>法三：同时直接一步编译多个源文件生成一个可执行文件。</li></ul></li><li><p>进入该项目目录，用 *.c 表示所有的源文件，即执行如下指令 <code>gcc *.c -o a.out</code>可同时编译该目录下所有源文件。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 杂技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> GCC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/vim/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/vim/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="vim"><a class="markdownIt-Anchor" href="#vim"></a> vim</h1><h2 id="vim中的六种基本模式"><a class="markdownIt-Anchor" href="#vim中的六种基本模式"></a> vim中的六种基本模式</h2><hr /><p>几乎所有的编辑器都会有插入和执行命令两种模式，并且大多数的编辑器使用了与Vim截然不同的方式：命令目录（鼠标或者键盘驱动），组合键（通常通过control键（CTRL）和alt键（ALT）组成）或者鼠标输入。Vim和vi一样，仅仅通过键盘来在这些模式之中切换。这就使得Vim可以不用进行菜单或者鼠标操作，并且最小化组合键的操作。对文字录入员或者程序员可以大大增强速度和效率。Vim具有6种基本模式和5种派生模式。</p><ol><li><strong>普通模式(Normal mode)</strong></li></ol><ul><li>在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是Vim启动后的默认模式。这正好和许多新用户期待的操作方式相反（大多数编辑器默认模式为插入模式）。</li><li>Vim强大的编辑能来自于其普通模式命令。普通模式命令往往需要一个操作符结尾。例如普通模式命令dd删除当前行，但是第一个&quot;d&quot;的后面可以跟另外的移动命令来代替第二个d，比如用移动到下一行的&quot;j&quot;键就可以删除当前行和下一行。另外还可以指定命令重复次数，2dd（重复dd两次），和dj的效果是一样的。用户学习了各种各样的文本间移动／跳转的命令和其他的普通模式的编辑命令，并且能够灵活组合使用的话，能够比那些没有模式的编辑器更加高效地进行文本编辑。</li><li>在普通模式中，有很多方法可以进入插入模式。比较普通的方式是按a（append／追加）键或者i（insert／插入）键。</li></ul><ol start="2"><li><strong>插入模式(Insert mode)</strong></li></ol><ul><li>在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。</li><li>在插入模式中，可以按ESC键回到普通模式。</li></ul><ol start="3"><li><strong>可视模式(Visual mode)</strong></li></ol><ul><li>这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。Vim的&quot;文本对象&quot;也能和移动命令一样用在这个模式中。</li></ul><ol start="4"><li><strong>选择模式(Select mode)</strong></li></ol><ul><li>这个模式和无模式编辑器的行为比较相似（Windows标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim会用这个字符替换选择的高亮文本块，并且自动进入插入模式。</li></ul><ol start="5"><li><strong>命令行模式(Command line mode)</strong></li></ol><ul><li>在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（:键），搜索（/和?键）或者过滤命令（!键）。在命令执行之后，Vim返回到命令行模式之前的模式，通常是普通模式。</li></ul><ol start="6"><li><strong>Ex模式(Ex mode)</strong></li></ol><ul><li>这和命令行模式比较相似，在使用:visual命令离开Ex模式前，可以一次执行多条命令。</li></ul><h2 id="vim三种常用模式的切换"><a class="markdownIt-Anchor" href="#vim三种常用模式的切换"></a> vim三种常用模式的切换</h2><ul><li>vim启动进入普通模式，处于插入模式或命令行模式时只需要按Esc或者Ctrl+[即可进入普通模式。普通模式中按i（插入）或a（附加）键都可以进入插入模式，普通模式中按:进入命令行模式。命令行模式中输入wq回车后保存并退出vim。</li></ul><h2 id="linux终端下进入vim"><a class="markdownIt-Anchor" href="#linux终端下进入vim"></a> Linux终端下进入vim</h2><ul><li>使用vim命令进入vim界面<ul><li>vim后面加上你要打开的已存在的文件名或者不存在（则作为新建文件）的文件名。</li><li>直接使用vim也可以打开vim编辑器，但是不会打开任何文件。（进入命令行模式后输入:e 文件路径 同样可以打开相应文件。）</li></ul></li></ul><h2 id="普通模式下光标移动"><a class="markdownIt-Anchor" href="#普通模式下光标移动"></a> 普通模式下光标移动</h2><ul><li>常用的移动光标的命令</li></ul><table><thead><tr><th>命令</th><th>操 作 说 明</th></tr></thead><tbody><tr><td>h</td><td>将光标向左移动一格</td></tr><tr><td>l</td><td>将光标向右移动一格</td></tr><tr><td>j</td><td>将光标向上移动一格</td></tr><tr><td>k</td><td>将光标向下移动一格</td></tr><tr><td>W或w</td><td>将光标移动到下一个字</td></tr><tr><td>e</td><td>将光标移动到本单词的最后一个字符。如果光标所在的位置为本单词的最后一个字符，则跳动到下一个单字的最后一个字符。标点符号如“.”、“,”或“/”等字符都会被当成一个字</td></tr><tr><td>b</td><td>将光标移动到单词的第一个字符，如果光标所在位置为本单词的第一个字符，则跳到上一个单词的第一个字符</td></tr><tr><td>0</td><td>将光标移动到该行的最前面</td></tr><tr><td>$</td><td>将光移动到该行的最后面</td></tr><tr><td>G</td><td>将光标移动到最后一行的开头</td></tr><tr><td>{</td><td>将光标移动到前面的“{”处。在C语言编程时，如果按两次就会找到函数开头“{”处，如果再次连续按两次还可以找到上一个函数的开头处(若全文没有“{”，则直接将光标移至文本开头</td></tr><tr><td>}</td><td>同“{”的使用，将光标移动到后面的“}”（若全文没有“}”，则直接将光标移至全文末尾）</td></tr><tr><td>Ctrl＋b</td><td>如果想要翻看文章的前后，可以使用Page Down和Page Up；但当这两个键不能使用时，可以使用Ctrl＋b将光标向前卷一页，相当于Page Up（方向键+shift)</td></tr><tr><td>Ctrl＋f</td><td>将光标向后卷一页，相当于Page Down</td></tr><tr><td>Ctrl＋u</td><td>将光标向前移半页</td></tr><tr><td>Ctrl＋d</td><td>将光标向后移半页</td></tr><tr><td>Ctrl＋e</td><td>将光标向下卷一行</td></tr><tr><td>Ctrl＋y</td><td>将光标向上卷一行</td></tr></tbody></table><h2 id="进入插入模式"><a class="markdownIt-Anchor" href="#进入插入模式"></a> 进入插入模式</h2><ul><li>在普通模式下使用下面的键将进入插入模式，并可以从相应的位置开始输入。</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>i</td><td>在当前光标处进行编辑（实际插入位置在光标之前）</td></tr><tr><td>I</td><td>在行首插入</td></tr><tr><td>A</td><td>在行末插入</td></tr><tr><td>a</td><td>在光标后插入编辑</td></tr><tr><td>o</td><td>在当前行后插入一个新行</td></tr><tr><td>O</td><td>在当前行前插入一个新行</td></tr><tr><td>cw</td><td>替换从光标所在位置后到一个单词结尾的字符</td></tr></tbody></table><h2 id="命令行模式下保存文档"><a class="markdownIt-Anchor" href="#命令行模式下保存文档"></a> 命令行模式下保存文档</h2><ul><li>从普通模式输入:进入命令行模式，输入w回车，保存文档。输入:w 文件名可以将文档另存为其他文件名或存到其它路径下</li></ul><h2 id="退出vim"><a class="markdownIt-Anchor" href="#退出vim"></a> 退出vim</h2><ul><li>命令行模式:</li><li>从普通模式输入:进入命令行模式，输入wq回车，保存并退出编辑。</li><li>以下为其它几种退出方式：</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>:q!</td><td>强制退出，不保存</td></tr><tr><td>:q</td><td>退出</td></tr><tr><td>:wq!</td><td>强制保存并退出</td></tr><tr><td>:w 文件路径</td><td>另存为</td></tr><tr><td>:saveas 文件路径</td><td>另存为</td></tr><tr><td>:x</td><td>保存并退出</td></tr><tr><td>:wq</td><td>保存并退出</td></tr></tbody></table><ul><li>普通模式：<br />普通模式下输入Shift+zz即可保存退出vim</li></ul><h2 id="普通模式下删除文本"><a class="markdownIt-Anchor" href="#普通模式下删除文本"></a> 普通模式下删除文本</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>d＋d</td><td>连按两次d，可将光标所在的行删除，若是连续删除，可以按住d不放</td></tr><tr><td>d＋w</td><td>删除光标所在位置的单词，若是光标在两个字之间，则删除光标后面的一个字符</td></tr><tr><td>n＋d＋d</td><td>删除包括光标所在行及向下的n行(n为数字)</td></tr><tr><td>n＋d＋上方向键</td><td>删除包括光标所在行及向上的n行</td></tr><tr><td>n＋d＋下方向键</td><td>同n＋d＋d命令</td></tr><tr><td>D或者d$</td><td>将光标所在行后所有的单词删除</td></tr><tr><td>x</td><td>将光标所在位置的字符删除</td></tr><tr><td>X</td><td>将光标所在位置前一个字符删除</td></tr><tr><td>n＋x</td><td>删除光标所在位置及其后的n个字符</td></tr><tr><td>n＋X</td><td>删除光标所在位置及其前的n个字符</td></tr></tbody></table><h2 id="vim的重复命令"><a class="markdownIt-Anchor" href="#vim的重复命令"></a> vim的重复命令</h2><ul><li>在普通模式下.(小数点)表示重复上一次的命令操作</li><li>例如：普通模式下输入x，删除第一个字符，输入.(小数点)会再次删除一个字符，除此之外也可以重复dd的删除操作</li><li>进入普通模式输入N<command>，N 表示重复后面的次数</li><li>在普通模式下，你还可以使用dw或者daw(delete a word)删除一个单词，所以你可以很容易的联想到dnw(n替换为相应数字) 表示删除n个单词</li><li>例如：输入10x，删除10个连续字符,输入3dd，将会删除3行文本。</li></ul><h2 id="普通模式下游标的快速跳转"><a class="markdownIt-Anchor" href="#普通模式下游标的快速跳转"></a> 普通模式下，游标的快速跳转</h2><h3 id="行间跳转"><a class="markdownIt-Anchor" href="#行间跳转"></a> 行间跳转</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>nG(n Shift+g)</td><td>游标移动到第 n 行(如果默认没有显示行号，请先进入命令模式，输入:set nu以显示行号)</td></tr><tr><td>gg</td><td>游标移动到到第一行</td></tr><tr><td>G(Shift+g)</td><td>到最后一行</td></tr></tbody></table><ul><li>小技巧：你在完成依次跳转后，可以使用 Ctrl+o 快速回到上一次(<strong>跳转前</strong>即中途用hjkl移动的不算，只是调回大跳转前的位置)光标所在位置,这个技巧很实用，比如当你在写代码时，忽然想起有个 bug，需要修改，这时候你跳过去改好了，只需要按下 Ctrl+o 就可以回到你之前的位置。</li></ul><h3 id="行内跳转"><a class="markdownIt-Anchor" href="#行内跳转"></a> 行内跳转</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>w</td><td>到下一个单词的开头</td></tr><tr><td>e</td><td>到当前单词的结尾</td></tr><tr><td>b</td><td>到前一个单词的开头</td></tr><tr><td>ge</td><td>到前一个单词的结尾</td></tr><tr><td>0或^</td><td>到行头</td></tr><tr><td>$</td><td>到行尾</td></tr><tr><td>f&lt;字母&gt;</td><td>向后搜索&lt;字母&gt;并跳转到第一个匹配的位置(非常实用)</td></tr><tr><td>F&lt;字母&gt;</td><td>向前搜索&lt;字母&gt;并跳转到第一个匹配的位置</td></tr><tr><td>t&lt;字母&gt;</td><td>向后搜索&lt;字母&gt;并跳转到第一个匹配位置之前的一个字母(不常用)</td></tr><tr><td>T&lt;字母&gt;</td><td>向前搜索&lt;字母&gt;并跳转到第一个匹配位置之后的一个字母(不常用)</td></tr></tbody></table><ul><li>注意：vim是以一些特殊字符和空格来区分单词的，比如中文的一句话在它眼里就是一个单词。</li><li>小技巧：使用~可以将当前光标所在的字母切换大小写，之后光标移动到下一位。</li></ul><h2 id="复制粘贴和剪切"><a class="markdownIt-Anchor" href="#复制粘贴和剪切"></a> 复制粘贴和剪切</h2><h3 id="复制及粘贴文本"><a class="markdownIt-Anchor" href="#复制及粘贴文本"></a> 复制及粘贴文本</h3><ul><li>普通模式中使用y复制</li><li>普通模式中，yy复制游标所在的整行（3yy表示复制3行）</li><li>普通模式中，y^ 复制至行首，或y0。不含光标所在处字符。</li><li>普通模式中，y$ 复制至行尾。含光标所在处字符。</li><li>普通模式中，yw 复制一个单词。</li><li>普通模式中，y2w 复制两个单词。</li><li>普通模式中，yG 复制至文本末。</li><li>普通模式中，y1G 复制至文本开头。</li><li>普通模式中使用 p 粘贴</li><li>普通模式中，p(小写)代表粘贴至光标后（下）</li><li>普通模式中，P(大写)代表粘贴至光标前（上）</li></ul><h3 id="剪切及粘贴文本"><a class="markdownIt-Anchor" href="#剪切及粘贴文本"></a> 剪切及粘贴文本</h3><ul><li>其实前面讲的 dd 删除命令就是剪切，你每次 dd 删除文档内容后，便可以使用p来粘贴，也这一点可以让我们实现一个很爽快的功能——交换上下行：</li><li>ddp ,就这么简单，即实现了快速交换光标所在行与它下面的行。</li></ul><h2 id="字符的替换和撤销undo操作"><a class="markdownIt-Anchor" href="#字符的替换和撤销undo操作"></a> 字符的替换和撤销（undo操作）</h2><ul><li>替换和Undo命令都是针对普通模式下的操作</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>r+&lt;待替换字母&gt;</td><td>将游标所在字母替换为指定字母</td></tr><tr><td>R</td><td>连续替换，直到按下Esc</td></tr><tr><td>cc</td><td>替换整行，即删除游标所在行，并进入插入模式</td></tr><tr><td>cw</td><td>替换一个单词，即删除一个单词，并进入插入模式</td></tr><tr><td>C(大写)</td><td>替换游标以后至行末</td></tr><tr><td>~</td><td>反转游标所在字母大小写</td></tr><tr><td>u{n}</td><td>撤销一次或n次操作</td></tr><tr><td>U(大写)</td><td>撤销当前行的所有修改</td></tr><tr><td>Ctrl+r</td><td>redo，即撤销undo的操作</td></tr></tbody></table><h2 id="快速缩进"><a class="markdownIt-Anchor" href="#快速缩进"></a> 快速缩进</h2><ul><li>普通模式下输入&gt;&gt; 整行将向右缩进（使用，用于格式化代码超爽）</li><li>普通模式下输入&lt;&lt; 整行向左回退</li><li>注： 普通模式下输入:进入命令行模式下对shiftwidth值进行设置可以控制缩进和回退的字符数</li><li>shiftwidth<ul><li>设置的命令：<code>set shiftwidth? //查看当前shiftwidth值</code> ,<code>set shiftwidth=10 //设置新的shiftwidth值</code></li></ul></li></ul><h2 id="调整文本的位置"><a class="markdownIt-Anchor" href="#调整文本的位置"></a> 调整文本的位置</h2><ul><li>命令行模式下输入<code>:ce</code>(center)命令使本行内容居中</li><li>命令行模式下输入<code>:ri</code>(right)命令使本行文本靠右</li><li>命令行模式下输入<code>:le</code>(left)命令使本行内容靠左</li></ul><h2 id="快速查找"><a class="markdownIt-Anchor" href="#快速查找"></a> 快速查找</h2><ul><li>普通模式下输入<code>/</code>然后键入需要查找的字符串 按回车后就会进行查找。 ？ 与/ 功能相同，只不过 ？ 是向上而 / 是向下查找。 进入查找之后，输入n 和 N 可以继续查找。 n是查找下一个内容,N查找上一个内容。(下面的四个功能在vscode上好像用不了)</li><li>普通模式下输入<code>\*</code>寻找游标所在处的单词</li><li>普通模式下输入<code>\#</code>同上，但 <code>\#</code> 是向前（上）找，<code>\*</code>则是向后（下）找</li><li>普通模式下输入<code>g\*</code>同<code>\*</code> ，但部分符合该单词即可</li><li>普通模式下输入<code>g\#</code>同<code>\#</code> ，但部分符合该单词即可(以上四个查找n, N 的继续查找命令依然可以用)</li></ul><h2 id="多文件编辑"><a class="markdownIt-Anchor" href="#多文件编辑"></a> 多文件编辑</h2><h3 id="使用vim编辑多个文件"><a class="markdownIt-Anchor" href="#使用vim编辑多个文件"></a> 使用vim编辑多个文件</h3><ul><li>打开vim时同时打开或创建两个文件</li><li>例如：<code>vim 1.txt 2.txt</code></li><li>将默认进入1.txt文件的编辑界面</li><li>命令行模式下输入 <code>:n</code> 编辑 2.txt 文件，可以加 ! 即 <code>:n! </code>强制切换，之前一个文件的输入没有保存，仅仅切换到另一个文件</li><li>命令行模式下输入 <code>:N </code>编辑 1.txt 文件，可以加 ! 即 <code>:N!</code> 强制切换，之前文件内的输入没有保存，仅仅是切换到另一个文件</li></ul><h3 id="进入vim后打开新文件"><a class="markdownIt-Anchor" href="#进入vim后打开新文件"></a> 进入vim后打开新文件</h3><ul><li>命令行模式下输入:e 3.txt 打开新文件3.txt</li><li>命令行模式下输入:e# 回到前一个文件</li><li>命令行模式下输入:ls可以列出以前编辑过的文档</li><li>命令行模式下输入:b 2.txt（或者编号）可以直接进入文件2.txt编辑</li><li>命令行模式下输入:bd 2.txt（或者编号）可以删除以前编辑过的列表中的文件项目</li><li>命令行模式下输入:e! 4.txt，新打开文件4.txt，放弃正在编辑的文件(类似强制转换)</li><li>命令行模式下输入:f 显示正在编辑的文件名</li><li>命令行模式下输入:f new.txt，改变正在编辑的文件名字为new.txt</li></ul><h3 id="恢复文件"><a class="markdownIt-Anchor" href="#恢复文件"></a> 恢复文件</h3><p>如果因为断电等原因造成文档没有保存，可以采用恢复方式，<code>vim -r</code>进入文档后，输入<code>:ewcover &lt;filename&gt;</code>来恢复</p><h2 id="可视模式"><a class="markdownIt-Anchor" href="#可视模式"></a> 可视模式</h2><ul><li>在普通模式下输入 v（小写），进入字符选择模式，就可以移动光标，光标走过的地方就会选取。再次按下v后就会取消选取。</li><li>在普通模式下输入 Shift+v（小写），进入行选择模式，按下V之后就会把整行选取，您可以上下移动光标选更多的行，同样，再按一次 Shift+v 就可以取消选取。</li><li>在普通模式下输入 Ctrl+v（小写），这是区域选择模式，可以进行矩形区域选择，再按一次 Ctrl+v 取消选取。</li><li>在可视模式下输入 d 删除选取区域内容</li><li>在可视模式下输入y复制选取区域内</li></ul><h2 id="视窗操作"><a class="markdownIt-Anchor" href="#视窗操作"></a> 视窗操作</h2><ul><li>vim 可以在一个界面里打开多个窗口进行编辑，这些编辑窗口称为 vim 的视窗。</li><li>打开方法有很多种，例如可以使用在命令行模式下输入 <code>:new</code> 打开一个新的 vim 视窗，并进入视窗编辑一个新文件（普通模式下输入 <code>Ctrl+w</code> 也可以），除了 :new 命令，下述列举的多种方法也可以在命令模式或普通模式下打开新的视窗：<ul><li>命令行模式下输入<code>:sp 1.txt</code> 打开新的<strong>水平分屏视窗</strong>来编辑1.txt</li><li>命令行模式下输入<code>:vsp 2.txt</code> 打开新的<strong>垂直分屏视窗</strong>来编辑2.txt</li><li>普通模式下<code>Ctrl+w s </code>将当前窗口分割成两个<strong>水平</strong>的窗口</li><li>普通模式下<code>Ctrl+w v</code> 将当前窗口分割成两个<strong>垂直</strong>的窗口</li><li>普通模式下<code>Ctrl+w q </code>即 <code>:q</code> 结束分割出来的视窗。如果在新视窗中有输入需要使用强制符！即<code>:q!</code></li><li>普通模式下<code>Ctrl+w o </code>打开一个视窗并且<strong>隐藏之前</strong>的所有视窗</li><li>普通模式下<code>Ctrl+w j</code> 移至下面视窗</li><li>普通模式下<code>Ctrl+w k</code> 移至上面视窗</li><li>普通模式下<code>Ctrl+w h</code> 移至左边视窗</li><li>普通模式下<code>Ctrl+w l</code> 移至右边视窗</li><li>普通模式下<code>Ctrl+w J</code> 将当前视窗移至下面</li><li>普通模式下<code>Ctrl+w K</code> 将当前视窗移至上面</li><li>普通模式下<code>Ctrl+w H</code> 将当前视窗移至左边</li><li>普通模式下<code>Ctrl+w L</code> 将当前视窗移至右边</li><li>普通模式下<code>Ctrl+w -</code> 减小视窗的高度</li><li>普通模式下<code>Ctrl+w +</code> 增加视窗的高度</li></ul></li></ul><h2 id="文档加密"><a class="markdownIt-Anchor" href="#文档加密"></a> 文档加密</h2><ul><li>命令：<code>vim -x &lt;filename&gt;</code></li><li>输入您的密码 确认密码 这样在下一次打开时，vim就会要求你输入密码</li></ul><h2 id="执行外部shell命令"><a class="markdownIt-Anchor" href="#执行外部shell命令"></a> 执行外部shell命令</h2><ul><li>在命令行模式中输入!可以执行外部的shell命令<ul><li><code>:!ls</code> 用于显示当前目录的内容</li><li><code>:!rm FILENAME</code>用于删除名为 FILENAME 的文件</li><li><code>:w FILENAME</code>可将当前 VIM 中正在编辑的文件另存为 FILENAME 文件</li></ul></li></ul><h2 id="vim帮助系统"><a class="markdownIt-Anchor" href="#vim帮助系统"></a> vim帮助系统</h2><p>vim中的查看帮助</p><ul><li>普通模式下按<code>F1</code>打开vim自己预设的帮助文档</li><li>命令行模式下输入<code>:h shiftwidth</code>打开名为shiftwidth的帮助文件</li><li>命令行模式下输入<code>:ver</code> 显示版本及参数</li></ul><h2 id="vim功能设定"><a class="markdownIt-Anchor" href="#vim功能设定"></a> vim功能设定</h2><h3 id="vim的功能设定"><a class="markdownIt-Anchor" href="#vim的功能设定"></a> vim的功能设定</h3><ul><li>可以在编辑文件的时候进行功能设定，如命令行模式下输入<code>:set nu（显示行数）</code>，设定值退出vim后<strong>不会保存</strong>。要<strong>永久</strong>保存配置需要修改vim配置文件。 vim的配置文件<code>~/.vimrc</code>，可以打开文件进行修改，不过务必小心不要影响vim正常使用</li></ul><h3 id="获取目前的设定"><a class="markdownIt-Anchor" href="#获取目前的设定"></a> 获取目前的设定</h3><ul><li>命令行模式下输入<code>:set</code>或者<code>:se</code>显示所有修改过的配置</li><li>命令行模式下输入<code>:set all</code> 显示所有的设定值</li><li>命令行模式下输入<code>:set option? </code>显示option的设定值</li><li>命令行模式下输入<code>:set nooption</code> 取消当前设定值</li></ul><h3 id="set功能的说明"><a class="markdownIt-Anchor" href="#set功能的说明"></a> set功能的说明</h3><ul><li>命令行模式下输入<code>:set autoindent(ai) </code>设置自动缩进</li><li>命令行模式下输入<code>:set autowrite(aw)</code> 设置自动存档，默认未打开</li><li>命令行模式下输入<code>:set background=dark或light</code>，设置背景风格</li><li>命令行模式下输入<code>:set backup(bk)</code> 设置自动备份，默认未打开</li><li>命令行模式下输入<code>: set cindent(cin)</code> 设置C语言风格缩进</li></ul><h2 id="vim配置"><a class="markdownIt-Anchor" href="#vim配置"></a> vim配置</h2>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 杂技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂技术 </tag>
            
            <tag> VIM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 线性表</title>
      <link href="//post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8/index.html"/>
      <url>//post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="第二章-线性表"><a class="markdownIt-Anchor" href="#第二章-线性表"></a> 第二章 线性表</h1><h2 id="线性表的定义"><a class="markdownIt-Anchor" href="#线性表的定义"></a> 线性表的定义</h2><ul><li>线性表是一个具有<strong>相同特性</strong>的数据元素的有限序列。</li><li>特性：<ul><li>相同特性：所有元素属于同一数据类型。</li><li>有限：数据元素个数是有限的。</li><li>序列：数据元素由逻辑序号唯一确定。一个线性表中可以有<strong>相同值</strong>的元素。</li><li>结构：除第一个元素无前驱、最后一个元素无后继外，其余每个元素都有<strong>唯一前驱和唯一后继元素</strong>。</li></ul></li><li>线性表中所含元素的个数叫做线性表的长度。</li><li>线性表的逻辑表示：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721183419.jpg" alt="" /></li></ul><h2 id="线性表的顺序存储结构"><a class="markdownIt-Anchor" href="#线性表的顺序存储结构"></a> 线性表的顺序存储结构</h2><h3 id="线性表的顺序存储结构定义"><a class="markdownIt-Anchor" href="#线性表的顺序存储结构定义"></a> 线性表的顺序存储结构定义</h3><ul><li>把线性表中元素按照顺序存储的方法存储（即存储位置为一篇连续的空间，如数组）</li><li>静态存储顺序表<ul><li>定义：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721183915.jpg" alt="" />（意味着last是从0开始的）</li><li>特性：<ul><li>随机存取</li></ul></li></ul></li><li>动态存储顺序表：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721223730.jpg" alt="" /><ul><li>创建动态存储的顺序表：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721223923.jpg" alt="" /><ul><li>关键在于数组的长度是根据具体情况来分配的<code>L-&gt;elem  = (ElemType *)malloc(maxSize*sizeof(ElemType))</code></li></ul></li></ul></li></ul><h3 id="线性表在静态顺序存储结构上的基本运算"><a class="markdownIt-Anchor" href="#线性表在静态顺序存储结构上的基本运算"></a> 线性表在静态顺序存储结构上的基本运算</h3><ul><li><ol><li>求某个元素在顺序表中的序号<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721184701.jpg" alt="" /></li></ol><ul><li>因为数组中计数是从0开始，而实际生活中数数是从1开始，所以需要<code>i + 1</code></li><li>控制条件为找到数组的最后一个元素<code>i &lt;= L.last</code></li></ul></li><li><ol start="2"><li>求序号为i的数据元素值</li></ol><ul><li><p>法一：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721185107.jpg" alt="" /></p><ul><li>注意控制条件，i过大或者过小都会超出数组边界，故需<code>i &lt; 1 || i &gt; L-&gt;last +1</code></li></ul></li><li><p>法二：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721185732.jpg" alt="" /></p></li><li><p>二者的区别在于直接返回元素的值还是通过指针传递元素的值。</p></li></ul></li><li><ol start="3"><li>在顺序表的第i个位置<strong>插入</strong>数据元素 (1 &lt;= i &lt;= last + 2)<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721215615.jpg" alt="" /></li></ol><ul><li>控制条件：此时插入位置i的范围要比数组原来的范围增加一，因为数组整体要先增加一个位置，所以有<code>i &lt; 1 || i &gt; L-&gt;last + 2</code>.</li><li>关键的元素后移操作：先在数组末尾增加上一个位置，然后从后往前逐次将第i位起的元素后移，<code>for(k = L-&gt;last; k &gt;= i - 1 ; k--) L-&gt;elem[k+1] = L-&gt;elem[k];</code></li><li>末尾别忘了<code>last</code>的更改。</li><li>算法的时间复杂度：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721220637.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721220653.jpg" alt="" /></li></ul></li><li><ol start="4"><li>顺序表<strong>删除</strong>第i个位置的元素（1 &lt; i &lt; last + 1)<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721221040.jpg" alt="" /></li></ol><ul><li>先将特殊的情况考虑，再做常规处理：i超出数组的范围和顺序表为空的两种情况。<code>i &lt; 1 || i &gt; L-&gt;last + 1</code>和<code>L-&gt;last &lt; 0</code>.(i = 0 不行是因为此处的i代表的是实际生活中的计数，而不是数组从零开始的计数)</li><li>关键的元素前移操作：从第i个元素之后的一个元素开始逐渐前移 <code>for(k = i; k &lt;= L-&gt;last; k++) L-&gt;elem[k-1] = L-&gt;elem[k];</code>，控制条件为<code>k &lt;= L -&gt;last</code>的原因是，此时的k作为数组的下标而不是实际生活中的计数，与last的意义相同了，所以不需要再做元素个数与数组下标之间+1 的转换。</li><li>算法的时间复杂度：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721222832.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721222948.jpg" alt="" /></li></ul></li></ul><h3 id="线性表动态顺序存储结构的算法"><a class="markdownIt-Anchor" href="#线性表动态顺序存储结构的算法"></a> 线性表动态顺序存储结构的算法</h3><ul><li>二路归并算法<ul><li>将两个非递减顺序表合并为一个有序表，称为二路归并。</li><li>基本原理：同时遍历两个顺序表，遍历过程中比较元素的大小并存入有序表中，并根据比较结果调整两个顺序表遍历的速度。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721225112.jpg" alt="" /></li><li>注意：两表的同时遍历进行结束之后，还要检查是否有哪个表没有遍历完。</li></ul></li></ul><h2 id="线性表的链式存储结构"><a class="markdownIt-Anchor" href="#线性表的链式存储结构"></a> 线性表的链式存储结构</h2><h3 id="线性表的链式存储结构的定义"><a class="markdownIt-Anchor" href="#线性表的链式存储结构的定义"></a> 线性表的链式存储结构的定义</h3><ul><li>链式存储结构即使用链表存储。使用链表时，每个逻辑结点单独存储，为了表示逻辑关系，每个结点里增加一个指针域。</li><li>链表的分类：<ul><li>单链表：每个物理结点里增加一个指向<strong>后继结点</strong>的指针域。<ul><li>当访问过一个结点后，只能接着访问它的后继结点，而无法访问它的前驱结点。</li></ul></li><li>循环单链表：将表中尾结点的指针域改为指向表头结点，整个链表形成一个环。<ul><li>从表中任一结点出发均可找到链表中其他结点。</li><li>链表中没有空指针域（最后一个结点的空指针域现在指向头结点）</li></ul></li><li>双向链表:  每个物理结点增加一个指向<strong>后继结点</strong>和一个指向<strong>前驱结点</strong>的指针。<ul><li>从任一结点出s发可以快速找到其前驱结点和后继结点。</li><li>从任一结点出发可以访问其他任一结点。</li></ul></li></ul></li></ul><h3 id="单链表"><a class="markdownIt-Anchor" href="#单链表"></a> 单链表</h3><h4 id="结点类型定义"><a class="markdownIt-Anchor" href="#结点类型定义"></a> 结点类型定义</h4><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200722110417.jpg" alt="" /></p><ul><li>单独创建一个 LinkList类型的目的是区分普通数据结点和头结点。</li></ul><h4 id="建表"><a class="markdownIt-Anchor" href="#建表"></a> 建表</h4><ul><li><p>头插法建表</p><ul><li>基本原理：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200722110741.jpg" alt="" /><ul><li>读取是从前往后，但最终形成的链表顺序是原来数据排列方式的从后往前。</li><li>最终的表头是一个不含数据的空结点。</li></ul></li><li>算法：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200722111848.jpg" alt="" /><ul><li>每一个结点（包括头结点）都是现场分配的内存。</li><li>头结点的指针域始终指向刚插入的结点（开始为NULL除外）。</li><li>每次插入操作需将头结点指针域赋给新结点的指针域，然后头结点指针域指向新结点。这样达到断开头结点与旧结点之间的旧链,而形成头结点与新结点之间新链的效果。</li></ul></li></ul></li><li><p>尾插法建表：</p><ul><li>基本原理：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200722112653.jpg" alt="" /><ul><li>增加一个移动的尾指针，使其一直指向链表的尾结点（开始时指向头结点）</li></ul></li><li>算法：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200722113210.jpg" alt="" /><ul><li>先使用尾指针，使旧尾结点的指针域指向新结点，然后将尾指针指向新结点。</li><li>注意：最后要将尾结点的指针域设置为NULL。</li></ul></li></ul></li></ul><h4 id="求线性表中第i个位置的数据元素"><a class="markdownIt-Anchor" href="#求线性表中第i个位置的数据元素"></a> 求线性表中第i个位置的数据元素</h4><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723094813.jpg" alt="" /></p><ul><li>设置一个移动的指针（最开始指向头结点），在计数（从0开始）的同时，移动指针。</li><li>在找到第i个元素之前，用循环移动指针。（注意控制条件：计数变量比i小，且不能超出链表元素数目）</li></ul><h4 id="按元素值查找"><a class="markdownIt-Anchor" href="#按元素值查找"></a> 按元素值查找</h4><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723095356.jpg" alt="" /></p><ul><li>设置一个移动的指针，从第一个有值域的结点开始查找，每一个元素和所找元素比较，若不相等，则指针向后移。</li></ul><h4 id="求带头单链表的长度"><a class="markdownIt-Anchor" href="#求带头单链表的长度"></a> 求带头单链表的长度</h4><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723095728.jpg" alt="" /></p><ul><li>设置一个移动的指针（开始指向头结点），设置一个计数变量(开始设为0表示头结点的序号为0，不算在数据结点的个数中），每移动一次指针，计数变量加一。</li><li>结束的控制条件：最后一个结点的指针域为NULL。</li></ul><h4 id="在链表的第i个位置插入数据元素"><a class="markdownIt-Anchor" href="#在链表的第i个位置插入数据元素"></a> 在链表的第i个位置插入数据元素</h4><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723100430.jpg" alt="" /></p><ul><li><a href="#%E6%B1%82%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B8%AD%E7%AC%ACi%E4%B8%AA%E4%BD%8D%E7%BD%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0">查找算法</a>和<a href="#%E5%BB%BA%E8%A1%A8">头插法创建链表算法</a>的结合。</li></ul><h4 id="删除链表的第i个位置的数据元素"><a class="markdownIt-Anchor" href="#删除链表的第i个位置的数据元素"></a> 删除链表的第i个位置的数据元素</h4><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723101022.jpg" alt="" /></p><ul><li>查找到第i-1个结点，利用它的指向后继结点的指针域（所以结束查找的条件是找到第i-1个元素或者当前结点的指针域为NULL），来删除第i个结点。</li><li>使用<code>free()</code>来删除一个结点。</li></ul><h4 id="合并两个有序链表为一个有序链表"><a class="markdownIt-Anchor" href="#合并两个有序链表为一个有序链表"></a> 合并两个有序链表为一个有序链表</h4><ul><li><p>占用其中一个链表来合并<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723102129.jpg" alt="" /></p><ul><li>基本原理类似<a href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E7%AE%97%E6%B3%95">二路归并算法</a></li><li>设置两个可移动指针，指向原来两个链表的数据元素。</li><li>新链表头指针指向原来某个链表的头结点，以此来占用该链表的空间。</li></ul></li><li><p>合并为一个全新的链表<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723103937.jpg" alt="" /></p><ul><li>所不同的是每一次插入都需要重新分配空间，故采用<a href="#%E5%BB%BA%E8%A1%A8">尾插法</a>重新建立一个链表。</li><li>最后没有遍历完的结点，需要使用循环来插入新链表中。</li><li>注意最后新链表尾结点的指针域要置为NULL。</li></ul></li></ul><h3 id="循环单链表"><a class="markdownIt-Anchor" href="#循环单链表"></a> 循环单链表</h3><ul><li>找到尾结点的条件变为：<code>p-&gt;next = L</code>。</li><li>结点类型：同单链表</li></ul><h4 id="初始化循环单链表"><a class="markdownIt-Anchor" href="#初始化循环单链表"></a> 初始化循环单链表</h4><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723222629.jpg" alt="" /></p><ul><li>形参为指向头结点指针的指针。</li><li>最开始时，头结点即为尾结点，故头结点的指针域指向自己。</li></ul><h4 id="创建循环单链表"><a class="markdownIt-Anchor" href="#创建循环单链表"></a> 创建循环单链表</h4><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723223045.jpg" alt="" /></p><ul><li>使用尾插法创建循环链表</li><li>最后要将尾结点的指针域设为头结点。</li></ul><h4 id="循环单链表的合并"><a class="markdownIt-Anchor" href="#循环单链表的合并"></a> 循环单链表的合并</h4><ul><li><p>传入两个循环单链表的头指针<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723223617.jpg" alt="" /></p><ul><li>找尾结点的循环：<code>while(p-&gt;next != LA) p = p-&gt;next;</code></li><li>第一个链表的尾结点的指针域设为第二个链表的第一个数据结点（不是头结点），第二个链表的尾结点的指针域设为第一个链表的头结点。</li></ul></li><li><p>传入两个循环单链表的尾指针<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723224057.jpg" alt="" /></p><ul><li>先找到两个链表的头结点，在修改各自尾结点的指针域。</li></ul></li></ul><h3 id="双向链表"><a class="markdownIt-Anchor" href="#双向链表"></a> 双向链表</h3><ul><li>结点类型定义<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723224256.jpg" alt="" /></li></ul><h4 id="建立双向链表"><a class="markdownIt-Anchor" href="#建立双向链表"></a> 建立双向链表</h4><ul><li><p>头插法建表<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200725220437.jpg" alt="" /></p><ul><li>头结点刚创立时前后驱指针域都设为空<code>(*L)-&gt;prior = (*L)-&gt;next = NULL;</code></li><li>新插入结点的前驱指针域设为头结点，后驱指针域设为原来头结点后原第一个数据结点。<code>s-&gt;next = (*L)-&gt;next; s-&gt;prior = *L</code></li><li>原第一个数据结点的前驱指针需修改为新插入结点<code>(*L)-&gt;next-&gt;prior = s;</code>,头结点的后驱指针域设为新插入结点<code>(*L)-&gt;next = s;</code></li><li>头插法的共性是建成的线性表是逆序的；</li><li>注意：传入函数的是指向头结点指针的指针，又有-&gt;的优先级高于*，所以需使用（*L）。</li></ul></li><li><p>尾插法建表<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200725221517.jpg" alt="" /></p><ul><li>设立一个可移动的尾指针，始终指向当前的尾结点；</li><li>最后注意将尾结点的后驱指针域设为NULL</li><li>相较头插法，只需修改两个结点的三个指针域，修改较少。</li></ul></li><li><p>建表的变式：逆置双向链表<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200725222226.jpg" alt="" /></p><ul><li>本质是头插法的运用;</li><li>需要新设两个可移动指针来扫描原来的链表。</li></ul></li></ul><h4 id="在第i个位置插入数据元素"><a class="markdownIt-Anchor" href="#在第i个位置插入数据元素"></a> 在第i个位置插入数据元素</h4><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200725222900.jpg" alt="" /></p><ul><li>本质是头插法</li><li>查找第i-1个结点即为尾插法</li></ul><h4 id="删除第i个结点"><a class="markdownIt-Anchor" href="#删除第i个结点"></a> 删除第i个结点</h4><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200725223227.jpg" alt="" /></p><ul><li>可以找到第i个结点，也可以找第i-1结点；</li><li>只需修改两个指针；</li></ul><h3 id="循环双向链表"><a class="markdownIt-Anchor" href="#循环双向链表"></a> 循环双向链表</h3><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727110328.jpg" alt="" /></p><ul><li>找到尾结点的条件变为了：<code>L-&gt;next = L</code></li><li>判断循环链表是否对称相等的算法<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727110858.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727111123.jpg" alt="" /><ul><li>设置两个可移动指针分别从链表头尾扫描向中间</li><li>数据结点数目不同，扫描完是两个扫描指针的相对位置不同。为奇数时，最后两个结点指向同一个数据结点<code>p == q</code>;为偶数时，最后两个扫描指针相邻<code>p-&gt;next == q</code>或者<code>p == q-&gt;prior</code></li></ul></li></ul><h2 id="线性表的应用"><a class="markdownIt-Anchor" href="#线性表的应用"></a> 线性表的应用</h2><h3 id="一元多项式的运算"><a class="markdownIt-Anchor" href="#一元多项式的运算"></a> 一元多项式的运算</h3><ul><li>基本原理（一元稀疏多项式的线性表表示）<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727112250.jpg" alt="" /></li><li>单链表储存一元多项式的结点定义<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727112636.jpg" alt="" /></li><li>创建一元多项式单链表存储的算法<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727153633.jpg" alt="" /><ul><li>尾插法创建</li><li>需要申请一个空的头结点</li></ul></li><li>两个一元多项式相加的算法<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727154010.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727154225.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727154452.jpg" alt="" /><ul><li>默认即将要相加的两个一元多项式是按照次数从小到大排好序的。</li><li>从头开始遍历，将指数较小的存入新表，两个的指数相等时系数相加后存入新表。</li><li>采用头插法创建相加后的新表</li></ul></li></ul><h2 id="线性表经典题目"><a class="markdownIt-Anchor" href="#线性表经典题目"></a> 线性表经典题目</h2><h3 id="1删除顺序表中值为x的元素"><a class="markdownIt-Anchor" href="#1删除顺序表中值为x的元素"></a> 1.删除顺序表中值为x的元素</h3><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727155451.jpg" alt="" /></p><ul><li>先找到第一个值为x的元素</li><li>之后将其后面值不为x的元素逐个前移</li><li>最后修改last的值。因为在移动最后一个元素后，i还加了1，所以<code>L-&gt;last = i-1</code></li></ul><h3 id="2带头结点单链表就地逆置"><a class="markdownIt-Anchor" href="#2带头结点单链表就地逆置"></a> 2.带头结点单链表就地逆置</h3><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200730101814.jpg" alt="" /></p><ul><li>将原来链表的头结点分离出来。</li><li>遍历原来链表的数据结点，然后用头插法插入分离出来的头结点中，从而实现就地逆置。</li></ul><h3 id="3以第一个元素为标准将数据元素分为两边"><a class="markdownIt-Anchor" href="#3以第一个元素为标准将数据元素分为两边"></a> 3.以第一个元素为标准将数据元素分为两边</h3><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200730103614.jpg" alt="" /></p><ul><li>p1为固定指针，始终指向第一个结点，方便其它结点与第一个结点比较大小。</li><li>pre、p、q为一套移动指针，其中p指向当前扫描到的与第一个结点比较大小的结点,q指向当前结点的下一个结点，pre指向当前结点的前一个结点。</li><li>pre的作用是当需要把当前结点移走时，能够使其它两个结点能够连起来。<code>pre-&gt;next = p-&gt;next</code>。</li><li>q的作用一方面是使p能够持续进行扫描，另一方面使在中间结点被移走的情况下协同pre建立边上两个结点的联系。</li></ul><h3 id="4存放一个二进制数的链表"><a class="markdownIt-Anchor" href="#4存放一个二进制数的链表"></a> 4.存放一个二进制数的链表</h3><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731094419.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731095000.jpg" alt="" /></p><ul><li>二进制的加法关键在于找到第一个值为0的位，然后进行01的互换（怪不得计算机要用二进制，确实好操作）</li><li>链表实现加法有两种情况，第一种是，不需增加位数，直接01互换即可；第二种是位数需进一位，此时需要增加一个新结点。</li><li>q指针的作用是扫描链表;r指针的作用是指向为最后一个值域为1的结点，若没有则指向头结点；temp指针的作用是在需要新增一个结点时，指向原来的第一个数据结点，以便与新增结点建立连接。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 专业基础 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章 数据结构及算法概念</title>
      <link href="//post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5/index.html"/>
      <url>//post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-绪论"><a class="markdownIt-Anchor" href="#第一章-绪论"></a> 第一章 绪论</h1><h2 id="1数据结构的基本概念"><a class="markdownIt-Anchor" href="#1数据结构的基本概念"></a> 1.数据结构的基本概念</h2><h3 id="数据的基本概念"><a class="markdownIt-Anchor" href="#数据的基本概念"></a> 数据的基本概念</h3><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200630163623.jpg" alt="" /><br />默认情况下，程序中处理的数据都是数据对象。</p><h3 id="数据结构定义"><a class="markdownIt-Anchor" href="#数据结构定义"></a> 数据结构定义</h3><p>数据结构 = 数据对象 + 结构<br />结构:数据元素之间的关系</p><h3 id="数据结构的组成"><a class="markdownIt-Anchor" href="#数据结构的组成"></a> 数据结构的组成</h3><ol><li>逻辑结构：数据元素间的逻辑关系<ul><li>逻辑结构的表示<ul><li>表</li><li>二元组</li><li>图形</li></ul></li><li>逻辑结构的分类<ul><li>线性结构</li><li>树形结构</li><li>集合类结构</li><li>图结构</li></ul></li></ul></li><li>存储结构：数据在计算机存储器中的存储方式就是存储结构。<ol><li>顺序存储结构<ol><li>数组</li></ol></li><li>链式存储结构<ol><li>链表</li></ol></li></ol></li><li>数据运算：数据运算是对数据的操作。分为两个阶段：运算描述和运算实现。</li></ol><p><strong>注：</strong></p><ul><li>同一逻辑结构可以对应多种存储结构。</li><li>同样的运算，在不同的存储结构中，其实现过程是不同的。</li><li>不同的实现过程的效率是不一样的。</li></ul><h2 id="2算法及其描述"><a class="markdownIt-Anchor" href="#2算法及其描述"></a> 2.算法及其描述</h2><h3 id="算法的定义及特性"><a class="markdownIt-Anchor" href="#算法的定义及特性"></a> 算法的定义及特性</h3><ul><li>算法的定义：数据元素之间的关系有逻辑关系和物理关系，对应的运算有基于<strong>逻辑结构的运算描述</strong>和基于<strong>存储结构的运算实现</strong>。通常把基于存储结构的运算实现的步骤或过程称为算法。</li><li>算法的五个特性：<ol><li>有穷性：在有穷步之后结束，算法能够停机。</li><li>确定性：无二义性。</li><li>可行性：可通过基本运算有限次执行来实现，也就是算法中每一个动作能够被机械地执行。</li><li>有输入</li><li>有输出（即存在数据处理过程）</li></ol></li><li>算法的描述：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200718094944.jpg" alt="" /></li></ul><h3 id="算法的分析"><a class="markdownIt-Anchor" href="#算法的分析"></a> 算法的分析</h3><h4 id="算法的时间复杂度分析"><a class="markdownIt-Anchor" href="#算法的时间复杂度分析"></a> 算法的时间复杂度分析</h4><ul><li>一个算法是由<strong>控制结构</strong>（顺序、分支和循环三种）和<strong>原操作</strong>（指固有数据类型的操作，如+、-、*、/、++和–等）构成的。算法执行时间取决于两者的综合效果。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200718100057.jpg" alt="" /></li><li>算法时间复杂度分析流程：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200718100413.jpg" alt="" /><ul><li>算法时间复杂度：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200718100713.jpg" alt="" /></li><li>简化分析：在算法分析时，计算T(n)时仅仅考虑基本操作的运算次数。</li></ul></li><li>示例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200718100857.jpg" alt="" /><ul><li>用修正常量得出循环次数 <img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200718101719.jpg" alt="" /></li></ul></li><li>分析技巧：<ul><li>无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)。</li><li>如果有循环，就计算循环的执行次数。（嵌套循环则是内层循环数等于每层循环次数相乘。计算最内层循环则可得出O(n)。）</li></ul></li><li>常见算法时间复杂度<ul><li>无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1),也称作常数阶。</li><li>一个只有一重循环的算法的执行时间与问题规模n的增长呈线性增大关系，记作O(n)，也称线性阶。</li><li>其余常用的算法时间复杂度还有平方阶O(n2)、立方阶O(n3)、对数阶O(log2n)、指数阶O(2n)等。</li></ul></li><li>各种时间复杂度比较：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200718102212.jpg" alt="" /></li><li>最好、最坏和平均时间复杂度分析<ul><li><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200720180009.jpg" alt="" /></li><li><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200720180044.jpg" alt="" /></li><li>时间复杂度存在变数的原因在于，循环的控制语句中存在随条件变化而变化的变量。</li></ul></li></ul><h4 id="算法的空间复杂度"><a class="markdownIt-Anchor" href="#算法的空间复杂度"></a> 算法的空间复杂度</h4><ul><li>空间复杂度：用于量度一个算法在运行过程中<strong>临时占用</strong>的存储空间大小。（即只考虑算法执行过程中分配的空间）</li><li>一般也作为问题规模n的函数，采用数量级形式描述，记作：S(n)=O(g(n))</li><li>特殊：若一个算法的空间复杂度为O(1)，则称此算法为原地工作或就地工作算法。</li></ul><h4 id="递归算法的时空复杂度"><a class="markdownIt-Anchor" href="#递归算法的时空复杂度"></a> 递归算法的时空复杂度</h4><ul><li><p>递归算法中，时空复杂度不仅仅是与问题规模有关的函数，它还与控制递归的递归条件有关。（类似一元函数的讨论变为了多元函数）</p></li><li><p>例题：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200720182551.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200720182751.PNG" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200720182718.PNG" alt="" /></p></li><li><p>求解递归算法的时空复杂度的关键在于<strong>根据递归条件写出递归方程组</strong>。</p></li></ul><h2 id="第二章-线性表"><a class="markdownIt-Anchor" href="#第二章-线性表"></a> 第二章 线性表</h2><h3 id="线性表的定义"><a class="markdownIt-Anchor" href="#线性表的定义"></a> 线性表的定义</h3><ul><li>线性表是一个具有<strong>相同特性</strong>的数据元素的有限序列。</li><li>特性：<ul><li>相同特性：所有元素属于同一数据类型。</li><li>有限：数据元素个数是有限的。</li><li>序列：数据元素由逻辑序号唯一确定。一个线性表中可以有<strong>相同值</strong>的元素。</li><li>结构：除第一个元素无前驱、最后一个元素无后继外，其余每个元素都有<strong>唯一前驱和唯一后继元素</strong>。</li></ul></li><li>线性表中所含元素的个数叫做线性表的长度。</li><li>线性表的逻辑表示：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721183419.jpg" alt="" /></li></ul><h3 id="线性表的顺序存储结构"><a class="markdownIt-Anchor" href="#线性表的顺序存储结构"></a> 线性表的顺序存储结构</h3><h4 id="线性表的顺序存储结构定义"><a class="markdownIt-Anchor" href="#线性表的顺序存储结构定义"></a> 线性表的顺序存储结构定义</h4><ul><li>把线性表中元素按照顺序存储的方法存储（即存储位置为一篇连续的空间，如数组）</li><li>静态存储顺序表<ul><li>定义：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721183915.jpg" alt="" />（意味着last是从0开始的）</li><li>特性：<ul><li>随机存取</li></ul></li></ul></li><li>动态存储顺序表：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721223730.jpg" alt="" /><ul><li>创建动态存储的顺序表：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721223923.jpg" alt="" /><ul><li>关键在于数组的长度是根据具体情况来分配的<code>L-&gt;elem  = (ElemType *)malloc(maxSize*sizeof(ElemType))</code></li></ul></li></ul></li></ul><h4 id="线性表在静态顺序存储结构上的基本运算"><a class="markdownIt-Anchor" href="#线性表在静态顺序存储结构上的基本运算"></a> 线性表在静态顺序存储结构上的基本运算</h4><ul><li><ol><li>求某个元素在顺序表中的序号<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721184701.jpg" alt="" /></li></ol><ul><li>因为数组中计数是从0开始，而实际生活中数数是从1开始，所以需要<code>i + 1</code></li><li>控制条件为找到数组的最后一个元素<code>i &lt;= L.last</code></li></ul></li><li><ol start="2"><li>求序号为i的数据元素值</li></ol><ul><li><p>法一：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721185107.jpg" alt="" /></p><ul><li>注意控制条件，i过大或者过小都会超出数组边界，故需<code>i &lt; 1 || i &gt; L-&gt;last +1</code></li></ul></li><li><p>法二：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721185732.jpg" alt="" /></p></li><li><p>二者的区别在于直接返回元素的值还是通过指针传递元素的值。</p></li></ul></li><li><ol start="3"><li>在顺序表的第i个位置<strong>插入</strong>数据元素 (1 &lt;= i &lt;= last + 2)<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721215615.jpg" alt="" /></li></ol><ul><li>控制条件：此时插入位置i的范围要比数组原来的范围增加一，因为数组整体要先增加一个位置，所以有<code>i &lt; 1 || i &gt; L-&gt;last + 2</code>.</li><li>关键的元素后移操作：先在数组末尾增加上一个位置，然后从后往前逐次将第i位起的元素后移，<code>for(k = L-&gt;last; k &gt;= i - 1 ; k--) L-&gt;elem[k+1] = L-&gt;elem[k];</code></li><li>末尾别忘了<code>last</code>的更改。</li><li>算法的时间复杂度：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721220637.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721220653.jpg" alt="" /></li></ul></li><li><ol start="4"><li>顺序表<strong>删除</strong>第i个位置的元素（1 &lt; i &lt; last + 1)<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721221040.jpg" alt="" /></li></ol><ul><li>先将特殊的情况考虑，再做常规处理：i超出数组的范围和顺序表为空的两种情况。<code>i &lt; 1 || i &gt; L-&gt;last + 1</code>和<code>L-&gt;last &lt; 0</code>.(i = 0 不行是因为此处的i代表的是实际生活中的计数，而不是数组从零开始的计数)</li><li>关键的元素前移操作：从第i个元素之后的一个元素开始逐渐前移 <code>for(k = i; k &lt;= L-&gt;last; k++) L-&gt;elem[k-1] = L-&gt;elem[k];</code>，控制条件为<code>k &lt;= L -&gt;last</code>的原因是，此时的k作为数组的下标而不是实际生活中的计数，与last的意义相同了，所以不需要再做元素个数与数组下标之间+1 的转换。</li><li>算法的时间复杂度：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721222832.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721222948.jpg" alt="" /></li></ul></li></ul><h4 id="线性表动态顺序存储结构的算法"><a class="markdownIt-Anchor" href="#线性表动态顺序存储结构的算法"></a> 线性表动态顺序存储结构的算法</h4><ul><li>二路归并算法<ul><li>将两个非递减顺序表合并为一个有序表，称为二路归并。</li><li>基本原理：同时遍历两个顺序表，遍历过程中比较元素的大小并存入有序表中，并根据比较结果调整两个顺序表遍历的速度。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200721225112.jpg" alt="" /></li><li>注意：两表的同时遍历进行结束之后，还要检查是否有哪个表没有遍历完。</li></ul></li></ul><h3 id="线性表的链式存储结构"><a class="markdownIt-Anchor" href="#线性表的链式存储结构"></a> 线性表的链式存储结构</h3><h4 id="线性表的链式存储结构的定义"><a class="markdownIt-Anchor" href="#线性表的链式存储结构的定义"></a> 线性表的链式存储结构的定义</h4><ul><li>链式存储结构即使用链表存储。使用链表时，每个逻辑结点单独存储，为了表示逻辑关系，每个结点里增加一个指针域。</li><li>链表的分类：<ul><li>单链表：每个物理结点里增加一个指向<strong>后继结点</strong>的指针域。<ul><li>当访问过一个结点后，只能接着访问它的后继结点，而无法访问它的前驱结点。</li></ul></li><li>循环单链表：将表中尾结点的指针域改为指向表头结点，整个链表形成一个环。<ul><li>从表中任一结点出发均可找到链表中其他结点。</li><li>链表中没有空指针域（最后一个结点的空指针域现在指向头结点）</li></ul></li><li>双向链表:  每个物理结点增加一个指向<strong>后继结点</strong>和一个指向<strong>前驱结点</strong>的指针。<ul><li>从任一结点出啊发可以快速找到其前驱结点和后继结点。</li><li>从任一结点出发可以访问其他任一结点。</li></ul></li></ul></li></ul><h4 id="单链表"><a class="markdownIt-Anchor" href="#单链表"></a> 单链表</h4><h5 id="结点类型定义"><a class="markdownIt-Anchor" href="#结点类型定义"></a> 结点类型定义</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200722110417.jpg" alt="" /></p><ul><li>单独创建一个 LinkList类型的目的是区分普通数据结点和头结点。</li></ul><h5 id="建表"><a class="markdownIt-Anchor" href="#建表"></a> 建表</h5><ul><li><p>头插法建表</p><ul><li>基本原理：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200722110741.jpg" alt="" /><ul><li>读取是从前往后，但最终形成的链表顺序是原来数据排列方式的从后往前。</li><li>最终的表头是一个不含数据的空结点。</li></ul></li><li>算法：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200722111848.jpg" alt="" /><ul><li>每一个结点（包括头结点）都是现场分配的内存。</li><li>头结点的指针域始终指向刚插入的结点（开始为NULL除外）。</li><li>每次插入操作需将头结点指针域赋给新结点的指针域，然后头结点指针域指向新结点。这样达到断开头结点与旧结点之间的旧链,而形成头结点与新结点之间新链的效果。</li></ul></li></ul></li><li><p>尾插法建表：</p><ul><li>基本原理：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200722112653.jpg" alt="" /><ul><li>增加一个移动的尾指针，使其一直指向链表的尾结点（开始时指向头结点）</li></ul></li><li>算法：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200722113210.jpg" alt="" /><ul><li>先使用尾指针，使旧尾结点的指针域指向新结点，然后将尾指针指向新结点。</li><li>注意：最后要将尾结点的指针域设置为NULL。</li></ul></li></ul></li></ul><h5 id="求线性表中第i个位置的数据元素"><a class="markdownIt-Anchor" href="#求线性表中第i个位置的数据元素"></a> 求线性表中第i个位置的数据元素</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723094813.jpg" alt="" /></p><ul><li>设置一个移动的指针（最开始指向头结点），在计数（从0开始）的同时，移动指针。</li><li>在找到第i个元素之前，用循环移动指针。（注意控制条件：计数变量比i小，且不能超出链表元素数目）</li></ul><h5 id="按元素值查找"><a class="markdownIt-Anchor" href="#按元素值查找"></a> 按元素值查找</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723095356.jpg" alt="" /></p><ul><li>设置一个移动的指针，从第一个有值域的结点开始查找，每一个元素和所找元素比较，若不相等，则指针向后移。</li></ul><h5 id="求带头单链表的长度"><a class="markdownIt-Anchor" href="#求带头单链表的长度"></a> 求带头单链表的长度</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723095728.jpg" alt="" /></p><ul><li>设置一个移动的指针（开始指向头结点），设置一个计数变量(开始设为0表示头结点的序号为0，不算在数据结点的个数中），每移动一次指针，计数变量加一。</li><li>结束的控制条件：最后一个结点的指针域为NULL。</li></ul><h5 id="在链表的第i个位置插入数据元素"><a class="markdownIt-Anchor" href="#在链表的第i个位置插入数据元素"></a> 在链表的第i个位置插入数据元素</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723100430.jpg" alt="" /></p><ul><li><a href="#%E6%B1%82%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B8%AD%E7%AC%ACi%E4%B8%AA%E4%BD%8D%E7%BD%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0">查找算法</a>和<a href="#%E5%BB%BA%E8%A1%A8">头插法创建链表算法</a>的结合。</li></ul><h5 id="删除链表的第i个位置的数据元素"><a class="markdownIt-Anchor" href="#删除链表的第i个位置的数据元素"></a> 删除链表的第i个位置的数据元素</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723101022.jpg" alt="" /></p><ul><li>查找到第i-1个结点，利用它的指向后继结点的指针域（所以结束查找的条件是找到第i-1个元素或者当前结点的指针域为NULL），来删除第i个结点。</li><li>使用<code>free()</code>来删除一个结点。</li></ul><h5 id="合并两个有序链表为一个有序链表"><a class="markdownIt-Anchor" href="#合并两个有序链表为一个有序链表"></a> 合并两个有序链表为一个有序链表</h5><ul><li><p>占用其中一个链表来合并<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723102129.jpg" alt="" /></p><ul><li>基本原理类似<a href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E7%AE%97%E6%B3%95">二路归并算法</a></li><li>设置两个可移动指针，指向原来两个链表的数据元素。</li><li>新链表头指针指向原来某个链表的头结点，以此来占用该链表的空间。</li></ul></li><li><p>合并为一个全新的链表<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723103937.jpg" alt="" /></p><ul><li>所不同的是每一次插入都需要重新分配空间，故采用<a href="#%E5%BB%BA%E8%A1%A8">尾插法</a>重新建立一个链表。</li><li>最后没有遍历完的结点，需要使用循环来插入新链表中。</li><li>注意最后新链表尾结点的指针域要置为NULL。</li></ul></li></ul><h4 id="循环单链表"><a class="markdownIt-Anchor" href="#循环单链表"></a> 循环单链表</h4><ul><li>找到尾结点的条件变为：<code>p-&gt;next = L</code>。</li><li>结点类型：同单链表</li></ul><h5 id="初始化循环单链表"><a class="markdownIt-Anchor" href="#初始化循环单链表"></a> 初始化循环单链表</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723222629.jpg" alt="" /></p><ul><li>形参为指向头结点指针的指针。</li><li>最开始时，头结点即为尾结点，故头结点的指针域指向自己。</li></ul><h5 id="创建循环单链表"><a class="markdownIt-Anchor" href="#创建循环单链表"></a> 创建循环单链表</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723223045.jpg" alt="" /></p><ul><li>使用尾插法创建循环链表</li><li>最后要将尾结点的指针域设为头结点。</li></ul><h5 id="循环单链表的合并"><a class="markdownIt-Anchor" href="#循环单链表的合并"></a> 循环单链表的合并</h5><ul><li><p>传入两个循环单链表的头指针<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723223617.jpg" alt="" /></p><ul><li>找尾结点的循环：<code>while(p-&gt;next != LA) p = p-&gt;next;</code></li><li>第一个链表的尾结点的指针域设为第二个链表的第一个数据结点（不是头结点），第二个链表的尾结点的指针域设为第一个链表的头结点。</li></ul></li><li><p>传入两个循环单链表的尾指针<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723224057.jpg" alt="" /></p><ul><li>先找到两个链表的头结点，在修改各自尾结点的指针域。</li></ul></li></ul><h4 id="双向链表"><a class="markdownIt-Anchor" href="#双向链表"></a> 双向链表</h4><ul><li>结点类型定义<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200723224256.jpg" alt="" /></li></ul><h5 id="建立双向链表"><a class="markdownIt-Anchor" href="#建立双向链表"></a> 建立双向链表</h5><ul><li><p>头插法建表<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200725220437.jpg" alt="" /></p><ul><li>头结点刚创立时前后驱指针域都设为空<code>(*L)-&gt;prior = (*L)-&gt;next = NULL;</code></li><li>新插入结点的前驱指针域设为头结点，后驱指针域设为原来头结点后原第一个数据结点。<code>s-&gt;next = (*L)-&gt;next; s-&gt;prior = *L</code></li><li>原第一个数据结点的前驱指针需修改为新插入结点<code>(*L)-&gt;next-&gt;prior = s;</code>,头结点的后驱指针域设为新插入结点<code>(*L)-&gt;next = s;</code></li><li>头插法的共性是建成的线性表是逆序的；</li><li>注意：传入函数的是指向头结点指针的指针，又有-&gt;的优先级高于*，所以需使用（*L）。</li></ul></li><li><p>尾插法建表<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200725221517.jpg" alt="" /></p><ul><li>设立一个可移动的尾指针，始终指向当前的尾结点；</li><li>最后注意将尾结点的后驱指针域设为NULL</li><li>相较头插法，只需修改两个结点的三个指针域，修改较少。</li></ul></li><li><p>建表的变式：逆置双向链表<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200725222226.jpg" alt="" /></p><ul><li>本质是头插法的运用;</li><li>需要新设两个可移动指针来扫描原来的链表。</li></ul></li></ul><h5 id="在第i个位置插入数据元素"><a class="markdownIt-Anchor" href="#在第i个位置插入数据元素"></a> 在第i个位置插入数据元素</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200725222900.jpg" alt="" /></p><ul><li>本质是头插法</li><li>查找第i-1个结点即为尾插法</li></ul><h5 id="删除第i个结点"><a class="markdownIt-Anchor" href="#删除第i个结点"></a> 删除第i个结点</h5><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200725223227.jpg" alt="" /></p><ul><li>可以找到第i个结点，也可以找第i-1结点；</li><li>只需修改两个指针；</li></ul><h4 id="循环双向链表"><a class="markdownIt-Anchor" href="#循环双向链表"></a> 循环双向链表</h4><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727110328.jpg" alt="" /></p><ul><li>找到尾结点的条件变为了：<code>L-&gt;next = L</code></li><li>判断循环链表是否对称相等的算法<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727110858.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727111123.jpg" alt="" /><ul><li>设置两个可移动指针分别从链表头尾扫描向中间</li><li>数据结点数目不同，扫描完是两个扫描指针的相对位置不同。为奇数时，最后两个结点指向同一个数据结点<code>p == q</code>;为偶数时，最后两个扫描指针相邻<code>p-&gt;next == q</code>或者<code>p == q-&gt;prior</code></li></ul></li></ul><h3 id="线性表的应用"><a class="markdownIt-Anchor" href="#线性表的应用"></a> 线性表的应用</h3><h4 id="一元多项式的运算"><a class="markdownIt-Anchor" href="#一元多项式的运算"></a> 一元多项式的运算</h4><ul><li>基本原理（一元稀疏多项式的线性表表示）<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727112250.jpg" alt="" /></li><li>单链表储存一元多项式的结点定义<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727112636.jpg" alt="" /></li><li>创建一元多项式单链表存储的算法<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727153633.jpg" alt="" /><ul><li>尾插法创建</li><li>需要申请一个空的头结点</li></ul></li><li>两个一元多项式相加的算法<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727154010.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727154225.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727154452.jpg" alt="" /><ul><li>默认即将要相加的两个一元多项式是按照次数从小到大排好序的。</li><li>从头开始遍历，将指数较小的存入新表，两个的指数相等时系数相加后存入新表。</li><li>采用头插法创建相加后的新表</li></ul></li></ul><h3 id="线性表经典题目"><a class="markdownIt-Anchor" href="#线性表经典题目"></a> 线性表经典题目</h3><h4 id="1删除顺序表中值为x的元素"><a class="markdownIt-Anchor" href="#1删除顺序表中值为x的元素"></a> 1.删除顺序表中值为x的元素</h4><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200727155451.jpg" alt="" /></p><ul><li>先找到第一个值为x的元素</li><li>之后将其后面值不为x的元素逐个前移</li><li>最后修改last的值。因为在移动最后一个元素后，i还加了1，所以<code>L-&gt;last = i-1</code></li></ul><h4 id="2带头结点单链表就地逆置"><a class="markdownIt-Anchor" href="#2带头结点单链表就地逆置"></a> 2.带头结点单链表就地逆置</h4><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200730101814.jpg" alt="" /></p><ul><li>将原来链表的头结点分离出来。</li><li>遍历原来链表的数据结点，然后用头插法插入分离出来的头结点中，从而实现就地逆置。</li></ul><h4 id="3以第一个元素为标准将数据元素分为两边"><a class="markdownIt-Anchor" href="#3以第一个元素为标准将数据元素分为两边"></a> 3.以第一个元素为标准将数据元素分为两边</h4><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200730103614.jpg" alt="" /></p><ul><li>p1为固定指针，始终指向第一个结点，方便其它结点与第一个结点比较大小。</li><li>pre、p、q为一套移动指针，其中p指向当前扫描到的与第一个结点比较大小的结点,q指向当前结点的下一个结点，pre指向当前结点的前一个结点。</li><li>pre的作用是当需要把当前结点移走时，能够使其它两个结点能够连起来。<code>pre-&gt;next = p-&gt;next</code>。</li><li>q的作用一方面是使p能够持续进行扫描，另一方面使在中间结点被移走的情况下协同pre建立边上两个结点的联系。</li></ul><h4 id="4存放一个二进制数的链表"><a class="markdownIt-Anchor" href="#4存放一个二进制数的链表"></a> 4.存放一个二进制数的链表</h4><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731094419.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731095000.jpg" alt="" /></p><ul><li>二进制的加法关键在于找到第一个值为0的位，然后进行01的互换（怪不得计算机要用二进制，确实好操作）</li><li>链表实现加法有两种情况，第一种是，不需增加位数，直接01互换即可；第二种是位数需进一位，此时需要增加一个新结点。</li><li>q指针的作用是扫描链表;r指针的作用是指向为最后一个值域为1的结点，若没有则指向头结点；temp指针的作用是在需要新增一个结点时，指向原来的第一个数据结点，以便与新增结点建立连接。</li></ul><h2 id="第三章-限定性线性表-栈与队列"><a class="markdownIt-Anchor" href="#第三章-限定性线性表-栈与队列"></a> 第三章 限定性线性表-栈与队列</h2><h3 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h3><h4 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h4><ul><li>栈与队列都是特殊的线性表，是操作受限的线性表，称为限定性线性表。</li><li>特点：先进后出（FILO:first in last out）或后进先出（LIFO:last in first out）<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731163004.jpg" alt="" /><ul><li>线性表可以在任意位置插入、删除，而栈只允许在栈顶进行插入或者删除操作，故称为操作受限。</li></ul></li><li>典例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200731163554.jpg" alt="" /></li></ul><h2 id="第九章-内排序"><a class="markdownIt-Anchor" href="#第九章-内排序"></a> 第九章 内排序</h2><h3 id="91-排序的概念"><a class="markdownIt-Anchor" href="#91-排序的概念"></a> 9.1 排序的概念</h3><h4 id="排序的定义"><a class="markdownIt-Anchor" href="#排序的定义"></a> 排序的定义</h4><p>所谓排序，是整理表中的记录，使之按关键字递增（或递减）有序排列。</p><h4 id="内排序与外排序"><a class="markdownIt-Anchor" href="#内排序与外排序"></a> 内排序与外排序</h4><p>在排序过程中，若整个表都是放在内存中处理，排序时不涉及数据的内、外存交换，则称之为<strong>内排序</strong>；反之，若排序过程中要进行数据的内、外存交换，则称之为<strong>外排序</strong>。</p><h4 id="内排序"><a class="markdownIt-Anchor" href="#内排序"></a> 内排序</h4><h5 id="内排序的分类"><a class="markdownIt-Anchor" href="#内排序的分类"></a> 内排序的分类</h5><ol><li>基于比较的排序算法<ol><li>插入排序</li><li>交换排序</li><li>选择排序</li><li>归并排序</li></ol></li><li>不基于比较的排序算法<ol><li>基数排序</li></ol></li></ol><h5 id="-基于比较的内排序的时间复杂度"><a class="markdownIt-Anchor" href="#-基于比较的内排序的时间复杂度"></a> ?-&gt;基于比较的内排序的时间复杂度</h5><ul><li>最好的平均时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li>最好情况是排序序列正序，此时时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><h5 id="内排序算法的稳定性"><a class="markdownIt-Anchor" href="#内排序算法的稳定性"></a> 内排序算法的稳定性</h5><ul><li>如果待排序的表中，存在有多个关键字相同的记录，经过排序后这些具有相同关键字的记录之间的相对次序保持不变，则称这种排序方法是<strong>稳定</strong>的。</li><li>反之，若具有相同关键字的记录之间的相对次序发生变化，则称这种排序方法是<strong>不稳定</strong>的。</li></ul><h5 id="正序与反序"><a class="markdownIt-Anchor" href="#正序与反序"></a> 正序与反序</h5><ul><li>若待排序的表中元素已按关键字排好序，称此表中元素为正序；</li><li>反之，若待排序的表中元素的关键字顺序正好和排好序的顺序相反，称此表中元素为反序。</li><li>有一些排序算法与初始序列的正序或反序有关，另一些排序算法与初始序列的情况无关。</li></ul><h5 id="内排序数据的组织"><a class="markdownIt-Anchor" href="#内排序数据的组织"></a> 内排序数据的组织</h5><p>待排序顺序表的数据元素类型定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct&#123;    KeyType key; &#x2F;&#x2F;关键字项    InfoType data; &#x2F;&#x2F;其它数据项&#125;RecType; &#x2F;&#x2F; 排序的记录类型定义</code></pre><h3 id="92-插入排序"><a class="markdownIt-Anchor" href="#92-插入排序"></a> 9.2 插入排序</h3><h4 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h4><ul><li>基本原理：将无序区的元素逐个插入有序区（局部有序）</li><li>分类：<ol><li>直接插入排序</li><li>折半插入排序</li><li>希尔排序</li></ol></li></ul><h4 id="1直接插入排序"><a class="markdownIt-Anchor" href="#1直接插入排序"></a> 1.直接插入排序</h4><ul><li><p>基本原理：插入排序通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入 ，如此重复，直至完成序列排序。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200630103424.jpg" alt="" /></p></li><li><p>算法分析：</p><ol><li>从序列第一个元素开始，该元素可以认为已经被排序（即有序区第一个元素）</li><li>取出下一个元素，设为待插入元素（即放入临时区：因为需要在有序区中插入一个元素，所以有序区得扩充一格，而临时区既能放置未找到位置的新入元素，又能为之后有序区元素的后移提供操作空间），在已经排序的元素序列中从后向前扫描，如果该元素（已排序）大于待插入元素，将该元素移到下一位置。</li><li>重复步骤2，直到找到已排序的元素小于或者等于待排序元素的位置，插入元素。</li><li>重复2，3步骤，完成排序。（得有两个循环嵌套）</li></ol></li><li><p>实例演示：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200630103537.png" alt="" /></p><ol><li>默认序列的第一个元素12已经被排序</li><li>取下一元素 15，从后往前与已排序序列一次比较，15插入12 之后，已排序序列为[12，15]。</li><li>取下一元素9，重复2步骤，将9插12 之前，已排序序列为[9，12，15]。</li><li>循环上述操作，直至最后一个元素24，插入合适位置，完成排序。</li></ol></li><li><p>直接插入排序代码（c)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void InsertSort(RecType R[],int n)&#123;   int i,j;   RecType temp；   for(i &#x3D; 1; i &lt; n; i++)&#123;      temp &#x3D; R[i]; &#x2F;&#x2F; 将取出的无序区元素放入临时区      j &#x3D; i - 1;   &#x2F;&#x2F; 找到有序区最后一个元素      while(j &gt;&#x3D; 0 &amp;&amp; R[j] &gt; temp)&#123;         R[j + 1] &#x3D; R[j];         j--;      &#125; &#x2F;&#x2F;从后往前逐个扫描有序区元素，直到找到比新入元素小或者相等的元素，同时将比新入元素大的元素这个往后移一位      R[j] &#x3D; temp; &#x2F;&#x2F;将新入元素插入扫描找到的元素之后   &#125;&#125;</code></pre></li><li><p>性能分析</p><ul><li>时间复杂度：<ul><li>最好的情况（正序排列）：比较<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>次（每个元素只与自己前面的元素比一次，而第一个元素没有前面的元素），时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>最坏的情况（反序排列）：比较<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n(n-1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>次（每个元素需与自己前面所有元素比一次），时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>平均时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul></li><li>空间复杂度：<ul><li>只有一个临时元素，故空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul></li><li>算法稳定性：<ul><li>直接插入排序是稳定的排序算法</li></ul></li></ul></li></ul><h4 id="2折半插入排序二分插入排序"><a class="markdownIt-Anchor" href="#2折半插入排序二分插入排序"></a> 2.折半插入排序（二分插入排序）</h4>]]></content>
      
      
      <categories>
          
          <category> 专业基础 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第九章 内排序</title>
      <link href="//post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%86%85%E6%8E%92%E5%BA%8F/index.html"/>
      <url>//post/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%86%85%E6%8E%92%E5%BA%8F/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="第九章-内排序"><a class="markdownIt-Anchor" href="#第九章-内排序"></a> 第九章 内排序</h1><h2 id="91-排序的概念"><a class="markdownIt-Anchor" href="#91-排序的概念"></a> 9.1 排序的概念</h2><h3 id="排序的定义"><a class="markdownIt-Anchor" href="#排序的定义"></a> 排序的定义</h3><p>所谓排序，是整理表中的记录，使之按关键字递增（或递减）有序排列。</p><h3 id="内排序与外排序"><a class="markdownIt-Anchor" href="#内排序与外排序"></a> 内排序与外排序</h3><p>在排序过程中，若整个表都是放在内存中处理，排序时不涉及数据的内、外存交换，则称之为<strong>内排序</strong>；反之，若排序过程中要进行数据的内、外存交换，则称之为<strong>外排序</strong>。</p><h3 id="内排序"><a class="markdownIt-Anchor" href="#内排序"></a> 内排序</h3><h4 id="内排序的分类"><a class="markdownIt-Anchor" href="#内排序的分类"></a> 内排序的分类</h4><ol><li>基于比较的排序算法<ol><li>插入排序</li><li>交换排序</li><li>选择排序</li><li>归并排序</li></ol></li><li>不基于比较的排序算法<ol><li>基数排序</li></ol></li></ol><h4 id="-基于比较的内排序的时间复杂度"><a class="markdownIt-Anchor" href="#-基于比较的内排序的时间复杂度"></a> ?-&gt;基于比较的内排序的时间复杂度</h4><ul><li>最好的平均时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li>最好情况是排序序列正序，此时时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="内排序算法的稳定性"><a class="markdownIt-Anchor" href="#内排序算法的稳定性"></a> 内排序算法的稳定性</h4><ul><li>如果待排序的表中，存在有多个关键字相同的记录，经过排序后这些具有相同关键字的记录之间的相对次序保持不变，则称这种排序方法是<strong>稳定</strong>的。</li><li>反之，若具有相同关键字的记录之间的相对次序发生变化，则称这种排序方法是<strong>不稳定</strong>的。</li></ul><h4 id="正序与反序"><a class="markdownIt-Anchor" href="#正序与反序"></a> 正序与反序</h4><ul><li>若待排序的表中元素已按关键字排好序，称此表中元素为正序；</li><li>反之，若待排序的表中元素的关键字顺序正好和排好序的顺序相反，称此表中元素为反序。</li><li>有一些排序算法与初始序列的正序或反序有关，另一些排序算法与初始序列的情况无关。</li></ul><h4 id="内排序数据的组织"><a class="markdownIt-Anchor" href="#内排序数据的组织"></a> 内排序数据的组织</h4><p>待排序顺序表的数据元素类型定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct&#123;    KeyType key; &#x2F;&#x2F;关键字项    InfoType data; &#x2F;&#x2F;其它数据项&#125;RecType; &#x2F;&#x2F; 排序的记录类型定义</code></pre><h2 id="92-插入排序"><a class="markdownIt-Anchor" href="#92-插入排序"></a> 9.2 插入排序</h2><h3 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h3><ul><li>基本原理：将无序区的元素逐个插入有序区（局部有序）</li><li>分类：<ol><li>直接插入排序</li><li>折半插入排序</li><li>希尔排序</li></ol></li></ul><h3 id="1直接插入排序"><a class="markdownIt-Anchor" href="#1直接插入排序"></a> 1.直接插入排序</h3><ul><li><p>基本原理：插入排序通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入 ，如此重复，直至完成序列排序。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200630103424.jpg" alt="" /></p></li><li><p>算法分析：</p><ol><li>从序列第一个元素开始，该元素可以认为已经被排序（即有序区第一个元素）</li><li>取出下一个元素，设为待插入元素（即放入临时区：因为需要在有序区中插入一个元素，所以有序区得扩充一格，而临时区既能放置未找到位置的新入元素，又能为之后有序区元素的后移提供操作空间），在已经排序的元素序列中从后向前扫描，如果该元素（已排序）大于待插入元素，将该元素移到下一位置。</li><li>重复步骤2，直到找到已排序的元素小于或者等于待排序元素的位置，插入元素。</li><li>重复2，3步骤，完成排序。（得有两个循环嵌套）</li></ol></li><li><p>实例演示：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200630103537.png" alt="" /></p><ol><li>默认序列的第一个元素12已经被排序</li><li>取下一元素 15，从后往前与已排序序列一次比较，15插入12 之后，已排序序列为[12，15]。</li><li>取下一元素9，重复2步骤，将9插12 之前，已排序序列为[9，12，15]。</li><li>循环上述操作，直至最后一个元素24，插入合适位置，完成排序。</li></ol></li><li><p>直接插入排序代码（c)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void InsertSort(RecType R[],int n)&#123;   int i,j;   RecType temp；   for(i &#x3D; 1; i &lt; n; i++)&#123;      temp &#x3D; R[i]; &#x2F;&#x2F; 将取出的无序区元素放入临时区      j &#x3D; i - 1;   &#x2F;&#x2F; 找到有序区最后一个元素      while(j &gt;&#x3D; 0 &amp;&amp; R[j] &gt; temp)&#123;         R[j + 1] &#x3D; R[j];         j--;      &#125; &#x2F;&#x2F;从后往前逐个扫描有序区元素，直到找到比新入元素小或者相等的元素，同时将比新入元素大的元素这个往后移一位      R[j] &#x3D; temp; &#x2F;&#x2F;将新入元素插入扫描找到的元素之后   &#125;&#125;</code></pre></li><li><p>性能分析</p><ul><li>时间复杂度：<ul><li>最好的情况（正序排列）：比较<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>次（每个元素只与自己前面的元素比一次，而第一个元素没有前面的元素），时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>最坏的情况（反序排列）：比较<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n(n-1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>次（每个元素需与自己前面所有元素比一次），时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>平均时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul></li><li>空间复杂度：<ul><li>只有一个临时元素，故空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li></ul></li><li>算法稳定性：<ul><li>直接插入排序是稳定的排序算法</li></ul></li></ul></li></ul><h3 id="2折半插入排序二分插入排序"><a class="markdownIt-Anchor" href="#2折半插入排序二分插入排序"></a> 2.折半插入排序（二分插入排序）</h3>]]></content>
      
      
      <categories>
          
          <category> 专业基础 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Linux/Linux%E5%9F%BA%E7%A1%80/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Linux/Linux%E5%9F%BA%E7%A1%80/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> Linux</h1><p><a href="https://www.runoob.com/linux/linux-command-manual.html">linux命令参考</a></p><h2 id="一-操作系统简介"><a class="markdownIt-Anchor" href="#一-操作系统简介"></a> 一、操作系统简介</h2><p><a href="http://mirrors.aliyun.com/ubuntu-releases/">ubuntu阿里云镜像地址</a></p><ul><li>计算机是一台机器，它按照用户的要求接收信息、存储数据、处理数据，然后再将处理结果输出（文字、图片、音频、视频等）。计算机由硬件和软件组成。</li><li>操作系统（Operating System，OS）是软件的一部分，它是硬件基础上的第一层软件，是硬件和其它软件沟通的桥梁（或者说接口、中间人、中介等）。</li><li>操作系统会控制其他程序运行，管理系统资源，提供最基本的计算功能，如管理及配置内存、决定系统资源供需的优先次序等，同时还提供一些基本的服务程序，例如：<ol><li><strong>文件系统</strong>：提供计算机存储信息的结构，信息存储在文件中，文件主要存储在计算机的内部硬盘里，在目录的分层结构中组织文件。文件系统为操作系统提供了组织管理数据的方式。</li><li><strong>设备驱动程序</strong>：提供连接计算机的每个硬件设备的接口，设备驱动器使程序能够写入设备，而不需要了解执行每个硬件的细节。</li><li><strong>用户接口</strong>：操作系统需要为用户提供一种运行程序和访问文件系统的方法。如常用的 Windows 图形界面，可以理解为一种用户与操作系统交互的方式；智能手机的 Android 或 iOS 系统，也是一种操作系统的交互方式。</li><li><strong>系统服务程序</strong>: 当计算机启动时，会自启动许多系统服务程序，执行安装文件系统、启动网络服务、运行预定任务等操作。</li></ol></li></ul><p>概览：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200621095426.png" alt="" /></p><h2 id="二-linux简介"><a class="markdownIt-Anchor" href="#二-linux简介"></a> 二、Linux简介</h2><h3 id="linux历史概述"><a class="markdownIt-Anchor" href="#linux历史概述"></a> Linux历史概述</h3><p>Linux内核最初是由李纳斯•托瓦兹（Linus Torvalds）在赫尔辛基大学读书时出于个人爱好而编写的，当时他觉得教学用的迷你版UNIX操作系统Minix太难用了，于是决定自己开发一个操作系统。第1版本于1991年9月发布，当时仅有10000行代码。李纳斯•托瓦兹没有保留Linux源代码的版权，公开了代码，并邀请他人一起完善Linux。与Windows及其他有专利权的操作系统不同，Linux开放源代码，任何人都可以免费使用它。</p><h3 id="linux版本"><a class="markdownIt-Anchor" href="#linux版本"></a> Linux版本</h3><ul><li>Linux的版本分为<strong>内核版本</strong>和<strong>发行版本</strong>。</li><li>Linux有上百种不同的发行版，如基于社区开发的debian、archlinux，和基于商业开发的Red Hat Enterprise Linux、SUSE、Oracle Linux等。</li></ul><h3 id="linux特性"><a class="markdownIt-Anchor" href="#linux特性"></a> Linux特性</h3><h4 id="开源性"><a class="markdownIt-Anchor" href="#开源性"></a> 开源性</h4><p>大都为开源自由软件，用户可以修改定制和再发布，由于基本免费没有资金支持，部分软件质量和体验欠缺；由全球所有的 Linux 开发者和自由软件社区提供支持。</p><h4 id="操作特性"><a class="markdownIt-Anchor" href="#操作特性"></a> 操作特性</h4><p>兼具图形界面操作（需要使用带有桌面环境的发行版）和完全的命令行操作，可以只用键盘完成一切操作，新手入门较困难，需要一些学习和指导，一旦熟练之后效率极高。</p><h4 id="多用户-多任务性"><a class="markdownIt-Anchor" href="#多用户-多任务性"></a> 多用户、多任务性</h4><p>Linux支持多用户，各个用户对于自己的文件设备有自己特殊的权利，保证了各用户之间互不影响。多任务则是现在电脑最主要的一个特点，Linux可以使多个程序同时并独立地运行。</p><h4 id="多平台性"><a class="markdownIt-Anchor" href="#多平台性"></a> 多平台性</h4><p>Linux可以运行在多种硬件平台上，如具有x86、680x0、SPARC、Alpha等处理器的平台。此外Linux还是一种嵌入式操作系统，可以运行在掌上电脑、机顶盒或游戏机上。</p><h4 id="可定制性"><a class="markdownIt-Anchor" href="#可定制性"></a> 可定制性</h4><p>Linux系统是完全开放、免费的。正是由于开放性，它可以任意修改源代码，定制用户所需的系统，这是其他系统所不具备的。</p><h3 id="选择linux的原因"><a class="markdownIt-Anchor" href="#选择linux的原因"></a> 选择Linux的原因</h3><h4 id="linux的应用"><a class="markdownIt-Anchor" href="#linux的应用"></a> Linux的应用</h4><ul><li><p>服务器领域：<br />Linux作为企业级服务器的应用十分广泛，利用Linux系统可以为企业构架WWW服务器、数据库服务器、负载均衡服务器、邮件服务器、DNS服务器、代理服务器(透明网关)、路由器等。大型、超大型互联网企业(百度、新浪、淘宝等)都在使用Linux系统作为其服务器端的程序运行平台，全球及国内排名前十的网站使用的几乎都是Linux系统。</p></li><li><p>嵌入式领域：<br />在嵌入式应用的领域里，从因特网设备(路由器、交换机、防火墙、负载均衡器等)到专用的控制系统(自动售货机、手机、PDA、各种家用电器等)，Linux操作系统都有很广阔的应用市场。例如，在智能手机领域，Android Linux已经在智能手机开发平台牢牢地占据了一席之地。</p></li></ul><h4 id="linux相对windows的优点"><a class="markdownIt-Anchor" href="#linux相对windows的优点"></a> Linux相对Windows的优点</h4><ul><li><p>命令行操作：<br />Linux兼具图形界面操作（需要使用带有桌面环境的发行版）和<strong>完全的命令行操作</strong>，可以只用键盘完成一切操作。一旦熟悉命令行操作，用户使用计算机的效率可以得到大幅提高。同时，使用命令行操作对程序员来说能更好地理解计算机的运行原理。</p></li><li><p>安全性：<br />相对于Windows，Linux更加的安全稳定。虽然不能说Linux一定不会受到病毒侵袭，但Linux比起Windows肯定要安全得多，而且不需要装各种杀毒软件便能正常工作。</p></li><li><p>费用低廉：<br />Linux 系统上有着大量的可用软件，且绝大多数是免费的，比如声名赫赫的 Apache、Samba、PHP、MySQL 等。从系统到软件，Linux基本都是免费的。而反观Windows却从系统到一些专业软件每一项都需花费上千元。</p></li></ul><h2 id="三-linux的安装及配置"><a class="markdownIt-Anchor" href="#三-linux的安装及配置"></a> 三、Linux的安装及配置</h2><h3 id="windows环境下使用vmware安装ubuntu"><a class="markdownIt-Anchor" href="#windows环境下使用vmware安装ubuntu"></a> Windows环境下使用VMware安装Ubuntu</h3><ol><li>下载安装VMware workstation pro（使用密钥激活）</li><li>下载Ubuntu20.04镜像文件（.iso文件）</li><li>创建虚拟机</li></ol><h3 id="ubuntu配置及美化"><a class="markdownIt-Anchor" href="#ubuntu配置及美化"></a> Ubuntu配置及美化</h3><h4 id="修改软件源并更新系统"><a class="markdownIt-Anchor" href="#修改软件源并更新系统"></a> 修改软件源并更新系统</h4><ul><li>Ubuntu 默认的软件源是境外的，速度上会有些问题，我们可以在「Software &amp; Updates」(软件和更新)中选择国内的镜像（例如阿里云）。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200622202631.jpg" alt="" /></li><li>修改软件源后需要进行更新<pre class="line-numbers language-none"><code class="language-none">sudo apt update &#x2F;&#x2F;更新本地包数据库sudo apt upgrade &#x2F;&#x2F;更新所有已安装的包sudo apt autoremove &#x2F;&#x2F;自动移除不需要的包</code></pre></li></ul><h4 id="桌面美化"><a class="markdownIt-Anchor" href="#桌面美化"></a> 桌面美化</h4><h5 id="安装gnome-tweak-tool及插件"><a class="markdownIt-Anchor" href="#安装gnome-tweak-tool及插件"></a> 安装gnome-tweak-tool及插件</h5><ul><li>gnome-tweak-tool可以进行对Gnome shell主题的安装和更改<br />gnome-shell-extensions 让 gnome 支持插件扩展<br />chrome-gnome-shell 浏览器扩展支持，可以使用浏览器安装插件</li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;安装gnome-tweak-tool及安装插件所需工具命令sudo apt install gnome-tweak-tool sudo apt install gnome-shell-extensions sudo apt install chrome-gnome-shell</code></pre><ul><li>进入<a href="https://extensions.gnome.xn--org-wu9dw88cvwl156d">https://extensions.gnome.org安装插件</a><br />插件列表：<br />dash to dock //自定义dock栏<br />user themes // 可自由安装主题<br />hide top bar // 自动隐藏状态栏</li></ul><h5 id="下载安装主题及配套图标"><a class="markdownIt-Anchor" href="#下载安装主题及配套图标"></a> 下载安装主题及配套图标</h5><ul><li>下载主题（os-catalina-gtk)并解压到/usr/share/themes/(主题网站<a href="https://www.gnome-look.org">https://www.gnome-look.org</a>)</li><li>在tweak中启动主题</li><li>下载图标并解压到/usr/share/icons（图标网址:<a href="https://www.opendesktop.org/s/Gnome/p/1102582/%EF%BC%89">https://www.opendesktop.org/s/Gnome/p/1102582/）</a></li><li>在tweak中启用图标</li><li>下载壁纸并使用（壁纸下载地址：<a href="https://pixabay.com">https://pixabay.com</a> <a href="https://unsplash.com">https://unsplash.com</a> <a href="https://wallpapersite.com">https://wallpapersite.com</a> <a href="https://wallpapershome.com">https://wallpapershome.com</a>）</li><li>最终效果图：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200623091036.jpg" alt="" /></li></ul><h4 id="命令行工具配置及美化"><a class="markdownIt-Anchor" href="#命令行工具配置及美化"></a> 命令行工具配置及美化</h4><ul><li>安装Terminator</li></ul><pre class="line-numbers language-none"><code class="language-none">sudo add-apt-repository ppa:gnome-terminatorsudo apt updatesudo apt install terminator</code></pre><p>可以对Terminnator进行个性化设置（如背景透明，字体颜色等）</p><ul><li>安装zsh同时将zsh设为默认shell</li></ul><pre class="line-numbers language-none"><code class="language-none">sudo apt install zsh  &#x2F;&#x2F;安装zshsudo chsh -s $(which zsh) &#x2F;&#x2F;将zsh设为默认shell</code></pre><ul><li>使用oh-my-zsh配置zsh</li></ul><pre class="line-numbers language-none"><code class="language-none">git clone git:&#x2F;&#x2F;github.com&#x2F;robbyrussell&#x2F;oh-my-zsh.git ~&#x2F;.oh-my-zsh &#x2F;&#x2F;从GitHub下载oh-my-zshcp ~&#x2F;.oh-my-zsh&#x2F;templates&#x2F;zshrc.zsh-template ~&#x2F;.zshrc &#x2F;&#x2F;启用oh-my-zsh</code></pre><ul><li>安装zsh插件<ul><li>下载zsh-autosuggestions:命令行命令键入时的历史命令建议插件</li></ul> <pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;zsh-users&#x2F;zsh-autosuggestions $&#123;ZSH_CUSTOM:-~&#x2F;.oh-my-zsh&#x2F;custom&#125;&#x2F;plugins&#x2F;zsh-autosuggestions</code></pre><ul><li>下载zsh-syntaxhighting: 命令行语法高亮插件</li></ul> <pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;zsh-users&#x2F;zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~&#x2F;.oh-my-zsh&#x2F;custom&#125;&#x2F;plugins&#x2F;zsh-syntax-highlighting</code></pre><ul><li>启用插件</li></ul> <pre class="line-numbers language-none"><code class="language-none">vi ~&#x2F;.zshrc &#x2F;&#x2F;打开~&#x2F;.zshrc 文件plugins&#x3D;(其他插件名  zsh-autosuggestions zsh-syntax-highlighting) &#x2F;&#x2F;在plugins这一行加上下载的插件名）</code></pre></li></ul><p>最终效果：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200623171216.jpg" alt="" /></p><h4 id="安装一些实用软件"><a class="markdownIt-Anchor" href="#安装一些实用软件"></a> 安装一些实用软件</h4><ul><li>vim编辑器<pre class="line-numbers language-none"><code class="language-none">sudo apt-get install vim</code></pre></li><li>Git:从GitHub上克隆需要Git<pre class="line-numbers language-none"><code class="language-none">sudo apt install git</code></pre></li></ul><h2 id="四-linux基本概念及基本操作"><a class="markdownIt-Anchor" href="#四-linux基本概念及基本操作"></a> 四、Linux基本概念及基本操作</h2><h3 id="1linux终端"><a class="markdownIt-Anchor" href="#1linux终端"></a> 1.Linux终端</h3><ul><li>终端的概念：通常我们在使用 Linux 时，并不是直接与系统打交道，而是通过一个叫做 Shell 的中间程序来完成的，在图形界面下为了实现让我们在一个窗口中完成用户输入和显示输出，Linux 系统还提供了一个叫做终端模拟器的程序（Terminal）。 下面是几个比较常见的终端模拟器： gnome-terminal，Konsole，xterm，rxvt，kvt，nxterm 和 eterm 。</li><li>终端本质上是对应着 Linux 上的 /dev/tty 设备，Linux 的多用户登录就是通过不同的 /dev/tty 设备完成的，Linux 默认提供了 6 个纯命令行界面的 “terminal”（准确的说这里应该是 6 个 virtual consoles）来让用户登录。可以通过使用[Ctrl]+[Alt]+[F1]～[F6]进行切换。<ul><li>示例：<br />ctrl+alt+F1<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200626190729.jpg" alt="" /><br />ctrl+alt+F2<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200626190732.jpg" alt="" /><br />crtl+alt+F3<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200626190731.jpg" alt="" /><br />crtl+alt+F4<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200626190730.jpg" alt="" /></li></ul></li></ul><h3 id="2shell"><a class="markdownIt-Anchor" href="#2shell"></a> 2.shell</h3><ul><li>通常在图形界面中对实际体验带来差异的不是上述的不同发行版的各种终端模拟器，而是这个 Shell（壳）。有壳就有核，这里的核就是指 UNIX/Linux 内核，Shell 是指“提供给使用者使用界面”的软件（命令解析器），类似于 DOS 下的 command（命令行）和后来的 cmd.exe 。普通意义上的 Shell 就是可以接受用户输入命令的程序。它之所以被称作 Shell 是因为它隐藏了操作系统底层的细节。同样的 UNIX/Linux 下的图形用户界面 GNOME 和 KDE，有时也被叫做“虚拟 shell”或“图形 shell”。</li><li>在 UNIX/Linux 中比较流行的常见的 Shell 有 bash、zsh、ksh、csh 等等（美化中将bash换为了zsh)，Ubuntu 终端默认使用的是 bash，默认的桌面环境是 GNOME 或者 Unity（基于 GNOME）。</li></ul><h3 id="3命令行基本操作"><a class="markdownIt-Anchor" href="#3命令行基本操作"></a> 3.命令行基本操作</h3><ul><li>命令：在 linux 中，最最重要的就是命令，这就包含了 2 个过程，输入和输出。<ul><li>输入：输入当然就是打开终端，然后按键盘输入，然后按回车。</li><li>输出：输出会返回你想要的结果，比如你要看什么文件，就会返回文件的内容。如果只是执行，执行失败会告诉你哪里错了，如果执行成功那么会没有输出。</li></ul></li><li>常用命令行快捷键</li></ul><table><thead><tr><th>按键</th><th>作用</th></tr></thead><tbody><tr><td>↑</td><td>显示历史命令</td></tr><tr><td>Tab</td><td>补全命令，目录，命令参数</td></tr><tr><td>CTRL+c</td><td>终止当前程序</td></tr><tr><td>CTRL+d</td><td>终止当前程序/键盘输入结束/退出终端</td></tr><tr><td>CTRL+s</td><td>暂停当前程序，暂停后按任意键恢复运行</td></tr><tr><td>CTRL+z</td><td>将当前程序放到后台运行，恢复到前台命令为fg</td></tr><tr><td>CTRL+a</td><td>将光标移至输入的行头</td></tr><tr><td>CTRL+e</td><td>将光标移至输入的行尾</td></tr><tr><td>CTRL+k</td><td>删除从光标所在位置到行末的输入</td></tr><tr><td>ALT+Backspace</td><td>删除输入中的一个单词（以空格为区分）</td></tr></tbody></table><ul><li>man命令（获取用户手册）<ul><li>在 Linux 环境中，如果你遇到困难，可以使用man命令，它是Manual pages的缩写。Manual pages 是 UNIX 或类 UNIX 操作系统中在线软件文档的一种普遍的形式， 内容包括计算机程序（包括库和系统调用）、正式的标准和惯例，甚至是抽象的概念。用户可以通过执行man命令调用手册页。</li><li>man命令基本使用方法：<code>man command_name</code></li></ul></li></ul><h3 id="4通配符"><a class="markdownIt-Anchor" href="#4通配符"></a> 4.通配符</h3><ul><li>通配符概念：<ul><li>通配符是一种特殊语句，主要有星号（*）和问号（?），用来对字符串进行模糊匹配（比如文件名、参数名）。</li><li>当查找文件夹时，可以使用它来代替一个或多个真正字符；当不知道真正字符或者懒得输入完整名字时，常常使用通配符代替一个或多个真正字符。</li><li>终端里面输入的通配符是由 Shell 处理的，不是由所涉及的命令语句处理的，它只会出现在命令的“参数值”里（它不能出现在命令名称里， 命令不记得，那就用Tab补全）。当 Shell 在“参数值”中遇到了通配符时，Shell 会将其当作路径或文件名在磁盘上搜寻可能的匹配：若符合要求的匹配存在，则进行代换（路径扩展）；否则就将该通配符作为一个普通字符传递给“命令”，然后再由命令进行处理。总之，通配符实际上就是一种 Shell 实现的路径扩展功能。在通配符被处理后， Shell 会先完成该命令的重组，然后继续处理重组后的命令，直至执行该命令。</li></ul></li><li>例如通配符<code>*</code>:匹配零或多个字符<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200626205113.jpg" alt="" /></li></ul><h2 id="五-linux用户及用户组管理"><a class="markdownIt-Anchor" href="#五-linux用户及用户组管理"></a> 五、Linux用户及用户组管理</h2><ul><li>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</li><li>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</li><li>每个用户账号都拥有一个唯一的用户名和各自的口令(password)。</li><li>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。</li></ul><h3 id="1查看用户"><a class="markdownIt-Anchor" href="#1查看用户"></a> 1.查看用户</h3><ul><li><code>who</code>命令查看用户：</li><li><code>who</code>命令的常用参数：</li></ul><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>打印全部信息</td></tr><tr><td>-d</td><td>打印死掉的进程</td></tr><tr><td>-m</td><td>显示当前伪终端用户的用户名</td></tr><tr><td>-q</td><td>打印当前登录的用户数和用户名</td></tr><tr><td>-u</td><td>打印当前登录用户的登录信息</td></tr><tr><td>-r</td><td>打印运行等级</td></tr></tbody></table><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200626220100.jpg" alt="" /><br />注：<code>whoami</code>命令可查看当前登录用户的用户名</p><h3 id="2创建用户"><a class="markdownIt-Anchor" href="#2创建用户"></a> 2.创建用户</h3><ul><li>root账户：在 Linux 系统里， root 账户拥有整个系统至高无上的权限，比如新建和添加用户。</li><li><code>sudo</code>命令：一般我们登录系统时都是以普通账户的身份登录的，要创建用户需要 root 权限，这里就要用到 sudo 这个命令了。<code>sudo &lt;cmd&gt; </code>可以以特权级别运行 cmd 命令，需要当前用户属于 sudo 组，且需要输入当前用户的密码（注：Linux环境输入密码不会有显示）</li><li><code>su</code>命令：<code>su &lt;user&gt; </code>可以切换到用户 user，执行时需要输入目标用户的密码；<code>su - &lt;user&gt; </code>命令也是切换用户，但是同时用户的环境变量和工作目录也会跟着改变成目标用户所对应的。</li><li>创建用户：<code>sudo adduser uername</code></li><li>切换用户：<code>su username</code><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200626222428.jpg" alt="" /></li></ul><h3 id="3用户组"><a class="markdownIt-Anchor" href="#3用户组"></a> 3.用户组</h3><ul><li>用户组简介：在 Linux 里面每个用户都有一个归属（用户组），用户组简单地理解就是一组用户的集合，它们共享一些资源和权限，同时拥有私有资源。</li><li>查看用户组：<ul><li>法一：<code>groups + username</code><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200628180051.jpg" alt="" /><br />其中冒号之前表示用户，后面表示该用户所属的用户组。每次新建用户如果不指定用户组的话，默认会自动创建一个与用户名相同的用户组（差不多就相当于家长的意思）。</li><li>法二：<code>cat /etc/group </code>(查看/etc/group目录)<ul><li>/etc/group 的内容包括用户组（Group）、用户组口令、GID（组 ID） 及该用户组所包含的用户（User），每个用户组一条记录。格式如下:<blockquote><p>group_name:password:GID:user_list</p></blockquote></li><li>示例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200628180842.jpg" alt="" /><br />你看到上面的 password 字段为一个 x，并不是说密码就是它，只是表示密码不可见而已。这里需要注意，如果用户的 GID 等于用户组的 GID，那么最后一个字段 user_list 就是空的</li></ul></li></ul></li></ul><h3 id="删除用户和用户组"><a class="markdownIt-Anchor" href="#删除用户和用户组"></a> 删除用户和用户组</h3><ul><li>删除用户：<code>sudo deluser username --remove-home</code></li><li>删除用户组：<code>sudo groupdel username --remove-home</code></li></ul><h2 id="六-linux文件类型及权限"><a class="markdownIt-Anchor" href="#六-linux文件类型及权限"></a> 六、Linux文件类型及权限</h2><h3 id="文件类型"><a class="markdownIt-Anchor" href="#文件类型"></a> 文件类型</h3><ol><li>普通文件(regular file)：一般存取的文件。大致可分为<ol><li>纯文本文件(ASCII)：这是Unix系统中最多的一种文件类型，之所以称为纯文本文件，是因为内容可以直接读到的数据，例如数字、字母等等。设 置文件几乎都属于这种文件类型。</li><li>二进制文件(binary)：系统其实仅认识且可以执行二进制文件(binary file)。Linux中的可执行文件(脚本，文本方式的批处理文件不算)就是这种格式的。举例来说，命令cat就是一个二进制文件。</li><li>数据格式的文件(data)：有些程序在运行过程中，会读取某些特定格式的文件，那些特定格式的文件可以称为数据文件(data file)。</li></ol></li><li>目录文件(directory)：就是目录。</li><li>软链接文件(link)：类似Windows下面的快捷方式。</li><li>设备与设备文件(device)：与系统外设及存储等相关的一些文件，通常都集中在 /dev目录。通常又分为两种：<ol><li>块设备文件：就是存储数据以供系统存取的接口设备，简单而言就是硬盘。</li><li>字符设备文件：即串行端口的接口设备，例如键盘、鼠标等等。</li></ol></li><li>套接字(sockets)：这类文件通常用在网络数据连接。可以启动一个程序来监听客户端的要求，客户端就可以通过套接字来进行数据通信。</li><li>管道(FIFO,pipe)：FIFO是first-in-first-out(先进先出)的缩写。管道分为匿名管道和命名管道。管道都是一端写入、另一端读取，它们是单方向数据传输的，它们的数据都是直接在内存中传输的，管道是进程间通信的一种方式，例如父进程写，子进程读。</li></ol><h3 id="文件权限"><a class="markdownIt-Anchor" href="#文件权限"></a> 文件权限</h3><ul><li>文件权限就是文件的访问控制权限，即哪些用户和组群可以访问文件以及可以执行什么样的操作。</li><li>Unix/Linux 系统是一个典型的多用户系统，不同的用户处于不同的地位，对文件和目录有不同的访问权限。为了保护系统的安全性，Unix/Linux 系统除了对用户权限作了严格的界定外，还在用户身份认证、访问控制、传输安全、文件读写权限等方面作了周密的控制。</li><li>在 Unix/Linux 中的每一个文件或目录都包含有访问权限，这些访问权限决定了谁能访问和如何访问这些文件和目录。</li></ul><h3 id="查看文件管理权限"><a class="markdownIt-Anchor" href="#查看文件管理权限"></a> 查看文件管理权限</h3><ul><li>使用<code>ls</code>命令(ls相当于list的缩写)<ul><li><code>ls -l</code>使用较长格式列出文件<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200629152013.jpg" alt="" /></li><li>参数含义：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200629152159.png" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200629152204.png" alt="" /></li><li>文件权限：<ul><li>读权限，表示你可以使用 <code>cat &lt;file name&gt;</code> 之类的命令来读取某个文件的内容；</li><li>写权限，表示你可以编辑和修改某个文件的内容；</li><li>执行权限，通常指可以运行的二进制程序文件或者脚本文件，如同 Windows 上的 exe 后缀的文件，不过 Linux 上不是通过文件后缀名来区分文件的类型。</li><li>注意:一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息。</li></ul></li></ul></li><li><code>ls</code>命令参数：<ul><li><code>ls -l</code>：使用较长格式列出文件</li><li><code>ls -a</code>:显示除了 .（当前目录）和 …（上一级目录）之外的所有文件，包括隐藏文件（Linux 下以 . 开头的文件为隐藏文件）(-a 相当于all)<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200629153028.jpg" alt="" /></li><li><code>ls -al</code>:同时使用-a和-l参数：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200629153246.jpg" alt="" /></li><li><code>ls dl &lt;目录名&gt;</code>:查看某一个目录的完整属性，而不是显示目录里面的文件属性<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200629153618.jpg" alt="" /></li><li><code>ls -asSh</code>:显示所有文件大小，并以普通人类能看懂的方式呈现。其中小 s 为显示文件大小，大 S 为按文件大小排序，若需要知道如何按其它方式排序，可以使用 man ls 命令查询。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200629153846.jpg" alt="" /></li></ul></li></ul><h3 id="变更文件所有者"><a class="markdownIt-Anchor" href="#变更文件所有者"></a> 变更文件所有者</h3><ul><li>变更文件所有者<code>chown &lt;username&gt; &lt;filename&gt;</code>:其中 chown 是change owner 的缩写</li><li>变更文件所属群组<code>chgrp &lt;usergroupname&gt; &lt;filename&gt;</code>:其中 chgrp 是change group的缩写</li></ul><h3 id="修改文件权限"><a class="markdownIt-Anchor" href="#修改文件权限"></a> 修改文件权限</h3><ul><li>加减修改法：<ul><li>示例：<code>chmod g-w zhangjie.txt</code><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200629201210.jpg" alt="" /><br />g、o 还有 u 分别表示 group（用户组）、others（其他用户） 和 user（用户），+ 和 - 分别表示增加和去掉相应的权限。</li></ul></li></ul><h2 id="七-linux目录结构及文件基本操作"><a class="markdownIt-Anchor" href="#七-linux目录结构及文件基本操作"></a> 七、Linux目录结构及文件基本操作</h2><h3 id="linux目录结构与windows区别"><a class="markdownIt-Anchor" href="#linux目录结构与windows区别"></a> Linux目录结构与Windows区别</h3><ul><li>Linux 的目录与 Windows 的目录的区别：或许对于一般操作上的感受来说没有多大不同，但从它们的实现机制来说是完全不同的。</li><li>一种不同是体现在目录与存储介质（磁盘，内存，DVD 等）的关系上，以往的 Windows 一直是以存储介质为主的，主要以盘符（C 盘，D 盘…）及分区来实现文件管理，然后之下才是目录，目录就显得不是那么重要，除系统文件之外的用户文件放在任何地方任何目录也是没有多大关系。所以通常 Windows 在使用一段时间后，磁盘上面的文件目录会显得杂乱无章。</li><li>然而 UNIX/Linux 恰好相反，UNIX 是以目录为主的，Linux 也继承了这一优良特性。 Linux 是以树形目录结构的形式来构建整个系统的，可以理解为树形目录是一个用户可操作系统的骨架。虽然本质上无论是目录结构还是操作系统内核都是存储在磁盘上的，但从逻辑上来说 Linux 的磁盘是“挂在”（挂载在）目录上的，每一个目录不仅能使用本地磁盘分区的文件系统，也可以使用网络上的文件系统。举例来说，可以利用网络文件系统（Network File System，NFS）服务器载入某特定目录等。</li><li>Linux中每一个文件在此目录树中的文件名(包含完整路径)都是独一无二的。</li></ul><h3 id="linux的目录结构-fhs标准"><a class="markdownIt-Anchor" href="#linux的目录结构-fhs标准"></a> Linux的目录结构-FHS标准</h3><p><a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs-3.0.pdf">FHS_3.0官方文档</a></p><h4 id="fhs简介"><a class="markdownIt-Anchor" href="#fhs简介"></a> FHS简介</h4><ul><li>FHS（英文：Filesystem Hierarchy Standard 中文：文件系统层次结构标准），多数 Linux 版本采用这种文件组织形式，FHS 定义了系统中每个区域的用途、所需要的最小构成的文件和目录同时还给出了例外处理与矛盾处理。</li><li>FHS 定义了两层规范，第一层是， /（根目录） 下面的各个目录应该要放什么文件数据，例如 /etc 应该放置设置文件，/bin 与 /sbin 则应该放置可执行文件等等。<br />第二层则是针对 /usr 及 /var 这两个目录的子目录来定义。例如 /var/log 放置系统日志文件，/usr/share 放置共享数据等等。</li><li>FHS 是根据以往无数 Linux 用户和开发者的经验总结出来的，并且会维持更新，FHS 依据文件系统使用的频繁与否以及是否允许用户随意改动（注意，不是不能，学习过程中，不要怕这些），将目录定义为四种交互作用的形态，如下表所示：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200630181751.png" alt="" /><ul><li>可分享的：可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据， 是能够分享给网络上其他主机挂载用的目录；</li><li>不可分享的：自己机器上面运作的装置文件或者是与程序有关的socket文件等， 由于仅与自身机器有关，所以当然就不适合分享给其他主机了。</li><li>不变的：有些数据是不会经常变动的，跟随着distribution而不变动。 例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等等；</li><li>可变动的：经常改变的数据，例如登录文件、一般用户可自行收受的新闻组等。</li></ul></li></ul><h4 id="fhs标准下目录结构"><a class="markdownIt-Anchor" href="#fhs标准下目录结构"></a> FHS标准下目录结构</h4><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200630182400.png" alt="" /></p><ul><li>用户安装的软件一般安装到<code>/usr/local</code>目录下，其中bin目录放可执行文件，src放源代码文件等。<br />真机演示：<br />利用<code>tree</code>命令可查看目录树：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200630183448.jpg" alt="" /></li></ul><h3 id="linux的目录路径"><a class="markdownIt-Anchor" href="#linux的目录路径"></a> Linux的目录路径</h3><h4 id="路径定义及分类"><a class="markdownIt-Anchor" href="#路径定义及分类"></a> 路径定义及分类</h4><ul><li>路径定义：顾名思义，路径就是你要去哪儿的路线。如果你想进入某个具体的目录或者想获得某个目录的文件（目录本身也是文件）那就得用路径来找到。</li><li>路径类型：<ul><li>绝对路径：以根&quot; / &quot;目录为起点的完整路径，以你所要到的目录为终点，表现形式如： /usr/local/bin，表示根目录下的 usr 目录中的 local 目录中的 bin 目录。</li><li>相对路径：相对路径，也就是相对于你当前的目录的路径，相对路径是以当前目录&quot; . “为起点，以你所要到的目录为终点，表现形式如： usr/local/bin （这里假设你当前目录为根目录）。(注意：我们表示相对路径实际并没有加上表示当前目录的那个” .&quot; ，而是直接以目录名开头，因为这个 usr 目录为 / 目录下的子目录，是可以省略这个 . 的；如果是当前目录的上一级目录，则需要使用&quot; …&quot; ，比如你当前目录为 /home/zhangjie 目录下，根目录就应该表示为 …/…/ ，表示上一级目录（ home 目录）的上一级目录（ / 目录）。)</li></ul></li></ul><h4 id="与路径相关命令"><a class="markdownIt-Anchor" href="#与路径相关命令"></a> 与路径相关命令</h4><ul><li><code>cd</code>(change directory/改变目录)命令：(注：cd 命令与后面参数间都有一个空格)<ul><li>进入上一级目录：<code>cd ..</code></li><li>进入子目录：<code>cd &lt;目录名&gt;</code></li><li>进入具体目录：<code>cd &lt;绝对路径&gt;</code>或<code>cd &lt;相对路径&gt;</code></li><li>返回home目录：<code>cd </code>或<code>cd /home/&lt;username&gt;</code>或<code>cd ~</code></li><li>返回进入此目录之前所在目录：<code>cd -</code></li><li>进入当前用户的家目录下：<code>cd ~</code>.</li><li>把上个cd命令的参数作为cd参数使用:<code>cd !$</code></li></ul></li><li>pwd（print working directory/显示当前工作目录)命令：（注：显示的是绝对路径）<br />示例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200701223833.jpg" alt="" /></li></ul><ol><li><code>cd /usr/bin</code>:以绝对路径进入</li><li><code>cd ./games</code>:以相对路径进入（在当前目录下，进入games目录）</li><li><code>cd ../../usr</code>:以相对路径进入（在当前目录的上两级目录下，进入usr目录）</li><li>技巧：输入cd后按Tab可显示当前目录下所有子目录，继续按Tab可顺序选择，按Shift+Tab可逆向选择</li></ol><h3 id="linux的文件基本操作"><a class="markdownIt-Anchor" href="#linux的文件基本操作"></a> Linux的文件基本操作</h3><h4 id="新建"><a class="markdownIt-Anchor" href="#新建"></a> 新建</h4><ul><li><p>新建空白文件</p><ul><li><code>touch &lt;filename&gt;</code>:使用 touch 命令创建空白文件,在不加任何参数的情况下，只指定一个文件名，则可以创建一个指定文件名的空白文件（不会覆盖已有同名文件，也可以同时创建多个文件）。</li></ul></li><li><p>新建目录</p><ul><li><code>mkdir &lt;directoryname&gt;</code>:使用 mkdir（make directories）命令可以创建一个空目录。</li><li><code>mkdir 相对路径/绝对路径</code>:使用 -p 参数，同时创建父目录（如果不存在该父目录）。</li></ul></li><li><p>示例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200702091205.jpg" alt="" /></p></li><li><p>注：</p><ul><li>若当前目录已经创建了一个 test 文件，再使用 mkdir test 新建同名的文件夹，系统会报错文件已存在。这符合 Linux 一切皆文件的理念。</li><li>若当前目录存在一个 test 文件夹，则 touch 命令，则会更改该文件夹的时间戳而不是新建文件（touch命令本来的主要用途就是更改时间戳的）。</li></ul></li></ul><h4 id="复制"><a class="markdownIt-Anchor" href="#复制"></a> 复制</h4><ul><li><p>复制文件</p><ul><li><code>cp &lt;文件名&gt; &lt;目录名&gt;</code>:使用 cp 命令（copy）复制一个文件到指定目录.</li><li>示例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200702124527.jpg" alt="" /></li><li><code>cp &lt;文件名&gt; &lt;目录名+要改的文件名&gt;</code>:改名复制,如果复制的目标位置已经存在同名的文件，则会提示是否覆盖。</li></ul></li><li><p>复制目录：</p><ul><li><code>cp -r &lt;待复制目录路径（相对与绝对均可）&gt; &lt;要复制到的目录名&gt;</code>:要成功复制目录需要加上 -r 或者 -R 参数，表示递归复制。</li><li>示例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200702130631.jpg" alt="" /></li></ul></li></ul><h4 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h4><ul><li><p>删除文件</p><ul><li><code>rm &lt;文件名&gt;</code>:使用 rm（remove files or directories）命令删除文件(可同时删除多个文件)</li><li>示例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200702213710.jpg" alt="" /></li><li><code>rm -f &lt;文件名&gt;</code>:有时候会遇到想要删除一些为只读权限的文件，若想强制删除文件，可以使用 -f 参数强制删除：</li></ul></li><li><p>删除目录</p><ul><li><code>rm -r &lt;目录名&gt;</code>:要删除一个目录，需要加上 -r 或 -R 参数。</li><li><code>rm -rf &lt;目录名&gt;</code>:强制删除。</li><li><code>rm -rf /*</code> 命令，执行后效果如下<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20201007173136.jpg" alt="" /><ul><li><code>rm</code>是删除命令，-r选项是删除目录，-f选项是强制删除，<code>/*</code>中<code>/</code>是用户的根目录，而<code>*</code>是通配符，代表根目录下的全部文件。所以这个命令是删除用户根目录下的全部文件。</li><li>但是因为这个用户不是root用户，所以不具有删除根目录下所有文件的权限，所以会出现大量无法删除。</li></ul></li><li>示例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200702214637.jpg" alt="" /></li></ul></li></ul><h4 id="打开可执行文件"><a class="markdownIt-Anchor" href="#打开可执行文件"></a> 打开可执行文件</h4><ul><li>在终端输入可执行的文件的全路径（绝对或相对均可）就可运行相应可执行文件</li><li>示例：在当前目录下运行a.out文件的命令：<code>./a.out</code></li></ul><h4 id="移动文件与文件重命名"><a class="markdownIt-Anchor" href="#移动文件与文件重命名"></a> 移动文件与文件重命名</h4><ul><li><p>移动文件(类似Windows的剪切粘贴)</p><ul><li><code>mv &lt;待移动的文件名&gt; &lt;目的目录名&gt;</code>:使用 mv（move or rename files）命令移动文件.</li></ul></li><li><p>重命名文件</p><ul><li><code>mv &lt;原文件名&gt; &lt;新命名的文件名&gt;</code>:mv 命令除了能移动文件外，还能给文件重命名。</li></ul></li><li><p>示例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200702215520.jpg" alt="" /></p></li></ul><h4 id="查看文件内容"><a class="markdownIt-Anchor" href="#查看文件内容"></a> 查看文件内容</h4><ul><li><p><code>cat</code> 命令查看</p><ul><li><code>cat &lt;filename&gt;</code>: 打印文件内容到终端（正序显示）。</li><li><code>cat -n &lt;filename&gt;</code>: 加上 -n 参数显示行号。</li><li>示例<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200702221517.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200702221417.jpg" alt="" /></li></ul></li><li><p><code>tac</code>命令查看</p><ul><li><code>tac &lt;filename&gt;</code>:打印文件内容到终端（逆序显示）。</li></ul></li><li><p><code>nl</code>命令查看</p><ul><li>主要参数：<ul><li>-b : 指定添加行号的方式，主要有两种：<ul><li>-b a:表示无论是否为空行，同样列出行号(&quot;cat -n&quot;就是这种方式)</li><li>-b t:只列出非空行的编号并列出（默认为这种方式）</li></ul></li><li>-n : 设置行号的样式，主要有三种：<ul><li>-n ln:在行号字段最左端显示</li><li>-n rn:在行号字段最右边显示，且不加 0</li><li>-n rz:在行号字段最右边显示，且加 0</li></ul></li><li>-w : 行号字段占用的位数(默认为 6 位)</li></ul></li><li><code>nl 参数 &lt;文件名&gt;</code>:添加行号并打印，这是个比 cat -n 更专业的行号打印命令。</li><li>示例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200702222824.jpg" alt="" /></li></ul></li><li><p>使用 <code>more</code> 和 <code>less</code> 命令分页查看文件</p><ul><li>more功能类似 cat ，cat命令是整个文件的内容从上到下显示在屏幕上。 more会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示；按 b 键就会往回（back）一页显示；按Enter 向下n行，需要定义，默认为1行；按下 h 显示帮助，q 退出。</li><li>less 工具也是对文件或其它输出进行分页显示的工具，应该说是linux正统查看文件内容的工具，功能极其强大。less 的用法比起 more 更加的有弹性。 在 more 的时候，我们并没有办法向前面翻， 只能往后面看，但若使用了 less 时，就可以使用 [pageup] [pagedown] 等按 键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！</li><li>示例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200709145656.jpg" alt="" /></li></ul></li><li><p>使用 <code>head</code> 和 <code>tail</code> 命令查看文件:</p><ul><li><code>head</code> 命令可以将一段文本的开头一部分输出到标准输出。<code>tail</code>将一段文本的结尾一部分输出到标准输出，也就是从某个节点位置开始输出。</li><li><code>tail</code> 命令，不得不提的还有它一个很牛的参数 -f，这个参数可以实现不停地读取某个文件的内容并显示。这可以让我们动态查看日志，达到实时监视的目的。</li><li>示例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200709150856.jpg" alt="" /></li></ul></li></ul><h4 id="查看文件类型"><a class="markdownIt-Anchor" href="#查看文件类型"></a> 查看文件类型</h4><ul><li><code>file &lt;filename&gt;</code>:使用 file 命令查看文件的类型。</li><li>与 Windows 不同的是，如果你新建了一个 zhangjie.txt 文件，Windows 会自动把它识别为文本文件，而 file 命令会识别为一个空文件。在 Linux 中文件的类型不是根据文件后缀来判断的。当你在文件里输入内容后才会显示文件类型。</li><li>示例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200709151648.jpg" alt="" /></li></ul><h4 id="编辑文件"><a class="markdownIt-Anchor" href="#编辑文件"></a> 编辑文件</h4><ul><li>在 Linux 下面编辑文件通常我们会直接使用专门的命令行编辑器比如（emacs，vim，nano）。</li><li>例如vim编辑器，它的使用方法可以使用<code>vimtutor</code>命令在Linux终端中直接查看。</li><li>示例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200709152425.jpg" alt="" /></li></ul><h4 id="文件查找"><a class="markdownIt-Anchor" href="#文件查找"></a> 文件查找</h4><ul><li><code>whereis </code>:whereis 只能搜索二进制文件(-b)，man 帮助文件(-m)和源代码文件(-s)。这个搜索很快，因为它并没有从硬盘中依次查找，而是直接从数据库中查询。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200709223029.jpg" alt="" /></li><li><code>locate</code>:<ul><li>使用 locate 命令查找文件也不会遍历硬盘，它通过查询 /var/lib/mlocate/mlocate.db 数据库来检索信息。不过这个数据库也不是实时更新的，系统会使用定时任务每天自动执行 updatedb 命令来更新数据库。所以有时候你刚添加的文件，它可能会找不到，需要手动执行一次 updatedb 命令。注意这个命令不是内置的命令，需要手动安装<code>sudo apt-get install locate</code>，然后执行更新。</li><li>如果想只统计数目可以加上 -c 参数，-i 参数可以忽略大小写进行查找，whereis 的 -b、-m、-s 同样可以使用。</li><li>它可以用来查找指定目录下的不同文件类型。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200709223144.jpg" alt="" /></li></ul></li><li><code>which</code>:which 本身是 Shell 内建的一个命令，我们通常使用 which 来确定是否安装了某个指定的程序。使用which我们可以看到某个系统命令是否存在以及执行的到底是哪一个地方的命令。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200709223605.jpg" alt="" /></li><li><code>find</code>:<ul><li>find 应该是这几个命令中最强大的了，它不但可以通过文件类型、文件名进行查找而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索。</li><li>注意 find 命令的路径是作为第一个参数的， 基本命令格式为 find [path][option] [action] 。</li><li><code>find</code>命令参数：<br />-name   filename               #查找名为filename的文件<br />-perm                                #按执行权限来查找<br />-user    username             #按文件属主来查找<br />-group groupname            #按组来查找<br />-mtime   -n +n                   #按文件更改时间来查找文件，-n指n天以内，+n指n天以前<br />-atime    -n +n                   #按文件访问时间来查找文件，-n指n天以内，+n指n天以前<br />-ctime    -n +n                  #按文件创建时间来查找文件，-n指n天以内，+n指n天以前<br />-nogroup                          #查无有效属组的文件，即文件的属组在/etc/groups中不存在<br />-nouser                            #查无有效属主的文件，即文件的属主在/etc/passwd中不存<br />-type    b/d/c/p/l/f             #查是块设备、目录、字符设备、管道、符号链接、普通文件<br />-size      n[c]                    #查长度为n块[或n字节]的文件<br />-mount                            #查文件时不跨越文件系统mount点<br />-follow                            #如果遇到符号链接文件，就跟踪链接所指的文件<br />-prune                            #忽略某个目录</li><li>示例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200709224529.jpg" alt="" /></li></ul></li></ul><h4 id="文件内容查找"><a class="markdownIt-Anchor" href="#文件内容查找"></a> 文件内容查找</h4><ul><li><code>grep</code>命令:Linux grep 命令用于查找文件里符合条件的字符串。</li><li>grep指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设grep指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为<code>-</code>，则grep 指令会从标准输入设备读取数据。</li><li>语法:<code>grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示行数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][--help][范本样式][文件或目录...]</code></li><li>参数：<br />-a 或 --text : 不要忽略二进制的数据。<br />-A&lt;显示行数&gt; 或 --after-context=&lt;显示行数&gt; : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。<br />-b 或 --byte-offset : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。<br />-B&lt;显示行数&gt; 或 --before-context=&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前的内容。<br />-c 或 --count : 计算符合样式的列数。<br />-C&lt;显示行数&gt; 或 --context=&lt;显示行数&gt;或-&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前后的内容。<br />-d &lt;动作&gt; 或 --directories=&lt;动作&gt; : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。<br />-e&lt;范本样式&gt; 或 --regexp=&lt;范本样式&gt; : 指定字符串做为查找文件内容的样式。<br />-E 或 --extended-regexp : 将样式为延伸的正则表达式来使用。<br />-f&lt;规则文件&gt; 或 --file=&lt;规则文件&gt; : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。<br />-F 或 --fixed-regexp : 将样式视为固定字符串的列表。<br />-G 或 --basic-regexp : 将样式视为普通的表示法来使用。<br />-h 或 --no-filename : 在显示符合样式的那一行之前，不标示该行所属的文件名称。<br />-H 或 --with-filename : 在显示符合样式的那一行之前，表示该行所属的文件名称。<br />-i 或 --ignore-case : 忽略字符大小写的差别。<br />-l 或 --file-with-matches : 列出文件内容符合指定的样式的文件名称。<br />-L 或 --files-without-match : 列出文件内容不符合指定的样式的文件名称。<br />-n 或 --line-number : 在显示符合样式的那一行之前，标示出该行的列数编号。<br />-o 或 --only-matching : 只显示匹配PATTERN 部分。<br />-q 或 --quiet或–silent : 不显示任何信息。<br />-r 或 --recursive : 此参数的效果和指定&quot;-d recurse&quot;参数相同。<br />-s 或 --no-messages : 不显示错误信息。<br />-v 或 --invert-match : 显示不包含匹配文本的所有行。<br />-V 或 --version : 显示版本信息。<br />-w 或 --word-regexp : 只显示全字符合的列。<br />-x --line-regexp : 只显示全列符合的列。<br />-y : 此参数的效果和指定&quot;-i&quot;参数相同。</li></ul><h4 id="文件打包与解压缩"><a class="markdownIt-Anchor" href="#文件打包与解压缩"></a> 文件打包与解压缩</h4><ul><li>压缩包文件格式</li></ul><table><thead><tr><th>文件后缀名</th><th>说明</th></tr></thead><tbody><tr><td>*.zip</td><td>zip 程序打包压缩的文件</td></tr><tr><td>*.rar</td><td>rar 程序压缩的文件</td></tr><tr><td>*.7z</td><td>7zip 程序压缩的文件</td></tr><tr><td>*.tar</td><td>tar 程序打包，未压缩的文件</td></tr><tr><td>*.gz</td><td>gzip 程序（GNU zip）压缩的文件</td></tr><tr><td>*.xz</td><td>xz 程序压缩的文件</td></tr><tr><td>*.bz2</td><td>bzip2 程序压缩的文件</td></tr><tr><td>*.tar.gz</td><td>tar 打包，gzip 程序压缩的文件</td></tr><tr><td>*.tar.xz</td><td>tar 打包，xz 程序压缩的文件</td></tr><tr><td>*tar.bz2</td><td>tar 打包，bzip2 程序压缩的文件</td></tr><tr><td>*.tar.7z</td><td>tar 打包，7z 程序压缩的文件</td></tr></tbody></table><ul><li>zip压缩打包程序<ul><li><code>zip</code>命令使用基本格式：<code>zip [选项] 压缩包名 源文件或源目录列表</code></li><li>常用参数：</li></ul></li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-r</td><td>递归压缩目录，即将制定目录下的所有文件以及子目录全部压缩。</td></tr><tr><td>-m</td><td>将文件压缩之后，删除原始文件，相当于把文件移到压缩文件中。</td></tr><tr><td>-v</td><td>显示详细的压缩过程信息。</td></tr><tr><td>-q</td><td>在压缩的时候不显示命令的执行过程。</td></tr><tr><td>-压缩级别</td><td>压缩级别是从 1~9 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好。</td></tr><tr><td>-u</td><td>更新压缩文件，即往压缩文件中添加新文件。</td></tr></tbody></table><ul><li><p>示例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200710113633.jpg" alt="" /><br />注：所有的压缩命令都可以同时压缩多个文件为一个压缩包。</p></li><li><p>unzip解压zip文件</p><ul><li>解压到当前目录：<code>unzip &lt;filename.zip&gt;</code></li><li>解压到指定目录：<code>unzip &lt;filename.zip&gt; -d &lt;目录&gt;</code></li><li>常用参数：</li></ul></li></ul><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-l</td><td>显 示压缩文件内所包含的文件。</td></tr><tr><td>-t</td><td>检 查压缩文件是否正确，但不解压。</td></tr><tr><td>-v</td><td>执行时显示详细的信息。</td></tr><tr><td>-a</td><td>对文本文件进行必要的字符转换。</td></tr><tr><td>-b</td><td>不 要对文本文件进行字符转换。</td></tr><tr><td>-C</td><td>压 缩文件中的文件名称区分大小写。</td></tr><tr><td>-L</td><td>将 压缩文件中的全部文件名改为小写。</td></tr><tr><td>-o</td><td>不 必先询问用户，unzip执 行后覆盖原有文件。</td></tr><tr><td>-P&lt;密码&gt;</td><td>使 用zip的密码选项。</td></tr><tr><td>-q</td><td>执 行时不显示任何信息。</td></tr><tr><td>-d&lt;目录&gt;</td><td>指 定文件解压缩后所要存储的目录。</td></tr><tr><td>-x&lt;文件&gt;</td><td>指 定不要处理.zip压 缩文件中的哪些文件。</td></tr></tbody></table><ul><li><p>示例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200710115840.jpg" alt="" /></p></li><li><p>tar打包工具</p><ul><li>首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。。</li><li>tar 原本只是一个打包工具，只是同时还是实现了对 7z、gzip、xz、bzip2 等工具的支持，这些压缩工具本身只能实现对文件或目录（单独压缩目录中的文件）的压缩，没有实现对文件的打包压缩。</li><li>基本命令格式：<code>tar(参数)(指定要打包的文件或目录列表)</code></li><li>常用参数：</li></ul></li></ul><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-A或–catenate</td><td>新增文件到以存在的备份文件</td></tr><tr><td>-B</td><td>设置区块大小</td></tr><tr><td>-c或–create</td><td>建立新的备份文件</td></tr><tr><td>-C &lt;目录&gt;</td><td>这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。</td></tr><tr><td>-d</td><td>记录文件的差别</td></tr><tr><td>-x或–extract或–get</td><td>从备份文件中还原文件</td></tr><tr><td>-t或–list</td><td>列出备份文件的内容</td></tr><tr><td>-z或–gzip或–ungzip</td><td>通过gzip指令处理备份文件</td></tr><tr><td>-Z或–compress或–uncompress</td><td>通过compress指令处理备份文件</td></tr><tr><td>-f&lt;备份文件&gt;或–file=&lt;备份文件&gt;</td><td>指定备份文件</td></tr><tr><td>-v或–verbose</td><td>显示指令执行过程</td></tr><tr><td>-r</td><td>添加文件到已经压缩的文件</td></tr><tr><td>-u</td><td>添加改变了和现有的文件到已经存在的压缩文件</td></tr><tr><td>-j</td><td>支持bzip2解压文件</td></tr><tr><td>-l</td><td>文件系统边界设置</td></tr><tr><td>-k</td><td>保留原有文件不覆盖</td></tr><tr><td>-m</td><td>保留文件不被覆盖</td></tr><tr><td>-w</td><td>确认压缩文件的正确性</td></tr><tr><td>-p或–same-permissions</td><td>用原来的文件权限还原文件</td></tr><tr><td>-P或–absolute-names</td><td>文件名使用绝对名称，不移除文件名称前的“/”号</td></tr><tr><td>-N &lt;日期格式&gt; 或 --newer=&lt;日期时间&gt;</td><td>只将较指定日期更新的文件保存到备份文件里</td></tr><tr><td>–exclude=&lt;范本样式&gt;</td><td>排除符合范本样式的文件</td></tr></tbody></table><ul><li>示例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200710191628.jpg" alt="" /><br />注：-c 表示创建一个 tar 包文件，-f 用于指定创建的文件名，注意文件名必须紧跟在 -f 参数之后，比如不能写成 tar -fc shiyanlou.tar，可以写成 tar -f shiyanlou.tar -c ~。我们只需要在创建 tar 文件的基础上添加 -z 参数，使用 gzip 来压缩文件。</li></ul><h2 id="八-数据流重定向"><a class="markdownIt-Anchor" href="#八-数据流重定向"></a> 八、数据流重定向</h2><h3 id="标准输出-输入及错误"><a class="markdownIt-Anchor" href="#标准输出-输入及错误"></a> 标准输出、输入及错误</h3><ul><li>Linux 默认提供了三个特殊设备，用于终端的显示和输出，分别为stdin（标准输入,对应于你在终端的输入），stdout（标准输出，对应于终端的输出），stderr（标准错误输出，对应于终端的输出）。</li></ul><table><thead><tr><th>文件描述符</th><th>设备文件</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>/dev/stdin</td><td>标准输入</td></tr><tr><td>1</td><td>/dev/stdout</td><td>标准输出</td></tr><tr><td>2</td><td>/dev/stderr</td><td>标准错误输出</td></tr></tbody></table><ul><li>文件描述符：文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统。</li></ul><h3 id="linux输入重定向"><a class="markdownIt-Anchor" href="#linux输入重定向"></a> Linux输入重定向</h3><ul><li>输入重定向中用到的符号及作用</li></ul><table><thead><tr><th>命令符号格式</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将指定文件作为命令的输入设备</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>表示从标准输入设备（键盘）中读入，直到遇到分界符才停止（读入的数据不包括分界符），这里的分界符其实就是自定义的字符串</td></tr><tr><td>命令 &lt; 文件 1 &gt; 文件 2</td><td>将文件 1 作为命令的输入设备，该命令的执行结果输出到文件 2 中。</td></tr></tbody></table><ul><li>示例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200715114325.jpg" alt="" /></li></ul><h3 id="linux输出重定向"><a class="markdownIt-Anchor" href="#linux输出重定向"></a> Linux输出重定向</h3><ul><li>输出重定向用到的符号及作用</li></ul><table><thead><tr><th>命令符号格式</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将命令执行的标准输出结果重定向输出到指定的文件中，如果该文件已包含数据，会清空原有数据，再写入新数据。</td></tr><tr><td>命令 2&gt; 文件</td><td>将命令执行的错误输出结果重定向到指定的文件中，如果该文件中已包含数据，会清空原有数据，再写入新数据。</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将命令执行的标准输出结果重定向输出到指定的文件中，如果该文件已包含数据，新数据将写入到原有内容的后面。</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将命令执行的错误输出结果重定向到指定的文件中，如果该文件中已包含数据，新数据将写入到原有内容的后面。</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1或者命令 &amp;&gt;&gt; 文件</td><td>将标准输出或者错误输出写入到指定文件，如果该文件中已包含数据，新数据将写入到原有内容的后面。注意，第一种格式中，最后的 2&gt;&amp;1 是一体的，可以认为是固定写法。</td></tr></tbody></table><ul><li>示例：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200715115607.jpg" alt="" /></li></ul><h2 id="九-基础底层知识"><a class="markdownIt-Anchor" href="#九-基础底层知识"></a> 九、基础底层知识</h2><h3 id="cpu"><a class="markdownIt-Anchor" href="#cpu"></a> cpu</h3><ul><li>中央处理器（CPU，central processing unit）作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元。CPU是计算机中负责读取指令，对指令译码并执行指令的核心部件。CPU的功效主要为处理指令、执行操作、控制时间、处理数据。</li><li>物理CPU:物理CPU是相对于虚拟CPU而言的概念，指实际存在的处理器,就是我们可以看的见，摸得着的CPU，就是插在主板上面的。</li><li>虚拟CPU:虚拟cpu是我们在做虚拟化时候，利用虚拟化技术，虚拟出来的CPU。如使用VMware时为虚拟机分配的CPU。</li><li>CPU主要有3大组成部分：<ul><li>运算器：算术逻辑运算单元（ALU，Arithmetic Logic Unit），负责执行所有的数学和逻辑工作。</li><li>控制器：控制单元（CU，Control Unit），控制计算机的所有其他部件，如输入输出设备以及存储器。</li><li>寄存器：存储单元，包括CPU片内缓存和寄存器组，是CPU中暂时存放数据的地方。</li></ul></li><li>CPU缓存：<ul><li>CPU缓存（Cache Memory）的出现是弥补CPU和主存（主内存，即内存条的）的速度差太大，用于提高效率的，有时可能也叫高速缓存。</li><li>高速缓存也分了很多层，一到四级，四级很少听但确实是有。一二级是各个核心独有的，三级缓存是所有核共享的。</li><li><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200711104614.png" alt="" /></li></ul></li><li>CPU的个数：即CPU芯片个数。</li><li>CPU工作原理图：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200711103931.png" alt="" /></li></ul><h3 id="核心"><a class="markdownIt-Anchor" href="#核心"></a> 核心</h3><ul><li>核心（core,又称内核）是一个硬件术语，描述单个计算组件（管芯或芯片）中独立中央处理器的数量。</li><li>CPU的核心数是指物理上，也就是硬件上存在着几个核心。比如，双核就是包括2个相对独立的CPU核心单元组，四核就包含4个相对独立的CPU核心单元组。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200711105800.png" alt="" /></li><li>物理核：CPU中包含的物理内核（核心），比如多核CPU，单核CPU（老式CPU），这个多核或者单核已经集成在CPU内部。</li><li>逻辑核（逻辑CPU或虚拟核）：用Intel的超线程技术(HT)将物理核虚拟而成的逻辑处理单元,现在大部分的主机的CPU都在使用HT技术，用一个物理核模拟两个虚拟核，即每个核两个线程。</li></ul><h3 id="超线程技术"><a class="markdownIt-Anchor" href="#超线程技术"></a> 超线程技术</h3><ul><li>超线程技术把多线程处理器内部的两个逻辑内核模拟成两个物理芯片，让单个处理器就能使用线程级的并行计算，进而兼容多线程操作系统和软件。超线程技术充分利用空闲CPU资源，在相同时间内完成更多工作。</li><li>虽然采用超线程技术能够同时执行两个线程，当两个线程同时需要某个资源时，其中一个线程必须让出资源暂时挂起，直到这些资源空闲以后才能继续。因此，超线程的性能并不等于两个CPU的性能。</li><li>超线程技术图示：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200711111930.jpg" alt="" /></li></ul><h3 id="程序-进程-线程"><a class="markdownIt-Anchor" href="#程序-进程-线程"></a> 程序、进程、线程</h3><ul><li><strong>进程（process）</strong>：进程是程序在一个数据集合上的一次执行过程，在早期的 UNIX、Linux 2.4 及更早的版本中，它是系统进行资源分配和调度的独立基本单位。</li><li><strong>程序（procedure)</strong>：程序是执行一系列有逻辑、有顺序结构的指令，帮我们达成某个结果。</li><li><strong>进程与程序的区别</strong>：<ul><li>简单来说，程序是为了完成某种任务而设计的软件，比如 vim 是程序。而进程就是运行中的程序。</li><li>进程的特性：<ul><li>动态性：进程的实质是一次程序执行的过程，有创建、撤销等状态的变化。而程序是一个静态的实体。</li><li>并发性：进程可以做到在一个时间段内，有多个程序在运行中。程序只是静态的实体，所以不存在并发性。</li><li>独立性：进程可以独立分配资源，独立接受调度，独立地运行。</li><li>异步性：进程以不可预知的速度向前推进。</li><li>结构性：进程拥有代码段、数据段、PCB（进程控制块，进程存在的唯一标志）。也正是因为有结构性，进程才可以做到独立地运行。</li></ul></li></ul></li><li><strong>进程的分类</strong>：<ul><li>以进程的功能与服务的对象来分:<ul><li>用户进程：通过执行用户程序、应用程序或称之为内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。</li><li>系统进程：通过执行系统内核程序而产生的进程，比如可以执行内存资源分配和进程切换等相对底层的工作；而且该进程的运行不受用户的干预，即使是 root 用户也不能干预系统进程的运行。</li></ul></li><li>以应用程序的服务类型来分:<ul><li>交互进程：由一个 shell 终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。</li><li>批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。</li><li>守护进程：守护进程是一直运行的一种进程，在 Linux 系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。</li></ul></li></ul></li><li><strong>进程的衍生</strong><ul><li>两个系统调用函数：<ul><li><code>fork()</code> 是一个系统调用（system call），它的主要作用就是为当前的进程创建一个新的进程，这个新的进程就是它的子进程，这个子进程除了父进程的返回值和 PID 以外其他的都一模一样，如进程的执行代码段，内存信息，文件描述，寄存器状态等等。</li><li><code>exec()</code> 也是系统调用，作用是切换子进程中的执行程序也就是替换其从父进程复制过来的代码段与数据段。</li></ul></li><li>子进程与父进程：子进程就是父进程通过系统调用 fork() 而产生的复制品，fork() 就是把父进程的 PCB 等进程的数据结构信息直接复制过来，只是修改了 PID，所以一模一样，只有在执行 exec() 之后才会不同。</li><li>子进程的退出与回收：<ul><li>当一个子进程要正常的终止运行时，或者该进程结束时它的主函数 main() 会执行 exit(n); 或者 return n，这里的返回值 n 是一个信号，系统会把这个 SIGCHLD 信号传给其父进程。</li><li>僵尸进程：在将要结束时的子进程代码执行部分已经结束执行了，系统的资源也基本归还给系统了，但若是其进程的进程控制块（PCB）仍驻留在内存中，而它的 PCB 还在，代表这个进程还存在（因为 PCB 就是进程存在的唯一标志，里面有 PID 等消息），并没有消亡，这样的进程称之为僵尸进程（Zombie）。</li><li>孤儿进程：另外如果父进程结束（非正常的结束），未能及时收回子进程，子进程仍在运行，这样的子进程称之为孤儿进程。在 Linux 系统中，孤儿进程一般会被 init 进程所“收养”，成为 init 的子进程。</li></ul></li><li>init进程：<ul><li>init 是用户进程的第一个进程也是所有用户进程的父进程或者祖先进程。就像一个树状图，而 init 进程就是这棵树的根，其他进程由根不断的发散，开枝散叶。</li><li>查看进程：<ul><li><code>pstree</code>命令查看进程树：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200715100301.jpg" alt="" /></li><li><code>ps -afxo user,ppid,pid,pgid,command</code>命令:其中 pid 就是该进程的一个唯一编号，ppid 就是该进程的父进程的 pid，command 表示的是该进程通过执行什么样的命令或者脚本而产生的。<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200715100557.jpg" alt="" /></li></ul></li></ul></li></ul></li><li><strong>进程组与Sessions</strong><ul><li>进程组：<ul><li>每一个进程都会是一个进程组的成员，而且这个进程组是唯一存在的，他们是依靠 PGID（process group ID）来区别的，而每当一个进程被创建的时候，它便会成为其父进程所在组中的一员。</li><li>一般情况，进程组的 PGID 等同于进程组的第一个成员的 PID，并且这样的进程称为该进程组的领导者,也就是领导进程，进程一般通过使用 getpgrp() 系统调用来寻找其所在组的 PGID，领导进程可以先终结，此时进程组依然存在，并持有相同的 PGID，直到进程组中最后一个进程终结。</li></ul></li><li>Session<ul><li>与进程组类似，每当一个进程被创建的时候，它便会成为其父进程所在 Session 中的一员，每一个进程组都会在一个 Session 中，并且这个 Session 是唯一存在的。</li><li>Session 主要是针对一个 tty（tty设备包括虚拟控制台，串口以及伪终端设备。tty是TeleTYpe的一个老缩写。） 建立，Session 中的每个进程都称为一个工作(job)。每个会话可以连接一个终端(control terminal)。当控制终端有输入输出时，都传递给该会话的前台进程组。Session 意义在于将多个 jobs 囊括在一个终端，并取其中的一个 job 作为前台，来直接接收该终端的输入输出以及终端信号。 其他 jobs 在后台运行。<ul><li>前台（foreground）就是在终端中运行，能与你有交互的。</li><li>后台（background）就是在终端中运行，但是你并不能与其任何的交互，也不会显示其执行的过程。</li></ul></li></ul></li></ul></li><li><strong>进程工作管理</strong><ul><li>我们都知道当一个进程在前台运作时我们可以用 <code>ctrl + c</code> 来终止它，但是若是在后台的话就不行了。我们可以通过<code> &amp;</code> 这个符号，让我们的命令在后台中运行。<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200715102419.jpg" alt="" />图中所显示的 [1] 18402分别是该 job 的 job number 与该进程的 PID，而最后一行的 Done 表示该命令已经在后台执行完毕。</li><li>我们还可以通过 ctrl + z 使我们的当前工作停止并丢到后台中去。使用<code>jobs</code>命令可以查看被停止并放置在后台的工作。<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200715102706.jpg" alt="" />其中第一列显示的为被放置后台 job 的编号，而第二列的 ＋ 表示最近(刚刚、最后)被放置后台的 job，同时也表示预设的工作，也就是若是有什么针对后台 job 的操作，首先对预设的 job，- 表示倒数第二（也就是在预设之前的一个）被放置后台的工作，倒数第三个（再之前的）以后都不会有这样的符号修饰，第三列表示它们的状态，而最后一列表示该进程执行的命令</li><li>通过<code>fg %jobnumber</code>（fg后面不加参数提取预设工作，加参数提取指定工作的编号将后台的工作拿到前台来。)<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200715103402.jpg" alt="" /></li><li>通过<code>bg %jobnumber</code>可以将工作放入后台运作。</li><li><code>kill</code>命令：<ul><li>删除一个工作，或者重启等等。</li><li>使用格式：<code>kill -signal %jobnumber</code></li><li>注意:<ul><li>若是在使用 kill ＋信号值然后直接加 pid，你将会对 pid 对应的进程进行操作。</li><li>若是在使用 kill+信号值然后 ％jobnumber，这时所操作的对象是 job，这个数字就是就当前 bash 中后台的运行的 job 的 ID。</li></ul></li><li>其中常用的有这些信号值</li></ul></li></ul></li></ul><table><thead><tr><th>信号值</th><th>作用</th></tr></thead><tbody><tr><td>-1</td><td>重新读取参数运行，类似与 restart</td></tr><tr><td>-2</td><td>如同 ctrl+c 的操作退出</td></tr><tr><td>-9</td><td>强制终止该任务</td></tr><tr><td>-15</td><td>正常的方式终止该任务</td></tr></tbody></table><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200715104822.jpg" alt="" /></p><ul><li><strong>进程查看</strong><ul><li><code>top</code>工具：<ul><li>top 工具是我们常用的一个查看工具，能实时的查看我们系统的一些关键信息的变化。</li><li>top 是一个在前台执行的程序，所以执行后便进入到这样的一个交互界面，正是因为交互界面我们才可以实时的获取到系统与进程的信息。在交互界面中我们可以通过一些指令来操作和筛选。</li><li>常用交互命令：</li></ul></li></ul></li></ul><table><thead><tr><th>常用交互命令</th><th>解释</th></tr></thead><tbody><tr><td>q</td><td>退出程序</td></tr><tr><td>I</td><td>切换显示平均负载和启动时间的信息</td></tr><tr><td>P</td><td>根据 CPU 使用百分比大小进行排序</td></tr><tr><td>M</td><td>根据驻留内存大小进行排序</td></tr><tr><td>i</td><td>忽略闲置和僵死的进程，这是一个开关式命令</td></tr><tr><td>k</td><td>终止一个进程，系统提示输入 PID 及发送的信号值。一般终止进程用 15 信号，不能正常结束则使用 9 信号。安全模式下该命令被屏蔽。</td></tr></tbody></table><ul><li>示例：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200715105949.jpg" alt="" /></li><li>top 显示的第一排，</li></ul><table><thead><tr><th>内容</th><th>解释</th></tr></thead><tbody><tr><td>top</td><td>表示当前程序的名称</td></tr><tr><td>10:59:28</td><td>表示当前的系统的时间</td></tr><tr><td>up 7 :06</td><td>表示该机器已经启动了多长时间</td></tr><tr><td>1 user</td><td>表示当前系统中只有一个用户</td></tr><tr><td>load average: 0.00,0.00,0.00</td><td>分别对应 1、5、15 分钟内 cpu 的平均负载</td></tr></tbody></table><ul><li>top 的第二行数据，基本上第二行是进程的一个情况统计</li></ul><table><thead><tr><th>内容</th><th>解释</th></tr></thead><tbody><tr><td>Tasks: 384 total</td><td>进程总数</td></tr><tr><td>1 running</td><td>1 个正在运行的进程数</td></tr><tr><td>383 sleeping</td><td>383 个睡眠的进程数</td></tr><tr><td>0 stopped</td><td>没有停止的进程数</td></tr><tr><td>0 zombie</td><td>没有僵尸进程数</td></tr></tbody></table><ul><li>top 的第三行数据，这一行基本上是 CPU 的一个使用情况的统计了</li></ul><table><thead><tr><th>内容</th><th>解释</th></tr></thead><tbody><tr><td>Cpu(s): 0.1 us</td><td>用户空间进程占用 CPU 百分比</td></tr><tr><td>0.2 sy</td><td>内核空间运行占用 CPU 百分比</td></tr><tr><td>0.0 ni</td><td>用户进程空间内改变过优先级的进程占用 CPU 百分比</td></tr><tr><td>99.7 id</td><td>空闲 CPU 百分比</td></tr><tr><td>0.0 wa</td><td>等待输入输出的 CPU 时间百分比</td></tr><tr><td>0.0 hi</td><td>硬中断(Hardware IRQ)占用 CPU 的百分比</td></tr><tr><td>0.0 si</td><td>软中断(Software IRQ)占用 CPU 的百分比</td></tr><tr><td>0.0 st</td><td>(Steal time) 是 hypervisor 等虚拟服务中，虚拟 CPU 等待实际 CPU 的时间的百分比</td></tr></tbody></table><ul><li>top 的第四行数据，这一行基本上是内存的一个使用情况的统计了：</li></ul><table><thead><tr><th>内容</th><th>解释</th></tr></thead><tbody><tr><td>3908.4 total</td><td>物理内存总量</td></tr><tr><td>436.1 free</td><td>空闲内存总量</td></tr><tr><td>1253.8 used</td><td>使用的物理内存总量</td></tr><tr><td>2218.6 buff/cache</td><td>用作内核缓存的内存量</td></tr></tbody></table><ul><li>top 的第五行数据，这一行基本上是交换区的一个使用情况的统计了</li></ul><table><thead><tr><th>内容</th><th>解释</th></tr></thead><tbody><tr><td>2048.0 total</td><td>交换区总量</td></tr><tr><td>2048.0 free</td><td>空闲交换区总量</td></tr><tr><td>0.0 used</td><td>使用的交换区总量</td></tr><tr><td>2379.4 avail Mem</td><td>缓冲的交换区总量,内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖</td></tr></tbody></table><ul><li>再下面就是进程的一个情况了</li></ul><table><thead><tr><th>列名</th><th>解释</th></tr></thead><tbody><tr><td>PID/进程号</td><td>进程 id</td></tr><tr><td>USER</td><td>该进程的所属用户</td></tr><tr><td>PR</td><td>该进程执行的优先级 priority 值</td></tr><tr><td>NI</td><td>该进程的 nice 值</td></tr><tr><td>VIRT</td><td>该进程任务所使用的虚拟内存的总数</td></tr><tr><td>RES</td><td>该进程所使用的物理内存数，也称之为驻留内存数</td></tr><tr><td>SHR</td><td>该进程共享内存的大小</td></tr><tr><td>S</td><td>该进程进程的状态: S=sleep R=running Z=zombie</td></tr><tr><td>%CPU</td><td>该进程 CPU 的利用率</td></tr><tr><td>%MEM</td><td>该进程内存的利用率</td></tr><tr><td>TIME+</td><td>该进程活跃的总时间</td></tr><tr><td>COMMAND</td><td>该进程运行的名字</td></tr></tbody></table><ul><li><p>注意：</p><ul><li>NICE 值叫做静态优先级，是用户空间的一个优先级值，其取值范围是-20 至 19。这个值越小，表示进程”优先级”越高，而值越大“优先级”越低。nice 值中的 -20 到 19，中 -20 优先级最高， 0 是默认的值，而 19 优先级最低。</li><li>PR 值表示 Priority 值叫动态优先级，是进程在内核中实际的优先级值，进程优先级的取值范围是通过一个宏定义的，这个宏的名称是 MAX_PRIO，它的值为 140。Linux 实际上实现了 140 个优先级范围，取值范围是从 0-139，这个值越小，优先级越高。而这其中的 0 - 99 是实时进程的值，而 100 - 139 是给用户的。其中 PR 中的 100 to 139 值部分有这么一个对应 PR = 20 + (-20 to +19)，这里的 -20 to +19 便是 nice 值，所以说两个虽然都是优先级，而且有千丝万缕的关系，但是他们的值，他们的作用范围并不相同</li><li>VIRT 任务所使用的虚拟内存的总数，其中包含所有的代码，数据，共享库和被换出 swap 空间的页面等所占据空间的总数</li></ul></li><li><p><strong>线程</strong>：线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。因为线程中几乎不包含系统资源，所以执行更快、更有效率。</p></li><li><p><strong>进程与线程对比</strong>：</p></li></ul><table><thead><tr><th>对比</th><th>进程</th><th>线程</th></tr></thead><tbody><tr><td>定义</td><td>进程是程序运行的一个实体的运行过程，是系统进行资源分配和调配的一个独立单位</td><td>线程是进程运行和执行的最小调度单位</td></tr><tr><td>系统开销</td><td>创建撤销切换开销大，资源要重新分配和收回</td><td>仅保存少量寄存器的内容，开销小，在进程的地址空间执行代码</td></tr><tr><td>拥有资源</td><td>资源拥有的基本单位</td><td>基本上不占资源，仅有不可少的资源（程序计数器，一组寄存器和栈）</td></tr><tr><td>调度</td><td>资源分配的基本单位</td><td>独立调度分配的单位</td></tr><tr><td>安全性</td><td>进程间相互独立，互不影响</td><td>线程共享一个进程下面的资源，可以互相通信和影响</td></tr><tr><td>地址空间</td><td>系统赋予的独立的内存地址空间</td><td>由相关堆栈寄存器和和线程控制表TCB组成，寄存器可被用来存储线程内的局部变量</td></tr></tbody></table><ul><li><strong>串行，并发与并行</strong><ul><li>串行<ul><li>多个任务，执行时一个执行完再执行另一个。</li><li>比喻：吃完饭再看视频。</li></ul></li><li>并发<ul><li>多个线程在单个核心运行，同一时间一个线程运行，系统不停切换线程，看起来像同时运行，实际上是线程不停切换。</li><li>比喻： 一会跑去厨房吃饭，一会跑去客厅看视频。</li></ul></li><li>并行<ul><li>每个线程分配给独立的核心，线程同时运行。</li><li>比喻：一边吃饭一边看视频。</li></ul></li></ul></li></ul><h2 id="十-多线程编程"><a class="markdownIt-Anchor" href="#十-多线程编程"></a> 十、多线程编程</h2><h3 id="多线程编程基本概念"><a class="markdownIt-Anchor" href="#多线程编程基本概念"></a> 多线程编程基本概念</h3><p>进程是资源管理的基本单元，而线程是系统调度的基本单元，线程是操作系统能够进行调度运算的最小单位，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。一个进程在某一个时刻只能做一件事情，有了多个控制线程以后，在程序的设计成在某一个时刻能够做不止一件事，每个线程处理独自的任务。<br />linux操作系统使用符合POSIX线程作为系统标准线程，该POSIX线程标准定义了一整套操作线程的API。</p><h3 id="进程的状态"><a class="markdownIt-Anchor" href="#进程的状态"></a> 进程的状态</h3><ul><li>进程从创建到运行结束，经历的全部过程，称为进程的生命周期。在生命周期的不同阶段，进程会呈现不同的状态。</li></ul><table><thead><tr><th>状态</th><th>含义</th></tr></thead><tbody><tr><td>创建状态</td><td>正在创建</td></tr><tr><td>就绪</td><td>刚刚创建好，还没运行过</td></tr><tr><td>内核状态</td><td>运行中</td></tr><tr><td>用户状态</td><td>暂停中</td></tr><tr><td>睡眠</td><td>运行中的进程因为某些需求得不到满足而进入等待状态</td></tr><tr><td>唤醒</td><td>睡眠中的进程，正在被唤醒</td></tr><tr><td>被抢占</td><td>运行期间，CPU 被另一个进程抢占</td></tr><tr><td>僵死状态</td><td>进程已经结束，但内存空间等占用的资源还未释放，被称为僵尸进程</td></tr></tbody></table><h3 id="线程标识"><a class="markdownIt-Anchor" href="#线程标识"></a> 线程标识</h3><ul><li>与进程有一个ID一样，每个线程有一个线程ID，所不同的是，进程ID在整个系统中是唯一的，而线程是依附于进程的，其线程ID只有在所属的进程中才有意义。线程ID用<code>pthread_t</code>表示。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F;pthread_self直接返回调用线程的ID#include &lt;pthread.h&gt;pthread_t pthread_self(void);</code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F;pthread_equal如果t1和t2所指定的线程ID相同，返回0；否则返回非0值。include &lt;pthread.h&gt;int pthread_equal(pthread_t t1, pthread_t t2);</code></pre><h3 id="线程创建"><a class="markdownIt-Anchor" href="#线程创建"></a> 线程创建</h3><ul><li>一个线程的生命周期起始于它被创建的那一刻。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F;pthread_creat创建线程#include &lt;pthread.h&gt;int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);参数说明：thread(输出参数)，线程的标识符，需要说明的是这个参数并不是用户确定的，用户只需声明一个pthread_t类型的变量，并将一个指向该变量的指针作为实参传递给pthread_create函数，函数在创建线程时会将新线程的线程标识符放到这个变量中。start_routine(输入参数)，新建线程的入口函数；arg(输入参数)，传递给新线程入口函数的参数；attr(输入参数)，指定新建线程的属性，如线程栈大小等；如果值为NULL，表示使用系统默认属性。函数返回值：成功，返回0；失败，返回相关错误码。</code></pre><h3 id="线程属性"><a class="markdownIt-Anchor" href="#线程属性"></a> 线程属性：</h3><ul><li>pthread_create函数的第二个参数类型定义如下：</li></ul>  <pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct &#123;  int detachstate;                  &#x2F;&#x2F;线程的分离状态  int schedpolicy;                  &#x2F;&#x2F;线程的调度策略  struct sched_param schedparam;    &#x2F;&#x2F;线程的调度参数  int inheritsched;                 &#x2F;&#x2F;线程的继承性  int scope;                        &#x2F;&#x2F;线程的作用域  size_t guardsize;  int stackaddr_set;                &#x2F;&#x2F;线程堆栈的位置，通常来说这是线程堆栈的最低位置  void *stackaddr;  size_t stacksize;                 &#x2F;&#x2F;线程堆栈的大小&#125;pthread_attr_t;</code></pre><ul><li>线程的初始化与销毁： 在使用一个线程属性对象之前，必须对其进行初始化，pthread_attr_init函数用于完成初始化；在使用完一个线程属性对象后，必须对其进行销毁，pthread_attr_destroy函数用于完成销毁工作。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;pthread.h&gt; int pthread_attr_init(pthread_attr_t *attr);int pthread_attr_destroy(pthread_attr_t *attr);</code></pre><h3 id="线程终止"><a class="markdownIt-Anchor" href="#线程终止"></a> 线程终止</h3><p>线程的终止分两种形式：被动终止和主动终止。</p><ul><li>被动终止的两种方式<ul><li>线程所在进程终止，任意线程执行exit、_Exit或者_exit函数，都会导致进程终止，从而导致依附于该进程的所有线程终止。</li><li>其他线程调用pthread_cancel请求取消该线程。</li></ul></li><li>主动终止的两种方式：<ul><li>在线程的入口函数中执行return语句，main函数(主线程入口函数)执行return语句会导致进程终止，从而导致依附于该进程的所有线程终止。</li><li>线程调用pthread_exit函数，main函数(主线程入口函数)调用pthread_exit函数， 主线程终止，但如果该进程内还有其他线程存在，进程会继续存在，进程内其他线程继续运行。</li></ul></li><li>线程终止函数：</li></ul>  <pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F;pthread_exit终止线程#include &lt;pthread.h&gt;void pthread_exit(void *retval);</code></pre><h3 id="线程终止的管理"><a class="markdownIt-Anchor" href="#线程终止的管理"></a> 线程终止的管理</h3><ul><li>线程的连接：一个线程的终止对于另外一个线程而言是一种异步的事件，有时我们想等待某个ID的线程终止了再去执行某些操作，pthread_join函数为我们提供了这种功能，该功能称为线程的连接。当线程X连接线程Y时，如果线程Y仍在运行，则线程X会阻塞直到线程Y终止；如果线程Y在被连接之前已经终止了，那么线程X的连接调用会立即返回。连接线程其实还有另外一层意义，一个线程终止后，如果没有人对它进行连接，那么该终止线程占用的资源，系统将无法回收，而该终止线程也会成为僵尸线程。因此，当我们去连接某个线程时，其实也是在告诉系统该终止线程的资源可以回收了。</li></ul>  <pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;pthread.h&gt;int pthread_join(pthread_t thread, void **retval);参数说明：thread(输入参数)，指定我们希望等待的线程retval(输出参数)，我们等待的线程终止时的返回值，就是在线程入口函数中return的值或者调用pthread_exit函数的参数返回值：成功时，返回0错误时，返回正数错误码</code></pre><ul><li>线程的分离：有时我们并不在乎某个线程是不是已经终止了，我们只是希望如果某个线程终止了，系统能自动回收掉该终止线程所占用的资源。pthread_detach函数为我们提供了这个功能，该功能称为线程的分离。默认情况下，一个线程终止了，是需要在被连接后系统才能回收其占有的资源的。如果我们调用pthread_detach函数去分离某个线程，那么该线程终止后系统将自动回收其资源。</li></ul>  <pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;pthread.h&gt;int pthread_detach(pthread_t thread);参数说明：thread(输入参数)，指定我们希望分离的线程。返回值：成功时，返回0错误时，返回正数错误码</code></pre><h3 id="简单的多线程打印实际操作"><a class="markdownIt-Anchor" href="#简单的多线程打印实际操作"></a> 简单的多线程打印实际操作</h3><ul><li>代码：</li></ul>  <pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;&#x2F;&#x2F;sleep函数在此头文件中void *mythread1(void)&#123;  int i;  for(i &#x3D; 0; i &lt; 10; i++)  &#123;    printf(&quot;This is the 1st pthread,created by zhangjie!\n&quot;);    sleep(1);  &#125;&#125;void *mythread2(void)&#123;  int i;  for(i &#x3D; 0; i &lt; 10; i++)  &#123;    printf(&quot;This is the 2st pthread,created by zhangjie!\n&quot;);    sleep(1);  &#125;&#125;int main(int argc, const char *argv[])&#123;  int i &#x3D; 0;  int ret &#x3D; 0;  pthread_t id1,id2;  ret &#x3D; pthread_create(&amp;id1, NULL, (void *)mythread1,NULL);  if(ret)  &#123;    printf(&quot;Create pthread error!\n&quot;);    return 1;  &#125;  ret &#x3D; pthread_create(&amp;id2, NULL, (void *)mythread2,NULL);  if(ret)  &#123;    printf(&quot;Create pthread error!\n&quot;);    return 1;  &#125;    pthread_join(id1,NULL);  pthread_join(id2,NULL);  return 0;&#125;</code></pre><ul><li>操作结果：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200714212245.jpg" alt="" /><br />注意：因为pthread的库不是linux系统的库，所以在进行编译的时候要加上-lpthread，否则编译不过。</li></ul><h3 id="线程间同步机制"><a class="markdownIt-Anchor" href="#线程间同步机制"></a> 线程间同步机制</h3><hr /><p>如果变量时只读的，多个线程同时读取该变量不会有一致性问题，但是，当一个线程可以修改的变量，其他线程也可以读取或者修改的时候，我们就需要对这些线程进行同步，确保它们在访问变量的存储内容时不会访问到无效的值。</p><h4 id="互斥锁"><a class="markdownIt-Anchor" href="#互斥锁"></a> 互斥锁</h4><ul><li>互斥量概念：多线程程序中可能会存在数据不一致的情况，那么如何保证数据一致呢？可以考虑同一时间只有一个线程访问数据。互斥量(mutex)就是一把锁。多个线程只有一把锁一个钥匙，谁上的锁就只有谁能开锁。当一个线程要访问一个共享变量时，先用锁把变量锁住，然后再操作，操作完了之后再释放掉锁，完成。当另一个线程也要访问这个变量时，发现这个变量被锁住了，无法访问，它就会一直等待，直到锁没了，它再给这个变量上个锁，然后使用，使用完了释放锁，以此进行。这个即使有多个线程同时访问这个变量，也好象是对这个变量的操作是顺序进行的。</li><li>互斥量用pthread_mutex_t数据类型表示。</li><li>互斥锁的使用：<ul><li>初始化锁：在Linux下，线程的互斥量数据类型是pthread_mutex_t。在使用前,要对它进行初始化。<ul><li>静态分配：<code>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</code></li><li>动态分配：<code>int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutex_attr_t *mutexattr);</code></li></ul></li><li>加锁:对共享资源的访问，要对互斥量进行加锁，如果互斥量已经上了锁，调用线程会阻塞，直到互斥量被解锁。<ul><li><code>int pthread_mutex_lock(pthread_mutex *mutex);</code>对互斥量mutex进行加锁，如果互斥量已经上锁，调用线程将一直阻塞直到互斥量被解锁。</li><li><code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code>尝试对互斥量mutex进行加锁，如果互斥量mutex处于未被锁住的状态，则将锁住该互斥量并返回0。如果互斥量mutex处于锁住的状态，则不能锁住该互斥量并返回EBUSY。</li></ul></li><li>解锁:在完成了对共享资源的访问后，要对互斥量进行解锁。<ul><li><code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code></li></ul></li><li>销毁锁:锁在是使用完成后，需要进行销毁以释放资源。<ul><li><code>int pthread_mutex_destroy(pthread_mutex *mutex);</code></li></ul></li></ul></li><li>互斥量的死锁:<ul><li>一个线程需要访问两个或者更多不同的共享资源，而每个资源又有不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就可能发生死锁。死锁就是指多个线程/进程因竞争资源而造成的一种僵局（相互等待），若无外力作用，这些进程都将无法向前推进。</li><li>死锁的处理策略：<ol><li>预防死锁：破坏死锁产生的四个条件：互斥条件、不剥夺条件、请求和保持条件以及循环等待条件。</li><li>避免死锁：在每次进行资源分配前，应该计算此次分配资源的安全性，如果此次资源分配不会导致系统进入不安全状态，那么将资源分配给进程，否则等待。</li><li>检测死锁：检测到死锁后通过资源剥夺、撤销进程、进程回退等方法解除死锁。</li></ol></li></ul></li><li>互斥锁在多线程打印中的应用示例：<ul><li>代码：</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;&#x2F;&#x2F;sleep函数在此头文件中static pthread_mutex_t g_mutex_lock;static int g_count &#x3D; 0;void *mythread1(void)&#123;    pthread_mutex_lock(&amp;g_mutex_lock);&#x2F;&#x2F;加锁    g_count++;    printf(&quot;This is the %d pthread,created by zhangjie!\n&quot;,g_count);        pthread_mutex_unlock(&amp;g_mutex_lock);&#x2F;&#x2F;解锁    sleep(1);&#125;void *mythread2(void)&#123;    pthread_mutex_lock(&amp;g_mutex_lock);    g_count++;    printf(&quot;This is the %d pthread,created by zhangjie!\n&quot;,g_count);    pthread_mutex_unlock(&amp;g_mutex_lock);&#x2F;&#x2F;解锁    sleep(1);  &#125;int main(int argc, const char *argv[])&#123;  int i &#x3D; 0;  int ret &#x3D; 0;  pthread_t id1,id2;  ret &#x3D; pthread_create(&amp;id1, NULL, (void *)mythread1,NULL);  if(ret)  &#123;    printf(&quot;Create pthread error!\n&quot;);    return 1;  &#125;  ret &#x3D; pthread_create(&amp;id2, NULL, (void *)mythread2,NULL);  if(ret)  &#123;    printf(&quot;Create pthread error!\n&quot;);    return 1;  &#125;    pthread_join(id1,NULL);  pthread_join(id2,NULL);  pthread_mutex_destroy(&amp;g_mutex_lock);&#x2F;&#x2F;销毁锁  return 0;&#125;</code></pre><ul><li>操作结果：<img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200715150033.jpg" alt="" /></li></ul></li><li>双线程交替打印AB<br />代码：</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;void* Print(void *Message)&#123;    for(;;)&#123;        int pauseTime &#x3D; rand() % 6;        sleep(pauseTime);        printf(&quot;%c\n&quot;, (char)Message);    &#125;    return NULL;&#125;int main()&#123;    pthread_t thread_1, thread_2;    srand(time(0));    pthread_create(&amp;thread_1, NULL, Print, (void*)&#39;A&#39;);    pthread_create(&amp;thread_2, NULL, Print, (void*)&#39;B&#39;);    pthread_join(thread_1, NULL);    pthread_join(thread_2, NULL);    return 0;&#125;</code></pre><h2 id="十一-linux内核"><a class="markdownIt-Anchor" href="#十一-linux内核"></a> 十一、Linux内核</h2><h3 id="linux内核的简介"><a class="markdownIt-Anchor" href="#linux内核的简介"></a> Linux内核的简介</h3><ul><li><strong>概述</strong>：Linux内核是Linux操作系统一部分。对下，它管理系统的所有硬件设备；对上，它通过系统调用，向Library Routine（例如C库）或者其它应用程序提供接口。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200714221339.jpeg" alt="" /></li><li><strong>Linux内核的任务</strong>：<ul><li>从技术层面讲，内核是硬件与软件之间的一个中间层。作用是将应用层序的请求传递给硬件，并充当底层驱动程序，对系统中的各种设备和组件进行寻址。</li><li>从应用程序的层面讲，应用程序与硬件没有联系，只与内核有联系，内核是应用程序知道的层次中的最底层。在实际工作中内核抽象了相关细节。</li><li>内核是一个资源管理程序。负责将可用的共享资源(CPU时间、磁盘空间、网络连接等)分配得到各个系统进程。</li><li>内核就像一个库，提供了一组面向系统的命令。系统调用对于应用程序来说，就像调用普通函数一样。</li></ul></li><li><strong>内核的实现策略</strong>：<ul><li>微内核：最基本的功能由中央内核（微内核）实现。所有其他的功能都委托给一些独立进程，这些进程通过明确定义的通信接口与中心内核通信。</li><li>宏内核：内核的所有代码，包括子系统（如内存管理、文件管理、设备驱动程序）都打包到一个文件中。内核中的每一个函数都可以访问到内核中所有其他部分。支持模块的动态装卸(裁剪)。Linux内核就是基于这个策略实现的。</li></ul></li><li><strong>Linux内核的组成部分</strong>：<ul><li>kernel：内核核心，一般为bzImage格式，通常位于/boot目录，名称为vmlinuz-VERSION-release；当系统启动之后该文件就不在使用，因为已经加载到内存，放置/boot下方便管理。</li><li>kernel object：内核模块，一般放置于/lib/modules/VERSION-release/；内核模块与内核核心版本一定要严格匹配。</li></ul></li></ul><h3 id="linux内核的整体架构"><a class="markdownIt-Anchor" href="#linux内核的整体架构"></a> Linux内核的整体架构</h3><ul><li><strong>整体架构</strong>：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200714222155.png" alt="" /></li><li><strong>子系统简介</strong>：根据内核的核心功能，Linux内核提出了5个子系统<ul><li>Process Scheduler：也称作进程管理、进程调度。负责管理CPU资源，以便让各个进程可以以尽量公平的方式访问CPU。</li><li>Memory Manager：内存管理。负责管理Memory（内存）资源，以便让各个进程可以安全地共享机器的内存资源。另外，内存管理会提供虚拟内存的机制，该机制可以让进程使用多于系统可用Memory的内存，不用的内存会通过文件系统保存在外部非易失存储器中，需要使用的时候，再取回到内存中。</li><li>VFS（Virtual File System）：虚拟文件系统。Linux内核将不同功能的外部设备，例如Disk设备（硬盘、磁盘、NAND Flash、Nor Flash等）、输入输出设备、显示设备等等，抽象为可以通过统一的文件操作接口（open、close、read、write等）来访问。这就是Linux系统“一切皆是文件”的体现。</li><li>Network：网络子系统。负责管理系统的网络设备，并实现多种多样的网络标准。</li><li>IPC（Inter-Process Communication），进程间通信。IPC不管理任何的硬件，它主要负责Linux系统中进程之间的通信。</li></ul></li></ul><h3 id="linux内核模块"><a class="markdownIt-Anchor" href="#linux内核模块"></a> Linux内核模块</h3><h4 id="linux内核的模块化设计"><a class="markdownIt-Anchor" href="#linux内核的模块化设计"></a> Linux内核的模块化设计</h4><ul><li><strong>内核模块化简介</strong>：<ul><li>为了改善单一体系结构的可扩展性、可维护性等，Linux操作系统使用了一种全新的内核模块机制。用户可以根据需要，在不需要对内核重新编译的情况下，模块能动态地装入内核或从内核移出。</li><li>模块是在内核空间运行的程序，实际上是一种目标对象文件，没有链接，不能独立运行，但是其代码可以在运行时链接到系统中作为内核的一部分运行或从内核中取下，从而可以动态扩充内核的功能。这种目标代码通常由一组函数和数据结构组成，用来实现一种文件系统，一个驱动程序，或其它内核上层的功能。模块机制的完整叫法应该是<em>动态可加载内核模块</em>(Loadable Kernel Module)或 <em>LKM</em>，一般就简称为模块。</li></ul></li><li><strong>内核模块化的特点</strong>：<ul><li>使得内核更加紧凑和灵活。</li><li>修改内核时，不必全部重新编译整个内核，可节省不少时间，避免人工操作的错误。系统中如果需要使用新模块，只要编译相应的模块然后使用特定用户空间的程序将模块插入即可。</li><li>模块可以不依赖于某个固定的硬件平台。</li><li>模块的目标代码一旦被链接到内核，它的作用和静态链接的内核目标代码完全等价。 所以，当调用模块的函数时，无须显式的消息传递。</li></ul></li><li><strong>Linux模块的组成部分</strong>：<ul><li>模块加载函数（必须）：当通过insmod命令加载内核模块时，模块的加载函数会自动被内核执行，完成本模块相关初始化工作。</li><li>模块卸载函数（必须）：当通过rmmod命令卸载模块时，模块的卸载函数会自动被内核执行，完成与模块加载函数相反的功能。</li><li>模块许可证声明（必须）：模块许可证（LICENCE）声明描述内核模块的许可权限，如果不声明LICENCE,模块被加载时将收到内核被污染的警告。大多数情况下，内核模块应遵循GPL 兼容许可权。Linux2.6 内核模块最常见的是以MODULE_LICENSE(“Dual BSD/GPL”)语句声明模块采用BSD/GPL 双LICENSE。</li><li>模块参数（可选）：模块参数是模块被加载的时候可以被传递给他的值，它本身对应模块内部的全局变量。</li><li>模块导出符号（可选）：内核模块可以导出符号(symbol,对应于函数或变量)，这样其他模块可以使用本模块中的变量或函数。</li><li>模块作者等信息声明（可选）。</li></ul></li><li><strong>内核模块与普通应用程序的比较</strong>：</li></ul><table><thead><tr><th></th><th>C语言普通应用程序</th><th>模块程序</th></tr></thead><tbody><tr><td>入口</td><td>main()</td><td>init_module()</td></tr><tr><td>出口</td><td>无</td><td>cleanup_module()</td></tr><tr><td>编译</td><td>gcc –c</td><td>编制专用Makefile，并调用gcc</td></tr><tr><td>连接</td><td>gcc</td><td>insmod</td></tr><tr><td>运行</td><td>直接运行</td><td>insmod</td></tr><tr><td>调试</td><td>gdb</td><td>kdbug, kdb, kgdb等内核调试工具</td></tr></tbody></table><h4 id="内核模块实现"><a class="markdownIt-Anchor" href="#内核模块实现"></a> 内核模块实现</h4><ul><li>内核模块的数据结构<ul><li>每一个内核模块在内核中都对应一个数据结构module，所有的模块通过一个链表维护。</li><li>部分成员例举（跟模块有关的数据结构存放在include/linux/module.h）：</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">  struct module&#123;    enum module_state state;                                &#x2F;&#x2F;状态    &#x2F;* Member of list of modules *&#x2F;    struct list_head list;                                &#x2F;&#x2F;所有的模块构成双链表，包头为全局变量modules    &#x2F;* Unique handle for this module *&#x2F;    char name[MODULE_NAME_LEN];                        &#x2F;&#x2F;模块名字，唯一，一般存储去掉.ko的部分    &#x2F;* Sysfs stuff. *&#x2F;    struct module_kobject mkobj;    struct module_attribute *modinfo_attrs;    const char *version;    const char *srcversion;    struct kobject *holders_dir;    &#x2F;* Exported symbols *&#x2F;&#x2F;**&#x2F;    const struct kernel_symbol *syms;                    &#x2F;&#x2F;导出符号信息，指向一个kernel_symbol的数组，有num_syms个表项。    const unsigned long *crcs;                        &#x2F;&#x2F;同样有num_syms个表项，不过存储的是符号的校验和    unsigned int num_syms;    &#x2F;* Kernel parameters. *&#x2F;    struct kernel_param *kp;    unsigned int num_kp;    &#x2F;* GPL-only exported symbols. *&#x2F;    unsigned int num_gpl_syms;&#x2F;                        &#x2F;具体意义同上面符号，但是这里只适用于GPL兼容的模块    const struct kernel_symbol *gpl_syms;    const unsigned long *gpl_crcs;#ifdef CONFIG_UNUSED_SYMBOLS    &#x2F;* unused exported symbols. *&#x2F;    const struct kernel_symbol *unused_syms;    const unsigned long *unused_crcs;    unsigned int num_unused_syms;    &#x2F;* GPL-only, unused exported symbols. *&#x2F;    unsigned int num_unused_gpl_syms;    const struct kernel_symbol *unused_gpl_syms;    const unsigned long *unused_gpl_crcs;#endif#ifdef CONFIG_MODULE_SIG    &#x2F;* Signature was verified. *&#x2F;    bool sig_ok;#endif    &#x2F;* symbols that will be GPL-only in the near future. *&#x2F;    const struct kernel_symbol *gpl_future_syms;    const unsigned long *gpl_future_crcs;    unsigned int num_gpl_future_syms;    &#x2F;* Exception table *&#x2F;    unsigned int num_exentries;    struct exception_table_entry *extable;    &#x2F;* Startup function. *&#x2F;    int (*init)(void);                            &#x2F;&#x2F;模块初始化函数指针    &#x2F;* If this is non-NULL, vfree after init() returns *&#x2F;    void *module_init;                            &#x2F;如果该函数不为空，则init结束后就可以调用进行适当释放    &#x2F;* Here is the actual code + data, vfree&#39;d on unload. *&#x2F;    void *module_core;                            &#x2F;&#x2F;核心数据和代码部分，在卸载的时候会调用    &#x2F;* Here are the sizes of the init and core sections *&#x2F;    unsigned int init_size, core_size;            &#x2F;&#x2F;对应于上面的init和core函数，决定各自占用的大小    &#x2F;* The size of the executable code in each section.  *&#x2F;    unsigned int init_text_size, core_text_size;    &#x2F;* Size of RO sections of the module (text+rodata) *&#x2F;    unsigned int init_ro_size, core_ro_size;    ......#ifdef CONFIG_MODULE_UNLOAD　　　　&#x2F;*模块间的依赖关系记录*&#x2F;    &#x2F;* What modules depend on me? *&#x2F;    struct list_head source_list;    &#x2F;* What modules do I depend on? *&#x2F;    struct list_head target_list;    &#x2F;* Who is waiting for us to be unloaded *&#x2F;    struct task_struct *waiter;                    &#x2F;&#x2F;等待队列，记录那些进程等待模块被卸载    &#x2F;* Destruction function. *&#x2F;    void (*exit)(void);                            &#x2F;&#x2F;卸载退出函数，模块中定义的exit函数    ......&#125;;</code></pre></li><li>内核符号表：<ul><li>内核符号表是一个用来存放所有模块可以访问的那些符号以及相应地址的特殊的表。模块的连接就是将模块插入到内核的过程。模块所声明的任何全局符号都成为内核符号表的一部分。内核模块根据系统符号表从内核空间中获取符号的地址，从而确保在内核空间中正确地运行。</li><li>这是一个公开的符号表，我们可以从文件/proc/kallsyms中以文本的方式读取。在这个文件中存放数据地格式如下：<br />内存地址      属性      符号名称        【所属模块】</li></ul></li><li>模块依赖：<ul><li>内核符号表记录了所有模块可以访问的符号及相应地址。一个内核模块被装入后，它所声明的符号就会被记录到这个表里，而这些符号当然就可能会被其他模块所引用。这就引出了模块依赖这个问题。</li><li>一个模块A引用另一个模块B所导出的符号，我们就说模块B被模块A引用，或者说模块A装载到模块B的上面。如果要链接模块A，必须先要链接模块B。否则，模块B所导出的那些符号的引用就不可能被链接到模块A中。这种模块间的相互关系就叫做模块依赖。</li><li>模块间的依赖关系通过两个节点source_list和target_list记录，前者记录那些模块依赖于本模块，后者记录本模块依赖于那些模块。节点通过module_use记录，module_use如下（定义在include/linux/module.h中）：</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">  struct module_use &#123;    struct list_head source_list;    struct list_head target_list;    struct module *source, *target;&#125;;</code></pre></li><li>内核描述：<ul><li>每当内核需要使用这个模块提供的功能，就会到链表modules中寻找这个模块，并调用模块使用export修饰的功能函数。module中，成员state为模块当前的状态。它是一个枚举类型的变量，可取的值为MODULE_STATE_LIVE、MODULE_STATE_COMING、MODULE_STATE_GOING，分为当前正常使用中（存活状态）、模块当前正在被加载和模块当前正在被卸载三种状态。</li><li>当模块向内核加载时，insmod调用内核的模块加载函数，该函数在完成模块的部分创建工作后，将模块的状态置为MODULE_STATE_COMING。接着内核将调用内核模块初始化函数，并在完成所有的初始化工作之后（包括将模块加入模块注册表，调用模块本身的初始化函数），将模块状态设置为MODULE_STATE_LIVE。</li><li>当使用rmmod命令卸载模块时，内核将调用系统调用delete_module，并将模块的状态置为MODULE_STATE_GOING。</li></ul></li></ul><h4 id="内核模块的基本操作"><a class="markdownIt-Anchor" href="#内核模块的基本操作"></a> 内核模块的基本操作</h4><ul><li>核心模块的观察<ul><li><code>lsmod</code>(list module)命令；</li><li>使用 lsmod 之后，系统会显示出目前已经存在於核心当中的模块，显示的内容包括有：模块名称(Module)；模块的大小(size)；此模块是否被其他模块所使用 (Used by)。<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200714234247.jpg" alt="" /></li></ul></li><li>核心模块的加载与移除：<ul><li><code>insmod</code>加载模块：格式<code>insmod &lt;modulename&gt;</code></li><li><code>remmod</code>移除模块：格式<code>rmmod &lt;modulename&gt;</code></li></ul></li></ul><h4 id="实现一个简单的内核模块"><a class="markdownIt-Anchor" href="#实现一个简单的内核模块"></a> 实现一个简单的内核模块</h4><ul><li><p>hello.c模块代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">  #define MODULE#include&lt;linux&#x2F;module.h&gt;int init_module(void)&#123;  printk(&quot;&lt;1&gt;Hello World，created by zhangjie!\n&quot;);  return 0;&#125;void cleanup_module(void)&#123;  printk(&quot;&lt;1&gt;GoodBye!\n&quot;);&#125;MODULE_LICENSE(&quot;GPL&quot;);</code></pre><p>说明：</p><ol><li>任何模块程序的编写都需要包含linux/module.h这个头文件，这个文件包含了对模块的结构定义以及模块的版本控制。</li><li>函数init_module()和函数exit_module( )是模块编程中最基本的也是必须的两个函数。init_module()向内核注册模块所提供的新功能；exit_module()负责注销所有由模块注册的功能。</li><li>注意我们在这儿使用的是printk()函数(不要习惯性地写成printf)，printk()函数是由Linux内核定义的，功能与printf相似。</li></ol></li><li><p>Makefile文件：</p><pre class="line-numbers language-none"><code class="language-none">TARGET &#x3D; helloPWD :&#x3D;$(shell pwd)KVER ?&#x3D;$(shell uname -r)KDIR :&#x3D; &#x2F;lib&#x2F;modules&#x2F;$(KVER)&#x2F;buildobj-m +&#x3D; $(TARGET).odefault:  make -C $(KDIR) M&#x3D;$(PWD) modules</code></pre></li><li><p>操作步骤：</p><ol><li>在Makefile及hello.c所在目录下，直接<code>make</code>，成功后查看当前目录下有无hello.ko文件产生，有则内核模块生成成功；</li><li>使用<code>insmod</code>命令，把此内核模块程序加载到内核中运行。结合<code>lsmod</code>，查看内核模块程序在内核中是否正确运行；</li><li>查看内核模块程序打印的信息，使用<code>dmesg</code>命令</li></ol></li><li><p>示例：<br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200715173315.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200715173659.jpg" alt="" /><br /><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200715174224.jpg" alt="" /></p></li></ul><h2 id="十二-linux的信号机制"><a class="markdownIt-Anchor" href="#十二-linux的信号机制"></a> 十二、Linux的信号机制</h2><h3 id="信号"><a class="markdownIt-Anchor" href="#信号"></a> 信号</h3><p>信号是进程间一种有限的通信方式，用来提醒进程一件事情已经发生。 当一个信号发送给进程时，系统终端进程的控制流程，如果定义了进程的信号处理函数，则执行处理函数，否则执行默认的处理函数。</p><p><code>signal.h</code> 中定义的信号如有:</p><ul><li><code>SIGINT</code>: 当用户希望中断进程时，SIGINT信号由用户的控制终端发送到进程。这通常通过按下Ctrl+C来发送，但是在某些系统中，可以使用“DELETE”键或“BREAK”键。</li><li><code>SIGHUP</code>: 检测到控制中断挂起或者控制进程死亡时，进程会收到 SIGHUP。现在操作系统，该信号通常意味着使用的 虚拟终端 已经被关闭。许多 守护进程 在接收到该信号时，会重载他们的设置和重新打开日志文件（logfiles），而不是去退出程序。nohup 命令用于无视该信号。</li><li><code>SIGTSTP</code>: 当用户希望挂起进程的时候，SIGTSTP信号由用户的控制终端发送到进程，通常通过按下 Ctrl + Z来发送，默认情况下会使进程暂停。</li><li><code>SIGKILL</code>: 发送SIGKILL信号到一个进程可以使其立即终止(KILL)。与SIGTERM和SIGINT相不同的是，这个信号不能被捕获或忽略，接收过程在接收到这个信号时不能执行任何清理。 以下例外情况适用:<ul><li>僵尸进程不能被杀死，因为它们已经死了，正在等待它们的父进程来收获它们。</li><li>处于阻塞状态的进程不会死亡，直到它们再次醒来。</li><li>init 进程是特殊的: init不接收任何它不打算处理的信号，因此它会忽略SIGKILL。这条规则有一个例外，Linux 上的 init 如果被 ptrace 了，那么它是可以接收 SIGKILL 并被杀死的。</li></ul></li></ul><h3 id="信号接收与处理"><a class="markdownIt-Anchor" href="#信号接收与处理"></a> 信号接收与处理</h3><p>信号的接受与处理都在<code>signal.h</code>中</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;void handler(int signum)&#123;    if(signum &#x3D;&#x3D; SIGINT)        printf(&quot;Recived SIGINT signal, ignoring...\n&quot;);    else if(signum &#x3D;&#x3D; SIGHUP)        printf(&quot;Recived SIGHUP signal. ignoring...\n&quot;);    else if(signum &#x3D;&#x3D; SIGTSTP)        printf(&quot;Recived SIGTSTP signal, ignoring...\n&quot;);    else        printf(&quot;Recived signal %d \n&quot;, signum);&#125;int main()&#123;    signal(SIGINT, handler);    signal(SIGHUP, handler);    signal(SIGTSTP,handler);    printf(&quot;Waiting for signal... \n\n&quot;);    for(;;)        sleep(10000);    return 0;&#125;</code></pre><h3 id="信号发送"><a class="markdownIt-Anchor" href="#信号发送"></a> 信号发送</h3><p>信号发送通过<code>kill()</code> 就可实现。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys&#x2F;types.h&gt;int main(int argc, char **argv)&#123;    if(argc !&#x3D; 2)&#123;       printf(&quot;A pid is needed\n&quot;);       return -1;    &#125;    int pid &#x3D; atoi(argv[1]);    if(pid &lt; 0) &#123;        printf(&quot;Pid is illgal\n&quot;);        return -1;    &#125;    printf(&quot;Sending SIGINT signal...\n&quot;);    getchar();    kill(pid, SIGINT);    printf(&quot;Sending SIGHUP signal...\n&quot;);    getchar();    kill(pid, SIGHUP);    printf(&quot;Sending SIGTSTP signal...\n&quot;);    getchar();    kill(pid, SIGTSTP);    printf(&quot;Sending SIGKILL Signal...\n&quot;);    getchar();    kill(pid, SIGKILL);    return 0;&#125;</code></pre><h3 id="中断"><a class="markdownIt-Anchor" href="#中断"></a> 中断</h3><p>中断是一个打断正常工作流程的事件，由硬件设备，CPU或者软件产生。</p><p>中断可分为</p><ul><li>同步: 通过一条指令产生</li><li>异步: 由外部指令产生</li><li>可屏蔽</li><li>不可屏蔽</li></ul><p>同步中断，通常被称之为异常，是在处理器处理指令过程中产生的，例如除以0</p><p>异步中断，通常被称之为中断，由外部IO设备产生，例如网卡在收到数据包的时候会产生中断</p><h4 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h4><p>通常异常有两个来源</p><ul><li>处理器检测到<ul><li>错误</li><li>陷阱</li><li>中断</li></ul></li><li>事先编程的</li></ul><p>错误通常可以在执行指令之前可以检测到，通常可以纠正。而陷阱通常是指令运行后报告的异常。</p><h4 id="中断的好处"><a class="markdownIt-Anchor" href="#中断的好处"></a> 中断的好处</h4><p>中断可以用来提高计算机运行效率，增强计算功能。 如果没有中断，则处理器在与外部设备通行的过程中， 必须反复轮询设备是否完成动作， 造成了大量的处理器周期被浪费。 引入中断后， 设备可以主动发送中断信号给处理器， 提示处理器工作完成， 处理器就可以回过头来处理结果。 这样， 在设备处理的过程中， 处理器可以继续执行其他工作， 提高了运行效率</p><h4 id="中断向量"><a class="markdownIt-Anchor" href="#中断向量"></a> 中断向量</h4><ul><li>每个中断和异常是由0～255之间的一个数来标识的，Intel把这个8位无符号整数叫做一个向量（vector）。非屏蔽中断的向量和异常的向量是固定的，而可屏蔽中断的向量是可以通过对中断控制器的编程来改变。</li><li>中断向量表<br />正如前面所说，中断和异常都是由一个中断向量来标识，在 Linux 中， 就有中断描述符表 (Interrupts Descriptor Table)， 在 <code>arch/x86/include/asm/irq_vectors.h</code> 有详细的定义。</li></ul><h4 id="rtc"><a class="markdownIt-Anchor" href="#rtc"></a> RTC</h4><p><a href="https://www.kernel.org/doc/html/latest/admin-guide/rtc.html">RTC on linux doc</a></p><p>RTC 是硬件驱动的实时时钟</p><p>RTC 可以产生周期性的中断(不一定是秒，而是内部的频率), 也可产生定时的中断 (Alarm)</p><p>/dev/rtc或者/dev/rtcN 可以通过 <code>ioctl</code> 读取和控制, 相关接口可见 <code>linux/rtc.h</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;linux&#x2F;rtc.h&gt;#include &lt;sys&#x2F;ioctl.h&gt;#include &lt;sys&#x2F;time.h&gt;#include &lt;sys&#x2F;types.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;int main(int argc, char **argv)&#123;    int flag;    struct rtc_time rtc_current;    if(getuid())&#123;        printf(&quot;\e[0;31m Root privilege is needed\n&quot;);        return -1;    &#125;    if(argc !&#x3D; 2)&#123;        printf(&quot;\e[0;31m An argument is needed\n&quot;);        return -1;    &#125;    char *rtc_dev &#x3D; argv[1];    &#x2F;&#x2F; Open RTC device    int fd &#x3D; open(rtc_dev, O_RDONLY);    if(fd &#x3D;&#x3D; -1) &#123;        printf(&quot;\e[0;31m RTC Device open error\n&quot;);        return -1;    &#125;    &#x2F;&#x2F; Read current time    flag &#x3D; ioctl(fd, RTC_RD_TIME, &amp;rtc_current);    if(flag &#x3D;&#x3D; -1) &#123;        printf(&quot;\e[0;31m Can&#39;t read current time\n&quot;);        return -1;    &#125;    printf(&quot;Current time %d-%d-%d, %02d:%02d:%02d \n&quot;,        rtc_current.tm_year + 1900, rtc_current.tm_mon + 1, rtc_current.tm_mday,        rtc_current.tm_hour, rtc_current.tm_min, rtc_current.tm_sec    );    &#x2F;&#x2F; Set alarm 10 min later    rtc_current.tm_min +&#x3D; 10;    if(rtc_current.tm_min &gt;&#x3D; 60) &#123;        rtc_current.tm_min &#x3D; 0;        rtc_current.tm_hour +&#x3D; 1;    &#125;    if(rtc_current.tm_hour &#x3D;&#x3D; 24) &#123;        rtc_current.tm_hour &#x3D; 0;    &#125;    flag &#x3D; ioctl(fd, RTC_ALM_SET, &amp;rtc_current);    if(flag &#x3D;&#x3D; -1) &#123;        printf(&quot;\e[0;31m Can&#39;t set alarm&quot;);        return -1;    &#125;    &#x2F;&#x2F; Read alarm settings    flag &#x3D; ioctl(fd, RTC_ALM_READ, &amp;rtc_current);    if(flag &#x3D;&#x3D; -1) &#123;        printf(&quot;\e[0;31m Can&#39;t read alarm&quot;);        return -1;    &#125;    printf(&quot;Alarm on %d-%d-%d, %02d:%02d:%02d \n&quot;,        rtc_current.tm_year + 1900, rtc_current.tm_mon + 1, rtc_current.tm_mday,        rtc_current.tm_hour, rtc_current.tm_min, rtc_current.tm_sec    );    &#x2F;&#x2F; Set alarm interrupt on    flag &#x3D; ioctl(fd, RTC_AIE_ON, 0);    if(flag &#x3D;&#x3D; -1) &#123;        printf(&quot;\e[0;31m Can&#39;t set alarm interrupt on&quot;);        return -1;    &#125;    &#x2F;&#x2F; Waiting for alarm on    unsigned long interrupt;    flag &#x3D; read(fd, &amp;interrupt, sizeof(long));    if(flag &#x3D;&#x3D; -1) &#123;        printf(&quot;\e[0;31m Read alarm error\n&quot;);        return -1;    &#125;    printf(&quot;Alarm rings!\n&quot;);    &#x2F;&#x2F; Disable alrm interrupt    flag &#x3D; (fd, RTC_AIE_OFF, 0);    if(flag &#x3D;&#x3D; -1) &#123;        printf(&quot;\e[0;31m Can&#39;t disable alarm interrupt\n&quot;);        return -1;    &#125;    return 0;&#125;</code></pre><h1 id="linux报错解决"><a class="markdownIt-Anchor" href="#linux报错解决"></a> Linux报错解决</h1><ul><li>E: 仓库 “<a href="http://ppa.launchpad.net/webupd8team/java/ubuntu">http://ppa.launchpad.net/webupd8team/java/ubuntu</a> eoan Release” 没有 Release 文件。</li><li><a href="https://www.cnblogs.com/yyee/p/12888675.html">解决</a></li></ul><h1 id="linux管道"><a class="markdownIt-Anchor" href="#linux管道"></a> Linux管道</h1><ul><li>管道是Linux由Unix那里继承过来的进程间的通信机制，它是Unix早期的一个重要通信机制。其思想是，在内存中创建一个共享文件，从而使通信双方利用这个共享文件来传递信息。由于这种方式具有单向传递数据的特点，所以这个作为传递消息的共享文件就叫做“管道”。</li><li>管道是一种通信机制，通常用于进程间的通信（也可通过socket进行网络通信），它表现出来的形式将前面每一个进程的输出（stdout）直接作为下一个进程的输入（stdin）。</li><li>管道命令使用<code>|</code>作为界定符号</li><li>管道命令仅能处理standard output,对于standard error output会予以忽略。</li><li>less,more,head,tail…都是可以接受standard input的命令，所以他们是管道命令</li><li>管道命令必须要能够接受来自前一个命令的数据成为standard input继续处理才行。</li></ul><h1 id="linux网络操作"><a class="markdownIt-Anchor" href="#linux网络操作"></a> Linux网络操作</h1><h2 id="主机名配置"><a class="markdownIt-Anchor" href="#主机名配置"></a> 主机名配置</h2><ul><li><code>hostname</code>:查看主机名;</li><li><code>hostname 新的主机名</code>:修改主机名，重启后无效</li></ul><h2 id="ip地址查看与配置"><a class="markdownIt-Anchor" href="#ip地址查看与配置"></a> ip地址查看与配置</h2><ul><li><code>ifcofig</code>可以查看和临时修改ip地址。</li></ul><h2 id="域名解析文件"><a class="markdownIt-Anchor" href="#域名解析文件"></a> 域名解析文件</h2><ul><li><code>/etc/hosts</code>文件中有域名的配置文件。</li></ul><h2 id="网络服务管理"><a class="markdownIt-Anchor" href="#网络服务管理"></a> 网络服务管理</h2><ul><li><code>service network status</code>:查看网络服务的状态</li><li><code>service network stop</code>:停止网络服务</li><li><code>service network start</code>:启动网络服务</li><li><code>service network restart</code>:重启网络服务</li><li><code>service --status-all</code>:查看系统中所有后台服务</li><li><code>netstat -nltp</code>:查看系统中网络进程的端口监听情况。</li></ul><hr /><ul><li><code>service iptables status</code>:查看防火墙状态</li><li><code>service iptables start</code>:启动防火墙</li><li><code>service iptables stop</code>:关闭防火墙</li><li><code>chkconfig iptables off</code>:禁止防火墙自启</li></ul><h1 id="linux的几种软件安装方式"><a class="markdownIt-Anchor" href="#linux的几种软件安装方式"></a> Linux的几种软件安装方式</h1><ol><li>二进制发布包：<ol><li>软件已经针对具体的平台编译打包发布，只要解压，修改配置即可。</li></ol></li><li>RPM包：<br />1.软件已经根据redhat的包管理工具规范RPM打包发布，需要获取到相应软件的rpm包，然后用rpm命令安装。</li><li>apt(apt-get)在线安装：（ubuntu系列）<ul><li><code>apt-cache search soft</code> 注：soft是你要找的软件的名称或相关信息</li><li>如果找到了软件soft.version，则用apt-get install soft.version命令安装软件<ul><li>注：只要你可以上网，只需要用apt-cache search查找软件;</li><li>用apt-get install软件详细介绍：<ul><li>apt-get是debian，ubuntu发行版的包管理工具，与红帽中的yum工具非常类似。</li><li>apt-get命令一般需要root权限执行，所以一般跟着sudo命令例sudo apt-get xxxx</li><li>apt-get install packagename——安装一个新软件包（参见下文的aptitude）</li><li>apt-get remove packagename——卸载一个已安装的软件包（保留配置文件）</li><li>apt-get --purge remove packagename——卸载一个已安装的软件包（删除配置文件）</li><li>dpkg --force-all --purge packagename ——有些软件很难卸载，而且还阻止了别的软件的应用，就可以用这个，不过有点冒险。</li><li>apt-get autoremove——因为apt会把已装或已卸的软件都备份在硬盘上，所以如果需要空间的话，可以让这个命令来删除你已经删掉的软件。</li><li>apt-get autoclean——定期运行这个命令来清除那些已经卸载的软件包的.deb文件。通过这种方式，可以释放大量的磁盘空间。如果需求十分迫切，可以使用apt-get clean以释放更多空间。这个命令会将已安装软件包裹的.deb文件一并删除。</li><li>apt-get clean——这个命令会把安装的软件的备份也删除，不过这样不会影响软件的使用的。</li><li>apt-get upgrade——更新所有已安装的软件包</li><li>apt-get dist-upgrade——将系统升级到新版本</li><li>apt-cache search string——在软件包列表中搜索字符串</li><li>apt-cache showpkg pkgs——显示软件包信息。</li><li>apt-cache stats——查看库里有多少软件</li><li>apt-cache dumpavail——打印可用软件包列表。</li><li>apt-cache show pkgs——显示软件包记录，类似于dpkg –print-avail。</li><li>apt-cache pkgnames——打印软件包列表中所有软件包的名称</li><li>简单的说： dpkg只能安装已经下载到本地机器上的deb包. apt-get能在线下载并安装deb包,能更新系统,且还能自动处理包与包之间的依赖问题,这个是dpkg工具所不具备的。</li></ul></li></ul></li></ul></li><li>源码编译安装：<ol><li>软件以源码工程的形式发布，需要获取到源码工程后，用相应的开发工具进行编译打包部署。</li></ol></li><li>ubuntu安装本地<code>.deb</code>包：<ol><li><code>dpkg -i deb包名</code></li><li>如果出现缺少依赖的错误，则可以通过<code>apt-get upgrade -f</code>来更新。</li></ol></li></ol><h1 id="ftpsftp文件传输"><a class="markdownIt-Anchor" href="#ftpsftp文件传输"></a> ftp/sftp文件传输</h1><ul><li>使用给予ftp或者sftp的工具进行客户端和服务端之间的文件传输。</li><li>如：filezilla，lrzsz，sftp等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkdownLearn</title>
      <link href="//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/MarkdownLearn/index.html"/>
      <url>//post/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E6%9D%82%E6%8A%80%E6%9C%AF/MarkdownLearn/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="markdownlearn"><a class="markdownIt-Anchor" href="#markdownlearn"></a> MarkdownLearn</h1><h2 id="一-markdown简介"><a class="markdownIt-Anchor" href="#一-markdown简介"></a> 一、Markdown简介</h2><blockquote><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。<br />Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。</p></blockquote><h2 id="二-编辑markdown的工具"><a class="markdownIt-Anchor" href="#二-编辑markdown的工具"></a> 二、 编辑Markdown的工具</h2><p>1.vscode</p><ul><li>需要安装插件<ul><li>Markdown All in One -&gt; 各种优化一股脑装上</li><li>Markdown Preview GitHub styling -&gt; 使预览格式与GitHub pages中一样</li><li>Markdown preview ehenced -&gt; 快捷键：英文输入状态下，同时按下ctrl,k 然后同时放开再按v可唤出预览窗口。</li><li>Markdownlint -&gt;  markdown语法检查纠正器</li><li>Markdown PDF -&gt; 将.md文件转换成pdf,jpeg,png,html格式</li></ul></li></ul><p>2.typora</p><ul><li>专业Markdown编辑器，可去<a href="https://www.typora.io/">官网</a>下载。</li><li>界面简约美观，专用于写Markdown文件，功能强劲。</li></ul><h2 id="三-文本编辑语法"><a class="markdownIt-Anchor" href="#三-文本编辑语法"></a> 三、文本编辑语法</h2><h3 id="标题"><a class="markdownIt-Anchor" href="#标题"></a> 标题</h3><pre class="line-numbers language-none"><code class="language-none"># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><p>标题一般支持六级。注意： # 与文字之间有一个空格</p><h3 id="缩进换行空行及对齐方式"><a class="markdownIt-Anchor" href="#缩进换行空行及对齐方式"></a> 缩进，换行，空行及对齐方式</h3><h4 id="首行缩进使用占位符"><a class="markdownIt-Anchor" href="#首行缩进使用占位符"></a> 首行缩进(使用占位符)</h4><p> 空四位</p><p> 空两位<br /> 空一位</p><pre class="line-numbers language-none"><code class="language-none">&amp;emsp;空四位  &amp;ensp;空两位&amp;nbsp;空一位</code></pre><p>注意：占位符后的 ； 不可少</p><h4 id="换行"><a class="markdownIt-Anchor" href="#换行"></a> 换行</h4><p>在一行字后面加了两个空格（space）再回车</p><h4 id="空行"><a class="markdownIt-Anchor" href="#空行"></a> 空行</h4><p>在一行中只有空格（space)或回车则为空行，但无论空了多少行，最终在预览中都只显示一行空格。</p><h4 id="对齐方式"><a class="markdownIt-Anchor" href="#对齐方式"></a> 对齐方式</h4><center>行中心对齐</center> <p align="left">行左对齐</p>   <p align="right">行右对齐</p><pre class="line-numbers language-none"><code class="language-none">&lt;center&gt; 行中心对齐&lt;&#x2F;center&gt; &#x2F;&#x2F;后面的&lt;&#x2F;center&gt;可省略&lt;p align&#x3D;&quot;left&quot;&gt;行左对齐&lt;&#x2F;p&gt;  &#x2F;&#x2F;后面的&lt;&#x2F;p&gt;可省略&lt;p align&#x3D;&quot;right&quot;&gt;行右对齐&lt;&#x2F;p&gt;</code></pre><h3 id="斜体粗体删除线下划线高亮"><a class="markdownIt-Anchor" href="#斜体粗体删除线下划线高亮"></a> 斜体，粗体，删除线，下划线,==高亮==</h3><p><em>斜体</em><br /><strong>粗体</strong><br /><em><strong>加粗斜体</strong></em><br /><s>删除线</s><br /><u>下划线</u><br />==高亮== (只有一些预览才支持)</p><pre class="line-numbers language-none"><code class="language-none">*斜体*  **粗体**  ***加粗斜体***  ~~删除线~~   &lt;u&gt;下划线&lt;&#x2F;u&gt;&#x3D;&#x3D;高亮&#x3D;&#x3D;</code></pre><h2 id="四-链接"><a class="markdownIt-Anchor" href="#四-链接"></a> 四、链接</h2><h3 id="行内式普通超链接"><a class="markdownIt-Anchor" href="#行内式普通超链接"></a> 行内式（普通超链接）</h3><p>GitHub欢迎你<a href="www.github.com">github</a></p><pre class="line-numbers language-none"><code class="language-none">GitHub欢迎你[github](www.github.com)   []方括号内放链接名字，（）圆括号内放链接地址</code></pre><h3 id="锚点页内超链接"><a class="markdownIt-Anchor" href="#锚点页内超链接"></a> 锚点（页内超链接）</h3><p><a href="#markdown%E7%AE%80%E4%BB%8B">跳转到markdown简介</a></p><pre class="line-numbers language-none"><code class="language-none">[跳转到markdown简介](#markdown简介)[]方括号中放显示的链接文字，（）圆括号中放要跳转的标题。  </code></pre><p>注意：锚点仅支持跳转到标题，且不管是几级的标题，（）圆括号中都只放一个#</p><h2 id="五-列表"><a class="markdownIt-Anchor" href="#五-列表"></a> 五、列表</h2><h3 id="无序列表"><a class="markdownIt-Anchor" href="#无序列表"></a> 无序列表</h3><ul><li>无序列表项一</li><li>无序列表项二<ul><li>无序列表五<ul><li>无序列表六</li></ul></li></ul></li></ul><ul><li>无序列表项三</li></ul><ul><li>无序列表项四</li></ul><pre class="line-numbers language-none"><code class="language-none">* 无序列表项一* 无序列表项二  * 无序列表五    * 无序列表六  + 无序列表项三- 无序列表项四</code></pre><p>注意：</p><ul><li><code>*</code>,<code>-</code>,<code>+</code>三种符号任意一个都可创建无序列表</li><li>无序列表每一行之后回车会自动新建一个空无序列表行</li><li>符号<code>* ，-, +</code>与字符之间要有空格</li><li>利用tab对<code>*、+、-</code>缩进，可以形成层级列表</li></ul><h3 id="有序列表"><a class="markdownIt-Anchor" href="#有序列表"></a> 有序列表</h3><ol><li>有序列表项一</li><li>有序列表项二</li><li>有序列表项三</li></ol><p>注意：</p><ol><li>数字加英文句点之后空格再加字符创建有序列表</li><li>每行之后回车会自动创建新的一行并且序号加一</li><li>结束有序列表需要在最后加空行（连按两次回车，或空格两次再回车）</li></ol><h2 id="六-图像插入"><a class="markdownIt-Anchor" href="#六-图像插入"></a> 六、图像插入</h2><h3 id="插入本地图片"><a class="markdownIt-Anchor" href="#插入本地图片"></a> 插入本地图片</h3><h4 id="相对路径法"><a class="markdownIt-Anchor" href="#相对路径法"></a> 相对路径法</h4><p><img src="./MarkdownLearn/back.jpg" alt="loading" /></p><pre class="line-numbers language-none"><code class="language-none">![loading](.&#x2F;MarkdownLearn&#x2F;back.jpg)[]方括号中放入当图片加载不出来时显示的文字（）圆括号中放入图片对.md文件的相对路径</code></pre><p>注意：</p><ol><li>需要再.md文件的同级目录下建立储存图片的文件夹</li><li>在vscode中需要打开包含.md和对应储存文件夹的文件夹</li><li>注意相对路径的格式</li><li>由于未知原因，在githubpages中不能显示</li></ol><h3 id="插入网络图片"><a class="markdownIt-Anchor" href="#插入网络图片"></a> 插入网络图片</h3><h4 id="建立图床"><a class="markdownIt-Anchor" href="#建立图床"></a> 建立图床</h4><p>利用picgo和gitee建立图床</p><h4 id="将图片上传至图床生成链接"><a class="markdownIt-Anchor" href="#将图片上传至图床生成链接"></a> 将图片上传至图床，生成链接</h4><p><img src="https://zjpicture.oss-cn-beijing.aliyuncs.com/giteePic/picgo-master/img/20200619184526.jpg" alt="" /></p><pre class="line-numbers language-none"><code class="language-none">![](https:&#x2F;&#x2F;zjpicture.oss-cn-beijing.aliyuncs.com&#x2F;giteePic&#x2F;picgo-master&#x2F;img&#x2F;20200619184526.jpg)圆括号内放图片链接，其余一样</code></pre><h2 id="七-引用"><a class="markdownIt-Anchor" href="#七-引用"></a> 七、引用</h2><blockquote><p>我是周树人</p><blockquote><p>你找鲁迅</p><blockquote><p>和我周树人有什么关系</p></blockquote></blockquote></blockquote><pre class="line-numbers language-none"><code class="language-none">&gt;我是周树人&gt;&gt;你找鲁迅&gt;&gt;&gt;和我周树人有什么关系  要终止引用，同结束列表一样，需要在引用之后空一行</code></pre><h2 id="八-字符设置"><a class="markdownIt-Anchor" href="#八-字符设置"></a> 八、字符设置</h2><h3 id="转义字符"><a class="markdownIt-Anchor" href="#转义字符"></a> 转义字符</h3><ul><li>*, \, \\</li></ul><pre class="line-numbers language-none"><code class="language-none">* \*, \\, \\\转义字符为&#39;\&#39;,对于特殊字符如&#39;*&#39;等，需要在其前面加入&#39;\&#39;才能显示其原本的字符（类似c语言）</code></pre><h3 id="字体-字号-颜色"><a class="markdownIt-Anchor" href="#字体-字号-颜色"></a> 字体、字号、颜色</h3><p><font face="黑体">我是黑体字</font><br /><font face="微软雅黑">我是微软雅黑</font><br /><font face="黑体" size=12 color=red>我是12号红色黑体</font></p><pre class="line-numbers language-none"><code class="language-none">&lt;font face&#x3D;&quot;黑体&quot;&gt;我是黑体字&lt;&#x2F;font&gt;&lt;font face&#x3D;&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;&#x2F;font&gt;&lt;font face&#x3D;&quot;黑体&quot; size&#x3D;12 color&#x3D;red&gt;我是12号红色黑体&lt;&#x2F;font&gt;欲要解锁更多字体，请自行查电脑的字体库，找到字体的名字</code></pre><h2 id="九-内容目录"><a class="markdownIt-Anchor" href="#九-内容目录"></a> 九、内容目录</h2><ul><li>支持[TOC]的编辑器上，直接在文前输入[TOC]</li><li>用hexo搭建的GitHubPages会自动生成目录</li><li>vscode安上markdown preview enhenced 之后会自动生成目录</li></ul><h2 id="十-代码块"><a class="markdownIt-Anchor" href="#十-代码块"></a> 十、代码块</h2><h3 id="行内式"><a class="markdownIt-Anchor" href="#行内式"></a> 行内式</h3><p>c语言的<code>scanf()</code>怎么用？</p><pre class="line-numbers language-none"><code class="language-none">c语言的&#96;scanf()&#96;怎么用？用&quot;&#96;&quot;符号包裹代码</code></pre><h3 id="缩进式多行代码"><a class="markdownIt-Anchor" href="#缩进式多行代码"></a> 缩进式多行代码</h3><pre><code>#include &lt;stdio.h&gt;int main()&#123;  printf(&quot;hello world!&quot;);  return 0;&#125;</code></pre><p>缩进4个空格则自动成为代码块，会一直持续到没有缩进的一行。（个人认为适用于不是任何编程语言但需要原封不动显示字符的地方）</p><h3 id="包裹式多行代码"><a class="markdownIt-Anchor" href="#包裹式多行代码"></a> 包裹式多行代码</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;    int main()    &#123;      printf(&quot;hello world!&quot;);      return 0;    &#125;</code></pre><ul><li>代码开始前输入```,之后加入语言类型以实现语法高亮，如```c</li><li>代码结束后输入```,之后代码块结束</li></ul><h2 id="十一-流程图"><a class="markdownIt-Anchor" href="#十一-流程图"></a> 十一、流程图</h2><pre class="line-numbers language-flow" data-language="flow"><code class="language-flow">st&#x3D;&gt;start: 开始e&#x3D;&gt;end: 结束op1&#x3D;&gt;operation: 新品开发流程op2&#x3D;&gt;operation: 产品需求提出op3&#x3D;&gt;operation: 产品试用 负责人：吴xxop4&#x3D;&gt;operation: 包装op5&#x3D;&gt;parallel: 继续讨论op6&#x3D;&gt;operation: 讨论cond&#x3D;&gt;condition: 确认？st-&gt;op1-&gt;op2-&gt;op3-&gt;condcond(yes)-&gt;op4-&gt;econd(no)-&gt;op6-&gt;e</code></pre><pre class="line-numbers language-none"><code class="language-none">st&#x3D;&gt;start: 开始e&#x3D;&gt;end: 结束op1&#x3D;&gt;operation: 新品开发流程op2&#x3D;&gt;operation: 产品需求提出op3&#x3D;&gt;operation: 产品试用 负责人：吴xxop4&#x3D;&gt;operation: 包装op5&#x3D;&gt;parallel: 继续讨论op6&#x3D;&gt;operation: 讨论cond&#x3D;&gt;condition: 确认？st-&gt;op1-&gt;op2-&gt;op3-&gt;condcond(yes)-&gt;op4-&gt;econd(no)-&gt;op6-&gt;e</code></pre><ol><li>通过三个`+flow进入流程图的代码块,再用三个`结束</li><li>编写流程图中的变量：变量=&gt;操作块: 备注名(注意：冒号为英文的冒号，冒号与备注名之间有一个空格)</li><li>构建变量之间的流程图关系</li><li>格式一旦有一点差错，流程图无法显示</li></ol><p>注意：生成流程图，有很多版本，如mermaid,flowchart,此处用flowchart示范</p><h2 id="十二-表格"><a class="markdownIt-Anchor" href="#十二-表格"></a> 十二、表格</h2><table><thead><tr><th>序号</th><th>姓名</th><th>学号</th></tr></thead><tbody><tr><td>1</td><td>张杰</td><td>2233</td></tr></tbody></table><table><thead><tr><th style="text-align:right">序号</th><th style="text-align:left">姓名</th><th style="text-align:center">学号</th></tr></thead><tbody><tr><td style="text-align:right">1</td><td style="text-align:left">杰</td><td style="text-align:center">2</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">|序号|姓名|学号||-|-|-||1|张杰|2233||序号|姓名|学号||-:|:-|:-:||1|杰|2|</code></pre><ol><li>第一行为表头</li><li>第二行分隔表头和主体部分（还可以为不同的列指定对齐方向：默认为左对齐，:-为左对齐，-:为右对齐，:-为居中对齐，其中，冒号为英文冒号）</li><li>从第三行起每一行为一个表格行</li><li>列与列之间用管道符“|”隔开</li></ol><h2 id="十三-latex公式"><a class="markdownIt-Anchor" href="#十三-latex公式"></a> 十三、Latex公式</h2><h3 id="行内公式"><a class="markdownIt-Anchor" href="#行内公式"></a> 行内公式</h3><p>质能守恒方程可以用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>=</mo><mi>m</mi><msup><mi>c</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E = m c^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>表示</p><pre class="line-numbers language-none"><code class="language-none">质能守恒方程可以用$E &#x3D; m c^2$表示</code></pre><h3 id="整行公式"><a class="markdownIt-Anchor" href="#整行公式"></a> 整行公式</h3><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>E</mi><mo>=</mo><mi>m</mi><msup><mi>c</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E = m c^2 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><pre class="line-numbers language-none"><code class="language-none">$$E &#x3D; m c^2$$</code></pre><h3 id="块级公式"><a class="markdownIt-Anchor" href="#块级公式"></a> 块级公式</h3><pre class="line-numbers language-math" data-language="math"><code class="language-math">E &#x3D;m c^2  </code></pre><p>```math<br />E =m c^2<br />```</p><p>注意：块级公式，需要特定支持</p><ul><li>一块只能写一个公式，换行没有意义（行内公式，整行公式也一样，一个包裹内只能写一个公式）</li></ul><h2 id="十四-分隔线"><a class="markdownIt-Anchor" href="#十四-分隔线"></a> 十四、分隔线</h2><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><pre class="line-numbers language-none"><code class="language-none">**** * ****------------------ - -____ _ ___________</code></pre><ul><li>三个及以上*,-,_(星号，减号，底线)，即可形成分隔线（中间有空格也可以），但是同一行不能出现其它字符。</li></ul><h2 id="十五-html语法"><a class="markdownIt-Anchor" href="#十五-html语法"></a> 十五、HTML语法</h2><p>可用HTML的语法编辑markdown</p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 杂技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂技术 </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
